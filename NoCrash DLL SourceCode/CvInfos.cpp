//  $Header:
//------------------------------------------------------------------------------------------------
//
//  FILE:    CvInfos.cpp
//
//  PURPOSE: The base class for all info classes to inherit from.  This gives us the base description
//				and type strings
//
//------------------------------------------------------------------------------------------------
//  Copyright (c) 2003 Firaxis Games, Inc. All rights reserved.
//------------------------------------------------------------------------------------------------
#include "CvGameCoreDLL.h"
#include "CvInfos.h"
#include "CvGlobals.h"
#include "CvArtFileMgr.h"
#include "CvXMLLoadUtility.h"
#include "CvDLLXMLIFaceBase.h"
#include "CvGameTextMgr.h"
#include "CvGameCoreUtils.h"

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CInfoBase()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvInfoBase::CvInfoBase() :
m_bGraphicalOnly(false)
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
,m_bForceOverwrite(false)
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CInfoBase()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvInfoBase::~CvInfoBase()
{
}

void CvInfoBase::read(FDataStreamBase* pStream)
{
	reset();

	pStream->Read(&m_bGraphicalOnly);
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		Possibly this doesn't need saved as it is useless data once XML is done loading			**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pStream->Read(&m_bForceOverwrite);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pStream->ReadString(m_szType);
	pStream->ReadString(m_szCivilopediaKey);
	pStream->ReadString(m_szHelpKey);
	pStream->ReadString(m_szStrategyKey);
	pStream->ReadString(m_szButton);
	pStream->ReadString(m_szTextKey);
}

void CvInfoBase::write(FDataStreamBase* pStream)
{
	pStream->Write(m_bGraphicalOnly);
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pStream->Write(m_bForceOverwrite);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pStream->WriteString(m_szType);
	pStream->WriteString(m_szCivilopediaKey);
	pStream->WriteString(m_szHelpKey);
	pStream->WriteString(m_szStrategyKey);
	pStream->WriteString(m_szButton);
	pStream->WriteString(m_szTextKey);
}

void CvInfoBase::reset()
{
	//clear cache
	m_aCachedDescriptions.clear();
	m_szCachedText.clear();
	m_szCachedHelp.clear();
	m_szCachedStrategy.clear();
	m_szCachedCivilopedia.clear();
}

bool CvInfoBase::isGraphicalOnly() const
{
	return m_bGraphicalOnly;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
const TCHAR* CvInfoBase::getType() const
{
/**								----  End Original Code  ----									**/
bool CvInfoBase::isForceOverwrite() const
{
	return m_bForceOverwrite;
}

const wchar* CvInfoBase::getCivilopediaKey() const
{
	return m_szCivilopediaKey;
}

const wchar* CvInfoBase::getHelpKey() const
{
	return m_szHelpKey;
}

const wchar* CvInfoBase::getStrategyKey() const
{
	return m_szStrategyKey;
}

const TCHAR* CvInfoBase::getType() const
{
	if (m_szType == NULL)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	if (m_szType.empty())
	{
		return NULL;
	}

	return m_szType;
}

const TCHAR* CvInfoBase::getButton() const
{
	if (m_szButton.empty())
	{
		return NULL;
	}

	return m_szButton;
}

const wchar* CvInfoBase::getTextKeyWide() const
{
	return m_szTextKey;
}

const wchar* CvInfoBase::getDescription(uint uiForm) const
{
	while(m_aCachedDescriptions.size() <= uiForm)
	{
		m_aCachedDescriptions.push_back(gDLL->getObjectText(m_szTextKey, m_aCachedDescriptions.size()));
	}

	return m_aCachedDescriptions[uiForm];
}

const wchar* CvInfoBase::getText() const
{
	// used instead of getDescription for Info entries that are not objects
	// so they do not have gender/plurality/forms defined in the Translator system
	if(m_szCachedText.empty())
	{
		m_szCachedText = gDLL->getText(m_szTextKey);
	}

	return m_szCachedText;
}

const wchar* CvInfoBase::getCivilopedia() const
{
	if(m_szCachedCivilopedia.empty())
	{
		m_szCachedCivilopedia = gDLL->getText(m_szCivilopediaKey);
	}

	return m_szCachedCivilopedia;
}

const wchar*  CvInfoBase::getHelp() const
{
	if (m_szCachedHelp.empty())
	{
		m_szCachedHelp = gDLL->getText(m_szHelpKey);
	}

	return m_szCachedHelp;
}

const wchar* CvInfoBase::getStrategy() const
{
	if (m_szCachedStrategy.empty())
	{
		m_szCachedStrategy = gDLL->getText(m_szStrategyKey);
	}

	return m_szCachedStrategy;
}

bool CvInfoBase::isMatchForLink(std::wstring szLink, bool bKeysOnly) const
{
	if (szLink == CvWString(getType()).GetCString())
	{
		return true;
	}

	if (!bKeysOnly)
	{
		uint iNumForms = gDLL->getNumForms(getTextKeyWide());
		for (uint i = 0; i < iNumForms; i++)
		{
			if (szLink == getDescription(i))
			{
				return true;
			}
		}
	}

	return false;
}

//
// read from XML
// TYPE, DESC, BUTTON
//
bool CvInfoBase::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	// Skip any comments and stop at the next value we might want
	if (!pXML->SkipToNextVal())
	{
		return false;
	}

	pXML->MapChildren();	// try to hash children for fast lookup by name

	// GRAPHICAL ONLY
	pXML->GetChildXmlValByName(&m_bGraphicalOnly, "bGraphicalOnly");

	// TYPE
	pXML->GetChildXmlValByName(m_szType, "Type");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	Most of this data is read and used immediately, rather than the typical "read and stored"	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bForceOverwrite, "bForceOverwrite");

	if (!GC.isAnyDependency() )
	{
		GC.resetDependencies(); //make sure this always starts empty!

		pXML->GetChildXmlValByName(&GC.getTypeDependency(), "bTypeDependency");
		if ( GC.getTypeDependency() )
		{
			GC.setAnyDependency(true);
		}

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AndDependencyTypes"))
		{
			GC.setAnyDependency(true);

			int iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (pXML->GetChildXmlVal(szTextVal))
			{
				GC.setAndDependencyTypes(szTextVal);

				for ( int iI = 1; iI < iNumChildren; iI++ )
				{
					if (pXML->GetNextXmlVal(szTextVal))
					{
						GC.setAndDependencyTypes(szTextVal);
					}
					else
					{
						break;
					}
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"OrDependencyTypes"))
		{
			GC.setAnyDependency(true);

			int iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (pXML->GetChildXmlVal(szTextVal))
			{
				GC.setOrDependencyTypes(szTextVal);

				for ( int iI = 1; iI < iNumChildren; iI++ )
				{
					if (pXML->GetNextXmlVal(szTextVal))
					{
						GC.setOrDependencyTypes(szTextVal);
					}
					else
					{
						break;
					}
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		if ( GC.isAnyDependency() )
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	// DESCRIPTION
	pXML->GetChildXmlValByName(m_szTextKey, "Description");

	// CIVILOPEDIA
	pXML->GetChildXmlValByName(m_szCivilopediaKey, "Civilopedia");

	// HELP
	pXML->GetChildXmlValByName(m_szHelpKey, "Help");

	// STRATEGY
	pXML->GetChildXmlValByName(m_szStrategyKey, "Strategy");

	// BUTTON
	pXML->GetChildXmlValByName(m_szButton, "Button");

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**																								**/
/**			Note:  These functions are best understood by looking at CvXMLLoadUtilitySet.		**/
/**					Few of them include new functions from FfH/FF so far						**/
/**	The basic gist of it is that we are going to use the Module, but this function lets us 		**/
/**	save some data from whatever was loaded previously, unless told not to include it all		**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvInfoBase::copyNonDefaults(CvInfoBase* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if(m_bGraphicalOnly	== false)											m_bGraphicalOnly	= pClassInfo->isGraphicalOnly();
	if(getType()			== NULL)				{FAssertMsg(false, "MrGenie Critical error Message! Type MUST be set! iIndex will be illegal without it");}
	else if(getType()		== cDefault)									{m_szType			= pClassInfo->getType();}

	if(getCivilopediaKey()	== NULL || getCivilopediaKey()	== wDefault)	m_szCivilopediaKey	= pClassInfo->getCivilopediaKey();
	if(getHelpKey()			== NULL || getHelpKey()			== wDefault)	m_szHelpKey			= pClassInfo->getHelpKey();
	if(getStrategyKey()		== NULL || getStrategyKey()		== wDefault)	m_szStrategyKey		= pClassInfo->getStrategyKey();
	if(getButton()			== NULL || getButton()			== cDefault)	m_szButton			= pClassInfo->getButton();
	if(getTextKeyWide()		== NULL || getTextKeyWide()		== wDefault)	m_szTextKey			= pClassInfo->getTextKeyWide();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
//======================================================================================================
//					CvScalableInfo
//======================================================================================================
bool CvScalableInfo::read(CvXMLLoadUtility* pXML)
{
	float fScale;
	pXML->GetChildXmlValByName(&fScale, "fScale");
	setScale(fScale);
	pXML->GetChildXmlValByName(&fScale, "fInterfaceScale", 1.0f);
	setInterfaceScale(fScale);
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvScalableInfo::copyNonDefaults(CvScalableInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	if (GC.getGameINLINE().isOption(GAMEOPTION_ADVENTURE_MODE))
	{
		if (getScale()			== 0.0f)	setScale(				pClassInfo->getScale()/2);
		if (getInterfaceScale()	== 0.5f)	setInterfaceScale(		pClassInfo->getInterfaceScale()*2);
	}
	else
	{
		if (getScale()			== 0.0f)	setScale(				pClassInfo->getScale());
		if (getInterfaceScale()	== 1.0f)	setInterfaceScale(		pClassInfo->getInterfaceScale());
	}
	if (getInterfaceScale()	== 1.0f)	setInterfaceScale(		pClassInfo->getInterfaceScale());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

float CvScalableInfo::getScale() const
{

//FfH Review: Added by Kael 03/15/2008
	if (GC.getGameINLINE().isOption(GAMEOPTION_ADVENTURE_MODE))
	{
		return (m_fScale * 2);
	}
//FfH: End Add

	return m_fScale;
}

void CvScalableInfo::setScale(float fScale)
{
	m_fScale = fScale;
}

float CvScalableInfo::getInterfaceScale() const
{

//FfH: Added by Kael 03/15/2008
	if (GC.getGameINLINE().isOption(GAMEOPTION_ADVENTURE_MODE))
	{
		return (m_fInterfaceScale / 2);
	}
//FfH: End Add

	return m_fInterfaceScale;
}

void CvScalableInfo::setInterfaceScale(float fInterfaceScale)
{
	m_fInterfaceScale = fInterfaceScale;
}


//======================================================================================================
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvHotkeyInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvHotkeyInfo::CvHotkeyInfo() :
m_iActionInfoIndex(-1),
m_iHotKeyVal(-1),
m_iHotKeyPriority(-1),
m_iHotKeyValAlt(-1),
m_iHotKeyPriorityAlt(-1),
m_iOrderPriority(0),
m_bAltDown(false),
m_bShiftDown(false),
m_bCtrlDown(false),
m_bAltDownAlt(false),
m_bShiftDownAlt(false),
m_bCtrlDownAlt(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvHotkeyInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvHotkeyInfo::~CvHotkeyInfo()
{
}

bool CvHotkeyInfo::read(CvXMLLoadUtility* pXML)
{
	int iVal;
	bool bVal;
	CvString szTextVal;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	if (pXML->GetChildXmlValByName(szTextVal, "HotKey"))
	{
		setHotKey(szTextVal);
	}
	else
	{
		setHotKey("");
	}
	iVal = pXML->GetHotKeyInt(szTextVal);
	setHotKeyVal(iVal);
  if (pXML->GetChildXmlValByName(&iVal, "iHotKeyPriority"))
	{
		setHotKeyPriority(iVal);
	}
	else
	{
		setHotKeyPriority(-1);
	}

	if (pXML->GetChildXmlValByName(szTextVal, "HotKeyAlt"))
	{
		iVal = pXML->GetHotKeyInt(szTextVal);
	}
	else
	{
		iVal = pXML->GetHotKeyInt("");
	}
	setHotKeyValAlt(iVal);
	if (pXML->GetChildXmlValByName(&iVal, "iHotKeyPriorityAlt"))
	{
		setHotKeyPriorityAlt(iVal);
	}
	else
	{
		setHotKeyPriorityAlt(-1);
	}

	if (pXML->GetChildXmlValByName(&bVal, "bAltDown"))
	{
		setAltDown(bVal);
	}
	else
	{
		setAltDown(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bShiftDown"))
	{
		setShiftDown(bVal);
	}
	else
	{
		setShiftDown(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bCtrlDown"))
	{
		setCtrlDown(bVal);
	}
	else
	{
		setCtrlDown(false);
	}

	if (pXML->GetChildXmlValByName(&bVal, "bAltDownAlt"))
	{
		setAltDownAlt(bVal);
	}
	else
	{
		setAltDownAlt(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bShiftDownAlt"))
	{
		setShiftDownAlt(bVal);
	}
	else
	{
		setShiftDownAlt(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bCtrlDownAlt"))
	{
		setCtrlDownAlt(bVal);
	}
	else
	{
		setCtrlDownAlt(false);
	}
	if (pXML->GetChildXmlValByName(&iVal, "iOrderPriority"))
	{
		setOrderPriority(iVal);
	}
	else
	{
		setOrderPriority(5);
	}

	setHotKeyDescription(getTextKeyWide(), NULL, pXML->CreateHotKeyFromDescription(getHotKey(), m_bShiftDown, m_bAltDown, m_bCtrlDown));

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvHotkeyInfo::copyNonDefaults(CvHotkeyInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if(getHotKeyVal()				== 0)				m_iHotKeyVal					= pClassInfo->getHotKeyVal();
	if(getHotKeyPriority()			== 0)				m_iHotKeyPriority				= pClassInfo->getHotKeyPriority();
	if(getHotKeyValAlt()			== 0)				m_iHotKeyValAlt					= pClassInfo->getHotKeyValAlt();
	if(getHotKeyPriorityAlt()		== 0)				m_iHotKeyPriorityAlt			= pClassInfo->getHotKeyPriorityAlt();
	if(getOrderPriority()			== 0)				m_iOrderPriority				= pClassInfo->getOrderPriority();
	if(isAltDown()					== false)			m_bAltDown						= pClassInfo->isAltDown();
	if(isShiftDown()				== false)			m_bShiftDown					= pClassInfo->isShiftDown();
	if(isCtrlDown()					== false)			m_bCtrlDown						= pClassInfo->isCtrlDown();
	if(isAltDownAlt()				== false)			m_bAltDownAlt					= pClassInfo->isAltDownAlt();
	if(isShiftDownAlt()				== false)			m_bShiftDownAlt					= pClassInfo->isShiftDownAlt();
	if(isCtrlDownAlt()				== false)			m_bCtrlDownAlt					= pClassInfo->isCtrlDownAlt();
	if(getHotKey()					== cDefault)		m_szHotKey						= pClassInfo->getHotKey();
	if(getHotKeyDescriptionKey()	== wDefault)		m_szHotKeyDescriptionKey		= pClassInfo->getHotKeyDescriptionKey();
	if(getHotKeyAltDescriptionKey()	== wDefault)		m_szHotKeyAltDescriptionKey		= pClassInfo->getHotKeyAltDescriptionKey();
	if(getHotKeyString()			== wDefault)		m_szHotKeyString				= pClassInfo->getHotKeyString();
}
const WCHAR* CvHotkeyInfo::getHotKeyDescriptionKey() const		{return m_szHotKeyDescriptionKey;}
const WCHAR* CvHotkeyInfo::getHotKeyAltDescriptionKey() const	{return m_szHotKeyAltDescriptionKey;}
const WCHAR* CvHotkeyInfo::getHotKeyString() const				{return m_szHotKeyString;}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
void CvHotkeyInfo::read(FDataStreamBase* pStream)
{
	CvInfoBase::read(pStream);

	uint uiFlag=0;
	pStream->Read(&uiFlag);	// flags for expansion

	pStream->Read(&m_iHotKeyVal);
	pStream->Read(&m_iHotKeyPriority);
	pStream->Read(&m_iHotKeyValAlt);
	pStream->Read(&m_iHotKeyPriorityAlt);
	pStream->Read(&m_iOrderPriority);
	pStream->Read(&m_bAltDown);
	pStream->Read(&m_bShiftDown);
	pStream->Read(&m_bCtrlDown);
	pStream->Read(&m_bAltDownAlt);
	pStream->Read(&m_bShiftDownAlt);
	pStream->Read(&m_bCtrlDownAlt);
	pStream->ReadString(m_szHotKey);
	pStream->ReadString(m_szHotKeyDescriptionKey);
	pStream->ReadString(m_szHotKeyAltDescriptionKey);
	pStream->ReadString(m_szHotKeyString);
}

void CvHotkeyInfo::write(FDataStreamBase* pStream)
{
	CvInfoBase::write(pStream);

	uint uiFlag = 0;
	pStream->Write(uiFlag);		// flag for expansion

	pStream->Write(m_iHotKeyVal);
	pStream->Write(m_iHotKeyPriority);
	pStream->Write(m_iHotKeyValAlt);
	pStream->Write(m_iHotKeyPriorityAlt);
	pStream->Write(m_iOrderPriority);
	pStream->Write(m_bAltDown);
	pStream->Write(m_bShiftDown);
	pStream->Write(m_bCtrlDown);
	pStream->Write(m_bAltDownAlt);
	pStream->Write(m_bShiftDownAlt);
	pStream->Write(m_bCtrlDownAlt);
	pStream->WriteString(m_szHotKey);
	pStream->WriteString(m_szHotKeyDescriptionKey);
	pStream->WriteString(m_szHotKeyAltDescriptionKey);
	pStream->WriteString(m_szHotKeyString);
}

int CvHotkeyInfo::getActionInfoIndex() const
{
	return m_iActionInfoIndex;
}

void CvHotkeyInfo::setActionInfoIndex(int i)
{
	m_iActionInfoIndex = i;
}

int CvHotkeyInfo::getHotKeyVal() const
{
	return m_iHotKeyVal;
}

void CvHotkeyInfo::setHotKeyVal(int i)
{
	m_iHotKeyVal = i;
}

int CvHotkeyInfo::getHotKeyPriority() const
{
	return m_iHotKeyPriority;
}

void CvHotkeyInfo::setHotKeyPriority(int i)
{
	m_iHotKeyPriority = i;
}

int CvHotkeyInfo::getHotKeyValAlt() const
{
	return m_iHotKeyValAlt;
}

void CvHotkeyInfo::setHotKeyValAlt(int i)
{
	m_iHotKeyValAlt = i;
}

int CvHotkeyInfo::getHotKeyPriorityAlt() const
{
	return m_iHotKeyPriorityAlt;
}

void CvHotkeyInfo::setHotKeyPriorityAlt(int i)
{
	m_iHotKeyPriorityAlt = i;
}

int CvHotkeyInfo::getOrderPriority() const
{
	return m_iOrderPriority;
}

void CvHotkeyInfo::setOrderPriority(int i)
{
	m_iOrderPriority = i;
}

bool CvHotkeyInfo::isAltDown() const
{
	return m_bAltDown;
}

void CvHotkeyInfo::setAltDown(bool b)
{
	m_bAltDown = b;
}

bool CvHotkeyInfo::isShiftDown() const
{
	return m_bShiftDown;
}

void CvHotkeyInfo::setShiftDown(bool b)
{
	m_bShiftDown = b;
}

bool CvHotkeyInfo::isCtrlDown() const
{
	return m_bCtrlDown;
}

void CvHotkeyInfo::setCtrlDown(bool b)
{
	m_bCtrlDown = b;
}

bool CvHotkeyInfo::isAltDownAlt() const
{
	return m_bAltDownAlt;
}

void CvHotkeyInfo::setAltDownAlt(bool b)
{
	m_bAltDownAlt = b;
}

bool CvHotkeyInfo::isShiftDownAlt() const
{
	return m_bShiftDownAlt;
}

void CvHotkeyInfo::setShiftDownAlt(bool b)
{
	m_bShiftDownAlt = b;
}

bool CvHotkeyInfo::isCtrlDownAlt() const
{
	return m_bCtrlDownAlt;
}

void CvHotkeyInfo::setCtrlDownAlt(bool b)
{
	m_bCtrlDownAlt = b;
}

const TCHAR* CvHotkeyInfo::getHotKey() const
{
	return m_szHotKey;
}

void CvHotkeyInfo::setHotKey(const TCHAR* szVal)
{
	m_szHotKey = szVal;
}

std::wstring CvHotkeyInfo::getHotKeyDescription() const
{
	CvWString szTemptext;
	if (!m_szHotKeyAltDescriptionKey.empty())
	{
		szTemptext.Format(L"%s (%s)", gDLL->getObjectText(m_szHotKeyAltDescriptionKey, 0).GetCString(), gDLL->getObjectText(m_szHotKeyDescriptionKey, 0).GetCString());
	}
	else
	{
		szTemptext = gDLL->getObjectText(m_szHotKeyDescriptionKey, 0);
	}

	if (!m_szHotKeyString.empty())
	{
		szTemptext += m_szHotKeyString;
	}

	return szTemptext;
}

void CvHotkeyInfo::setHotKeyDescription(const wchar* szHotKeyDescKey, const wchar* szHotKeyAltDescKey, const wchar* szHotKeyString)
{
	m_szHotKeyDescriptionKey = szHotKeyDescKey;
	m_szHotKeyAltDescriptionKey = szHotKeyAltDescKey;
	m_szHotKeyString = szHotKeyString;
}

//======================================================================================================
//					CvDiplomacyResponse
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvDiplomacyResponse()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyResponse::CvDiplomacyResponse() :
m_iNumDiplomacyText(0),
m_pbCivilizationTypes(NULL),
m_pbLeaderHeadTypes(NULL),
m_pbAttitudeTypes(NULL),
m_pbDiplomacyPowerTypes(NULL),
m_paszDiplomacyText(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDiplomacyResponse()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyResponse::~CvDiplomacyResponse()
{
	SAFE_DELETE_ARRAY(m_pbCivilizationTypes);
	SAFE_DELETE_ARRAY(m_pbLeaderHeadTypes);
	SAFE_DELETE_ARRAY(m_pbAttitudeTypes);
	SAFE_DELETE_ARRAY(m_pbDiplomacyPowerTypes);
	SAFE_DELETE_ARRAY(m_paszDiplomacyText);
}

int CvDiplomacyResponse::getNumDiplomacyText()
{
	return m_iNumDiplomacyText;
}

void CvDiplomacyResponse::setNumDiplomacyText(int i)
{
	m_iNumDiplomacyText = i;
}

bool CvDiplomacyResponse::getCivilizationTypes(int i)
{
	FAssertMsg(i < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationTypes[i];
}

bool* CvDiplomacyResponse::getCivilizationTypes() const
{
	return m_pbCivilizationTypes;
}

void CvDiplomacyResponse::setCivilizationTypes(int i, bool bVal)
{
	FAssertMsg(i < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbCivilizationTypes[i] = bVal;
}

bool CvDiplomacyResponse::getLeaderHeadTypes(int i)
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbLeaderHeadTypes[i];
}

bool* CvDiplomacyResponse::getLeaderHeadTypes() const
{
	return m_pbLeaderHeadTypes;
}

void CvDiplomacyResponse::setLeaderHeadTypes(int i, bool bVal)
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbLeaderHeadTypes[i] = bVal;
}

bool CvDiplomacyResponse::getAttitudeTypes(int i) const
{
	FAssertMsg(i < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbAttitudeTypes[i];
}

bool* CvDiplomacyResponse::getAttitudeTypes() const
{
	return m_pbAttitudeTypes;
}

void CvDiplomacyResponse::setAttitudeTypes(int i, bool bVal)
{
	FAssertMsg(i < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbAttitudeTypes[i] = bVal;
}

bool CvDiplomacyResponse::getDiplomacyPowerTypes(int i)
{
	FAssertMsg(i < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbDiplomacyPowerTypes[i];
}

bool* CvDiplomacyResponse::getDiplomacyPowerTypes() const
{
	return m_pbDiplomacyPowerTypes;
}

void CvDiplomacyResponse::setDiplomacyPowerTypes(int i, bool bVal)
{
	FAssertMsg(i < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbDiplomacyPowerTypes[i] = bVal;
}

const TCHAR* CvDiplomacyResponse::getDiplomacyText(int i) const
{
	return m_paszDiplomacyText[i];
}

const CvString* CvDiplomacyResponse::getDiplomacyText() const
{
	return m_paszDiplomacyText;
}

void CvDiplomacyResponse::setDiplomacyText(int i, CvString szText)
{
	FAssertMsg(i < getNumDiplomacyText(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszDiplomacyText[i] = szText;
}

void CvDiplomacyResponse::read(FDataStreamBase* stream)
{
	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iNumDiplomacyText);

	SAFE_DELETE_ARRAY(m_pbCivilizationTypes);
	m_pbCivilizationTypes = new bool[GC.getNumCivilizationInfos()];
	stream->Read(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);

	SAFE_DELETE_ARRAY(m_pbLeaderHeadTypes);
	m_pbLeaderHeadTypes = new bool[GC.getNumLeaderHeadInfos()];
	stream->Read(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);

	SAFE_DELETE_ARRAY(m_pbAttitudeTypes);
	m_pbAttitudeTypes = new bool[NUM_ATTITUDE_TYPES];
	stream->Read(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);

	SAFE_DELETE_ARRAY(m_pbDiplomacyPowerTypes);
	m_pbDiplomacyPowerTypes = new bool[NUM_DIPLOMACYPOWER_TYPES];
	stream->Read(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);

	SAFE_DELETE_ARRAY(m_paszDiplomacyText);
	m_paszDiplomacyText = new CvString[m_iNumDiplomacyText];
	stream->ReadString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

void CvDiplomacyResponse::write(FDataStreamBase* stream)
{
	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iNumDiplomacyText);

	stream->Write(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);
	stream->Write(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);
	stream->Write(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);
	stream->Write(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);
	stream->WriteString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

bool CvDiplomacyResponse::read(CvXMLLoadUtility* pXML)
{
	pXML->SetVariableListTagPair(&m_pbCivilizationTypes, "Civilizations", sizeof(GC.getCivilizationInfo((CivilizationTypes)0)), GC.getNumCivilizationInfos());
	// Leaders
	pXML->SetVariableListTagPair(&m_pbLeaderHeadTypes, "Leaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());
	// AttitudeTypes
	pXML->SetVariableListTagPair(&m_pbAttitudeTypes, "Attitudes", sizeof(GC.getAttitudeInfo((AttitudeTypes)0)), NUM_ATTITUDE_TYPES);
	// PowerTypes
	pXML->SetVariableListTagPair(&m_pbDiplomacyPowerTypes, "DiplomacyPowers", GC.getDiplomacyPowerTypes(), NUM_DIPLOMACYPOWER_TYPES);
	// DiplomacyText
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"DiplomacyText"))
	{
		pXML->SetStringList(&m_paszDiplomacyText, &m_iNumDiplomacyText);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvDiplomacyResponse::UpdateDiplomacies(CvDiplomacyInfo* pDiplomacyInfo, int iIndex)
{
	bool bDefault = false;
	CvXMLLoadUtilityModTools* pModTools = new CvXMLLoadUtilityModTools;

	// We use the String append mechanism from WOC default = assume the modder added his strings
	// purposly, so those are on the first place, the strings previously are appended after them
	CvString* m_paszNewNames = new CvString[pDiplomacyInfo->getNumDiplomacyText(iIndex)];
	for ( int i = 0; i < pDiplomacyInfo->getNumDiplomacyText(iIndex); i++)
	{
		m_paszNewNames[i] = pDiplomacyInfo->getDiplomacyText(iIndex, i);
	}

	pModTools->StringArrayExtend(&m_paszDiplomacyText, &m_iNumDiplomacyText, &m_paszNewNames, pDiplomacyInfo->getNumDiplomacyText(iIndex));
	SAFE_DELETE_ARRAY(m_paszNewNames);
	SAFE_DELETE(pModTools);

	// if anything is true, we don't overwrite(assuming the modder did set it true purposly
	for ( int i = 0; i < GC.getNumLeaderHeadInfos(); ++i)
	{
		if (m_pbLeaderHeadTypes[i] == bDefault)
		{
			m_pbLeaderHeadTypes[i] = pDiplomacyInfo->getLeaderHeadTypes(iIndex, i);
		}
	}
	for ( int i = 0; i < NUM_ATTITUDE_TYPES; ++i)
	{
		if (m_pbAttitudeTypes[i] == bDefault)
		{
			m_pbAttitudeTypes[i] = pDiplomacyInfo->getAttitudeTypes(iIndex, i);
		}
	}
	for ( int i = 0; i < NUM_DIPLOMACYPOWER_TYPES; ++i)
	{
		if (m_pbDiplomacyPowerTypes[i] == bDefault)
		{
			m_pbDiplomacyPowerTypes[i] = pDiplomacyInfo->getDiplomacyPowerTypes(iIndex, i);
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSpecialistInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpecialistInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialistInfo::CvSpecialistInfo() :
m_iGreatPeopleUnitClass(NO_UNITCLASS),
m_iGreatPeopleRateChange(0),
m_iMissionType(NO_MISSION),
m_bVisible(false),
m_piYieldChange(NULL),
m_piCommerceChange(NULL),
m_piFlavorValue(NULL),
/*************************************************************************************************/
/** Specialists Enhancements, by Supercheese 10/9/09           Imported by Valkrionn   10/22/09  */
/**                                                                                              */
/**                                                                                              */
/*************************************************************************************************/
m_iHealth(0),
m_iHappiness(0),
m_iCrime(0),
/*************************************************************************************************/
/** Specialists Enhancements                          END                                        */
/*************************************************************************************************/
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iExperience(0)
/**								----  End Original Code  ----									**/
m_iExperience(0.0f)
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpecialistInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialistInfo::~CvSpecialistInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piCommerceChange);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
}

/*************************************************************************************************/
/** Specialists Enhancements, by Supercheese 10/9/09           Imported by Valkrionn   10/22/09  */
/**                                                                                              */
/**                                                                                              */
/*************************************************************************************************/
int CvSpecialistInfo::getHealth() const
{
	return m_iHealth;
}
int CvSpecialistInfo::getHappiness() const
{
	return m_iHappiness;
}
int CvSpecialistInfo::getCrime() const
{
	return m_iCrime;
}
/*************************************************************************************************/
/** Specialists Enhancements                          END                                        */
/*************************************************************************************************/

int CvSpecialistInfo::getGreatPeopleUnitClass() const
{
	return m_iGreatPeopleUnitClass;
}

int CvSpecialistInfo::getGreatPeopleRateChange() const
{
	return m_iGreatPeopleRateChange;
}

int CvSpecialistInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvSpecialistInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

bool CvSpecialistInfo::isVisible() const
{
	return m_bVisible;
}

int CvSpecialistInfo::getExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

// Arrays

int CvSpecialistInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

const int* CvSpecialistInfo::getYieldChangeArray() const
{
	return m_piYieldChange;
}

int CvSpecialistInfo::getCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceChange ? m_piCommerceChange[i] : -1;
}

int CvSpecialistInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

const TCHAR* CvSpecialistInfo::getTexture() const
{
	return m_szTexture;
}

void CvSpecialistInfo::setTexture(const TCHAR* szVal)
{
	m_szTexture = szVal;
}

//
// read from xml
//
bool CvSpecialistInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Texture");
	setTexture(szTextVal);

	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	pXML->GetChildXmlValByName(szTextVal, "GreatPeopleUnitClass");
	m_iGreatPeopleUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iGreatPeopleRateChange, "iGreatPeopleRateChange");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Yields"))
	{
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Commerces"))
	{
		pXML->SetCommerce(&m_piCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceChange, NUM_COMMERCE_TYPES);
	}

/*************************************************************************************************/
/** Specialists Enhancements, by Supercheese 10/9/09           Imported by Valkrionn   10/22/09  */
/**                                                                                              */
/**                                                                                              */
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iCrime, "iCrime");
	/*************************************************************************************************/
/** Specialists Enhancements                          END                                        */
/*************************************************************************************************/

	pXML->GetChildXmlValByName(&m_iExperience, "iExperience");

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpecialistInfo::copyNonDefaults(CvSpecialistInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isVisible()					== false)				m_bVisible					= pClassInfo->isVisible();
	if (getGreatPeopleRateChange()	== 0)					m_iGreatPeopleRateChange	= pClassInfo->getGreatPeopleRateChange();
	if (getExperience()				== 0.0f)				m_iExperience				= (float)(pClassInfo->getExperience()/100.0);
	if (getTexture()				== cDefault)			setTexture(					pClassInfo->getTexture());
	if (getGreatPeopleUnitClass()	== NO_UNITCLASS)		m_iGreatPeopleUnitClass		= pClassInfo->getGreatPeopleUnitClass();
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if(getYieldChange(i)		== 0)					m_piYieldChange[i]			= pClassInfo->getYieldChange(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if(getCommerceChange(i)		== 0)					m_piCommerceChange[i]		= pClassInfo->getCommerceChange(i);
	}
/*************************************************************************************************/
/** Specialists Enhancements, by Supercheese 10/9/09           Imported by Valkrionn   10/22/09  */
/**                                                                                              */
/**                                                                                              */
/*************************************************************************************************/
	if (getHealth()                 == 0)                   m_iHealth                   = pClassInfo->getHealth();
	if (getHappiness()              == 0)                   m_iHappiness                = pClassInfo->getHappiness();
	if (getCrime() == 0)                   m_iCrime = pClassInfo->getCrime();
	/*************************************************************************************************/
/** Specialists Enhancements                          END                                        */
/*************************************************************************************************/
	for ( int i = 0; i < GC.getNumFlavorTypes(); i++ )
	{
		if(getFlavorValue(i)		== 0)					m_piFlavorValue[i]			= pClassInfo->getFlavorValue(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvTechInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTechInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTechInfo::CvTechInfo() :
	m_iAdvisorType(NO_ADVISOR),
	m_iAIWeight(0),
	m_iAITradeModifier(0),
	m_iResearchCost(0),
	m_iAdvancedStartCost(0),
	m_iAdvancedStartCostIncrease(0),
	m_iEra(NO_ERA),
	m_iTradeRoutes(0),
	m_iFeatureProductionModifier(0),
	m_iWorkerSpeedModifier(0),
	m_iFirstFreeUnitClass(NO_UNITCLASS),
	m_iHealth(0),
	m_iHappiness(0),
	m_iFirstFreeTechs(0),
	m_iAssetValue(0),
	m_iPowerValue(0),
	m_iGridX(0),
	m_iGridY(0),
	m_bRepeat(false),
	m_bTrade(false),
	m_bDisable(false),
	m_bGoodyTech(false),
	m_bExtraWaterSeeFrom(false),
	m_bMapCentering(false),
	m_bMapVisible(false),
	m_bMapTrading(false),
	m_bTechTrading(false),
	m_bGoldTrading(false),
	m_bOpenBordersTrading(false),
	m_bDefensivePactTrading(false),
	m_bPermanentAllianceTrading(false),
	m_bVassalStateTrading(false),
	m_bBridgeBuilding(false),
	m_bIrrigation(false),
	m_bIgnoreIrrigation(false),
	m_bWaterWork(false),
	m_bRiverTrade(false),
	m_piDomainExtraMoves(NULL),
	m_piFlavorValue(NULL),
	m_piPrereqOrTechs(NULL),
	m_piPrereqAndTechs(NULL),
	m_pbCommerceFlexible(NULL),
	m_pbTerrainTrade(NULL),

	//FfH Techs: Added by Kael 08/09/2007
	m_bWater(false),
	/*************************************************************************************************/
	/**	Cutting								25/07/10										Snarko	**/
	/**																								**/
	/**				Removing rarely used/redundant stuff to improve speed.							**/
	/*************************************************************************************************/
	/**								---- Start Original Code ----									**
	m_iPreferredAlignment(NO_ALIGNMENT),
	/**								----  End Original Code  ----									**/
	/*************************************************************************************************/
	/**	Cutting									END													**/
	/*************************************************************************************************/
	m_iPrereqReligion(NO_RELIGION)
	//FfH: End Add
	/*************************************************************************************************/
	/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
	/*************************************************************************************************/
	, m_iCityCapModifier(0)
	/*************************************************************************************************/
	/** CityPopCap                  END                                                             **/
	/*************************************************************************************************/

	/************************************************************************************************/
	/* Influence Driven War                   06/24/10                                 Valkrionn    */
	/*                                                                                              */
	/*						Prevents IDW effects within specific borders                            */
	/************************************************************************************************/
	, m_bInfluenceAllowed(false)
	, m_iVictoryInfluenceModifier(100)
	, m_iDefeatInfluenceModifier(100)
	, m_iPillageInfluenceModifier(100),
	/*************************************************************************************************/
	/**	END																							**/
	/*************************************************************************************************/

	/*************************************************************************************************/
	/**	New Tag Defs	(TechInfos)				01/05/09								Xienwolf	**/
	/**																								**/
	/**										Initial Values											**/
	/*************************************************************************************************/

	m_piiTechCostShifts(NULL),
	m_iNumTechCostShifts(0), 
	m_piiTechCostMods(NULL),
	m_iNumTechCostMods(0),
m_piBonusCostShift(NULL),
m_piBonusCostMod(NULL),
m_iPrereqBroadAlignment(0),
m_iAlignmentModifier(0),
m_iFirstToTechAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iPrereqBroadEthicalAlignment(0),
m_iEthicalAlignmentModifier(0),
m_iFirstToTechEthicalAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iBonusPrereq(0)
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTechInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTechInfo::~CvTechInfo()
{
	SAFE_DELETE_ARRAY(m_piDomainExtraMoves);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piPrereqOrTechs);
	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);
	SAFE_DELETE_ARRAY(m_pbTerrainTrade);
/*************************************************************************************************/
/**	New Tag Defs	(TechInfos)				01/05/09								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piBonusCostShift);
	SAFE_DELETE_ARRAY(m_piBonusCostMod);
	if (m_piiTechCostShifts != NULL)
	{
		for (int iI = 0; iI < m_iNumTechCostShifts; iI++)
		{
			SAFE_DELETE_ARRAY(m_piiTechCostShifts[iI]);
		}
		SAFE_DELETE_ARRAY(m_piiTechCostShifts);
	}
	if (m_piiTechCostMods != NULL)
	{
		for (int iI = 0; iI < m_iNumTechCostMods; iI++)
		{
			SAFE_DELETE_ARRAY(m_piiTechCostMods[iI]);
		}
		SAFE_DELETE_ARRAY(m_piiTechCostMods);
	}
	/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
}

int CvTechInfo::getAdvisorType() const
{
	return m_iAdvisorType;
}

int CvTechInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvTechInfo::getAITradeModifier() const
{
	return m_iAITradeModifier;
}

int CvTechInfo::getResearchCost() const
{
	return m_iResearchCost;
}

int CvTechInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvTechInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvTechInfo::getEra() const
{
	return m_iEra;
}

int CvTechInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvTechInfo::getFeatureProductionModifier() const
{
	return m_iFeatureProductionModifier;
}

int CvTechInfo::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}

int CvTechInfo::getFirstFreeUnitClass() const
{
	return m_iFirstFreeUnitClass;
}

int CvTechInfo::getHealth() const
{
	return m_iHealth;
}

int CvTechInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvTechInfo::getFirstFreeTechs() const
{
	return m_iFirstFreeTechs;
}

int CvTechInfo::getAssetValue() const
{
	return m_iAssetValue;
}

int CvTechInfo::getPowerValue() const
{
	return m_iPowerValue;
}

int CvTechInfo::getGridX() const
{
	return m_iGridX;
}

int CvTechInfo::getGridY() const
{
	return m_iGridY;
}

bool CvTechInfo::isRepeat() const
{
	return m_bRepeat;
}

bool CvTechInfo::isTrade() const
{
	return m_bTrade;
}

bool CvTechInfo::isDisable() const
{
	return m_bDisable;
}

bool CvTechInfo::isGoodyTech() const
{
	return m_bGoodyTech;
}

bool CvTechInfo::isExtraWaterSeeFrom() const
{
	return m_bExtraWaterSeeFrom;
}

bool CvTechInfo::isMapCentering() const
{
	return m_bMapCentering;
}

bool CvTechInfo::isMapVisible() const
{
	return m_bMapVisible;
}

bool CvTechInfo::isMapTrading() const
{
	return m_bMapTrading;
}

bool CvTechInfo::isTechTrading() const
{
	return m_bTechTrading;
}

bool CvTechInfo::isGoldTrading() const
{
	return m_bGoldTrading;
}

bool CvTechInfo::isOpenBordersTrading() const
{
	return m_bOpenBordersTrading;
}

bool CvTechInfo::isDefensivePactTrading() const
{
	return m_bDefensivePactTrading;
}

bool CvTechInfo::isPermanentAllianceTrading() const
{
	return m_bPermanentAllianceTrading;
}

bool CvTechInfo::isVassalStateTrading() const
{
	return m_bVassalStateTrading;
}

bool CvTechInfo::isBridgeBuilding() const
{
	return m_bBridgeBuilding;
}

bool CvTechInfo::isIrrigation() const
{
	return m_bIrrigation;
}

bool CvTechInfo::isIgnoreIrrigation() const
{
	return m_bIgnoreIrrigation;
}

bool CvTechInfo::isWaterWork() const
{
	return m_bWaterWork;
}

bool CvTechInfo::isRiverTrade() const
{
	return m_bRiverTrade;
}

std::wstring CvTechInfo::getQuote()	const
{
	return gDLL->getText(m_szQuoteKey);
}

void CvTechInfo::setQuoteKey(const TCHAR* szVal)
{
	m_szQuoteKey = szVal;
}

const TCHAR* CvTechInfo::getSound() const
{
	return m_szSound;
}

void CvTechInfo::setSound(const TCHAR* szVal)
{
	m_szSound = szVal;
}

const TCHAR* CvTechInfo::getSoundMP() const
{
	return m_szSoundMP;
}

void CvTechInfo::setSoundMP(const TCHAR* szVal)
{
	m_szSoundMP = szVal;
}

//FfH Techs: Added by Kael 08/09/2007
bool CvTechInfo::isWater() const
{
	return m_bWater;
}
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvTechInfo::getPreferredAlignment() const
{
	return m_iPreferredAlignment;
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
int CvTechInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
int CvTechInfo::getCityCapModifier() const
{
	return m_iCityCapModifier;
}
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/24/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
bool CvTechInfo::isInfluenceAllowed() const
{
	return m_bInfluenceAllowed;
}

int CvTechInfo::getVictoryInfluenceModifier() const
{
	return m_iVictoryInfluenceModifier;
}

int CvTechInfo::getDefeatInfluenceModifier() const
{
	return m_iDefeatInfluenceModifier;
}

int CvTechInfo::getPillageInfluenceModifier() const
{
	return m_iPillageInfluenceModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
// Arrays

int CvTechInfo::getDomainExtraMoves(int i) const
{
	return m_piDomainExtraMoves ? m_piDomainExtraMoves[i] : -1;
}

int CvTechInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvTechInfo::getPrereqOrTechs(int i) const
{
	return m_piPrereqOrTechs ? m_piPrereqOrTechs[i] : -1;
}

int CvTechInfo::getPrereqAndTechs(int i) const
{
	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;
}

bool CvTechInfo::isCommerceFlexible(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCommerceFlexible ? m_pbCommerceFlexible[i] : false;
}

bool CvTechInfo::isTerrainTrade(int i) const
{
	return m_pbTerrainTrade ? m_pbTerrainTrade[i] : false;
}
/*************************************************************************************************/
/**	New Tag Defs	(TechInfos)				01/05/09								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvTechInfo::getPrereqBroadAlignment() const					{return m_iPrereqBroadAlignment;}
int CvTechInfo::getAlignmentModifier() const					{return m_iAlignmentModifier;}
int CvTechInfo::getFirstToTechAlignmentModifier() const			{return m_iFirstToTechAlignmentModifier;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvTechInfo::getPreferredEthicalAlignment() const            {return m_iPreferredEthicalAlignment;}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
int CvTechInfo::getPrereqBroadEthicalAlignment() const			{return m_iPrereqBroadEthicalAlignment;}
int CvTechInfo::getEthicalAlignmentModifier() const				{return m_iEthicalAlignmentModifier;}
int CvTechInfo::getFirstToTechEthicalAlignmentModifier() const	{return m_iFirstToTechEthicalAlignmentModifier;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
int CvTechInfo::getBonusPrereq() const							{return m_iBonusPrereq;}
int CvTechInfo::getTechCostShift(int i, bool bValue) const
{
	FAssertMsg(i < m_iNumTechCostShifts, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piiTechCostShifts[i][bValue ? 1 : 0];
}
int CvTechInfo::getTechCostMod(int i, bool bValue) const
{
	FAssertMsg(i < m_iNumTechCostMods, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piiTechCostMods[i][bValue ? 1 : 0];
}

int CvTechInfo::getNumTechCostMods() const
{
	return m_iNumTechCostMods;
}
int CvTechInfo::getNumTechCostShifts() const
{
	return m_iNumTechCostShifts;
}
int CvTechInfo::getBonusCostShift(int i) const					{return m_piBonusCostShift	? m_piBonusCostShift[i]	: 0;}
int CvTechInfo::getBonusCostMod(int i) const					{return m_piBonusCostMod	? m_piBonusCostMod[i]	: 100;}
const TCHAR* CvTechInfo::getQuoteKey()							{return m_szQuoteKey;}
int CvTechInfo::getPrereqReligionVectorSize()					{return m_aszExtraXMLforPass3.size();}
CvString CvTechInfo::getPrereqReligionVectorElement(int i)		{return m_aszExtraXMLforPass3[i];}
int CvTechInfo::getBonusCostShiftsVectorSize()					{return m_aszBonusCostShiftsforPass3.size();}
CvString CvTechInfo::getBonusCostShiftNamesVectorElement(int i)	{return m_aszBonusCostShiftsforPass3[i];}
int CvTechInfo::getBonusCostShiftValuesVectorElement(int i)		{return m_aiBonusCostShiftsforPass3[i];}
int CvTechInfo::getBonusCostModsVectorSize()					{return m_aszBonusCostModsforPass3.size();}
CvString CvTechInfo::getBonusCostModNamesVectorElement(int i)	{return m_aszBonusCostModsforPass3[i];}
int CvTechInfo::getBonusCostModValuesVectorElement(int i)		{return m_aiBonusCostModsforPass3[i];}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

void CvTechInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iAdvisorType);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iAITradeModifier);
	stream->Read(&m_iResearchCost);
	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);
	stream->Read(&m_iEra);
	stream->Read(&m_iFirstFreeUnitClass);
	stream->Read(&m_iFeatureProductionModifier);
	stream->Read(&m_iWorkerSpeedModifier);
	stream->Read(&m_iTradeRoutes);
	stream->Read(&m_iHealth);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iFirstFreeTechs);
	stream->Read(&m_iAssetValue);
	stream->Read(&m_iPowerValue);
	stream->Read(&m_bRepeat);
	stream->Read(&m_bTrade);
	stream->Read(&m_bDisable);
	stream->Read(&m_bGoodyTech);
	stream->Read(&m_bExtraWaterSeeFrom);
	stream->Read(&m_bMapCentering);
	stream->Read(&m_bMapVisible);
	stream->Read(&m_bMapTrading);
	stream->Read(&m_bTechTrading);
	stream->Read(&m_bGoldTrading);
	stream->Read(&m_bOpenBordersTrading);
	stream->Read(&m_bDefensivePactTrading);
	stream->Read(&m_bPermanentAllianceTrading);
	stream->Read(&m_bVassalStateTrading);
	stream->Read(&m_bBridgeBuilding);
	stream->Read(&m_bIrrigation);
	stream->Read(&m_bIgnoreIrrigation);
	stream->Read(&m_bWaterWork);
	stream->Read(&m_bRiverTrade);
	stream->Read(&m_iGridX);
	stream->Read(&m_iGridY);

	SAFE_DELETE_ARRAY(m_piDomainExtraMoves);
	m_piDomainExtraMoves = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainExtraMoves);

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piPrereqOrTechs);
	m_piPrereqOrTechs = new int[GC.getNUM_OR_TECH_PREREQS()];
	stream->Read(GC.getNUM_OR_TECH_PREREQS(), m_piPrereqOrTechs);

	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	m_piPrereqAndTechs = new int[GC.getNUM_AND_TECH_PREREQS()];
	stream->Read(GC.getNUM_AND_TECH_PREREQS(), m_piPrereqAndTechs);

	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);
	m_pbCommerceFlexible = new bool[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);

	SAFE_DELETE_ARRAY(m_pbTerrainTrade);
	m_pbTerrainTrade = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainTrade);

	stream->ReadString(m_szQuoteKey);
	stream->ReadString(m_szSound);
	stream->ReadString(m_szSoundMP);

//FfH Techs: Added by Kael 08/09/2007
	stream->Read(&m_bWater);
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iPreferredAlignment);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqReligion);
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	stream->Read(&m_iCityCapModifier);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/24/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Read(&m_bInfluenceAllowed);
	stream->Read(&m_iVictoryInfluenceModifier);
	stream->Read(&m_iDefeatInfluenceModifier);
	stream->Read(&m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(TechInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBroadAlignment);
	stream->Read(&m_iAlignmentModifier);
	stream->Read(&m_iFirstToTechAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iPreferredEthicalAlignment);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBroadEthicalAlignment);
	stream->Read(&m_iEthicalAlignmentModifier);
	stream->Read(&m_iFirstToTechEthicalAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iBonusPrereq);

	if (m_piiTechCostShifts != NULL)
	{
		for (int i = 0; i < m_iNumTechCostShifts; i++)
		{
			SAFE_DELETE_ARRAY(m_piiTechCostShifts[i]);
		}
		SAFE_DELETE_ARRAY(m_piiTechCostShifts);
	}
	stream->Read(&m_iNumTechCostShifts);
	m_piiTechCostShifts = new int* [m_iNumTechCostShifts];
	for (int i = 0; i < m_iNumTechCostShifts; i++)
	{
		m_piiTechCostShifts[i] = new int[1];
		stream->Read(1, m_piiTechCostShifts[i]);
	}
	if (m_piiTechCostMods != NULL)
	{
		for (int i = 0; i < m_iNumTechCostMods; i++)
		{
			SAFE_DELETE_ARRAY(m_piiTechCostMods[i]);
		}
		SAFE_DELETE_ARRAY(m_piiTechCostMods);
	}
	stream->Read(&m_iNumTechCostMods);
	m_piiTechCostMods = new int* [m_iNumTechCostMods];
	for (int i = 0; i < m_iNumTechCostMods; i++)
	{
		m_piiTechCostMods[i] = new int[1];
		stream->Read(1, m_piiTechCostMods[i]);
	}
	
	SAFE_DELETE_ARRAY(m_piBonusCostShift);
	m_piBonusCostShift = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusCostShift);

	
	SAFE_DELETE_ARRAY(m_piBonusCostMod);
	m_piBonusCostMod = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusCostMod);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

}

void CvTechInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iAdvisorType);
	stream->Write(m_iAIWeight);
	stream->Write(m_iAITradeModifier);
	stream->Write(m_iResearchCost);
	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);
	stream->Write(m_iEra);
	stream->Write(m_iFirstFreeUnitClass);
	stream->Write(m_iFeatureProductionModifier);
	stream->Write(m_iWorkerSpeedModifier);
	stream->Write(m_iTradeRoutes);
	stream->Write(m_iHealth);
	stream->Write(m_iHappiness);
	stream->Write(m_iFirstFreeTechs);
	stream->Write(m_iAssetValue);
	stream->Write(m_iPowerValue);
	stream->Write(m_bRepeat);
	stream->Write(m_bTrade);
	stream->Write(m_bDisable);
	stream->Write(m_bGoodyTech);
	stream->Write(m_bExtraWaterSeeFrom);
	stream->Write(m_bMapCentering);
	stream->Write(m_bMapVisible);
	stream->Write(m_bMapTrading);
	stream->Write(m_bTechTrading);
	stream->Write(m_bGoldTrading);
	stream->Write(m_bOpenBordersTrading);
	stream->Write(m_bDefensivePactTrading);
	stream->Write(m_bPermanentAllianceTrading);
	stream->Write(m_bVassalStateTrading);
	stream->Write(m_bBridgeBuilding);
	stream->Write(m_bIrrigation);
	stream->Write(m_bIgnoreIrrigation);
	stream->Write(m_bWaterWork);
	stream->Write(m_bRiverTrade);
	stream->Write(m_iGridX);
	stream->Write(m_iGridY);

	stream->Write(NUM_DOMAIN_TYPES, m_piDomainExtraMoves);
	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(GC.getNUM_OR_TECH_PREREQS(), m_piPrereqOrTechs);
	stream->Write(GC.getNUM_AND_TECH_PREREQS(), m_piPrereqAndTechs);
	stream->Write(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainTrade);

	stream->WriteString(m_szQuoteKey);
	stream->WriteString(m_szSound);
	stream->WriteString(m_szSoundMP);

//FfH Techs: Added by Kael 08/09/2007
	stream->Write(m_bWater);
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iPreferredAlignment);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	stream->Write(m_iPrereqReligion);
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	stream->Write(m_iCityCapModifier);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/24/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Write(m_bInfluenceAllowed);
	stream->Write(m_iVictoryInfluenceModifier);
	stream->Write(m_iDefeatInfluenceModifier);
	stream->Write(m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(TechInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBroadAlignment);
	stream->Write(m_iAlignmentModifier);
	stream->Write(m_iFirstToTechAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iPreferredEthicalAlignment);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBroadEthicalAlignment);
	stream->Write(m_iEthicalAlignmentModifier);
	stream->Write(m_iFirstToTechEthicalAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iBonusPrereq);
	stream->Write(m_iNumTechCostShifts);
	for (int i = 0; i < m_iNumTechCostShifts; i++)
	{
		stream->Write(1, m_piiTechCostShifts[i]);
	}
	stream->Write(m_iNumTechCostMods);
	for (int i = 0; i < m_iNumTechCostMods; i++)
	{
		stream->Write(1, m_piiTechCostMods[i]);
	}
	stream->Write(GC.getNumBonusInfos(), m_piBonusCostShift);
	stream->Write(GC.getNumBonusInfos(), m_piBonusCostMod);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

}

bool CvTechInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Advisor");
	m_iAdvisorType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iAITradeModifier, "iAITradeModifier");
	pXML->GetChildXmlValByName(&m_iResearchCost, "iCost");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");

	pXML->GetChildXmlValByName(szTextVal, "Era");
	m_iEra = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FirstFreeUnitClass");
	m_iFirstFreeUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iFeatureProductionModifier, "iFeatureProductionModifier");
	pXML->GetChildXmlValByName(&m_iWorkerSpeedModifier, "iWorkerSpeedModifier");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iFirstFreeTechs, "iFirstFreeTechs");
	pXML->GetChildXmlValByName(&m_iAssetValue, "iAsset");
	pXML->GetChildXmlValByName(&m_iPowerValue, "iPower");
	pXML->GetChildXmlValByName(&m_bRepeat, "bRepeat");
	pXML->GetChildXmlValByName(&m_bTrade, "bTrade");
	pXML->GetChildXmlValByName(&m_bDisable, "bDisable");
	pXML->GetChildXmlValByName(&m_bGoodyTech, "bGoodyTech");
	pXML->GetChildXmlValByName(&m_bExtraWaterSeeFrom, "bExtraWaterSeeFrom");
	pXML->GetChildXmlValByName(&m_bMapCentering, "bMapCentering");
	pXML->GetChildXmlValByName(&m_bMapVisible, "bMapVisible");
	pXML->GetChildXmlValByName(&m_bMapTrading, "bMapTrading");
	pXML->GetChildXmlValByName(&m_bTechTrading, "bTechTrading");
	pXML->GetChildXmlValByName(&m_bGoldTrading, "bGoldTrading");
	pXML->GetChildXmlValByName(&m_bOpenBordersTrading, "bOpenBordersTrading");
	pXML->GetChildXmlValByName(&m_bDefensivePactTrading, "bDefensivePactTrading");
	pXML->GetChildXmlValByName(&m_bPermanentAllianceTrading, "bPermanentAllianceTrading");
	pXML->GetChildXmlValByName(&m_bVassalStateTrading, "bVassalTrading");
	pXML->GetChildXmlValByName(&m_bBridgeBuilding, "bBridgeBuilding");
	pXML->GetChildXmlValByName(&m_bIrrigation, "bIrrigation");
	pXML->GetChildXmlValByName(&m_bIgnoreIrrigation, "bIgnoreIrrigation");
	pXML->GetChildXmlValByName(&m_bWaterWork, "bWaterWork");
	pXML->GetChildXmlValByName(&m_bRiverTrade, "bRiverTrade");
	pXML->GetChildXmlValByName(&m_iGridX, "iGridX");
	pXML->GetChildXmlValByName(&m_iGridY, "iGridY");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceFlexible"))
	{
		pXML->SetCommerce(&m_pbCommerceFlexible);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_pbCommerceFlexible, NUM_COMMERCE_TYPES);
	}

	pXML->SetVariableListTagPair(&m_piDomainExtraMoves, "DomainExtraMoves", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);
	pXML->SetVariableListTagPair(&m_pbTerrainTrade, "TerrainTrades", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos(), false);
	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());

	pXML->GetChildXmlValByName(szTextVal, "Quote");
	setQuoteKey(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SoundMP");
	setSoundMP(szTextVal);

//FfH Techs: Added by Kael 08/09/2007
	pXML->GetChildXmlValByName(&m_bWater, "bWater");
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "PreferredAlignment");
	m_iPreferredAlignment = pXML->FindInInfoClass(szTextVal);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "PreferredEthicalAlignment");
	m_iPreferredEthicalAlignment = pXML->FindInInfoClass(szTextVal);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_aszExtraXMLforPass3.push_back(szTextVal);
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(TechInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqBroadAlignment, "iPrereqBroadAlignment");
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iFirstToTechAlignmentModifier, "iFirstToTechAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqBroadEthicalAlignment, "iPrereqBroadEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iFirstToTechEthicalAlignmentModifier, "iFirstToTechEthicalAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "BonusPrereq");
	m_iBonusPrereq = GC.getInfoTypeForString(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusCostShifts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							m_aszBonusCostShiftsforPass3.push_back(szTextVal);
							pXML->GetNextXmlVal(&iTemp);
							m_aiBonusCostShiftsforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusCostMods"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							m_aszBonusCostModsforPass3.push_back(szTextVal);
							pXML->GetNextXmlVal(&iTemp);
							m_aiBonusCostModsforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iCityCapModifier, "iCityCapModifier", 0);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/24/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bInfluenceAllowed, "bInfluenceAllowed");
	pXML->GetChildXmlValByName(&m_iVictoryInfluenceModifier, "iVictoryInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iDefeatInfluenceModifier, "iDefeatInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iPillageInfluenceModifier, "iPillageInfluenceModifier", 100);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		This lists MUST exist so we can compare them during CopyNonDefaults function			**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pXML->InitList(&m_piPrereqOrTechs, GC.getNUM_OR_TECH_PREREQS(), -1);
	pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_AND_TECH_PREREQS(), -1);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}

bool CvTechInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	These calls retrieve the InfoBase set of fields which are available to most all XML files	**/
/**				That gets you Type, Definition, Civilopedia, bForceOverwrite...					**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"OrPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_OR_TECH_PREREQS()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqOrTechs, GC.getNUM_OR_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_OR_TECH_PREREQS()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (int j = 0; j < iNumSibs; ++j)
					{
						m_piPrereqOrTechs[j] = GC.getInfoTypeForString(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AndPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_AND_TECH_PREREQS()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_AND_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_AND_TECH_PREREQS()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (int j = 0; j < iNumSibs; ++j)
					{
						m_piPrereqAndTechs[j] = GC.getInfoTypeForString(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	New Tag Defs	(TechInfos)				01/06/09								Xienwolf	**/
/**																								**/
/**					Second Pass to reference information within the same file					**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TechCostShifts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				m_iNumTechCostShifts = iNumSibs;
				pXML->Init2DIntList(&m_piiTechCostShifts, iNumSibs, 1);
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					if (0 < iNumSibs)
					{
						for (int i = 0; i < iNumSibs; i++)
						{
							pXML->GetChildXmlValByName(szTextVal, "PromotionType");
							int iIndex = pXML->FindInInfoClass(szTextVal);

							if (iIndex > -1)
							{
								// Set the promotion value...
								m_piiTechCostShifts[i][0] = iIndex;
								// and how many we need
								pXML->GetChildXmlValByName(&m_piiTechCostShifts[i][1], "iCombatMod");
							}

							if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
							{
								break;
							}
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TechCostMods"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				m_iNumTechCostMods = iNumSibs;
				pXML->Init2DIntList(&m_piiTechCostMods, iNumSibs, 1);
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					if (0 < iNumSibs)
					{
						for (int i = 0; i < iNumSibs; i++)
						{
							pXML->GetChildXmlValByName(szTextVal, "PromotionType");
							int iIndex = pXML->FindInInfoClass(szTextVal);

							if (iIndex > -1)
							{
								// Set the promotion value...
								m_piiTechCostMods[i][0] = iIndex;
								// and how many we need
								pXML->GetChildXmlValByName(&m_piiTechCostMods[i][1], "iCombatMod");
							}

							if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
							{
								break;
							}
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	return true;
}

//FfH: Techs: Added by Kael 08/09/2007
bool CvTechInfo::readPass3()
{
/*************************************************************************************************/
/**	New Tag Defs	(TechInfos)				01/06/09								Xienwolf	**/
/**																								**/
/**					Third Pass to reference information which didn't exist before				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iPrereqReligion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	m_piBonusCostShift = new int[GC.getNumBonusInfos()];
	for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		m_piBonusCostShift[iI] = 0;
	}
	int iNumLoad = m_aiBonusCostShiftsforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszBonusCostShiftsforPass3[iI]) >= 0, "Warning, about to leak memory in CvTechInfo::readPass3");
		m_piBonusCostShift[GC.getInfoTypeForString(m_aszBonusCostShiftsforPass3[iI])] += m_aiBonusCostShiftsforPass3[iI];
	}
	m_aszBonusCostShiftsforPass3.clear();
	m_aiBonusCostShiftsforPass3.clear();
	m_piBonusCostMod = new int[GC.getNumBonusInfos()];
	for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		m_piBonusCostMod[iI] = 100;
	}
	iNumLoad = m_aiBonusCostModsforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszBonusCostModsforPass3[iI]) >= 0, "Warning, about to leak memory in CvTechInfo::readPass3");
		m_piBonusCostMod[GC.getInfoTypeForString(m_aszBonusCostModsforPass3[iI])] += m_aiBonusCostModsforPass3[iI];
	}
	m_aszBonusCostModsforPass3.clear();
	m_aiBonusCostModsforPass3.clear();

	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iPrereqReligion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTechInfo::copyNonDefaults(CvTechInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getAIWeight()					== 0)				m_iAIWeight								= pClassInfo->getAIWeight();
	if (getAITradeModifier()			== 0)				m_iAITradeModifier						= pClassInfo->getAITradeModifier();
	if (getResearchCost()				== 0)				m_iResearchCost							= pClassInfo->getResearchCost();
	if (getAdvancedStartCost()			== 0)				m_iAdvancedStartCost					= pClassInfo->getAdvancedStartCost();
	if (getAdvancedStartCostIncrease()	== 0)				m_iAdvancedStartCostIncrease			= pClassInfo->getAdvancedStartCostIncrease();
	if (getFeatureProductionModifier()	== 0)				m_iFeatureProductionModifier			= pClassInfo->getFeatureProductionModifier();
	if (getWorkerSpeedModifier()		== 0)				m_iWorkerSpeedModifier					= pClassInfo->getWorkerSpeedModifier();
	if (getTradeRoutes()				== 0)				m_iTradeRoutes							= pClassInfo->getTradeRoutes();
	if (getHealth()						== 0)				m_iHealth								= pClassInfo->getHealth();
	if (getHappiness()					== 0)				m_iHappiness							= pClassInfo->getHappiness();
	if (getFirstFreeTechs()				== 0)				m_iFirstFreeTechs						= pClassInfo->getFirstFreeTechs();
	if (getAssetValue()					== 0)				m_iAssetValue							= pClassInfo->getAssetValue();
	if (getPowerValue()					== 0)				m_iPowerValue							= pClassInfo->getPowerValue();
	if (getGridX()						== 0)				m_iGridX								= pClassInfo->getGridX();
	if (getGridY()						== 0)				m_iGridY								= pClassInfo->getGridY();
	if(m_iPrereqBroadAlignment			== 0)				m_iPrereqBroadAlignment					= pClassInfo->getPrereqBroadAlignment();
	if(m_iAlignmentModifier				== 0)				m_iAlignmentModifier					= pClassInfo->getAlignmentModifier();
	if(m_iFirstToTechAlignmentModifier	== 0)				m_iFirstToTechAlignmentModifier			= pClassInfo->getFirstToTechAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if(m_iPrereqBroadEthicalAlignment			== 0)		m_iPrereqBroadEthicalAlignment			= pClassInfo->getPrereqBroadEthicalAlignment();
	if(m_iEthicalAlignmentModifier				== 0)		m_iEthicalAlignmentModifier				= pClassInfo->getEthicalAlignmentModifier();
	if(m_iFirstToTechEthicalAlignmentModifier	== 0)		m_iFirstToTechEthicalAlignmentModifier	= pClassInfo->getFirstToTechEthicalAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/24/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	if(m_bInfluenceAllowed						== false)	m_bInfluenceAllowed						= pClassInfo->isInfluenceAllowed();
	if(m_iVictoryInfluenceModifier				== 100)		m_iVictoryInfluenceModifier				= pClassInfo->getVictoryInfluenceModifier();
	if(m_iDefeatInfluenceModifier				== 100)		m_iDefeatInfluenceModifier				= pClassInfo->getDefeatInfluenceModifier();
	if(m_iPillageInfluenceModifier				== 100)		m_iPillageInfluenceModifier				= pClassInfo->getPillageInfluenceModifier();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	if (isRepeat()						== false)			m_bRepeat								= pClassInfo->isRepeat();
	if (isTrade()						== false)			m_bTrade								= pClassInfo->isTrade();
	if (isDisable()						== false)			m_bDisable								= pClassInfo->isDisable();
	if (isGoodyTech()					== false)			m_bGoodyTech							= pClassInfo->isGoodyTech();
	if (isExtraWaterSeeFrom()			== false)			m_bExtraWaterSeeFrom					= pClassInfo->isExtraWaterSeeFrom();
	if (isMapCentering()				== false)			m_bMapCentering							= pClassInfo->isMapCentering();
	if (isMapVisible()					== false)			m_bMapVisible							= pClassInfo->isMapVisible();
	if (isMapTrading()					== false)			m_bMapTrading							= pClassInfo->isMapTrading();
	if (isTechTrading()					== false)			m_bTechTrading							= pClassInfo->isTechTrading();
	if (isGoldTrading()					== false)			m_bGoldTrading							= pClassInfo->isGoldTrading();
	if (isOpenBordersTrading()			== false)			m_bOpenBordersTrading					= pClassInfo->isOpenBordersTrading();
	if (isDefensivePactTrading()		== false)			m_bDefensivePactTrading					= pClassInfo->isDefensivePactTrading();
	if (isPermanentAllianceTrading()	== false)			m_bPermanentAllianceTrading				= pClassInfo->isPermanentAllianceTrading();
	if (isVassalStateTrading()			== false)			m_bVassalStateTrading					= pClassInfo->isVassalStateTrading();
	if (isBridgeBuilding()				== false)			m_bBridgeBuilding						= pClassInfo->isBridgeBuilding();
	if (isIrrigation()					== false)			m_bIrrigation							= pClassInfo->isIrrigation();
	if (isIgnoreIrrigation()			== false)			m_bIgnoreIrrigation						= pClassInfo->isIgnoreIrrigation();
	if (isWaterWork()					== false)			m_bWaterWork							= pClassInfo->isWaterWork();
	if (isRiverTrade()					== false)			m_bRiverTrade							= pClassInfo->isRiverTrade();
	if (m_bWater						== false)			m_bWater								= pClassInfo->isWater();
	if (getQuoteKey()					== cDefault)		m_szQuoteKey							= pClassInfo->getQuoteKey();
	if (getSound()						== cDefault)		m_szSound								= pClassInfo->getSound();
	if (getSoundMP()					== cDefault)		m_szSoundMP								= pClassInfo->getSoundMP();
	if (m_iEra							== NO_ERA)			m_iEra									= pClassInfo->getEra();
	if (m_iAdvisorType					== NO_ADVISOR)		m_iAdvisorType							= pClassInfo->getAdvisorType();
	if (m_iFirstFreeUnitClass			== NO_UNITCLASS)	m_iFirstFreeUnitClass					= pClassInfo->getFirstFreeUnitClass();
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_iPreferredAlignment			== NO_ALIGNMENT)	m_iPreferredAlignment					= pClassInfo->getPreferredAlignment();
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_iPreferredEthicalAlignment	== NO_ETHICAL_ALIGNMENT)	m_iPreferredEthicalAlignment	= pClassInfo->getPreferredEthicalAlignment();
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (m_iBonusPrereq					== NO_BONUS)		m_iBonusPrereq							= pClassInfo->getBonusPrereq();
	for ( int j = 0; j < NUM_COMMERCE_TYPES; j++)
	{
		if (m_pbCommerceFlexible[j]		== false)			m_pbCommerceFlexible[j]					= pClassInfo->isCommerceFlexible(j);
	}
	for ( int j = 0; j < NUM_DOMAIN_TYPES; j++)
	{
		if (m_piDomainExtraMoves[j]		== 0)				m_piDomainExtraMoves[j]					= pClassInfo->getDomainExtraMoves(j);
		if (m_piDomainExtraMoves[j]		== 0)				m_piDomainExtraMoves[j]					= pClassInfo->getDomainExtraMoves(j);
	}
	for ( int j = 0; j < GC.getNumTerrainInfos(); j++)
	{
		if (m_pbTerrainTrade[j]			== false)			m_pbTerrainTrade[j]						= pClassInfo->isTerrainTrade(j);
	}
	for ( int j = 0; j < GC.getNumFlavorTypes(); j++)
	{
		if (m_piFlavorValue[j]			== 0)				m_piFlavorValue[j]						= pClassInfo->getFlavorValue(j);
	}

	// Readpass2 stuff
	for ( int j = 0; j < GC.getNUM_OR_TECH_PREREQS(); j++)
	{
		if(getPrereqOrTechs(j)			== NO_TECH)			m_piPrereqOrTechs[j]					= pClassInfo->getPrereqOrTechs(j);
	}
	for ( int j = 0; j < GC.getNUM_AND_TECH_PREREQS(); j++)
	{
		if(getPrereqAndTechs(j)			== NO_TECH)			m_piPrereqAndTechs[j]					= pClassInfo->getPrereqAndTechs(j);
	}
	//if(!m_piTechCostShift)									pXML->InitList(&m_piTechCostShift, GC.getNumTechInfos(), 0);
	//if(!m_piTechCostMod)									pXML->InitList(&m_piTechCostMod, GC.getNumTechInfos(), 100);
//	for (int i = 0; i < GC.getNumTechInfos(); ++i)
//	{
//		if(getTechCostShift(i)			== 0)				m_piTechCostShift[i]					= pClassInfo->getTechCostShift(i);
//		if(getTechCostMod(i)			== 100)				m_piTechCostMod[i]						= pClassInfo->getTechCostMod(i);
//	}

	//Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getPrereqReligionVectorSize(); i++ )
	{
														m_aszExtraXMLforPass3.push_back(		pClassInfo->getPrereqReligionVectorElement(i));
	}
	for ( int i = 0; i < pClassInfo->getBonusCostShiftsVectorSize(); i++ )
	{
														m_aszBonusCostShiftsforPass3.push_back(	pClassInfo->getBonusCostShiftNamesVectorElement(i));
														m_aiBonusCostShiftsforPass3.push_back(	pClassInfo->getBonusCostShiftValuesVectorElement(i));
	}
	for ( int i = 0; i < pClassInfo->getBonusCostModsVectorSize(); i++ )
	{
														m_aszBonusCostModsforPass3.push_back(	pClassInfo->getBonusCostModNamesVectorElement(i));
														m_aiBonusCostModsforPass3.push_back(	pClassInfo->getBonusCostModValuesVectorElement(i));
	}
}

void CvTechInfo::copyNonDefaultsReadPass2(CvTechInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	for ( int i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++ )
	{
		if(bOver || pClassInfo->getPrereqOrTechs(i)		!= NO_TECH)	m_piPrereqOrTechs[i]	= pClassInfo->getPrereqOrTechs(i);
	}
	for ( int i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++ )
	{
		if(bOver || pClassInfo->getPrereqAndTechs(i)	!= NO_TECH)	m_piPrereqAndTechs[i]	= pClassInfo->getPrereqAndTechs(i);
	}
	if (pClassInfo->getNumTechCostShifts() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumTechCostShifts() : getNumTechCostShifts() + pClassInfo->getNumTechCostShifts();
		int** tempArray = new int* [iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumTechCostShifts(); ++i)
		{
			tempArray[i] = new int[1];
			tempArray[i][0] = pClassInfo->getTechCostShift(i);
			tempArray[i][1] = pClassInfo->getTechCostShift(i, true);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumTechCostShifts(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumTechCostShifts(); ++i)
				{
					if (getTechCostShift(i) == pClassInfo->getTechCostShift(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = new int[1];
					tempArray[iNewItems][0] = getTechCostShift(i);
					tempArray[iNewItems][1] = getTechCostShift(i, true);
					iNewItems++;
				}
			}

		}
		for (int i = 0; i < getNumTechCostShifts(); i++)
		{
			SAFE_DELETE_ARRAY(m_piiTechCostShifts[i]);
		}
		SAFE_DELETE_ARRAY(m_piiTechCostShifts);
		iGoalSize = iNewItems;
		m_piiTechCostShifts = new int* [iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piiTechCostShifts[i] = new int[1];
			m_piiTechCostShifts[i][0] = tempArray[i][0];
			m_piiTechCostShifts[i][1] = tempArray[i][1];
			FAssertMsg(m_piiTechCostShifts[i][0] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piiTechCostShifts[i][0] > -1, "Out of Bounds Array Melding");
		}
		m_iNumTechCostShifts = iGoalSize;
		for (int i = 0; i < iGoalSize; i++)
		{
			SAFE_DELETE_ARRAY(tempArray[i]);
		}
		SAFE_DELETE_ARRAY(tempArray);
	}
	if (pClassInfo->getNumTechCostMods() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumTechCostMods() : getNumTechCostMods() + pClassInfo->getNumTechCostMods();
		int** tempArray = new int* [iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumTechCostMods(); ++i)
		{
			tempArray[i] = new int[1];
			tempArray[i][0] = pClassInfo->getTechCostMod(i);
			tempArray[i][1] = pClassInfo->getTechCostMod(i, true);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumTechCostMods(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumTechCostMods(); ++i)
				{
					if (getTechCostMod(i) == pClassInfo->getTechCostMod(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = new int[1];
					tempArray[iNewItems][0] = getTechCostMod(i);
					tempArray[iNewItems][1] = getTechCostMod(i, true);
					iNewItems++;
				}
			}

		}
		for (int i = 0; i < getNumTechCostMods(); i++)
		{
			SAFE_DELETE_ARRAY(m_piiTechCostMods[i]);
		}
		SAFE_DELETE_ARRAY(m_piiTechCostMods);
		iGoalSize = iNewItems;
		m_piiTechCostMods = new int* [iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piiTechCostMods[i] = new int[1];
			m_piiTechCostMods[i][0] = tempArray[i][0];
			m_piiTechCostMods[i][1] = tempArray[i][1];
			FAssertMsg(m_piiTechCostMods[i][0] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piiTechCostMods[i][0] > -1, "Out of Bounds Array Melding");
		}
		m_iNumTechCostMods = iGoalSize;
		for (int i = 0; i < iGoalSize; i++)
		{
			SAFE_DELETE_ARRAY(tempArray[i]);
		}
		SAFE_DELETE_ARRAY(tempArray);
	}

	
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvPromotionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvPromotionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvPromotionInfo::CvPromotionInfo() :
m_iLayerAnimationPath(ANIMATIONPATH_NONE),
m_iPrereqPromotion(NO_PROMOTION),
m_iPrereqOrPromotion1(NO_PROMOTION),
m_iPrereqOrPromotion2(NO_PROMOTION),
m_iTechPrereq(NO_TECH),
m_iStateReligionPrereq(NO_RELIGION),
m_iCaptureUnitClass(NO_UNITCLASS),
m_iVisibilityChange(0),
m_iMovesChange(0),
m_iMoveDiscountChange(0),
m_iAirRangeChange(0),
m_iInterceptChange(0),
m_iEvasionChange(0),
m_iWithdrawalChange(0),
m_iEnemyWithdrawalChange(0),
m_iCargoChange(0),
m_iCollateralDamageChange(0),
m_iBombardRateChange(0),
m_iFirstStrikesChange(0),
m_iChanceFirstStrikesChange(0),
m_iEnemyHealChange(0),
m_iNeutralHealChange(0),
m_iFriendlyHealChange(0),
m_iSameTileHealChange(0),
m_iAdjacentTileHealChange(0),
m_iCombatPercent(0),
m_iCityAttackPercent(0),
m_iCityDefensePercent(0),
m_iHillsAttackPercent(0),
m_iHillsDefensePercent(0),
m_iCommandType(NO_COMMAND),
m_iRevoltProtection(0),
m_iCollateralDamageProtection(0),
m_iPillageChange(0),
m_iUpgradeDiscount(0),
m_iExperiencePercent(0),
m_iKamikazePercent(0),
m_bLeader(false),
m_bBlitz(false),
m_bAmphib(false),
m_bRiver(false),
m_bEnemyRoute(false),
m_bAlwaysHeal(false),
m_bHillsDoubleMove(false),
m_bImmuneToFirstStrikes(false),

m_bTradeDefender(false),

m_piNoBadExploreImprovement(NULL),
m_piTerrainAttackPercent(NULL),
m_piTerrainDefensePercent(NULL),
m_piFeatureAttackPercent(NULL),
m_piFeatureDefensePercent(NULL),
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvPromotionInfo
m_iPromotionPeakCost(0),
m_iPromotionHillCost(0),
m_piPromotionTerrainCost(NULL),
m_piPromotionFeatureCost(NULL),
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
m_piUnitCombatModifierPercent(NULL),
m_piUnitCombatCaptureRatePercent(NULL), // Upgraded Capture Rate by BI  08/16/11
m_pbUnitCombatNonCapture(NULL), 
m_piDomainModifierPercent(NULL),
m_pbTerrainDoubleMove(NULL),
m_pbFeatureDoubleMove(NULL),
/*************************************************************************************************/
/**	MobileCage								01/28/2010								Valkrionn	**/
/**																								**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
m_iLeashRange(-100),
m_iLeashChance(-1),
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
m_bLeveledImmortality(false),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
m_bNonInfluence(false),
m_bInfluence(false),
m_iVictoryInfluenceModifier(100),
m_iDefeatInfluenceModifier(100),
m_iPillageInfluenceModifier(100),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
m_iExtraPerception(0),
m_iInvisibleLevel(0),
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iCommandLimit(0),
m_iCommandRange(0),
m_iCommandXPShareRate(0),
m_iNumMinionPromotions(0),
m_piMinionPromotions(NULL),
m_iNumCapturePromotions(0),
m_piCapturePromotions(NULL),
m_iNumCommanderPromotions(0),
m_piCommanderPromotions(NULL),
m_iNumSlavePromotions(0),
m_piSlavePromotions(NULL),
m_iNumMasterPromotions(0),
m_piMasterPromotions(NULL),
m_bCommunalProperty(false),
m_bNeverHostile(false),
m_bBlind(false),
m_bOverrideHelpText(false),
m_bCannotCast(false),
m_bFreeUnit(false),
m_bNoSupply(false),
m_bTerritorial(false),
m_bRivalTerritoryExplore(false),
m_bRivalTerritoryBlock(false),
m_bPillageOnMove(false),
m_bSelfPillage(false),
m_bGetCasterXP(false),
m_bNonWarWeariness(false),
m_bNoMapReveal(false),
m_bCannotCapture(false),
m_bCityHappy(false),
m_bCityNoHappy(false),
m_bNoSupport(false),
m_bCanPillage(false),
m_bCannotPillage(false),
m_bCitySpy(false),
m_bStartGoldenAge(false),
m_bNoDefenseBonus(false),
m_bMoveImpassable(false),
m_bClimbPeaks(false),
m_bFlatMoveCost(false),
m_bIgnoreTerrainCosts(false),
m_bAttackNoWar(false),
m_bAllowAttacks(false),
m_bFirstStrikeVulnerable(false),
m_bAllowDefenseBonuses(false),
m_bNonAbandon(false),
m_bIndependant(false),
m_bReligiousCommanderPromo(false),//ReligiousCommander by BI 07/24/11
m_bEffectProm(false),
m_bStackEffect(false),
m_bAutoAcquire(false),
m_bMustMaintain(false),
m_bPrereqInCity(false),
m_bNoXP(false),
m_bPrereqInBorderEnemy(false),
m_bPrereqInBorderRival(false),
m_bPrereqInBorderTeam(false),
m_bPrereqInBorderSelf(false),
m_bPrereqInBorderNone(false),
m_bAllowNULLUnitCombat(false),
m_iRandomApplyChance(0),
m_iAssetValue(0),
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iPowerValue(0),
/**								----  End Original Code  ----									**/
m_iPowerAdd(0),
m_iPowerMult(0),
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
m_iDamageOnRemove(0),
m_iTempUnitCombat(NO_UNITCOMBAT),
m_iFreeXPCap(0),
m_fCasterXPRate(0.0f),
m_iDuration(0),
m_iAirCombat(0),
m_iAirCombatLimitBoost(0),
m_iExtraDropRange(0),
m_iAlignmentModifier(0),
m_iPrereqBroadAlignment(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iEthicalAlignmentModifier(0),
m_iPrereqBroadEthicalAlignment(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iSpellExtraRange(0),
m_iCombatConversionChance(0),
m_iCombatUnitGenerationChance(0),
m_iSlaveGenerationChance(0),
m_iGiftableXP(0.0f),
m_iCombatExtraDuration(0),
m_iDurationPerTurn(0),
m_iDurationAlter(0),
m_iChangeDuration(0),
m_iExtraSupport(0),
m_iChanceMiscast(0),
m_iCombatDmgCapBoost(0),
m_iCollateralLimitCap(0),
m_iCollateralLimitBoost(0),
m_iCollateralTargetsLimit(0),
m_iCollateralExtraTargets(0),
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
m_iFlankingLimitBoost(0),
m_iFlankingExtraTargets(0),
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
m_iHammerSacrifice(0),
m_iExtraHammerPerPop(0),
m_iFoodSacrifice(0),
m_iPopulationAdd(0),
m_iBeakerSacrifice(0),
m_iExtraBeakerPerPop(0),
m_iGoldSacrifice(0),
m_iExtraGoldPerPop(0),
m_iCultureSacrifice(0),
m_iExtraCulturePerPop(0),
m_iPrereqMinAge(0),
m_iPrereqMaxAge(0),
m_iGoldCost(0),
m_iXPTranserRate(0),
m_iPrereqWeaponTier(0),
m_iNumPromotionExcludes(0),
m_iNumPromotionReplacedBy(0),
m_iNumPromotionOverwrites(0),
m_iNumPromotionDegradesTo(0),
m_iNumPrereqUnits(0),
m_iNumPrereqReligions(0),
m_iNumPrereqTechANDs(0),
m_iNumPrereqTechORs(0),
m_iNumPrereqAlignments(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iNumPrereqEthicalAlignments(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iNumPrereqFeatures(0),
m_iNumPrereqTerrains(0),
m_iNumPrereqBonusANDs(0),
m_iNumPrereqBonusORs(0),
m_iNumPrereqCivilizations(0),
m_iNumPrereqCivics(0),
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
 m_iNumSecondaryUnitCombats(0),
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
m_iNumPrereqImprovements(0),
m_iNumPrereqCorporations(0),
m_iNumPrereqTraits(0),
m_iNumPrereqBuildingANDs(0),
m_iNumPrereqBuildingORs(0),
m_iNumPrereqEventANDs(0),
m_iNumPrereqEventORs(0),
m_iNumPrereqFeatANDs(0),
m_iNumPrereqFeatORs(0),
m_iNumPrereqFeatNOTs(0),
m_aiInvisibleTypes(NULL),
m_aiSeeInvisibleTypes(NULL),
m_piYieldFromWin(NULL),
m_piYieldForLoss(NULL),
m_piCommerceFromWin(NULL),
m_piCommerceForLoss(NULL),
m_piPromotionExcludes(NULL),
m_piPromotionReplacedBy(NULL),
m_piPromotionOverwrites(NULL),
m_piPromotionDegradesTo(NULL),
m_piPrereqUnits(NULL),
m_piPrereqReligions(NULL),
m_piPrereqTechANDs(NULL),
m_piPrereqTechORs(NULL),
m_piPrereqAlignments(NULL),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_piPrereqEthicalAlignments(NULL),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_piPrereqFeatures(NULL),
m_piPrereqTerrains(NULL),
m_piPrereqBonusANDs(NULL),
m_piPrereqBonusORs(NULL),
m_piPrereqCivilizations(NULL),
m_piPrereqCivics(NULL),
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
m_piSecondaryUnitCombats(NULL),
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
m_piPrereqImprovements(NULL),
m_piPrereqCorporations(NULL),
m_piPrereqTraits(NULL),
m_piPrereqBuildingANDs(NULL),
m_piPrereqBuildingORs(NULL),
m_piPrereqEventANDs(NULL),
m_piPrereqEventORs(NULL),
m_piPrereqFeatANDs(NULL),
m_piPrereqFeatORs(NULL),
m_piPrereqFeatNOTs(NULL),
m_iNumCityBonuses(0),
m_cbCityBonuses(NULL),
m_iNumPromotionAllows(0),
m_bRequirePermission(false),
m_piPromotionAllows(NULL),
m_iNumPrereqUnitTypesOnTile(0),
m_piPrereqUnitTypesOnTile(NULL),
m_iNumPrereqUnitTypesNOTOnTile(0),
m_piPrereqUnitTypesNOTOnTile(NULL),
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
m_iNumPromotionBuilds(0),
m_piPromotionBuilds(NULL),
m_iNumPromotionCannotBuilds(0),
m_piPromotionCannotBuilds(NULL),
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
m_iNumAffinities(0),
m_piAffinities(NULL),
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
m_iNumPrereqUnitClassesOnTile(0),
m_piPrereqUnitClassesOnTile(NULL),
m_iNumPrereqUnitClassesNOTOnTile(0),
m_piPrereqUnitClassesNOTOnTile(NULL),
m_iNumPrereqPromotionsOnTile(0),
m_piPrereqPromotionsOnTile(NULL),
m_iNumPrereqPromotionsNOTOnTile(0),
m_piPrereqPromotionsNOTOnTile(NULL),
m_iNoBadExplore(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Added by Kael 07/30/2007
m_bAIControl(false),
m_bBoarding(false),
m_bOnlyDefensive(false),
m_bDispellable(false),
m_bDoubleFortifyBonus(false),
m_bEquipment(false),
m_bFear(false),
m_bFlying(false),
m_bPrereqAliveCapture(false),
m_bHeld(false),
m_bHiddenNationality(false),
m_bIgnoreBuildingDefense(false),
m_bImmortal(false),
m_bImmuneToCapture(false),
m_bImmuneToDefensiveStrike(false),
m_bImmuneToFear(false),
m_bImmuneToMagic(false),
m_bInvisible(false),
m_bMutation(false),
/*************************************************************************************************/
/**	Dynamic Mutation						06/15/10								Valkrionn	**/
/**																								**/
/**							New tags used by the Dynamic Mutation system						**/
/*************************************************************************************************/
m_iMutationWeight(0),
m_iMutationMin(1),
m_iMutationMax(1),
m_iMutationMaxApplications(1),
m_bBadEffect(false),
/*************************************************************************************************/
/**	DynamicMutation								END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
m_iMaxApplications(0),
m_piUnitCombat(NULL),
m_piiPrereqPromotionORs(NULL),
m_piiPrereqPromotionANDs(NULL),
m_iNumPrereqPromotionORs(0),
m_iNumPrereqPromotionANDs(0),
m_piiPromotionCombatMods(NULL),
m_iNumPromotionCombatMods(0),
m_iAntiWithdrawal(0),
m_iAntiFirstStrikes(0),
m_iRangedCombatPercent(0),
m_iRangedCombatPercentGlobalCounter(0),
m_iRangedCombatPercentInBorders(0),
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
m_bNotAlive(false),
m_bPrereqAlive(false),
m_bPrereqRevealed(false),
m_bPrereqHidden(false),
m_bRace(false),
m_bGraphicalAddOnPromotion(false),
m_bRemovedByCasting(false),
m_bRemovedByCombat(false),
m_bRemovedWhenHealed(false),
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_bSeeInvisible(false),
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
m_bTargetWeakestUnit(false),
m_bTargetWeakestUnitCounter(false),
m_bTwincast(false),
m_bValidate(false),
m_bWaterWalking(false),
m_iAIWeight(0),
m_iBetrayalChance(0),
m_iBetterDefenderThanPercent(0),
m_iCasterResistModify(0),
m_iCombatCapturePercent(0),
m_iCombatHealPercent(0),
m_iCombatLimit(0),
m_iCombatPercentDefense(0),
m_iCombatPercentGlobalCounter(0),
m_iCombatPercentInBorders(0),
m_iDefensiveStrikeChance(0),
m_iDefensiveStrikeDamage(0),
m_iExpireChance(0),
m_iExtraCombatStr(0),
m_iExtraCombatDefense(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iFreeXPPerTurn(0),
m_iFreeXPFromCombat(0),
m_iGoldFromCombat(0),
/**								----  End Original Code  ----									**/
m_iFreeXPPerTurn(0.0f),
m_iFreeXPFromCombat(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iGroupSize(0),
m_iMinLevel(0),
/*************************************************************************************************/
/**	PrereqStrBoostSize						10/16/09								Valkrionn	**/
/**																								**/
/**					Allows a units StrBoost to be used as a promotion prereq					**/
/*************************************************************************************************/
m_iPrereqStrBoostSize(0),
/*************************************************************************************************/
/**	PrereqStrBoostSize							END												**/
/*************************************************************************************************/
m_iModifyGlobalCounter(0),
m_iModifyGlobalCounterOnCombat(0),
m_iResistMagic(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
m_iSpellCasterXP(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iSpellDamageModify(0),
m_iWorkRateModify(0),
m_iCaptureUnitCombat(NO_UNITCOMBAT),
m_iBlockedSpellClass(NO_SPELLCLASS),
m_iPromotionCombatApply(NO_PROMOTION),
/*************************************************************************************************/
/**	Cutting								30/01/12										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/**			Use PromotionExcludes instead, both faster and more flexible						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iPromotionImmune1(NO_PROMOTION),
m_iPromotionImmune2(NO_PROMOTION),
m_iPromotionImmune3(NO_PROMOTION),
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
m_iPromotionRandomApply(NO_PROMOTION),
m_iPromotionSummonPerk(NO_PROMOTION),
m_iBonusPrereq(NO_BONUS),
m_iPromotionPrereqOr3(NO_PROMOTION),
m_iPromotionPrereqOr4(NO_PROMOTION),
m_iPromotionPrereqAnd(NO_PROMOTION),
m_iUnitReligionPrereq(NO_RELIGION),  //PrereqUnitReligion by BI 07/24/11
m_iPromotionNextLevel(NO_PROMOTION),
m_iUnitArtStyleType(NO_UNIT_ARTSTYLE),
m_iPromotionCombatType(NO_PROMOTION),
m_iPromotionCombatMod(0),

//ReligionCombatBonus by BI 07/25/11
m_iReligionCombatType(NO_RELIGION),
m_iReligionCombatMod(0),
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
m_bInquisition(false),
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/

m_piBonusAffinity(NULL),
m_piDamageTypeCombat(NULL),
m_piDamageTypeResist(NULL),
//FfH: End Add
//PromotionClass
m_iPromotionClass(NO_PROMOTIONCLASS),
m_iSpecialCargo(NO_SPECIALUNIT),
m_iDomainCargo(NO_DOMAIN),

//Magic Rework
m_iMagicalPower(0)
//m_iDominionCapacity(0),
//m_piSpellClassExtraPower(NULL)


{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvPromotionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvPromotionInfo::~CvPromotionInfo()
{
/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piMinionPromotions);
	SAFE_DELETE_ARRAY(m_piCapturePromotions);
	SAFE_DELETE_ARRAY(m_piCommanderPromotions);
	SAFE_DELETE_ARRAY(m_piSlavePromotions);
	SAFE_DELETE_ARRAY(m_piMasterPromotions);
	m_cbCityBonuses.clear();
	m_aiInvisibleTypes.clear();
	m_aiSeeInvisibleTypes.clear();
	SAFE_DELETE_ARRAY(m_piYieldFromWin);
	SAFE_DELETE_ARRAY(m_piYieldForLoss);
	SAFE_DELETE_ARRAY(m_piCommerceFromWin);
	SAFE_DELETE_ARRAY(m_piCommerceForLoss);
	SAFE_DELETE_ARRAY(m_piPromotionExcludes);
	SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
	SAFE_DELETE_ARRAY(m_piPromotionOverwrites);
	SAFE_DELETE_ARRAY(m_piPromotionDegradesTo);
	SAFE_DELETE_ARRAY(m_piPrereqUnits);
	SAFE_DELETE_ARRAY(m_piPrereqReligions);
	SAFE_DELETE_ARRAY(m_piPrereqTechANDs);
	SAFE_DELETE_ARRAY(m_piPrereqTechORs);
	SAFE_DELETE_ARRAY(m_piPrereqAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqFeatures);
	SAFE_DELETE_ARRAY(m_piPrereqTerrains);
	SAFE_DELETE_ARRAY(m_piPrereqBonusANDs);
	SAFE_DELETE_ARRAY(m_piPrereqBonusORs);
	SAFE_DELETE_ARRAY(m_piPrereqCivilizations);
	SAFE_DELETE_ARRAY(m_piPrereqCivics);
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piSecondaryUnitCombats);
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqImprovements);
	SAFE_DELETE_ARRAY(m_piPrereqCorporations);
	SAFE_DELETE_ARRAY(m_piPrereqTraits);
	SAFE_DELETE_ARRAY(m_piPrereqBuildingANDs);
	SAFE_DELETE_ARRAY(m_piPrereqBuildingORs);
	SAFE_DELETE_ARRAY(m_piPrereqEventANDs);
	SAFE_DELETE_ARRAY(m_piPrereqEventORs);
	SAFE_DELETE_ARRAY(m_piPrereqFeatANDs);
	SAFE_DELETE_ARRAY(m_piPrereqFeatORs);
	SAFE_DELETE_ARRAY(m_piPrereqFeatNOTs);
	SAFE_DELETE_ARRAY(m_piPromotionAllows);
	SAFE_DELETE_ARRAY(m_piPrereqUnitTypesOnTile);
	SAFE_DELETE_ARRAY(m_piPrereqUnitTypesNOTOnTile);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPromotionBuilds);
	SAFE_DELETE_ARRAY(m_piPromotionCannotBuilds);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAffinities);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	int iI;
	if (m_piiPrereqPromotionORs != NULL)
	{
		for (iI=0;iI<m_iNumPrereqPromotionORs;iI++)
		{
			SAFE_DELETE_ARRAY(m_piiPrereqPromotionORs[iI]);
		}
		SAFE_DELETE_ARRAY(m_piiPrereqPromotionORs);
	}
	if (m_piiPrereqPromotionANDs != NULL)
	{
		for (iI=0;iI<m_iNumPrereqPromotionANDs;iI++)
		{
			SAFE_DELETE_ARRAY(m_piiPrereqPromotionANDs[iI]);
		}
		SAFE_DELETE_ARRAY(m_piiPrereqPromotionANDs);
	}
	if (m_piiPromotionCombatMods != NULL)
	{
		for (iI = 0; iI < m_iNumPromotionCombatMods; iI++)
		{
			SAFE_DELETE_ARRAY(m_piiPromotionCombatMods[iI]);
		}
		SAFE_DELETE_ARRAY(m_piiPromotionCombatMods);
	}
	/* original code
	SAFE_DELETE_ARRAY(m_piiPrereqPromotionORs);
	SAFE_DELETE_ARRAY(m_piiPrereqPromotionANDs);
	*/
	SAFE_DELETE_ARRAY(m_piUnitCombat);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqUnitClassesOnTile);
	SAFE_DELETE_ARRAY(m_piPrereqUnitClassesNOTOnTile);
	SAFE_DELETE_ARRAY(m_piPrereqPromotionsOnTile);
	SAFE_DELETE_ARRAY(m_piPrereqPromotionsNOTOnTile);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

//FfH Damage Types: Added by Kael 08/23/2007
	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
	SAFE_DELETE_ARRAY(m_piDamageTypeResist);
//FfH: End Add
	SAFE_DELETE_ARRAY(m_piNoBadExploreImprovement);

	SAFE_DELETE_ARRAY(m_piTerrainAttackPercent);
	SAFE_DELETE_ARRAY(m_piTerrainDefensePercent);
	SAFE_DELETE_ARRAY(m_piFeatureAttackPercent);
	SAFE_DELETE_ARRAY(m_piFeatureDefensePercent);
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvPromotionInfo
	SAFE_DELETE_ARRAY(m_piPromotionTerrainCost);
	SAFE_DELETE_ARRAY(m_piPromotionFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piUnitCombatModifierPercent);
	SAFE_DELETE_ARRAY(m_piUnitCombatCaptureRatePercent); // Upgrade Capture Rate by BI 08/16/11
	SAFE_DELETE_ARRAY(m_pbUnitCombatNonCapture); 
	SAFE_DELETE_ARRAY(m_piDomainModifierPercent);
	SAFE_DELETE_ARRAY(m_pbTerrainDoubleMove);
	SAFE_DELETE_ARRAY(m_pbFeatureDoubleMove);
	//Magic Rework
	//SAFE_DELETE_ARRAY(m_piSpellClassExtraPower);

}

int CvPromotionInfo::getLayerAnimationPath() const
{
	return m_iLayerAnimationPath;
}

int CvPromotionInfo::getPrereqPromotion() const
{
	return m_iPrereqPromotion;
}

void CvPromotionInfo::setPrereqPromotion(int i)
{
	m_iPrereqPromotion = i;
}

int CvPromotionInfo::getPrereqOrPromotion1() const
{
	return m_iPrereqOrPromotion1;
}

void CvPromotionInfo::setPrereqOrPromotion1(int i)
{
	m_iPrereqOrPromotion1 = i;
}

int CvPromotionInfo::getPrereqOrPromotion2() const
{
	return m_iPrereqOrPromotion2;
}

void CvPromotionInfo::setPrereqOrPromotion2(int i)
{
	m_iPrereqOrPromotion2 = i;
}

int CvPromotionInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvPromotionInfo::getStateReligionPrereq() const
{
	return m_iStateReligionPrereq;
}
int CvPromotionInfo::getCaptureUnitClass() const
{
	return m_iCaptureUnitClass;
}

int CvPromotionInfo::getVisibilityChange() const
{
	return m_iVisibilityChange;
}

int CvPromotionInfo::getMovesChange() const
{
	return m_iMovesChange;
}

int CvPromotionInfo::getMoveDiscountChange() const
{
	return m_iMoveDiscountChange;
}

int CvPromotionInfo::getAirRangeChange() const
{
	return m_iAirRangeChange;
}

int CvPromotionInfo::getInterceptChange() const
{
	return m_iInterceptChange;
}

int CvPromotionInfo::getEvasionChange() const
{
	return m_iEvasionChange;
}

int CvPromotionInfo::getWithdrawalChange() const
{
	return m_iWithdrawalChange;
}
int CvPromotionInfo::getEnemyWithdrawalChange() const
{
	return m_iEnemyWithdrawalChange;
}

int CvPromotionInfo::getCargoChange() const
{
	return m_iCargoChange;
}

int CvPromotionInfo::getCollateralDamageChange() const
{
	return m_iCollateralDamageChange;
}

int CvPromotionInfo::getBombardRateChange() const
{
	return m_iBombardRateChange;
}

int CvPromotionInfo::getFirstStrikesChange() const
{
	return m_iFirstStrikesChange;
}

int CvPromotionInfo::getChanceFirstStrikesChange() const
{
	return m_iChanceFirstStrikesChange;
}

int CvPromotionInfo::getEnemyHealChange() const
{
	return m_iEnemyHealChange;
}

int CvPromotionInfo::getNeutralHealChange() const
{
	return m_iNeutralHealChange;
}

int CvPromotionInfo::getFriendlyHealChange() const
{
	return m_iFriendlyHealChange;
}

int CvPromotionInfo::getSameTileHealChange() const
{
	return m_iSameTileHealChange;
}

int CvPromotionInfo::getAdjacentTileHealChange() const
{
	return m_iAdjacentTileHealChange;
}

int CvPromotionInfo::getCombatPercent() const
{
	return m_iCombatPercent;
}

int CvPromotionInfo::getCityAttackPercent() const
{
	return m_iCityAttackPercent;
}

int CvPromotionInfo::getCityDefensePercent() const
{
	return m_iCityDefensePercent;
}

int CvPromotionInfo::getHillsAttackPercent() const
{
	return m_iHillsAttackPercent;
}

int CvPromotionInfo::getHillsDefensePercent() const
{
	return m_iHillsDefensePercent;
}

int CvPromotionInfo::getCommandType() const
{
	return m_iCommandType;
}

void CvPromotionInfo::setCommandType(int iNewType)
{
	m_iCommandType = iNewType;
}

int CvPromotionInfo::getRevoltProtection() const
{
	return m_iRevoltProtection;
}

int CvPromotionInfo::getCollateralDamageProtection() const
{
	return m_iCollateralDamageProtection;
}

int CvPromotionInfo::getPillageChange() const
{
	return m_iPillageChange;
}

int CvPromotionInfo::getUpgradeDiscount() const
{
	return m_iUpgradeDiscount;
}

int CvPromotionInfo::getExperiencePercent() const
{
	return m_iExperiencePercent;
}

int CvPromotionInfo::getKamikazePercent() const
{
	return m_iKamikazePercent;
}

bool CvPromotionInfo::isLeader() const
{
	return m_bLeader;
}

bool CvPromotionInfo::isBlitz() const
{
	return m_bBlitz;
}

bool CvPromotionInfo::isAmphib() const
{
	return m_bAmphib;
}

bool CvPromotionInfo::isRiver() const
{
	return m_bRiver;
}

bool CvPromotionInfo::isEnemyRoute() const
{
	return m_bEnemyRoute;
}

bool CvPromotionInfo::isAlwaysHeal() const
{
	return m_bAlwaysHeal;
}

bool CvPromotionInfo::isHillsDoubleMove() const
{
	return m_bHillsDoubleMove;
}

bool CvPromotionInfo::isImmuneToFirstStrikes() const
{
	return m_bImmuneToFirstStrikes;
}

bool CvPromotionInfo::isTradeDefender() const
{
	return m_bTradeDefender;
}


const TCHAR* CvPromotionInfo::getSound() const
{
	return m_szSound;
}

void CvPromotionInfo::setSound(const TCHAR* szVal)
{
	m_szSound = szVal;
}
/*************************************************************************************************/
/**	MobileCage								01/28/2010								Valkrionn	**/
/**																								**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
int CvPromotionInfo::getLeashRange() const								{return m_iLeashRange;}
bool CvPromotionInfo::isLeashed() const
{
	if (m_iLeashRange != -100)
	{
		return true;
	}
	if (m_iLeashChance > 0)
	{
		return true;
	}
	return false;
}
int CvPromotionInfo::getLeashChance() const								{return m_iLeashChance;}
int CvPromotionInfo::getMaxLeash() const								{return m_iLeashRange + m_iLeashChance;}
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
bool CvPromotionInfo::isLeveledImmortality() const						{return m_bLeveledImmortality;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
bool CvPromotionInfo::isNonInfluence() const
{
	return m_bNonInfluence;
}

bool CvPromotionInfo::isInfluence() const
{
	return m_bInfluence;
}

int CvPromotionInfo::getVictoryInfluenceModifier() const
{
	return m_iVictoryInfluenceModifier;
}

int CvPromotionInfo::getDefeatInfluenceModifier() const
{
	return m_iDefeatInfluenceModifier;
}

int CvPromotionInfo::getPillageInfluenceModifier() const
{
	return m_iPillageInfluenceModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
int CvPromotionInfo::getExtraPerception() const									{return m_iExtraPerception;}
int CvPromotionInfo::getInvisibleLevel() const { return m_iInvisibleLevel; }
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvPromotionInfo::getCommandLimit() const							{return m_iCommandLimit;}
int CvPromotionInfo::getCommandRange() const							{return m_iCommandRange;}
int CvPromotionInfo::getCommandXPShareRate() const						{return m_iCommandXPShareRate;}
int CvPromotionInfo::getNumMinionPromotions() const						{return m_iNumMinionPromotions;}
PromotionTypes CvPromotionInfo::getMinionPromotion(int iI) const		{return (getNumMinionPromotions() > iI)		? (PromotionTypes)m_piMinionPromotions[iI]		: NO_PROMOTION;}
int CvPromotionInfo::getNumCapturePromotions() const { return m_iNumCapturePromotions; }
PromotionTypes CvPromotionInfo::getCapturePromotion(int iI) const { return (getNumCapturePromotions() > iI) ? (PromotionTypes)m_piCapturePromotions[iI] : NO_PROMOTION; }
int CvPromotionInfo::getNumCommanderPromotions() const					{return m_iNumCommanderPromotions;}
PromotionTypes CvPromotionInfo::getCommanderPromotion(int iI) const		{return (getNumCommanderPromotions() > iI)	? (PromotionTypes)m_piCommanderPromotions[iI]	: NO_PROMOTION;}
int CvPromotionInfo::getNumSlavePromotions() const						{return m_iNumSlavePromotions;}
PromotionTypes CvPromotionInfo::getSlavePromotion(int iI) const			{return (getNumSlavePromotions() > iI)		? (PromotionTypes)m_piSlavePromotions[iI]		: NO_PROMOTION;}
int CvPromotionInfo::getNumMasterPromotions() const						{return m_iNumMasterPromotions;}
PromotionTypes CvPromotionInfo::getMasterPromotion(int iI) const		{return (getNumMasterPromotions() > iI)		? (PromotionTypes)m_piMasterPromotions[iI]		: NO_PROMOTION;}
CvString CvPromotionInfo::getPrereqUnitsVectorElement(int i)			{return m_aszPrereqUnitsforPass3[i];}
CvString CvPromotionInfo::getPrereqCivilizationsVectorElement(int i)	{return m_aszPrereqCivilizationsforPass3[i];}
CvString CvPromotionInfo::getPrereqCivicsVectorElement(int i)			{return m_aszPrereqCivicsforPass3[i];}
CvString CvPromotionInfo::getPrereqImprovementsVectorElement(int i)		{return m_aszPrereqImprovementsforPass3[i];}
CvString CvPromotionInfo::getPrereqCorporationsVectorElement(int i)		{return m_aszPrereqCorporationsforPass3[i];}
CvString CvPromotionInfo::getPrereqTraitsVectorElement(int i)			{return m_aszPrereqTraitsforPass3[i];}
CvString CvPromotionInfo::getPrereqBuildingANDsVectorElement(int i)		{return m_aszPrereqBuildingANDsforPass3[i];}
CvString CvPromotionInfo::getPrereqBuildingORsVectorElement(int i)		{return m_aszPrereqBuildingORsforPass3[i];}
CvString CvPromotionInfo::getPrereqEventANDsVectorElement(int i)		{return m_aszPrereqEventANDsforPass3[i];}
CvString CvPromotionInfo::getPrereqEventORsVectorElement(int i)			{return m_aszPrereqEventORsforPass3[i];}
CvString CvPromotionInfo::getPrereqUnitTypesOnTileVectorElement(int i)	{return m_aszPrereqUnitTypesOnTileforPass3[i];}
CvString CvPromotionInfo::getPrereqUnitTypesNOTOnTileVectorElement(int i){return m_aszPrereqUnitTypesNOTOnTileforPass3[i];}
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
CvString CvPromotionInfo::getPromotionBuildsVectorElement(int i)		{return m_aszPromotionBuildsforPass3[i];}
CvString CvPromotionInfo::getPromotionCannotBuildsVectorElement(int i)	{return m_aszPromotionCannotBuildsforPass3[i];}
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
CvString CvPromotionInfo::getAffinitiesVectorElement(int i)				{return m_aszAffinitiesforPass3[i];}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
int CvPromotionInfo::getUnitArtStyleTypeVectorSize()					{return m_aszExtraXMLforPass3.size();}
CvString CvPromotionInfo::getUnitArtStyleTypeVectorElement(int i)		{return m_aszExtraXMLforPass3[i];}
const TCHAR *CvPromotionInfo::getPyOnRemove() const						{return m_szPyOnRemove;}
bool CvPromotionInfo::isCommunalProperty() const						{return m_bCommunalProperty;}
bool CvPromotionInfo::isNeverHostile() const							{return m_bNeverHostile;}
bool CvPromotionInfo::isBlind() const									{return m_bBlind;}
bool CvPromotionInfo::isOverrideHelpText() const						{return m_bOverrideHelpText;}
bool CvPromotionInfo::isFreeUnit() const								{return m_bFreeUnit;}
bool CvPromotionInfo::isNoSupply() const								{return m_bNoSupply;}
bool CvPromotionInfo::isCannotCast() const								{return m_bCannotCast;}
bool CvPromotionInfo::isTerritorial() const								{return m_bTerritorial;}
bool CvPromotionInfo::isRivalTerritoryExplore() const					{return m_bRivalTerritoryExplore;}
bool CvPromotionInfo::isRivalTerritoryBlock() const						{return m_bRivalTerritoryBlock;}
bool CvPromotionInfo::isPillageOnMove() const							{return m_bPillageOnMove;}
bool CvPromotionInfo::isSelfPillage() const								{return m_bSelfPillage;}
bool CvPromotionInfo::isGetCasterXP() const								{return m_bGetCasterXP;}
bool CvPromotionInfo::isNonWarWeariness() const							{return m_bNonWarWeariness;}
bool CvPromotionInfo::isNoMapReveal() const								{return m_bNoMapReveal;}
bool CvPromotionInfo::isCannotCapture() const							{return m_bCannotCapture;}
bool CvPromotionInfo::isCityHappy() const								{return m_bCityHappy;}
bool CvPromotionInfo::isCityNoHappy() const								{return m_bCityNoHappy;}
bool CvPromotionInfo::isNoSupport() const								{return m_bNoSupport;}
bool CvPromotionInfo::isCanPillage() const								{return m_bCanPillage;}
bool CvPromotionInfo::isCannotPillage() const							{return m_bCannotPillage;}
bool CvPromotionInfo::isCitySpy() const									{return m_bCitySpy;}
bool CvPromotionInfo::isStartGoldenAge() const							{return m_bStartGoldenAge;}
bool CvPromotionInfo::isNoDefenseBonus() const							{return m_bNoDefenseBonus;}
bool CvPromotionInfo::isMoveImpassable() const							{return m_bMoveImpassable;}
bool CvPromotionInfo::isClimbPeaks() const								{return m_bClimbPeaks;}
bool CvPromotionInfo::isFlatMoveCost() const							{return m_bFlatMoveCost;}
bool CvPromotionInfo::isIgnoreTerrainCosts() const						{return m_bIgnoreTerrainCosts;}
bool CvPromotionInfo::isAttackNoWar() const								{return m_bAttackNoWar;}
bool CvPromotionInfo::isAllowAttacks() const							{return m_bAllowAttacks;}
bool CvPromotionInfo::isFirstStrikeVulnerable() const					{return m_bFirstStrikeVulnerable;}
bool CvPromotionInfo::isAllowDefenseBonuses() const						{return m_bAllowDefenseBonuses;}
bool CvPromotionInfo::isNonAbandon() const								{return m_bNonAbandon;}
bool CvPromotionInfo::isIndependant() const								{return m_bIndependant;}
bool CvPromotionInfo::isReligiousCommanderPromo() const								{return m_bReligiousCommanderPromo;} //ReligiousCommander by BI 07/24/11
bool CvPromotionInfo::isEffectProm() const								{return m_bEffectProm;}
bool CvPromotionInfo::isStackEffect() const								{return m_bStackEffect;}
bool CvPromotionInfo::isAutoAcquire() const								{return m_bAutoAcquire;}
bool CvPromotionInfo::isMustMaintain() const							{return m_bMustMaintain;}
bool CvPromotionInfo::isPrereqInCity() const							{return m_bPrereqInCity;}
bool CvPromotionInfo::isNoXP() const									{return m_bNoXP;}
bool CvPromotionInfo::isPrereqInBorderEnemy() const						{return m_bPrereqInBorderEnemy;}
bool CvPromotionInfo::isPrereqInBorderRival() const						{return m_bPrereqInBorderRival;}
bool CvPromotionInfo::isPrereqInBorderTeam() const						{return m_bPrereqInBorderTeam;}
bool CvPromotionInfo::isPrereqInBorderSelf() const						{return m_bPrereqInBorderSelf;}
bool CvPromotionInfo::isPrereqInBorderNone() const						{return m_bPrereqInBorderNone;}
bool CvPromotionInfo::isAllowNULLUnitCombat() const						{return m_bAllowNULLUnitCombat;}
int CvPromotionInfo::getRandomApplyChance() const						{return m_iRandomApplyChance;}
int CvPromotionInfo::getAssetValue() const								{return m_iAssetValue;}
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvPromotionInfo::getPowerValue() const								{return m_iPowerValue;}
/**								----  End Original Code  ----									**/
int CvPromotionInfo::getPowerAdd() const								{return m_iPowerAdd;}
int CvPromotionInfo::getPowerMult() const								{return m_iPowerMult;}
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/

int CvPromotionInfo::getDamageOnRemove() const							{return m_iDamageOnRemove;}
int CvPromotionInfo::getTempUnitCombat() const							{return m_iTempUnitCombat;}
int CvPromotionInfo::getFreeXPCap() const								{return m_iFreeXPCap;}
float CvPromotionInfo::getCasterXPRate() const							{return m_fCasterXPRate;}
int CvPromotionInfo::getDuration() const								{return m_iDuration;}
int CvPromotionInfo::getAirCombat() const								{return m_iAirCombat;}
int CvPromotionInfo::getAirCombatLimitBoost() const						{return m_iAirCombatLimitBoost;}
int CvPromotionInfo::getExtraDropRange() const							{return m_iExtraDropRange;}
int CvPromotionInfo::getAlignmentModifier() const						{return m_iAlignmentModifier;}
int CvPromotionInfo::getPrereqBroadAlignment() const					{return m_iPrereqBroadAlignment;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvPromotionInfo::getEthicalAlignmentModifier() const				{return m_iEthicalAlignmentModifier;}
int CvPromotionInfo::getPrereqBroadEthicalAlignment() const				{return m_iPrereqBroadEthicalAlignment;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
int CvPromotionInfo::getSpellExtraRange() const							{return m_iSpellExtraRange;}
int CvPromotionInfo::getCombatConversionChance() const					{return m_iCombatConversionChance;}
int CvPromotionInfo::getCombatUnitGenerationChance() const				{return m_iCombatUnitGenerationChance;}
int CvPromotionInfo::getSlaveGenerationChance() const					{return m_iSlaveGenerationChance;}
int CvPromotionInfo::getGiftableXP() const								{return (int)(m_iGiftableXP*100);}
int CvPromotionInfo::getCombatExtraDuration() const						{return m_iCombatExtraDuration;}
int CvPromotionInfo::getDurationPerTurn() const							{return m_iDurationPerTurn;}
int CvPromotionInfo::getDurationAlter() const							{return m_iDurationAlter;}
int CvPromotionInfo::getChangeDuration() const							{return m_iChangeDuration;}
int CvPromotionInfo::getExtraSupport() const							{return m_iExtraSupport;}
int CvPromotionInfo::getChanceMiscast() const							{return m_iChanceMiscast;}
int CvPromotionInfo::getCombatDmgCapBoost() const						{return m_iCombatDmgCapBoost;}
int CvPromotionInfo::getCollateralLimitCap() const						{return m_iCollateralLimitCap;}
int CvPromotionInfo::getCollateralLimitBoost() const					{return m_iCollateralLimitBoost;}
int CvPromotionInfo::getCollateralTargetsLimit() const					{return m_iCollateralTargetsLimit;}
int CvPromotionInfo::getCollateralExtraTargets() const					{return m_iCollateralExtraTargets;}

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
int CvPromotionInfo::getFlankingLimitBoost() const						{return m_iFlankingLimitBoost;}
int CvPromotionInfo::getFlankingExtraTargets() const					{return m_iFlankingExtraTargets;}
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

int CvPromotionInfo::getHammerSacrifice() const							{return m_iHammerSacrifice;}
int CvPromotionInfo::getExtraHammerPerPop() const						{return m_iExtraHammerPerPop;}
int CvPromotionInfo::getFoodSacrifice() const							{return m_iFoodSacrifice;}
int CvPromotionInfo::getPopulationAdd() const							{return m_iPopulationAdd;}
int CvPromotionInfo::getBeakerSacrifice() const							{return m_iBeakerSacrifice;}
int CvPromotionInfo::getExtraBeakerPerPop() const						{return m_iExtraBeakerPerPop;}
int CvPromotionInfo::getGoldSacrifice() const							{return m_iGoldSacrifice;}
int CvPromotionInfo::getExtraGoldPerPop() const							{return m_iExtraGoldPerPop;}
int CvPromotionInfo::getCultureSacrifice() const						{return m_iCultureSacrifice;}
int CvPromotionInfo::getExtraCulturePerPop() const						{return m_iExtraCulturePerPop;}
int CvPromotionInfo::getPrereqMinAge() const							{return m_iPrereqMinAge;}
int CvPromotionInfo::getPrereqMaxAge() const							{return m_iPrereqMaxAge;}
int CvPromotionInfo::getGoldCost() const								{return m_iGoldCost;}
int CvPromotionInfo::getXPTranserRate() const							{return m_iXPTranserRate;}
int CvPromotionInfo::getPrereqTier() const								{return m_iPrereqTier;}
int CvPromotionInfo::getPrereqWeaponTier() const						{return m_iPrereqWeaponTier;}
const TCHAR *CvPromotionInfo::getPyPostCombatLost() const				{return m_szPyPostCombatLost;}
const TCHAR *CvPromotionInfo::getPyPostCombatWon() const				{return m_szPyPostCombatWon;}
/*************************************************************************************************/
/**	PyOnPromoTaken							   08/28/10								Valkrionn	**/
/*************************************************************************************************/
const TCHAR *CvPromotionInfo::getPyOnPromoTaken() const					{return m_szPyOnPromoTaken;}
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
const TCHAR *CvPromotionInfo::getNewName() const						{return m_szNewName;}
int CvPromotionInfo::getYieldFromWin(int i) const						{return m_piYieldFromWin					? m_piYieldFromWin[i]							: -1;}
int CvPromotionInfo::getYieldForLoss(int i) const						{return m_piYieldForLoss					? m_piYieldForLoss[i]							: -1;}
int CvPromotionInfo::getCommerceFromWin(int i) const					{return m_piCommerceFromWin					? m_piCommerceFromWin[i]						: -1;}
int CvPromotionInfo::getCommerceForLoss(int i) const					{return m_piCommerceForLoss					? m_piCommerceForLoss[i]						: -1;}
PromotionTypes CvPromotionInfo::getPromotionExcludes(int iI) const		{return (getNumPromotionExcludes() > iI)	? (PromotionTypes)m_piPromotionExcludes[iI]		: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionExcludes() const					{return m_iNumPromotionExcludes;}
PromotionTypes CvPromotionInfo::getPromotionReplacedBy(int iI) const	{return (getNumPromotionReplacedBy() > iI)	? (PromotionTypes)m_piPromotionReplacedBy[iI]	: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionReplacedBy() const					{return m_iNumPromotionReplacedBy;}
PromotionTypes CvPromotionInfo::getPromotionOverwrites(int iI) const	{return (getNumPromotionOverwrites() > iI)	? (PromotionTypes)m_piPromotionOverwrites[iI]	: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionOverwrites() const					{return m_iNumPromotionOverwrites;}
PromotionTypes CvPromotionInfo::getPromotionDegradesTo(int iI) const	{return (getNumPromotionDegradesTo() > iI)	? (PromotionTypes)m_piPromotionDegradesTo[iI]	: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionDegradesTo() const					{return m_iNumPromotionDegradesTo;}
int CvPromotionInfo::getPrereqUnit(int iI) const						{return (getNumPrereqUnits() > iI)			? m_piPrereqUnits[iI]							: -1;}
int CvPromotionInfo::getNumPrereqUnits() const							{return m_iNumPrereqUnits;}
int CvPromotionInfo::getPrereqReligion(int iI) const					{return (getNumPrereqReligions() > iI)		? m_piPrereqReligions[iI]						: -1;}
int CvPromotionInfo::getNumPrereqReligions() const						{return m_iNumPrereqReligions;}
int CvPromotionInfo::getPrereqTechAND(int iI) const						{return (getNumPrereqTechANDs() > iI)		? m_piPrereqTechANDs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqTechANDs() const						{return m_iNumPrereqTechANDs;}
int CvPromotionInfo::getPrereqTechOR(int iI) const						{return (getNumPrereqTechORs() > iI)		? m_piPrereqTechORs[iI]							: -1;}
int CvPromotionInfo::getNumPrereqTechORs() const						{return m_iNumPrereqTechORs;}
int CvPromotionInfo::getPrereqAlignment(int iI) const					{return (getNumPrereqAlignments() > iI)		? m_piPrereqAlignments[iI]						: -1;}
int CvPromotionInfo::getNumPrereqAlignments() const						{return m_iNumPrereqAlignments;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvPromotionInfo::getPrereqEthicalAlignment(int iI) const			{return (getNumPrereqEthicalAlignments() > iI)		? m_piPrereqEthicalAlignments[iI]		: -1;}
int CvPromotionInfo::getNumPrereqEthicalAlignments() const				{return m_iNumPrereqEthicalAlignments;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
int CvPromotionInfo::getPrereqFeature(int iI) const						{return (getNumPrereqFeatures() > iI)		? m_piPrereqFeatures[iI]						: -1;}
int CvPromotionInfo::getNumPrereqFeatures() const						{return m_iNumPrereqFeatures;}
int CvPromotionInfo::getPrereqTerrain(int iI) const						{return (getNumPrereqTerrains() > iI)		? m_piPrereqTerrains[iI]						: -1;}
int CvPromotionInfo::getNumPrereqTerrains() const						{return m_iNumPrereqTerrains;}
int CvPromotionInfo::getPrereqBonusAND(int iI) const					{return (getNumPrereqBonusANDs() > iI)		? m_piPrereqBonusANDs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqBonusANDs() const						{return m_iNumPrereqBonusANDs;}
int CvPromotionInfo::getPrereqBonusOR(int iI) const						{return (getNumPrereqBonusORs() > iI)		? m_piPrereqBonusORs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqBonusORs() const						{return m_iNumPrereqBonusORs;}
int CvPromotionInfo::getPrereqCivilization(int iI) const				{return (getNumPrereqCivilizations() > iI)	? m_piPrereqCivilizations[iI]					: -1;}
int CvPromotionInfo::getNumPrereqCivilizations() const					{return m_iNumPrereqCivilizations;}
int CvPromotionInfo::getPrereqCivic(int iI) const						{return (getNumPrereqCivics() > iI)			? m_piPrereqCivics[iI]							: -1;}
int CvPromotionInfo::getNumPrereqCivics() const							{return m_iNumPrereqCivics;}
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
int CvPromotionInfo::getSecondaryUnitCombats(int iI) const				{return (getNumSecondaryUnitCombats() > iI) ? m_piSecondaryUnitCombats[iI]					: -1;}
int CvPromotionInfo::getNumSecondaryUnitCombats() const					{return m_iNumSecondaryUnitCombats;}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
int CvPromotionInfo::getPrereqImprovement(int iI) const					{return (getNumPrereqImprovements() > iI)	? m_piPrereqImprovements[iI]					: -1;}
int CvPromotionInfo::getNumPrereqImprovements() const					{return m_iNumPrereqImprovements;}
int CvPromotionInfo::getPrereqCorporation(int iI) const					{return (getNumPrereqCorporations() > iI)	? m_piPrereqCorporations[iI]					: -1;}
int CvPromotionInfo::getNumPrereqCorporations() const					{return m_iNumPrereqCorporations;}
int CvPromotionInfo::getPrereqTrait(int iI) const						{return (getNumPrereqTraits() > iI)			? m_piPrereqTraits[iI]							: -1;}
int CvPromotionInfo::getNumPrereqTraits() const							{return m_iNumPrereqTraits;}
int CvPromotionInfo::getPrereqBuildingAND(int iI) const					{return (getNumPrereqBuildingANDs() > iI)	? m_piPrereqBuildingANDs[iI]					: -1;}
int CvPromotionInfo::getNumPrereqBuildingANDs() const					{return m_iNumPrereqBuildingANDs;}
int CvPromotionInfo::getPrereqBuildingOR(int iI) const					{return (getNumPrereqBuildingORs() > iI)	? m_piPrereqBuildingORs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqBuildingORs() const					{return m_iNumPrereqBuildingORs;}
int CvPromotionInfo::getPrereqEventAND(int iI) const					{return (getNumPrereqEventANDs() > iI)		? m_piPrereqEventANDs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqEventANDs() const						{return m_iNumPrereqEventANDs;}
int CvPromotionInfo::getPrereqEventOR(int iI) const						{return (getNumPrereqEventORs() > iI)		? m_piPrereqEventORs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqEventORs() const						{return m_iNumPrereqEventORs;}
int CvPromotionInfo::getPrereqFeatAND(int iI) const						{return (getNumPrereqFeatANDs() > iI)		? m_piPrereqFeatANDs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqFeatANDs() const						{return m_iNumPrereqFeatANDs;}
int CvPromotionInfo::getPrereqFeatOR(int iI) const						{return (getNumPrereqFeatORs() > iI)		? m_piPrereqFeatORs[iI]							: -1;}
int CvPromotionInfo::getNumPrereqFeatORs() const						{return m_iNumPrereqFeatORs;}
int CvPromotionInfo::getPrereqFeatNOT(int iI) const						{return (getNumPrereqFeatNOTs() > iI)		? m_piPrereqFeatNOTs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqFeatNOTs() const						{return m_iNumPrereqFeatNOTs;}
int CvPromotionInfo::getInvisibleType(int i) const						{return m_aiInvisibleTypes[i];}
int CvPromotionInfo::getNumInvisibleTypes() const						{return (int)m_aiInvisibleTypes.size();}
int CvPromotionInfo::getSeeInvisibleType(int i) const					{return m_aiSeeInvisibleTypes[i];}
int CvPromotionInfo::getNumSeeInvisibleTypes() const					{return (int)m_aiSeeInvisibleTypes.size();}
int CvPromotionInfo::getNumCityBonuses() const							{return m_iNumCityBonuses;}
CityBonuses CvPromotionInfo::getCityBonus(int iI) const
{
	int iCount = 0;
	CityBonuses cbTemp;
	for (std::list<CityBonuses>::const_iterator iter = m_cbCityBonuses.begin(); iter != m_cbCityBonuses.end(); ++iter)
	{
		if (iCount == iI)
		{
			cbTemp = *iter;
			break;
		}
		iCount++;
	}
	return cbTemp;
}
std::list<CityBonuses> CvPromotionInfo::listCityBonuses()				{return m_cbCityBonuses;}
bool CvPromotionInfo::isRequirePermission() const						{return m_bRequirePermission;}
PromotionTypes CvPromotionInfo::getPromotionAllows(int iI) const		{return (getNumPromotionAllows() > iI)				? (PromotionTypes)m_piPromotionAllows[iI]	: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionAllows() const						{return m_iNumPromotionAllows;}
int CvPromotionInfo::getPrereqUnitTypeOnTile(int iI) const				{return (getNumPrereqUnitTypesOnTile() > iI)		? m_piPrereqUnitTypesOnTile[iI]				: -1;}
int CvPromotionInfo::getNumPrereqUnitTypesOnTile() const				{return m_iNumPrereqUnitTypesOnTile;}
int CvPromotionInfo::getPrereqUnitTypeNOTOnTile(int iI) const			{return (getNumPrereqUnitTypesNOTOnTile() > iI)		? m_piPrereqUnitTypesNOTOnTile[iI]			: -1;}
int CvPromotionInfo::getNumPrereqUnitTypesNOTOnTile() const				{return m_iNumPrereqUnitTypesNOTOnTile;}
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
int CvPromotionInfo::getPromotionBuilds(int iI) const					{return (getNumPromotionBuilds() > iI)				? m_piPromotionBuilds[iI]					: -1;}
int CvPromotionInfo::getNumPromotionBuilds() const						{return m_iNumPromotionBuilds;}
int CvPromotionInfo::getPromotionCannotBuilds(int iI) const				{return (getNumPromotionCannotBuilds() > iI)		? m_piPromotionCannotBuilds[iI]				: -1;}
int CvPromotionInfo::getNumPromotionCannotBuilds() const				{return m_iNumPromotionCannotBuilds;}
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
int CvPromotionInfo::getAffinities(int iI) const						{return (getNumAffinities() > iI)					? m_piAffinities[iI]						: -1;}
int CvPromotionInfo::getNumAffinities() const							{return m_iNumAffinities;}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
int CvPromotionInfo::getPrereqUnitClassOnTile(int iI) const				{return (getNumPrereqUnitClassesOnTile() > iI)		? m_piPrereqUnitClassesOnTile[iI]			: -1;}
int CvPromotionInfo::getNumPrereqUnitClassesOnTile() const				{return m_iNumPrereqUnitClassesOnTile;}
int CvPromotionInfo::getPrereqUnitClassNOTOnTile(int iI) const			{return (getNumPrereqUnitClassesNOTOnTile() > iI)	? m_piPrereqUnitClassesNOTOnTile[iI]		: -1;}
int CvPromotionInfo::getNumPrereqUnitClassesNOTOnTile() const			{return m_iNumPrereqUnitClassesNOTOnTile;}
int CvPromotionInfo::getPrereqPromotionOnTile(int iI) const				{return (getNumPrereqPromotionsOnTile() > iI)		? m_piPrereqPromotionsOnTile[iI]			: -1;}
int CvPromotionInfo::getNumPrereqPromotionsOnTile() const				{return m_iNumPrereqPromotionsOnTile;}
int CvPromotionInfo::getPrereqPromotionNOTOnTile(int iI) const			{return (getNumPrereqPromotionsNOTOnTile() > iI)	? m_piPrereqPromotionsNOTOnTile[iI]			: -1;}
int CvPromotionInfo::getNumPrereqPromotionsNOTOnTile() const			{return m_iNumPrereqPromotionsNOTOnTile;}
int CvPromotionInfo::getNoBadExplore() const							{return m_iNoBadExplore;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Added by Kael 07/30/2007
bool CvPromotionInfo::isAIControl() const
{
	return m_bAIControl;
}

bool CvPromotionInfo::isBoarding() const
{
	return m_bBoarding;
}

bool CvPromotionInfo::isOnlyDefensive() const
{
	return m_bOnlyDefensive;
}

bool CvPromotionInfo::isDispellable() const
{
	return m_bDispellable;
}

bool CvPromotionInfo::isDoubleFortifyBonus() const
{
	return m_bDoubleFortifyBonus;
}

bool CvPromotionInfo::isEquipment() const
{
	return m_bEquipment;
}

bool CvPromotionInfo::isFear() const
{
	return m_bFear;
}

bool CvPromotionInfo::isFlying() const
{
	return m_bFlying;
}

bool CvPromotionInfo::isPrereqAliveCapture() const
{
	return m_bPrereqAliveCapture;
}
bool CvPromotionInfo::isHeld() const
{
	return m_bHeld;
}

bool CvPromotionInfo::isHiddenNationality() const
{
	return m_bHiddenNationality;
}

bool CvPromotionInfo::isIgnoreBuildingDefense() const
{
	return m_bIgnoreBuildingDefense;
}

bool CvPromotionInfo::isImmortal() const
{
	return m_bImmortal;
}

bool CvPromotionInfo::isImmuneToCapture() const
{
	return m_bImmuneToCapture;
}

bool CvPromotionInfo::isImmuneToDefensiveStrike() const
{
	return m_bImmuneToDefensiveStrike;
}

bool CvPromotionInfo::isImmuneToFear() const
{
	return m_bImmuneToFear;
}

bool CvPromotionInfo::isImmuneToMagic() const
{
	return m_bImmuneToMagic;
}

bool CvPromotionInfo::isInvisible() const
{
	return m_bInvisible;
}

bool CvPromotionInfo::isMutation() const
{
	return m_bMutation;
}


/*************************************************************************************************/
/**	Dynamic Mutation						06/15/10								Valkrionn	**/
/**																								**/
/**							New tags used by the Dynamic Mutation system						**/
/*************************************************************************************************/
int CvPromotionInfo::getMutationWeight() const
{
	return m_iMutationWeight;
}

int CvPromotionInfo::getMutationMin() const
{
	return m_iMutationMin;
}

int CvPromotionInfo::getMutationMax() const
{
	return m_iMutationMax;
}

int CvPromotionInfo::getMutationMaxApplications() const
{
	return m_iMutationMaxApplications;
}

bool CvPromotionInfo::isBadEffect() const
{
	return m_bBadEffect;
}
/*************************************************************************************************/
/**	DynamicMutation								END												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
int CvPromotionInfo::getMaxApplications() const
{
	return m_iMaxApplications;
}

int CvPromotionInfo::getUnitCombatMaxApplications(int i) const
{
	return m_piUnitCombat ? m_piUnitCombat[i] : 0;
}

bool CvPromotionInfo::getUnitCombat(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombat ? getUnitCombatMaxApplications(i) > -1 : false;
}

int CvPromotionInfo::getNumPrereqPromotionORs() const
{
	return m_iNumPrereqPromotionORs;
}

int CvPromotionInfo::getPrereqPromotionORs(int i, bool bValue) const
{
	FAssertMsg(i < m_iNumPrereqPromotionORs, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piiPrereqPromotionORs[i][bValue ? 1 : 0];
}

int CvPromotionInfo::getNumPrereqPromotionANDs() const
{
	return m_iNumPrereqPromotionANDs;
}

int CvPromotionInfo::getPrereqPromotionANDs(int i, bool bValue) const
{
	FAssertMsg(i < m_iNumPrereqPromotionANDs, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piiPrereqPromotionANDs[i][bValue ? 1 : 0];
}

int CvPromotionInfo::getNumPromotionCombatMods() const
{
	return m_iNumPromotionCombatMods;
}

int CvPromotionInfo::getPromotionCombatMods(int i, bool bValue) const
{
	FAssertMsg(i < m_iNumPromotionCombatMods, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piiPromotionCombatMods[i][bValue ? 1 : 0];
}


int CvPromotionInfo::getAntiWithdrawal() const
{
	return m_iAntiWithdrawal;
}

int CvPromotionInfo::getAntiFirstStrikes() const
{
	return m_iAntiFirstStrikes;
}

int CvPromotionInfo::getRangedCombatPercent() const
{
	return m_iRangedCombatPercent;
}

int CvPromotionInfo::getRangedCombatPercentGlobalCounter() const
{
	return m_iRangedCombatPercentGlobalCounter;
}

int CvPromotionInfo::getRangedCombatPercentInBorders() const
{
	return m_iRangedCombatPercentInBorders;
}
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/

bool CvPromotionInfo::isNotAlive() const
{
	return m_bNotAlive;
}

bool CvPromotionInfo::isPrereqAlive() const
{
	return m_bPrereqAlive;
}

bool CvPromotionInfo::isPrereqRevealed() const
{
	return m_bPrereqRevealed;
}
bool CvPromotionInfo::isPrereqHidden() const
{
	return m_bPrereqHidden;
}
bool CvPromotionInfo::isRace() const
{
	return m_bRace;
}
bool CvPromotionInfo::isGraphicalAddOnPromotion() const
{
	return m_bGraphicalAddOnPromotion;
}

bool CvPromotionInfo::isRemovedByCasting() const
{
	return m_bRemovedByCasting;
}

bool CvPromotionInfo::isRemovedByCombat() const
{
	return m_bRemovedByCombat;
}

bool CvPromotionInfo::isRemovedWhenHealed() const
{
	return m_bRemovedWhenHealed;
}

/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvPromotionInfo::isSeeInvisible() const
{
	return m_bSeeInvisible;
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

bool CvPromotionInfo::isTargetWeakestUnit() const
{
	return m_bTargetWeakestUnit;
}

bool CvPromotionInfo::isTargetWeakestUnitCounter() const
{
	return m_bTargetWeakestUnitCounter;
}

bool CvPromotionInfo::isTwincast() const
{
	return m_bTwincast;
}

bool CvPromotionInfo::isValidate() const
{
	return m_bValidate;
}

bool CvPromotionInfo::isWaterWalking() const
{
	return m_bWaterWalking;
}

int CvPromotionInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvPromotionInfo::getBetrayalChance() const
{
	return m_iBetrayalChance;
}

int CvPromotionInfo::getBetterDefenderThanPercent() const
{
	return m_iBetterDefenderThanPercent;
}

int CvPromotionInfo::getCasterResistModify() const
{
	return m_iCasterResistModify;
}

int CvPromotionInfo::getCombatCapturePercent() const
{
	return m_iCombatCapturePercent;
}

int CvPromotionInfo::getCombatHealPercent() const
{
	return m_iCombatHealPercent;
}

int CvPromotionInfo::getCombatLimit() const
{
/*************************************************************************************************/
/**	Higher hitpoints				28/01/11				Imported from wiser orcs by Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iCombatLimit;
/**								----  End Original Code  ----									**/
	return m_iCombatLimit * GC.getDefineINT("HIT_POINT_FACTOR"); // Wiser Orcs - Allow diffierent maximum HP for combat to work correctly.
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
}

int CvPromotionInfo::getCombatPercentDefense() const
{
	return m_iCombatPercentDefense;
}

int CvPromotionInfo::getCombatPercentGlobalCounter() const
{
	return m_iCombatPercentGlobalCounter;
}

int CvPromotionInfo::getDefensiveStrikeChance() const
{
	return m_iDefensiveStrikeChance;
}

int CvPromotionInfo::getDefensiveStrikeDamage() const
{
	return m_iDefensiveStrikeDamage;
}

int CvPromotionInfo::getExpireChance() const
{
	return m_iExpireChance;
}

int CvPromotionInfo::getExtraCombatStr() const
{
	return m_iExtraCombatStr;
}

int CvPromotionInfo::getExtraCombatDefense() const
{
	return m_iExtraCombatDefense;
}

int CvPromotionInfo::getCombatPercentInBorders() const
{
	return m_iCombatPercentInBorders;
}

int CvPromotionInfo::getFreeXPPerTurn() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iFreeXPPerTurn;
/**								----  End Original Code  ----									**/
	return (int)(m_iFreeXPPerTurn*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvPromotionInfo::getFreeXPFromCombat() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iFreeXPFromCombat;
/**								----  End Original Code  ----									**/
	return (int)(m_iFreeXPFromCombat*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvPromotionInfo::getGoldFromCombat() const
{
	return m_iGoldFromCombat;
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

int CvPromotionInfo::getGroupSize() const
{
	return m_iGroupSize;
}

int CvPromotionInfo::getMinLevel() const
{
	return m_iMinLevel;
}

/*************************************************************************************************/
/**	PrereqStrBoostSize						10/16/09								Valkrionn	**/
/**																								**/
/**					Allows a units StrBoost to be used as a promotion prereq					**/
/*************************************************************************************************/
int CvPromotionInfo::getPrereqStrBoostSize() const
{
	return m_iPrereqStrBoostSize;
}
/*************************************************************************************************/
/**	PrereqStrBoostSize							END												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Promotion PyHelp		 				07/09/10								Valkrionn	**/
/**																								**/
/**							Allows promotions to have dynamic help								**/
/*************************************************************************************************/
const char* CvPromotionInfo::getPythonHelp() const			{return m_szPyHelp;}
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/

int CvPromotionInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvPromotionInfo::getModifyGlobalCounterOnCombat() const
{
	return m_iModifyGlobalCounterOnCombat;
}

int CvPromotionInfo::getResistMagic() const
{
	return m_iResistMagic;
}

int CvPromotionInfo::getSpellCasterXP() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
	return (int)(m_iSpellCasterXP*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvPromotionInfo::getSpellDamageModify() const
{
	return m_iSpellDamageModify;
}

int CvPromotionInfo::getWorkRateModify() const
{
	return m_iWorkRateModify;
}

int CvPromotionInfo::getCaptureUnitCombat() const
{
	return m_iCaptureUnitCombat;
}
int CvPromotionInfo::getBlockedSpellClass() const
{
	return m_iBlockedSpellClass;
}

int CvPromotionInfo::getPromotionCombatApply() const
{
	return m_iPromotionCombatApply;
}

int CvPromotionInfo::getPromotionRandomApply() const
{
	return m_iPromotionRandomApply;
}

int CvPromotionInfo::getPromotionSummonPerk() const
{
	return m_iPromotionSummonPerk;
}

int CvPromotionInfo::getBonusPrereq() const
{
	return m_iBonusPrereq;
}

int CvPromotionInfo::getPromotionPrereqOr3() const
{
	return m_iPromotionPrereqOr3;
}

int CvPromotionInfo::getPromotionPrereqOr4() const
{
	return m_iPromotionPrereqOr4;
}

int CvPromotionInfo::getPromotionPrereqAnd() const
{
	return m_iPromotionPrereqAnd;
}

//PrereqUnitReligion by BI 07/24/11
int CvPromotionInfo::getUnitReligionPrereq() const
{
	return m_iUnitReligionPrereq;
}

int CvPromotionInfo::getPromotionNextLevel() const
{
	return m_iPromotionNextLevel;
}

int CvPromotionInfo::getUnitArtStyleType() const
{
	return m_iUnitArtStyleType;
}

int CvPromotionInfo::getPromotionCombatType() const
{
	return m_iPromotionCombatType;
}

int CvPromotionInfo::getPromotionCombatMod() const
{
	return m_iPromotionCombatMod;
}
//ReligionCombatBonus by BI 07/25/11
int CvPromotionInfo::getReligionCombatType() const
{
	return m_iReligionCombatType;
}

int CvPromotionInfo::getReligionCombatMod() const
{
	return m_iReligionCombatMod;
}

const TCHAR *CvPromotionInfo::getPyPerTurn() const
{
	return m_szPyPerTurn;
}

const TCHAR* CvPromotionInfo::getExtraArtType() const
{
	return m_szExtraArtType;
}


const TCHAR* CvPromotionInfo::getReplaceArtType() const
{
	return m_szReplaceArtType;
}
int CvPromotionInfo::getBonusAffinity(int i) const
{
	return m_piBonusAffinity ? m_piBonusAffinity[i] : -1;
}

int CvPromotionInfo::getDamageTypeCombat(int i) const
{
	return m_piDamageTypeCombat ? m_piDamageTypeCombat[i] : -1;
}

int CvPromotionInfo::getDamageTypeResist(int i) const
{
	return m_piDamageTypeResist ? m_piDamageTypeResist[i] : -1;
}
//FfH: End Add

// Arrays
int CvPromotionInfo::getNoBadExploreImprovement(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piNoBadExploreImprovement ? m_piNoBadExploreImprovement[i] : -1;
}

int CvPromotionInfo::getNoBadExploreImprovementsVectorSize() { return m_aszNoBadExploreImprovementsforPass3.size(); }
CvString CvPromotionInfo::getNoBadExploreImprovementNamesVectorElement(int i) { return m_aszNoBadExploreImprovementsforPass3[i]; }
int CvPromotionInfo::getNoBadExploreImprovementValuesVectorElement(int i) { return m_aiNoBadExploreImprovementsforPass3[i]; }


int CvPromotionInfo::getTerrainAttackPercent(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainAttackPercent ? m_piTerrainAttackPercent[i] : -1;
}

int CvPromotionInfo::getTerrainDefensePercent(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainDefensePercent ? m_piTerrainDefensePercent[i] : -1;
}

int CvPromotionInfo::getFeatureAttackPercent(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureAttackPercent ? m_piFeatureAttackPercent[i] : -1;
}

int CvPromotionInfo::getFeatureDefensePercent(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureDefensePercent ? m_piFeatureDefensePercent[i] : -1;
}

/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvPromotionInfo Public
int CvPromotionInfo::getPromotionHillCost() const
{
	return m_iPromotionHillCost;
}

int CvPromotionInfo::getPromotionPeakCost() const
{
	return m_iPromotionPeakCost;
}

int CvPromotionInfo::getPromotionTerrainCost(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPromotionTerrainCost ? m_piPromotionTerrainCost[i] : -1;
}

int CvPromotionInfo::getPromotionFeatureCost(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPromotionFeatureCost ? m_piPromotionFeatureCost[i] : -1;
}

/*
int CvPromotionInfo::getPromotionHillCost() const
{
	return CvUnit::getHillCostModifier();
}

int CvPromotionInfo::getPromotionPeakCost() const
{
	return CvUnit::getPeakCostModifier();
}

int CvPromotionInfo::getPromotionTerrainCost(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return CvUnit::getTerrainCostModifier(i);
}

int CvPromotionInfo::getPromotionFeatureCost(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return CvUnit::getFeatureCostModifier(i);
}
*/
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/

int CvPromotionInfo::getUnitCombatModifierPercent(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatModifierPercent ? m_piUnitCombatModifierPercent[i] : -1;
}

// Upgraded Capture Rate, by BI 08/16/11
int CvPromotionInfo::getUnitCombatCaptureRatePercent(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatCaptureRatePercent ? m_piUnitCombatCaptureRatePercent[i] : -1;
}
bool CvPromotionInfo::isUnitCombatNonCapture(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbUnitCombatNonCapture ? m_pbUnitCombatNonCapture[i] : -1;
}

int CvPromotionInfo::getDomainModifierPercent(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDomainModifierPercent ? m_piDomainModifierPercent[i] : -1;
}

bool CvPromotionInfo::getTerrainDoubleMove(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainDoubleMove ? m_pbTerrainDoubleMove[i] : false;
}

bool CvPromotionInfo::getFeatureDoubleMove(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureDoubleMove ? m_pbFeatureDoubleMove[i] : false;
}
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
bool CvPromotionInfo::isInquisition() const
{
	return m_bInquisition;
}
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
//PromotionClass
PromotionClassTypes CvPromotionInfo::getPromotionClass() const  
{
	return m_iPromotionClass;
}

SpecialUnitTypes CvPromotionInfo::getSpecialCargo() const  
{
	return m_iSpecialCargo;
}

DomainTypes CvPromotionInfo::getDomainCargo() const  
{
	return m_iDomainCargo;
}

//Magic Rework
int CvPromotionInfo::getMagicalPower() const
{
	return m_iMagicalPower;
}
//int CvPromotionInfo::getDominionCapacity() const
//{
//	return m_iDominionCapacity;
//}
//
//int CvPromotionInfo::getSpellClassExtraPower(int i) const
//{
//	FAssertMsg(i < GC.getNumSpellClassInfos(), "Index out of bounds");
//	FAssertMsg(i > -1, "Index out of bounds");
//	return m_piSpellClassExtraPower ? m_piSpellClassExtraPower[i] : 0;
//}
//


void CvPromotionInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iLayerAnimationPath);
	stream->Read(&m_iPrereqPromotion);
	stream->Read(&m_iPrereqOrPromotion1);
	stream->Read(&m_iPrereqOrPromotion2);

	stream->Read(&m_iTechPrereq);
	stream->Read(&m_iStateReligionPrereq);
	stream->Read(&m_iCaptureUnitClass);
	stream->Read(&m_iVisibilityChange);
	stream->Read(&m_iMovesChange);
	stream->Read(&m_iMoveDiscountChange);
	stream->Read(&m_iAirRangeChange);
	stream->Read(&m_iInterceptChange);
	stream->Read(&m_iEvasionChange);
	stream->Read(&m_iWithdrawalChange);
	stream->Read(&m_iEnemyWithdrawalChange);
	stream->Read(&m_iCargoChange);
	stream->Read(&m_iCollateralDamageChange);
	stream->Read(&m_iBombardRateChange);
	stream->Read(&m_iFirstStrikesChange);
	stream->Read(&m_iChanceFirstStrikesChange);
	stream->Read(&m_iEnemyHealChange);
	stream->Read(&m_iNeutralHealChange);
	stream->Read(&m_iFriendlyHealChange);
	stream->Read(&m_iSameTileHealChange);
	stream->Read(&m_iAdjacentTileHealChange);
	stream->Read(&m_iCombatPercent);
	stream->Read(&m_iCityAttackPercent);
	stream->Read(&m_iCityDefensePercent);
	stream->Read(&m_iHillsAttackPercent);
	stream->Read(&m_iHillsDefensePercent);
	stream->Read(&m_iCommandType);
	stream->Read(&m_iRevoltProtection);
	stream->Read(&m_iCollateralDamageProtection);
	stream->Read(&m_iPillageChange);
	stream->Read(&m_iUpgradeDiscount);
	stream->Read(&m_iExperiencePercent);
	stream->Read(&m_iKamikazePercent);

	stream->Read(&m_bLeader);
	stream->Read(&m_bBlitz);
	stream->Read(&m_bAmphib);
	stream->Read(&m_bRiver);
	stream->Read(&m_bEnemyRoute);
	stream->Read(&m_bAlwaysHeal);
	stream->Read(&m_bHillsDoubleMove);
	stream->Read(&m_bImmuneToFirstStrikes);
	
	stream->Read(&m_bTradeDefender);

	stream->ReadString(m_szSound);
/*************************************************************************************************/
/**	Promotion PyHelp		 				07/09/10								Valkrionn	**/
/**																								**/
/**							Allows promotions to have dynamic help								**/
/*************************************************************************************************/
	stream->ReadString(m_szPyHelp);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MobileCage								01/28/2010								Valkrionn	**/
/**																								**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	stream->Read(&m_iLeashRange);
	stream->Read(&m_iLeashChance);
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	stream->Read(&m_bLeveledImmortality);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Read(&m_bNonInfluence);
	stream->Read(&m_bInfluence);
	stream->Read(&m_iVictoryInfluenceModifier);
	stream->Read(&m_iDefeatInfluenceModifier);
	stream->Read(&m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Read(&m_iExtraPerception);
	stream->Read(&m_iInvisibleLevel);
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iCommandLimit);
	stream->Read(&m_iCommandRange);
	stream->Read(&m_iCommandXPShareRate);
	stream->Read(&m_iNumMinionPromotions);
	if (m_iNumMinionPromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piMinionPromotions);
		m_piMinionPromotions = new int[m_iNumMinionPromotions];
		stream->Read(m_iNumMinionPromotions, m_piMinionPromotions);
	}
	stream->Read(&m_iNumCapturePromotions);
	if (m_iNumCapturePromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piCapturePromotions);
		m_piCapturePromotions = new int[m_iNumCapturePromotions];
		stream->Read(m_iNumCapturePromotions, m_piCapturePromotions);
	}
	if (m_iNumCommanderPromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piCommanderPromotions);
		m_piCommanderPromotions = new int[m_iNumCommanderPromotions];
		stream->Read(m_iNumCommanderPromotions, m_piCommanderPromotions);
	}
	if (m_iNumSlavePromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piSlavePromotions);
		m_piSlavePromotions = new int[m_iNumSlavePromotions];
		stream->Read(m_iNumSlavePromotions, m_piSlavePromotions);
	}
	if (m_iNumMasterPromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piMasterPromotions);
		m_piMasterPromotions = new int[m_iNumMasterPromotions];
		stream->Read(m_iNumMasterPromotions, m_piMasterPromotions);
	}
	stream->ReadString(m_szPyOnRemove);
	stream->Read(&m_bCommunalProperty);
	stream->Read(&m_bNeverHostile);
	stream->Read(&m_bBlind);
	stream->Read(&m_bOverrideHelpText);
	stream->Read(&m_bCannotCast);
	stream->Read(&m_bFreeUnit);
	stream->Read(&m_bNoSupply);
	stream->Read(&m_bTerritorial);
	stream->Read(&m_bRivalTerritoryExplore);
	stream->Read(&m_bRivalTerritoryBlock);
	stream->Read(&m_bPillageOnMove);
	stream->Read(&m_bSelfPillage);
	stream->Read(&m_bGetCasterXP);
	stream->Read(&m_bNonWarWeariness);
	stream->Read(&m_bNoMapReveal);
	stream->Read(&m_bCannotCapture);
	stream->Read(&m_bCityHappy);
	stream->Read(&m_bCityNoHappy);
	stream->Read(&m_bNoSupport);
	stream->Read(&m_bCanPillage);
	stream->Read(&m_bCannotPillage);
	stream->Read(&m_bCitySpy);
	stream->Read(&m_bStartGoldenAge);
	stream->Read(&m_bNoDefenseBonus);
	stream->Read(&m_bMoveImpassable);
	stream->Read(&m_bClimbPeaks);
	stream->Read(&m_bFlatMoveCost);
	stream->Read(&m_bIgnoreTerrainCosts);
	stream->Read(&m_bAttackNoWar);
	stream->Read(&m_bAllowAttacks);
	stream->Read(&m_bFirstStrikeVulnerable);
	stream->Read(&m_bAllowDefenseBonuses);
	stream->Read(&m_bNonAbandon);
	stream->Read(&m_bIndependant);
	stream->Read(&m_bReligiousCommanderPromo); //ReligiousCommander by BI 07/24/11
	stream->Read(&m_bEffectProm);
	stream->Read(&m_bStackEffect);
	stream->Read(&m_bAutoAcquire);
	stream->Read(&m_bMustMaintain);
	stream->Read(&m_bPrereqInCity);
	stream->Read(&m_bNoXP);
	stream->Read(&m_bPrereqInBorderEnemy);
	stream->Read(&m_bPrereqInBorderRival);
	stream->Read(&m_bPrereqInBorderTeam);
	stream->Read(&m_bPrereqInBorderSelf);
	stream->Read(&m_bPrereqInBorderNone);
	stream->Read(&m_bAllowNULLUnitCombat);
	stream->Read(&m_iRandomApplyChance);
	stream->Read(&m_iAssetValue);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iPowerValue);
/**								----  End Original Code  ----									**/
	stream->Read(&m_iPowerAdd);
	stream->Read(&m_iPowerMult);
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	stream->Read(&m_iDamageOnRemove);
	stream->Read(&m_iTempUnitCombat);
	stream->Read(&m_iFreeXPCap);
	stream->Read(&m_fCasterXPRate);
	stream->Read(&m_iDuration);
	stream->Read(&m_iAirCombat);
	stream->Read(&m_iAirCombatLimitBoost);
	stream->Read(&m_iExtraDropRange);
	stream->Read(&m_iAlignmentModifier);
	stream->Read(&m_iPrereqBroadAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iEthicalAlignmentModifier);
	stream->Read(&m_iPrereqBroadEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iSpellExtraRange);
	stream->Read(&m_iCombatConversionChance);
	stream->Read(&m_iCombatUnitGenerationChance);
	stream->Read(&m_iSlaveGenerationChance);
	stream->Read(&m_iGiftableXP);
	stream->Read(&m_iCombatExtraDuration);
	stream->Read(&m_iDurationPerTurn);
	stream->Read(&m_iDurationAlter);
	stream->Read(&m_iChangeDuration);
	stream->Read(&m_iExtraSupport);
	stream->Read(&m_iChanceMiscast);
	stream->Read(&m_iCombatDmgCapBoost);
	stream->Read(&m_iCollateralLimitCap);
	stream->Read(&m_iCollateralLimitBoost);
	stream->Read(&m_iCollateralTargetsLimit);
	stream->Read(&m_iCollateralExtraTargets);
	stream->Read(&m_iHammerSacrifice);
	stream->Read(&m_iExtraHammerPerPop);
	stream->Read(&m_iFoodSacrifice);
	stream->Read(&m_iPopulationAdd);
	stream->Read(&m_iBeakerSacrifice);
	stream->Read(&m_iExtraBeakerPerPop);
	stream->Read(&m_iGoldSacrifice);
	stream->Read(&m_iExtraGoldPerPop);
	stream->Read(&m_iCultureSacrifice);
	stream->Read(&m_iExtraCulturePerPop);
	stream->Read(&m_iPrereqMinAge);
	stream->Read(&m_iPrereqMaxAge);
	stream->Read(&m_iGoldCost);
	stream->Read(&m_iXPTranserRate);
	stream->Read(&m_iPrereqTier);
	stream->Read(&m_iPrereqWeaponTier);
	stream->ReadString(m_szPyPostCombatLost);
	stream->ReadString(m_szPyPostCombatWon);
/*************************************************************************************************/
/**	PyOnPromoTaken							   08/28/10								Valkrionn	**/
/*************************************************************************************************/
	stream->ReadString(m_szPyOnPromoTaken);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	stream->ReadString(m_szNewName);
	stream->Read(&m_iNumCityBonuses);
	m_cbCityBonuses.clear();
	if (m_iNumCityBonuses != 0)
	{
		CityBonuses cbTemp;
		for (int iI = 0; iI < m_iNumCityBonuses; iI++)
		{
			cbTemp.read(stream);
			m_cbCityBonuses.push_back(cbTemp);
		}
	}
	SAFE_DELETE_ARRAY(m_piYieldFromWin);
	m_piYieldFromWin = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldFromWin);
	SAFE_DELETE_ARRAY(m_piYieldForLoss);
	m_piYieldForLoss = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldForLoss);
	SAFE_DELETE_ARRAY(m_piCommerceFromWin);
	m_piCommerceFromWin = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceFromWin);
	SAFE_DELETE_ARRAY(m_piCommerceForLoss);
	m_piCommerceForLoss = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceForLoss);
	stream->Read(&m_iNumPromotionExcludes);
	if (m_iNumPromotionExcludes > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionExcludes);
		m_piPromotionExcludes = new int[m_iNumPromotionExcludes];
		stream->Read(m_iNumPromotionExcludes, m_piPromotionExcludes);
	}
	stream->Read(&m_iNumPromotionReplacedBy);
	if (m_iNumPromotionReplacedBy > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
		m_piPromotionReplacedBy = new int[m_iNumPromotionReplacedBy];
		stream->Read(m_iNumPromotionReplacedBy, m_piPromotionReplacedBy);
	}
	stream->Read(&m_iNumPromotionOverwrites);
	if (m_iNumPromotionOverwrites > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionOverwrites);
		m_piPromotionOverwrites = new int[m_iNumPromotionOverwrites];
		stream->Read(m_iNumPromotionOverwrites, m_piPromotionOverwrites);
	}
	stream->Read(&m_iNumPromotionDegradesTo);
	if (m_iNumPromotionDegradesTo > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionDegradesTo);
		m_piPromotionDegradesTo = new int[m_iNumPromotionDegradesTo];
		stream->Read(m_iNumPromotionDegradesTo, m_piPromotionDegradesTo);
	}
	stream->Read(&m_iNumPrereqUnits);
	if (m_iNumPrereqUnits > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqUnits);
		m_piPrereqUnits = new int[m_iNumPrereqUnits];
		stream->Read(m_iNumPrereqUnits, m_piPrereqUnits);
	}
	stream->Read(&m_iNumPrereqReligions);
	if (m_iNumPrereqReligions > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqReligions);
		m_piPrereqReligions = new int[m_iNumPrereqReligions];
		stream->Read(m_iNumPrereqReligions, m_piPrereqReligions);
	}
	stream->Read(&m_iNumPrereqTechANDs);
	if (m_iNumPrereqTechANDs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqTechANDs);
		m_piPrereqTechANDs = new int[m_iNumPrereqTechANDs];
		stream->Read(m_iNumPrereqTechANDs, m_piPrereqTechANDs);
	}
	stream->Read(&m_iNumPrereqTechORs);
	if (m_iNumPrereqTechORs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqTechORs);
		m_piPrereqTechORs = new int[m_iNumPrereqTechORs];
		stream->Read(m_iNumPrereqTechORs, m_piPrereqTechORs);
	}
	stream->Read(&m_iNumPrereqAlignments);
	if (m_iNumPrereqAlignments > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqAlignments);
		m_piPrereqAlignments = new int[m_iNumPrereqAlignments];
		stream->Read(m_iNumPrereqAlignments, m_piPrereqAlignments);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iNumPrereqEthicalAlignments);
	if (m_iNumPrereqEthicalAlignments > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
		m_piPrereqEthicalAlignments = new int[m_iNumPrereqEthicalAlignments];
		stream->Read(m_iNumPrereqEthicalAlignments, m_piPrereqEthicalAlignments);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iNumPrereqFeatures);
	if (m_iNumPrereqFeatures > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqFeatures);
		m_piPrereqFeatures = new int[m_iNumPrereqFeatures];
		stream->Read(m_iNumPrereqFeatures, m_piPrereqFeatures);
	}
	stream->Read(&m_iNumPrereqTerrains);
	if (m_iNumPrereqTerrains > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqTerrains);
		m_piPrereqTerrains = new int[m_iNumPrereqTerrains];
		stream->Read(m_iNumPrereqTerrains, m_piPrereqTerrains);
	}
	stream->Read(&m_iNumPrereqBonusANDs);
	if (m_iNumPrereqBonusANDs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqBonusANDs);
		m_piPrereqBonusANDs = new int[m_iNumPrereqBonusANDs];
		stream->Read(m_iNumPrereqBonusANDs, m_piPrereqBonusANDs);
	}
	stream->Read(&m_iNumPrereqBonusORs);
	if (m_iNumPrereqBonusORs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqBonusORs);
		m_piPrereqBonusORs = new int[m_iNumPrereqBonusORs];
		stream->Read(m_iNumPrereqBonusORs, m_piPrereqBonusORs);
	}
	stream->Read(&m_iNumPrereqCivilizations);
	if (m_iNumPrereqCivilizations > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqCivilizations);
		m_piPrereqCivilizations = new int[m_iNumPrereqCivilizations];
		stream->Read(m_iNumPrereqCivilizations, m_piPrereqCivilizations);
	}
	stream->Read(&m_iNumPrereqCivics);
	if (m_iNumPrereqCivics > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqCivics);
		m_piPrereqCivics = new int[m_iNumPrereqCivics];
		stream->Read(m_iNumPrereqCivics, m_piPrereqCivics);
	}
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	stream->Read(&m_iNumSecondaryUnitCombats);
	if (m_iNumSecondaryUnitCombats > 0)
	{
		SAFE_DELETE_ARRAY(m_piSecondaryUnitCombats);
		m_piSecondaryUnitCombats = new int[m_iNumSecondaryUnitCombats];
		stream->Read(m_iNumSecondaryUnitCombats, m_piSecondaryUnitCombats);
	}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
	stream->Read(&m_iNumPrereqImprovements);
	if (m_iNumPrereqImprovements > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqImprovements);
		m_piPrereqImprovements = new int[m_iNumPrereqImprovements];
		stream->Read(m_iNumPrereqImprovements, m_piPrereqImprovements);
	}
	stream->Read(&m_iNumPrereqCorporations);
	if (m_iNumPrereqCorporations > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqCorporations);
		m_piPrereqCorporations = new int[m_iNumPrereqCorporations];
		stream->Read(m_iNumPrereqCorporations, m_piPrereqCorporations);
	}
	stream->Read(&m_iNumPrereqTraits);
	if (m_iNumPrereqTraits > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqTraits);
		m_piPrereqTraits = new int[m_iNumPrereqTraits];
		stream->Read(m_iNumPrereqTraits, m_piPrereqTraits);
	}
	stream->Read(&m_iNumPrereqBuildingANDs);
	if (m_iNumPrereqBuildingANDs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqBuildingANDs);
		m_piPrereqBuildingANDs = new int[m_iNumPrereqBuildingANDs];
		stream->Read(m_iNumPrereqBuildingANDs, m_piPrereqBuildingANDs);
	}
	stream->Read(&m_iNumPrereqBuildingORs);
	if (m_iNumPrereqBuildingORs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqBuildingORs);
		m_piPrereqBuildingORs = new int[m_iNumPrereqBuildingORs];
		stream->Read(m_iNumPrereqBuildingORs, m_piPrereqBuildingORs);
	}
	stream->Read(&m_iNumPrereqEventANDs);
	if (m_iNumPrereqEventANDs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqEventANDs);
		m_piPrereqEventANDs = new int[m_iNumPrereqEventANDs];
		stream->Read(m_iNumPrereqEventANDs, m_piPrereqEventANDs);
	}
	stream->Read(&m_iNumPrereqEventORs);
	if (m_iNumPrereqEventORs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqEventORs);
		m_piPrereqEventORs = new int[m_iNumPrereqEventORs];
		stream->Read(m_iNumPrereqEventORs, m_piPrereqEventORs);
	}
	stream->Read(&m_iNumPrereqFeatANDs);
	if (m_iNumPrereqFeatANDs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqFeatANDs);
		m_piPrereqFeatANDs = new int[m_iNumPrereqFeatANDs];
		stream->Read(m_iNumPrereqFeatANDs, m_piPrereqFeatANDs);
	}
	stream->Read(&m_iNumPrereqFeatORs);
	if (m_iNumPrereqFeatORs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqFeatORs);
		m_piPrereqFeatORs = new int[m_iNumPrereqFeatORs];
		stream->Read(m_iNumPrereqFeatORs, m_piPrereqFeatORs);
	}
	stream->Read(&m_iNumPrereqFeatNOTs);
	if (m_iNumPrereqFeatNOTs > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqFeatNOTs);
		m_piPrereqFeatNOTs = new int[m_iNumPrereqFeatNOTs];
		stream->Read(m_iNumPrereqFeatNOTs, m_piPrereqFeatNOTs);
	}
	int iNumInvisTypes;
	stream->Read(&iNumInvisTypes);
	for(int i=0;i<iNumInvisTypes;i++)
	{
		int iInvisibleType;
		stream->Read(&iInvisibleType);
		m_aiInvisibleTypes.push_back(iInvisibleType);
	}
	int iNumInvisibleTypes;
	stream->Read(&iNumInvisibleTypes);
	for(int i=0;i<iNumInvisibleTypes;i++)
	{
		int iSeeInvisibleType;
		stream->Read(&iSeeInvisibleType);
		m_aiSeeInvisibleTypes.push_back(iSeeInvisibleType);
	}
	stream->Read(&m_bRequirePermission);
	stream->Read(&m_iNumPromotionAllows);
	if (m_iNumPromotionAllows > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionAllows);
		m_piPromotionAllows = new int[m_iNumPromotionAllows];
		stream->Read(m_iNumPromotionAllows, m_piPromotionAllows);
	}
	stream->Read(&m_iNumPrereqUnitTypesOnTile);
	if (m_iNumPrereqUnitTypesOnTile > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqUnitTypesOnTile);
		m_piPrereqUnitTypesOnTile = new int[m_iNumPrereqUnitTypesOnTile];
		stream->Read(m_iNumPrereqUnitTypesOnTile, m_piPrereqUnitTypesOnTile);
	}
	stream->Read(&m_iNumPrereqUnitTypesNOTOnTile);
	if (m_iNumPrereqUnitTypesNOTOnTile > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqUnitTypesNOTOnTile);
		m_piPrereqUnitTypesNOTOnTile = new int[m_iNumPrereqUnitTypesNOTOnTile];
		stream->Read(m_iNumPrereqUnitTypesNOTOnTile, m_piPrereqUnitTypesNOTOnTile);
	}
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	stream->Read(&m_iNumPromotionBuilds);
	if (m_iNumPromotionBuilds > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionBuilds);
		m_piPromotionBuilds = new int[m_iNumPromotionBuilds];
		stream->Read(m_iNumPromotionBuilds, m_piPromotionBuilds);
	}

	stream->Read(&m_iNumPromotionCannotBuilds);
	if (m_iNumPromotionCannotBuilds > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionCannotBuilds);
		m_piPromotionCannotBuilds = new int[m_iNumPromotionCannotBuilds];
		stream->Read(m_iNumPromotionCannotBuilds, m_piPromotionCannotBuilds);
	}
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	stream->Read(&m_iNumAffinities);
	if (m_iNumAffinities > 0)
	{
		SAFE_DELETE_ARRAY(m_piAffinities);
		m_piAffinities = new int[m_iNumAffinities];
		stream->Read(m_iNumAffinities, m_piAffinities);
	}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	stream->Read(&m_iNumPrereqUnitClassesOnTile);
	if (m_iNumPrereqUnitClassesOnTile > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqUnitClassesOnTile);
		m_piPrereqUnitClassesOnTile = new int[m_iNumPrereqUnitClassesOnTile];
		stream->Read(m_iNumPrereqUnitClassesOnTile, m_piPrereqUnitClassesOnTile);
	}
	stream->Read(&m_iNumPrereqUnitClassesNOTOnTile);
	if (m_iNumPrereqUnitClassesNOTOnTile > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqUnitClassesNOTOnTile);
		m_piPrereqUnitClassesNOTOnTile = new int[m_iNumPrereqUnitClassesNOTOnTile];
		stream->Read(m_iNumPrereqUnitClassesNOTOnTile, m_piPrereqUnitClassesNOTOnTile);
	}
	stream->Read(&m_iNumPrereqPromotionsOnTile);
	if (m_iNumPrereqPromotionsOnTile > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqPromotionsOnTile);
		m_piPrereqPromotionsOnTile = new int[m_iNumPrereqPromotionsOnTile];
		stream->Read(m_iNumPrereqPromotionsOnTile, m_piPrereqPromotionsOnTile);
	}
	stream->Read(&m_iNumPrereqPromotionsNOTOnTile);
	if (m_iNumPrereqPromotionsNOTOnTile > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqPromotionsNOTOnTile);
		m_piPrereqPromotionsNOTOnTile = new int[m_iNumPrereqPromotionsNOTOnTile];
		stream->Read(m_iNumPrereqPromotionsNOTOnTile, m_piPrereqPromotionsNOTOnTile);
	}
	stream->Read(&m_iNoBadExplore);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Added by Kael 07/30/2007
	stream->Read(&m_bAIControl);
	stream->Read(&m_bBoarding);
	stream->Read(&m_bOnlyDefensive);
	stream->Read(&m_bDispellable);
	stream->Read(&m_bDoubleFortifyBonus);
	stream->Read(&m_bEquipment);
	stream->Read(&m_bFear);
	stream->Read(&m_bFlying);
	stream->Read(&m_bPrereqAliveCapture);
	stream->Read(&m_bHeld);
	stream->Read(&m_bHiddenNationality);
	stream->Read(&m_bIgnoreBuildingDefense);
	stream->Read(&m_bImmortal);
	stream->Read(&m_bImmuneToCapture);
	stream->Read(&m_bImmuneToDefensiveStrike);
	stream->Read(&m_bImmuneToFear);
	stream->Read(&m_bImmuneToMagic);
	stream->Read(&m_bInvisible);
	stream->Read(&m_bMutation);
/*************************************************************************************************/
/**	Dynamic Mutation						06/15/10								Valkrionn	**/
/**																								**/
/**							New tags used by the Dynamic Mutation system						**/
/*************************************************************************************************/
	stream->Read(&m_iMutationWeight);
	stream->Read(&m_iMutationMin);
	stream->Read(&m_iMutationMax);
	stream->Read(&m_iMutationMaxApplications);
	stream->Read(&m_bBadEffect);
/*************************************************************************************************/
/**	DynamicMutation								END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	stream->Read(&m_iMaxApplications);
	stream->Read(&m_iAntiWithdrawal);
	stream->Read(&m_iAntiFirstStrikes);
	stream->Read(&m_iRangedCombatPercent);
	stream->Read(&m_iRangedCombatPercentGlobalCounter);
	stream->Read(&m_iRangedCombatPercentInBorders);

	SAFE_DELETE_ARRAY(m_piUnitCombat);
	m_piUnitCombat = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombat);

	/* original code
	SAFE_DELETE_ARRAY(m_piPrereqPromotionORs);
	m_piPrereqPromotionORs = new int[GC.getNumPromotionInfos()];
	stream->Read(GC.getNumPromotionInfos(), m_piPrereqPromotionORs);

	SAFE_DELETE_ARRAY(m_piPrereqPromotionANDs);
	m_piPrereqPromotionANDs = new int[GC.getNumPromotionInfos()];
	stream->Read(GC.getNumPromotionInfos(), m_piPrereqPromotionANDs);
	*/
	if (m_piiPrereqPromotionORs != NULL)
	{
		for(int i=0;i<m_iNumPrereqPromotionORs;i++)
		{
			SAFE_DELETE_ARRAY(m_piiPrereqPromotionORs[i]);
		}
		SAFE_DELETE_ARRAY(m_piiPrereqPromotionORs);
	}
	stream->Read(&m_iNumPrereqPromotionORs);
	m_piiPrereqPromotionORs = new int*[m_iNumPrereqPromotionORs];
	for(int i=0;i<m_iNumPrereqPromotionORs;i++)
	{
		m_piiPrereqPromotionORs[i]  = new int[1];
		stream->Read(1, m_piiPrereqPromotionORs[i]);
	}

	if (m_piiPrereqPromotionANDs != NULL)
	{
		for(int i=0;i<m_iNumPrereqPromotionANDs;i++)
		{
			SAFE_DELETE_ARRAY(m_piiPrereqPromotionANDs[i]);
		}
		SAFE_DELETE_ARRAY(m_piiPrereqPromotionANDs);
	}
	stream->Read(&m_iNumPrereqPromotionANDs);
	m_piiPrereqPromotionANDs = new int*[m_iNumPrereqPromotionANDs];
	for(int i=0;i<m_iNumPrereqPromotionANDs;i++)
	{
		m_piiPrereqPromotionANDs[i]  = new int[1];
		stream->Read(1, m_piiPrereqPromotionANDs[i]);
	}
	if (m_piiPromotionCombatMods != NULL)
	{
		for (int i = 0; i < m_iNumPromotionCombatMods; i++)
		{
			SAFE_DELETE_ARRAY(m_piiPromotionCombatMods[i]);
		}
		SAFE_DELETE_ARRAY(m_piiPromotionCombatMods);
	}
	stream->Read(&m_iNumPromotionCombatMods);
	m_piiPromotionCombatMods = new int* [m_iNumPromotionCombatMods];
	for (int i = 0; i < m_iNumPromotionCombatMods; i++)
	{
		m_piiPromotionCombatMods[i] = new int[1];
		stream->Read(1, m_piiPromotionCombatMods[i]);
	}
	/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	stream->Read(&m_bNotAlive);
	stream->Read(&m_bPrereqAlive);
	stream->Read(&m_bPrereqRevealed);
	stream->Read(&m_bPrereqHidden);
	stream->Read(&m_bRace);
	stream->Read(&m_bGraphicalAddOnPromotion);
	stream->Read(&m_bRemovedByCasting);
	stream->Read(&m_bRemovedByCombat);
	stream->Read(&m_bRemovedWhenHealed);
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_bSeeInvisible);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	stream->Read(&m_bTargetWeakestUnit);
	stream->Read(&m_bTargetWeakestUnitCounter);
	stream->Read(&m_bTwincast);
	stream->Read(&m_bValidate);
	stream->Read(&m_bWaterWalking);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iBetrayalChance);
	stream->Read(&m_iBetterDefenderThanPercent);
	stream->Read(&m_iCasterResistModify);
	stream->Read(&m_iCombatCapturePercent);
	stream->Read(&m_iCombatHealPercent);
	stream->Read(&m_iCombatLimit);
	stream->Read(&m_iCombatPercentDefense);
	stream->Read(&m_iCombatPercentGlobalCounter);
	stream->Read(&m_iCombatPercentInBorders);
	stream->Read(&m_iDefensiveStrikeChance);
	stream->Read(&m_iDefensiveStrikeDamage);
	stream->Read(&m_iExpireChance);
	stream->Read(&m_iExtraCombatStr);
	stream->Read(&m_iExtraCombatDefense);
	stream->Read(&m_iFreeXPPerTurn);
	stream->Read(&m_iFreeXPFromCombat);
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iGoldFromCombat);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	stream->Read(&m_iGroupSize);
	stream->Read(&m_iMinLevel);
/*************************************************************************************************/
/**	PrereqStrBoostSize						10/16/09								Valkrionn	**/
/**																								**/
/**					Allows a units StrBoost to be used as a promotion prereq					**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqStrBoostSize);
/*************************************************************************************************/
/**	PrereqStrBoostSize							END												**/
/*************************************************************************************************/
	stream->Read(&m_iModifyGlobalCounter);
	stream->Read(&m_iModifyGlobalCounterOnCombat);
	stream->Read(&m_iResistMagic);
	stream->Read(&m_iSpellCasterXP);
	stream->Read(&m_iSpellDamageModify);
	stream->Read(&m_iWorkRateModify);
	stream->Read(&m_iCaptureUnitCombat);
	stream->Read(&m_iBlockedSpellClass);
	stream->Read(&m_iPromotionCombatApply);

	stream->Read(&m_iPromotionRandomApply);
	stream->Read(&m_iPromotionSummonPerk);
	stream->Read(&m_iBonusPrereq);
	stream->Read(&m_iPromotionPrereqOr3);
	stream->Read(&m_iPromotionPrereqOr4);
	stream->Read(&m_iPromotionPrereqAnd);
	stream->Read(&m_iUnitReligionPrereq); //PrereqUnitReligion by BI 07/24/11
	stream->Read(&m_iPromotionNextLevel);
	stream->ReadString(m_szPyPerTurn);
	stream->ReadString(m_szExtraArtType);
	stream->ReadString(m_szReplaceArtType);
	stream->Read(&m_iUnitArtStyleType);
	stream->Read(&m_iPromotionCombatType);
	stream->Read(&m_iPromotionCombatMod);
	//ReligionCombatBonus by BI 07/25/11
	stream->Read(&m_iReligionCombatType);
	stream->Read(&m_iReligionCombatMod);
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
	stream->Read(&m_bInquisition);
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/


	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	m_piBonusAffinity = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusAffinity);

	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
	m_piDamageTypeCombat = new int[GC.getNumDamageTypeInfos()];
	stream->Read(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);

	SAFE_DELETE_ARRAY(m_piDamageTypeResist);
	m_piDamageTypeResist = new int[GC.getNumDamageTypeInfos()];
	stream->Read(GC.getNumDamageTypeInfos(), m_piDamageTypeResist);
//FfH: End Add

	// Arrays
	SAFE_DELETE_ARRAY(m_piNoBadExploreImprovement);
	m_piNoBadExploreImprovement = new int[GC.getNumImprovementInfos()];
	stream->Read(GC.getNumImprovementInfos(), m_piNoBadExploreImprovement);

	SAFE_DELETE_ARRAY(m_piTerrainAttackPercent);
	m_piTerrainAttackPercent = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainAttackPercent);

	SAFE_DELETE_ARRAY(m_piTerrainDefensePercent);
	m_piTerrainDefensePercent = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainDefensePercent);

	SAFE_DELETE_ARRAY(m_piFeatureAttackPercent);
	m_piFeatureAttackPercent = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureAttackPercent);

	SAFE_DELETE_ARRAY(m_piFeatureDefensePercent);
	m_piFeatureDefensePercent = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureDefensePercent);

/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvPromotionInfo
	stream->Read(&m_iPromotionHillCost);
	stream->Read(&m_iPromotionPeakCost);

	SAFE_DELETE_ARRAY(m_piPromotionTerrainCost);
	m_piPromotionTerrainCost = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piPromotionTerrainCost);

	SAFE_DELETE_ARRAY(m_piPromotionFeatureCost);
	m_piPromotionFeatureCost = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piPromotionFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piUnitCombatModifierPercent);
	m_piUnitCombatModifierPercent = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatModifierPercent);

	// Upgraded Capture Rate by BI 08/16/11
	SAFE_DELETE_ARRAY(m_piUnitCombatCaptureRatePercent);
	m_piUnitCombatCaptureRatePercent = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatCaptureRatePercent);

	SAFE_DELETE_ARRAY(m_pbUnitCombatNonCapture);
	m_pbUnitCombatNonCapture = new bool[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pbUnitCombatNonCapture);


	SAFE_DELETE_ARRAY(m_piDomainModifierPercent);
	m_piDomainModifierPercent = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainModifierPercent);

	SAFE_DELETE_ARRAY(m_pbTerrainDoubleMove);
	m_pbTerrainDoubleMove = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainDoubleMove);

	SAFE_DELETE_ARRAY(m_pbFeatureDoubleMove);
	m_pbFeatureDoubleMove = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureDoubleMove);
	//Magic Rework

	stream->Read(&m_iMagicalPower);
	//stream->Read(&m_iDominionCapacity);
	//SAFE_DELETE_ARRAY(m_piSpellClassExtraPower);
	//m_piSpellClassExtraPower = new int[GC.getNumSpellClassInfos()];
	//stream->Read(GC.getNumSpellClassInfos(), m_piSpellClassExtraPower);

}

void CvPromotionInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iLayerAnimationPath);
	stream->Write(m_iPrereqPromotion);
	stream->Write(m_iPrereqOrPromotion1);
	stream->Write(m_iPrereqOrPromotion2);

	stream->Write(m_iTechPrereq);
	stream->Write(m_iStateReligionPrereq);
	stream->Write(m_iCaptureUnitClass);
	stream->Write(m_iVisibilityChange);
	stream->Write(m_iMovesChange);
	stream->Write(m_iMoveDiscountChange);
	stream->Write(m_iAirRangeChange);
	stream->Write(m_iInterceptChange);
	stream->Write(m_iEvasionChange);
	stream->Write(m_iWithdrawalChange);
	stream->Write(m_iEnemyWithdrawalChange);
	stream->Write(m_iCargoChange);
	stream->Write(m_iCollateralDamageChange);
	stream->Write(m_iBombardRateChange);
	stream->Write(m_iFirstStrikesChange);
	stream->Write(m_iChanceFirstStrikesChange);
	stream->Write(m_iEnemyHealChange);
	stream->Write(m_iNeutralHealChange);
	stream->Write(m_iFriendlyHealChange);
	stream->Write(m_iSameTileHealChange);
	stream->Write(m_iAdjacentTileHealChange);
	stream->Write(m_iCombatPercent);
	stream->Write(m_iCityAttackPercent);
	stream->Write(m_iCityDefensePercent);
	stream->Write(m_iHillsAttackPercent);
	stream->Write(m_iHillsDefensePercent);
	stream->Write(m_iCommandType);
	stream->Write(m_iRevoltProtection);
	stream->Write(m_iCollateralDamageProtection);
	stream->Write(m_iPillageChange);
	stream->Write(m_iUpgradeDiscount);
	stream->Write(m_iExperiencePercent);
	stream->Write(m_iKamikazePercent);

	stream->Write(m_bLeader);
	stream->Write(m_bBlitz);
	stream->Write(m_bAmphib);
	stream->Write(m_bRiver);
	stream->Write(m_bEnemyRoute);
	stream->Write(m_bAlwaysHeal);
	stream->Write(m_bHillsDoubleMove);
	stream->Write(m_bImmuneToFirstStrikes);

	stream->Write(m_bTradeDefender);
	
	stream->WriteString(m_szSound);
/*************************************************************************************************/
/**	Promotion PyHelp		 				07/09/10								Valkrionn	**/
/**																								**/
/**							Allows promotions to have dynamic help								**/
/*************************************************************************************************/
	stream->WriteString(m_szPyHelp);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MobileCage								01/28/2010								Valkrionn	**/
/**																								**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	stream->Write(m_iLeashRange);
	stream->Write(m_iLeashChance);
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	stream->Write(m_bLeveledImmortality);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Write(m_bNonInfluence);
	stream->Write(m_bInfluence);
	stream->Write(m_iVictoryInfluenceModifier);
	stream->Write(m_iDefeatInfluenceModifier);
	stream->Write(m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Write(m_iExtraPerception);
	stream->Write(m_iInvisibleLevel);
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iCommandLimit);
	stream->Write(m_iCommandRange);
	stream->Write(m_iCommandXPShareRate);
	stream->Write(m_iNumMinionPromotions);
	if (m_iNumMinionPromotions > 0)
		stream->Write(m_iNumMinionPromotions, m_piMinionPromotions);
	stream->Write(m_iNumCapturePromotions);
	if (m_iNumCapturePromotions > 0)
		stream->Write(m_iNumCapturePromotions, m_piCapturePromotions);
	stream->Write(m_iNumCommanderPromotions);
	if (m_iNumCommanderPromotions > 0)
		stream->Write(m_iNumCommanderPromotions, m_piCommanderPromotions);
	stream->Write(m_iNumSlavePromotions);
	if (m_iNumSlavePromotions > 0)
		stream->Write(m_iNumSlavePromotions, m_piSlavePromotions);
	stream->Write(m_iNumMasterPromotions);
	if (m_iNumMasterPromotions > 0)
		stream->Write(m_iNumMasterPromotions, m_piMasterPromotions);
	stream->WriteString(m_szPyOnRemove);
	stream->Write(m_bCommunalProperty);
	stream->Write(m_bNeverHostile);
	stream->Write(m_bBlind);
	stream->Write(m_bOverrideHelpText);
	stream->Write(m_bCannotCast);
	stream->Write(m_bFreeUnit);
	stream->Write(m_bNoSupply);
	stream->Write(m_bTerritorial);
	stream->Write(m_bRivalTerritoryExplore);
	stream->Write(m_bRivalTerritoryBlock);
	stream->Write(m_bPillageOnMove);
	stream->Write(m_bSelfPillage);
	stream->Write(m_bGetCasterXP);
	stream->Write(m_bNonWarWeariness);
	stream->Write(m_bNoMapReveal);
	stream->Write(m_bCannotCapture);
	stream->Write(m_bCityHappy);
	stream->Write(m_bCityNoHappy);
	stream->Write(m_bNoSupport);
	stream->Write(m_bCanPillage);
	stream->Write(m_bCannotPillage);
	stream->Write(m_bCitySpy);
	stream->Write(m_bStartGoldenAge);
	stream->Write(m_bNoDefenseBonus);
	stream->Write(m_bMoveImpassable);
	stream->Write(m_bClimbPeaks);
	stream->Write(m_bFlatMoveCost);
	stream->Write(m_bIgnoreTerrainCosts);
	stream->Write(m_bAttackNoWar);
	stream->Write(m_bAllowAttacks);
	stream->Write(m_bFirstStrikeVulnerable);
	stream->Write(m_bAllowDefenseBonuses);
	stream->Write(m_bNonAbandon);
	stream->Write(m_bIndependant);
	stream->Write(m_bReligiousCommanderPromo); //ReligiousCommander by BI 07/24/11
	stream->Write(m_bEffectProm);
	stream->Write(m_bStackEffect);
	stream->Write(m_bAutoAcquire);
	stream->Write(m_bMustMaintain);
	stream->Write(m_bPrereqInCity);
	stream->Write(m_bNoXP);
	stream->Write(m_bPrereqInBorderEnemy);
	stream->Write(m_bPrereqInBorderRival);
	stream->Write(m_bPrereqInBorderTeam);
	stream->Write(m_bPrereqInBorderSelf);
	stream->Write(m_bPrereqInBorderNone);
	stream->Write(m_bAllowNULLUnitCombat);
	stream->Write(m_iRandomApplyChance);
	stream->Write(m_iAssetValue);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iPowerValue);
/**								----  End Original Code  ----									**/
	stream->Write(m_iPowerAdd);
	stream->Write(m_iPowerMult);
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	stream->Write(m_iDamageOnRemove);
	stream->Write(m_iTempUnitCombat);
	stream->Write(m_iFreeXPCap);
	stream->Write(m_fCasterXPRate);
	stream->Write(m_iDuration);
	stream->Write(m_iAirCombat);
	stream->Write(m_iAirCombatLimitBoost);
	stream->Write(m_iExtraDropRange);
	stream->Write(m_iAlignmentModifier);
	stream->Write(m_iPrereqBroadAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iEthicalAlignmentModifier);
	stream->Write(m_iPrereqBroadEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iSpellExtraRange);
	stream->Write(m_iCombatConversionChance);
	stream->Write(m_iCombatUnitGenerationChance);
	stream->Write(m_iSlaveGenerationChance);
	stream->Write(m_iGiftableXP);
	stream->Write(m_iCombatExtraDuration);
	stream->Write(m_iDurationPerTurn);
	stream->Write(m_iDurationAlter);
	stream->Write(m_iChangeDuration);
	stream->Write(m_iExtraSupport);
	stream->Write(m_iChanceMiscast);
	stream->Write(m_iCombatDmgCapBoost);
	stream->Write(m_iCollateralLimitCap);
	stream->Write(m_iCollateralLimitBoost);
	stream->Write(m_iCollateralTargetsLimit);
	stream->Write(m_iCollateralExtraTargets);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	stream->Write(m_iFlankingLimitBoost);
	stream->Write(m_iFlankingExtraTargets);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	stream->Write(m_iHammerSacrifice);
	stream->Write(m_iExtraHammerPerPop);
	stream->Write(m_iFoodSacrifice);
	stream->Write(m_iPopulationAdd);
	stream->Write(m_iBeakerSacrifice);
	stream->Write(m_iExtraBeakerPerPop);
	stream->Write(m_iGoldSacrifice);
	stream->Write(m_iExtraGoldPerPop);
	stream->Write(m_iCultureSacrifice);
	stream->Write(m_iExtraCulturePerPop);
	stream->Write(m_iPrereqMinAge);
	stream->Write(m_iPrereqMaxAge);
	stream->Write(m_iGoldCost);
	stream->Write(m_iXPTranserRate);
	stream->Write(m_iPrereqTier);
	stream->Write(m_iPrereqWeaponTier);
	stream->WriteString(m_szPyPostCombatLost);
	stream->WriteString(m_szPyPostCombatWon);
/*************************************************************************************************/
/**	PyOnPromoTaken							   08/28/10								Valkrionn	**/
/*************************************************************************************************/
	stream->WriteString(m_szPyOnPromoTaken);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	stream->WriteString(m_szNewName);
	stream->Write(m_iNumCityBonuses);
	if (m_iNumCityBonuses != 0)
	{
		std::list<CityBonuses> cbDupe = m_cbCityBonuses;
		while (!cbDupe.empty())
		{
			CityBonuses cbTemp = cbDupe.front();
			cbDupe.pop_front();
			cbTemp.write(stream);
		}
	}
	stream->Write(NUM_YIELD_TYPES, m_piYieldFromWin);
	stream->Write(NUM_YIELD_TYPES, m_piYieldForLoss);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceFromWin);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceForLoss);
	stream->Write(m_iNumPromotionExcludes);
	if (m_iNumPromotionExcludes > 0)
		stream->Write(m_iNumPromotionExcludes, m_piPromotionExcludes);
	stream->Write(m_iNumPromotionReplacedBy);
	if (m_iNumPromotionReplacedBy > 0)
		stream->Write(m_iNumPromotionReplacedBy, m_piPromotionReplacedBy);
	stream->Write(m_iNumPromotionOverwrites);
	if (m_iNumPromotionOverwrites > 0)
		stream->Write(m_iNumPromotionOverwrites, m_piPromotionOverwrites);
	stream->Write(m_iNumPromotionDegradesTo);
	if (m_iNumPromotionDegradesTo > 0)
		stream->Write(m_iNumPromotionDegradesTo, m_piPromotionDegradesTo);
	stream->Write(m_iNumPrereqUnits);
	if (m_iNumPrereqUnits > 0)
		stream->Write(m_iNumPrereqUnits, m_piPrereqUnits);
	stream->Write(m_iNumPrereqReligions);
	if (m_iNumPrereqReligions > 0)
		stream->Write(m_iNumPrereqReligions, m_piPrereqReligions);
	stream->Write(m_iNumPrereqTechANDs);
	if (m_iNumPrereqTechANDs > 0)
		stream->Write(m_iNumPrereqTechANDs, m_piPrereqTechANDs);
	stream->Write(m_iNumPrereqTechORs);
	if (m_iNumPrereqTechORs > 0)
		stream->Write(m_iNumPrereqTechORs, m_piPrereqTechORs);
	stream->Write(m_iNumPrereqAlignments);
	if (m_iNumPrereqAlignments > 0)
		stream->Write(m_iNumPrereqAlignments, m_piPrereqAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iNumPrereqEthicalAlignments);
	if (m_iNumPrereqEthicalAlignments > 0)
		stream->Write(m_iNumPrereqEthicalAlignments, m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iNumPrereqFeatures);
	if (m_iNumPrereqFeatures > 0)
		stream->Write(m_iNumPrereqFeatures, m_piPrereqFeatures);
	stream->Write(m_iNumPrereqTerrains);
	if (m_iNumPrereqTerrains > 0)
		stream->Write(m_iNumPrereqTerrains, m_piPrereqTerrains);
	stream->Write(m_iNumPrereqBonusANDs);
	if (m_iNumPrereqBonusANDs > 0)
		stream->Write(m_iNumPrereqBonusANDs, m_piPrereqBonusANDs);
	stream->Write(m_iNumPrereqBonusORs);
	if (m_iNumPrereqBonusORs > 0)
		stream->Write(m_iNumPrereqBonusORs, m_piPrereqBonusORs);
	stream->Write(m_iNumPrereqCivilizations);
	if (m_iNumPrereqCivilizations > 0)
		stream->Write(m_iNumPrereqCivilizations, m_piPrereqCivilizations);
	stream->Write(m_iNumPrereqCivics);
	if (m_iNumPrereqCivics > 0)
		stream->Write(m_iNumPrereqCivics, m_piPrereqCivics);
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	stream->Write(m_iNumSecondaryUnitCombats);
	if (m_iNumSecondaryUnitCombats > 0)
		stream->Write(m_iNumSecondaryUnitCombats, m_piSecondaryUnitCombats);
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
	stream->Write(m_iNumPrereqImprovements);
	if (m_iNumPrereqImprovements > 0)
		stream->Write(m_iNumPrereqImprovements, m_piPrereqImprovements);
	stream->Write(m_iNumPrereqCorporations);
	if (m_iNumPrereqCorporations > 0)
		stream->Write(m_iNumPrereqCorporations, m_piPrereqCorporations);
	stream->Write(m_iNumPrereqTraits);
	if (m_iNumPrereqTraits > 0)
		stream->Write(m_iNumPrereqTraits, m_piPrereqTraits);
	stream->Write(m_iNumPrereqBuildingANDs);
	if (m_iNumPrereqBuildingANDs > 0)
		stream->Write(m_iNumPrereqBuildingANDs, m_piPrereqBuildingANDs);
	stream->Write(m_iNumPrereqBuildingORs);
	if (m_iNumPrereqBuildingORs > 0)
		stream->Write(m_iNumPrereqBuildingORs, m_piPrereqBuildingORs);
	stream->Write(m_iNumPrereqEventANDs);
	if (m_iNumPrereqEventANDs > 0)
		stream->Write(m_iNumPrereqEventANDs, m_piPrereqEventANDs);
	stream->Write(m_iNumPrereqEventORs);
	if (m_iNumPrereqEventORs > 0)
		stream->Write(m_iNumPrereqEventORs, m_piPrereqEventORs);
	stream->Write(m_iNumPrereqFeatANDs);
	if (m_iNumPrereqFeatANDs > 0)
		stream->Write(m_iNumPrereqFeatANDs, m_piPrereqFeatANDs);
	stream->Write(m_iNumPrereqFeatORs);
	if (m_iNumPrereqFeatORs > 0)
		stream->Write(m_iNumPrereqFeatORs, m_piPrereqFeatORs);
	stream->Write(m_iNumPrereqFeatNOTs);
	if (m_iNumPrereqFeatNOTs > 0)
		stream->Write(m_iNumPrereqFeatNOTs, m_piPrereqFeatNOTs);
	stream->Write((int)m_aiInvisibleTypes.size());
	for(int iI=0;iI<(int)m_aiInvisibleTypes.size();iI++)
		stream->Write(m_aiInvisibleTypes[iI]);
	stream->Write((int)m_aiSeeInvisibleTypes.size());
	for(int i=0;i<(int)m_aiSeeInvisibleTypes.size();i++)
		stream->Write(m_aiSeeInvisibleTypes[i]);
	stream->Write(m_bRequirePermission);
	stream->Write(m_iNumPromotionAllows);
	if (m_iNumPromotionAllows > 0)
		stream->Write(m_iNumPromotionAllows, m_piPromotionAllows);
	stream->Write(m_iNumPrereqUnitTypesOnTile);
	if (m_iNumPrereqUnitTypesOnTile > 0)
		stream->Write(m_iNumPrereqUnitTypesOnTile, m_piPrereqUnitTypesOnTile);
	stream->Write(m_iNumPrereqUnitTypesNOTOnTile);
	if (m_iNumPrereqUnitTypesNOTOnTile > 0)
		stream->Write(m_iNumPrereqUnitTypesNOTOnTile, m_piPrereqUnitTypesNOTOnTile);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	stream->Write(m_iNumPromotionBuilds);
	if (m_iNumPromotionBuilds > 0)
		stream->Write(m_iNumPromotionBuilds, m_piPromotionBuilds);
	stream->Write(m_iNumPromotionCannotBuilds);
	if (m_iNumPromotionCannotBuilds > 0)
		stream->Write(m_iNumPromotionCannotBuilds, m_piPromotionCannotBuilds);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	stream->Write(m_iNumAffinities);
	if (m_iNumAffinities > 0)
		stream->Write(m_iNumAffinities, m_piAffinities);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	stream->Write(m_iNumPrereqUnitClassesOnTile);
	if (m_iNumPrereqUnitClassesOnTile > 0)
		stream->Write(m_iNumPrereqUnitClassesOnTile, m_piPrereqUnitClassesOnTile);
	stream->Write(m_iNumPrereqUnitClassesNOTOnTile);
	if (m_iNumPrereqUnitClassesNOTOnTile > 0)
		stream->Write(m_iNumPrereqUnitClassesNOTOnTile, m_piPrereqUnitClassesNOTOnTile);
	stream->Write(m_iNumPrereqPromotionsOnTile);
	if (m_iNumPrereqPromotionsOnTile > 0)
		stream->Write(m_iNumPrereqPromotionsOnTile, m_piPrereqPromotionsOnTile);
	stream->Write(m_iNumPrereqPromotionsNOTOnTile);
	if (m_iNumPrereqPromotionsNOTOnTile > 0)
		stream->Write(m_iNumPrereqPromotionsNOTOnTile, m_piPrereqPromotionsNOTOnTile);
	stream->Write(m_iNoBadExplore);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Added by Kael 07/30/2007
	stream->Write(m_bAIControl);
	stream->Write(m_bBoarding);
	stream->Write(m_bOnlyDefensive);
	stream->Write(m_bDispellable);
	stream->Write(m_bDoubleFortifyBonus);
	stream->Write(m_bEquipment);
	stream->Write(m_bFear);
	stream->Write(m_bFlying);
	stream->Write(m_bPrereqAliveCapture);
	stream->Write(m_bHeld);
	stream->Write(m_bHiddenNationality);
	stream->Write(m_bIgnoreBuildingDefense);
	stream->Write(m_bImmortal);
	stream->Write(m_bImmuneToCapture);
	stream->Write(m_bImmuneToDefensiveStrike);
	stream->Write(m_bImmuneToFear);
	stream->Write(m_bImmuneToMagic);
	stream->Write(m_bInvisible);
	stream->Write(m_bMutation);
/*************************************************************************************************/
/**	Dynamic Mutation						06/15/10								Valkrionn	**/
/**																								**/
/**							New tags used by the Dynamic Mutation system						**/
/*************************************************************************************************/
	stream->Write(m_iMutationWeight);
	stream->Write(m_iMutationMin);
	stream->Write(m_iMutationMax);
	stream->Write(m_iMutationMaxApplications);
	stream->Write(m_bBadEffect);
/*************************************************************************************************/
/**	DynamicMutation								END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	//You HAVE TO add the read and write in the same order!!!
	stream->Write(m_iMaxApplications);
	/* original code
	stream->Write(GC.getNumPromotionInfos(), m_piPrereqPromotionORs);
	stream->Write(GC.getNumPromotionInfos(), m_piPrereqPromotionANDs);
	*/
	stream->Write(m_iAntiWithdrawal);
	stream->Write(m_iAntiFirstStrikes);
	stream->Write(m_iRangedCombatPercent);
	stream->Write(m_iRangedCombatPercentGlobalCounter);
	stream->Write(m_iRangedCombatPercentInBorders);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombat);
	stream->Write(m_iNumPrereqPromotionORs);
	for(int i=0;i<m_iNumPrereqPromotionORs;i++)
	{
		stream->Write(1, m_piiPrereqPromotionORs[i]);
	}
	stream->Write(m_iNumPrereqPromotionANDs);
	for(int i=0;i<m_iNumPrereqPromotionANDs;i++)
	{
		stream->Write(1, m_piiPrereqPromotionANDs[i]);
	}
	stream->Write(m_iNumPromotionCombatMods);
	for (int i = 0; i < m_iNumPromotionCombatMods; i++)
	{
		stream->Write(1, m_piiPromotionCombatMods[i]);
	}
	/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	stream->Write(m_bNotAlive);
	stream->Write(m_bPrereqAlive);
	stream->Write(m_bPrereqRevealed);
	stream->Write(m_bPrereqHidden);
	stream->Write(m_bRace);
	stream->Write(m_bGraphicalAddOnPromotion);
	stream->Write(m_bRemovedByCasting);
	stream->Write(m_bRemovedByCombat);
	stream->Write(m_bRemovedWhenHealed);
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_bSeeInvisible);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	stream->Write(m_bTargetWeakestUnit);
	stream->Write(m_bTargetWeakestUnitCounter);
	stream->Write(m_bTwincast);
	stream->Write(m_bValidate);
	stream->Write(m_bWaterWalking);
	stream->Write(m_iAIWeight);
	stream->Write(m_iBetrayalChance);
	stream->Write(m_iBetterDefenderThanPercent);
	stream->Write(m_iCasterResistModify);
	stream->Write(m_iCombatCapturePercent);
	stream->Write(m_iCombatHealPercent);
	stream->Write(m_iCombatLimit);
	stream->Write(m_iCombatPercentDefense);
	stream->Write(m_iCombatPercentGlobalCounter);
	stream->Write(m_iCombatPercentInBorders);
	stream->Write(m_iDefensiveStrikeChance);
	stream->Write(m_iDefensiveStrikeDamage);
	stream->Write(m_iExpireChance);
	stream->Write(m_iExtraCombatStr);
	stream->Write(m_iExtraCombatDefense);
	stream->Write(m_iFreeXPPerTurn);
	stream->Write(m_iFreeXPFromCombat);
	stream->Write(m_iGroupSize);
	stream->Write(m_iMinLevel);
/*************************************************************************************************/
/**	PrereqStrBoostSize						10/16/09								Valkrionn	**/
/**																								**/
/**					Allows a units StrBoost to be used as a promotion prereq					**/
/*************************************************************************************************/
	stream->Write(m_iPrereqStrBoostSize);
/*************************************************************************************************/
/**	PrereqStrBoostSize							END												**/
/*************************************************************************************************/
	stream->Write(m_iModifyGlobalCounter);
	stream->Write(m_iModifyGlobalCounterOnCombat);
	stream->Write(m_iResistMagic);
	stream->Write(m_iSpellCasterXP);
	stream->Write(m_iSpellDamageModify);
	stream->Write(m_iWorkRateModify);
	stream->Write(m_iCaptureUnitCombat);
	stream->Write(m_iBlockedSpellClass);
	stream->Write(m_iPromotionCombatApply);
/*************************************************************************************************/
/**	Cutting								30/01/12										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/**			Use PromotionExcludes instead, both faster and more flexible						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iPromotionImmune1);
	stream->Write(m_iPromotionImmune2);
	stream->Write(m_iPromotionImmune3);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	stream->Write(m_iPromotionRandomApply);
	stream->Write(m_iPromotionSummonPerk);
	stream->Write(m_iBonusPrereq);
	stream->Write(m_iPromotionPrereqOr3);
	stream->Write(m_iPromotionPrereqOr4);
	stream->Write(m_iPromotionPrereqAnd);
	stream->Write(m_iUnitReligionPrereq);//PrereqUnitReligion by BI 07/24/11
	stream->Write(m_iPromotionNextLevel);
	stream->WriteString(m_szPyPerTurn);
	stream->WriteString(m_szExtraArtType);
	stream->WriteString(m_szReplaceArtType);
	stream->Write(m_iUnitArtStyleType);
	stream->Write(m_iPromotionCombatType);
	stream->Write(m_iPromotionCombatMod);

	//ReligionCombatBonus by BI 07/25/11
	stream->Write(m_iReligionCombatType);
	stream->Write(m_iReligionCombatMod);
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
	stream->Write(m_bInquisition);
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/

	stream->Write(GC.getNumBonusInfos(), m_piBonusAffinity);
	stream->Write(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);
	stream->Write(GC.getNumDamageTypeInfos(), m_piDamageTypeResist);
//FfH: End Add

	// Arrays
	stream->Write(GC.getNumImprovementInfos(), m_piNoBadExploreImprovement);

	stream->Write(GC.getNumTerrainInfos(), m_piTerrainAttackPercent);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainDefensePercent);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureAttackPercent);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureDefensePercent);
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvPromotionInfo
	stream->Write(&m_iPromotionHillCost);
	stream->Write(&m_iPromotionPeakCost);
	stream->Write(GC.getNumTerrainInfos(), m_piPromotionTerrainCost);
	stream->Write(GC.getNumFeatureInfos(), m_piPromotionFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatModifierPercent);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatCaptureRatePercent);//Upgraded Capture Rate by BI 08/16/11
	stream->Write(GC.getNumUnitCombatInfos(), m_pbUnitCombatNonCapture);//Upgraded Capture Rate by BI 08/16/11
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainModifierPercent);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainDoubleMove);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureDoubleMove);
	//Magic Rework
	stream->Write(m_iMagicalPower);
	//stream->Write(m_iDominionCapacity);
	//stream->Write(GC.getNumSpellClassInfos(), m_piSpellClassExtraPower);

}

bool CvPromotionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "LayerAnimationPath");
	m_iLayerAnimationPath = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StateReligionPrereq");
	m_iStateReligionPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "CaptureUnitClass");
	m_iCaptureUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bLeader, "bLeader");
	if (m_bLeader)
	{
		m_bGraphicalOnly = true;  // don't show in Civilopedia list of promotions
	}
	pXML->GetChildXmlValByName(&m_bBlitz, "bBlitz");
	pXML->GetChildXmlValByName(&m_bAmphib, "bAmphib");
	pXML->GetChildXmlValByName(&m_bRiver, "bRiver");
	pXML->GetChildXmlValByName(&m_bEnemyRoute, "bEnemyRoute");
	pXML->GetChildXmlValByName(&m_bAlwaysHeal, "bAlwaysHeal");
	pXML->GetChildXmlValByName(&m_bHillsDoubleMove, "bHillsDoubleMove");
	pXML->GetChildXmlValByName(&m_bImmuneToFirstStrikes, "bImmuneToFirstStrikes");
	
	pXML->GetChildXmlValByName(&m_bTradeDefender, "bTradeDefender");
	
	pXML->GetChildXmlValByName(&m_iVisibilityChange, "iVisibilityChange");
	pXML->GetChildXmlValByName(&m_iMovesChange, "iMovesChange");
	pXML->GetChildXmlValByName(&m_iMoveDiscountChange, "iMoveDiscountChange");
	pXML->GetChildXmlValByName(&m_iAirRangeChange, "iAirRangeChange");
	pXML->GetChildXmlValByName(&m_iInterceptChange, "iInterceptChange");
	pXML->GetChildXmlValByName(&m_iEvasionChange, "iEvasionChange");
	pXML->GetChildXmlValByName(&m_iWithdrawalChange, "iWithdrawalChange");
	pXML->GetChildXmlValByName(&m_iEnemyWithdrawalChange, "iEnemyWithdrawalChange");
	pXML->GetChildXmlValByName(&m_iCargoChange, "iCargoChange");
	pXML->GetChildXmlValByName(&m_iCollateralDamageChange, "iCollateralDamageChange");
	pXML->GetChildXmlValByName(&m_iBombardRateChange, "iBombardRateChange");
	pXML->GetChildXmlValByName(&m_iFirstStrikesChange, "iFirstStrikesChange");
	pXML->GetChildXmlValByName(&m_iChanceFirstStrikesChange, "iChanceFirstStrikesChange");
	pXML->GetChildXmlValByName(&m_iEnemyHealChange, "iEnemyHealChange");
	pXML->GetChildXmlValByName(&m_iNeutralHealChange, "iNeutralHealChange");
	pXML->GetChildXmlValByName(&m_iFriendlyHealChange, "iFriendlyHealChange");
	pXML->GetChildXmlValByName(&m_iSameTileHealChange, "iSameTileHealChange");
	pXML->GetChildXmlValByName(&m_iAdjacentTileHealChange, "iAdjacentTileHealChange");
	pXML->GetChildXmlValByName(&m_iCombatPercent, "iCombatPercent");
	pXML->GetChildXmlValByName(&m_iCityAttackPercent, "iCityAttack");
	pXML->GetChildXmlValByName(&m_iCityDefensePercent, "iCityDefense");
	pXML->GetChildXmlValByName(&m_iHillsAttackPercent, "iHillsAttack");
	pXML->GetChildXmlValByName(&m_iHillsDefensePercent, "iHillsDefense");
	pXML->GetChildXmlValByName(&m_iRevoltProtection, "iRevoltProtection");
	pXML->GetChildXmlValByName(&m_iCollateralDamageProtection, "iCollateralDamageProtection");
	pXML->GetChildXmlValByName(&m_iPillageChange, "iPillageChange");
	pXML->GetChildXmlValByName(&m_iUpgradeDiscount, "iUpgradeDiscount");
	pXML->GetChildXmlValByName(&m_iExperiencePercent, "iExperiencePercent");
	pXML->GetChildXmlValByName(&m_iKamikazePercent, "iKamikazePercent");
	//Magic Rework
	pXML->GetChildXmlValByName(&m_iMagicalPower, "iMagicalPower", 0);
	//pXML->GetChildXmlValByName(&m_iDominionCapacity, "iDominionCapacity", 0);
	//pXML->SetVariableListTagPair(&m_piSpellClassExtraPower, "SpellClassExtraPowers", sizeof(GC.getSpellClassInfo((SpellClassTypes)0)), GC.getNumSpellClassInfos());

	//pXML->SetVariableListTagPair(&m_piNoBadExploreImprovement, "NoBadExploreImprovements", sizeof(GC.getImprovementInfo((ImprovementTypes)0)), GC.getNumImprovementInfos());
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "NoBadExploreImprovements"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i = 0; i < iNumSibs; i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							m_aszNoBadExploreImprovementsforPass3.push_back(szTextVal);
							pXML->GetNextXmlVal(&iTemp);
							m_aiNoBadExploreImprovementsforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->SetVariableListTagPair(&m_piTerrainAttackPercent, "TerrainAttacks", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piTerrainDefensePercent, "TerrainDefenses", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piFeatureAttackPercent, "FeatureAttacks", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_piFeatureDefensePercent, "FeatureDefenses", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvPromotionInfo
	pXML->GetChildXmlValByName(&m_iPromotionHillCost, "iHillMoveCost");
	pXML->GetChildXmlValByName(&m_iPromotionPeakCost, "iPeakMoveCost");
	pXML->SetVariableListTagPair(&m_piPromotionTerrainCost, "TerrainMoveCosts", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piPromotionFeatureCost, "FeatureMoveCosts", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piUnitCombatModifierPercent, "UnitCombatMods", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
/// Upgraded Capture Rate by BI 08/16/11

	pXML->SetVariableListTagPair(&m_piUnitCombatCaptureRatePercent, "UnitCombatCaptureRates", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pbUnitCombatNonCapture, "NotCapturedUnitCombats", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());


	pXML->SetVariableListTagPair(&m_piDomainModifierPercent, "DomainMods", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);

	pXML->SetVariableListTagPair(&m_pbTerrainDoubleMove, "TerrainDoubleMoves", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureDoubleMove, "FeatureDoubleMoves", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	Promotion PyHelp		 				07/09/10								Valkrionn	**/
/**																								**/
/**							Allows promotions to have dynamic help								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(m_szPyHelp, "PyHelp");
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MobileCage								01/28/2010								Valkrionn	**/
/**																								**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iLeashRange, "iLeashRange", -100);
	pXML->GetChildXmlValByName(&m_iLeashChance, "iLeashChance", -1);
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bLeveledImmortality, "bLeveledImmortality", false);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bNonInfluence, "bNonInfluence");
	pXML->GetChildXmlValByName(&m_bInfluence, "bInfluence");
	pXML->GetChildXmlValByName(&m_iVictoryInfluenceModifier, "iVictoryInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iDefeatInfluenceModifier, "iDefeatInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iPillageInfluenceModifier, "iPillageInfluenceModifier", 100);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iExtraPerception, "iExtraPerception", 0);
	pXML->GetChildXmlValByName(&m_iInvisibleLevel, "iInvisibleLevel", 0);
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**	New Tag Defs	(CityBonuses)			05/15/08											**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iCommandLimit, "iCommandLimit");
	pXML->GetChildXmlValByName(&m_iCommandRange, "iCommandRange");
	pXML->GetChildXmlValByName(&m_iCommandXPShareRate, "iCommandXPShareRate");
	pXML->GetChildXmlValByName(m_szPyOnRemove, "PythonOnRemove");
	pXML->GetChildXmlValByName(&m_bCommunalProperty, "bCommunalProperty");
	pXML->GetChildXmlValByName(&m_bNeverHostile, "bNeverHostile");
	pXML->GetChildXmlValByName(&m_bBlind, "bBlind");
	pXML->GetChildXmlValByName(&m_bOverrideHelpText, "bOverrideHelpText");
	pXML->GetChildXmlValByName(&m_bRequirePermission, "PrereqPermission");
	pXML->GetChildXmlValByName(&m_bCannotCast, "bCannotCast");
	pXML->GetChildXmlValByName(&m_bFreeUnit, "bFreeUnit");
	pXML->GetChildXmlValByName(&m_bNoSupply, "bNoSupply");
	pXML->GetChildXmlValByName(&m_bTerritorial, "bTerritorial");
	pXML->GetChildXmlValByName(&m_bRivalTerritoryExplore, "bRivalTerritoryExplore");
	pXML->GetChildXmlValByName(&m_bRivalTerritoryBlock, "bRivalTerritoryBlock");
	pXML->GetChildXmlValByName(&m_bPillageOnMove, "bPillageOnMove");
	pXML->GetChildXmlValByName(&m_bSelfPillage, "bSelfPillage");
	pXML->GetChildXmlValByName(&m_bGetCasterXP, "bGetCasterXP");
	pXML->GetChildXmlValByName(&m_bNonWarWeariness, "bNonWarWeariness");
	pXML->GetChildXmlValByName(&m_bNoMapReveal, "bNoMapReveal");
	pXML->GetChildXmlValByName(&m_bCannotCapture, "bCannotCapture");
	pXML->GetChildXmlValByName(&m_bCityHappy, "bCityHappy");
	pXML->GetChildXmlValByName(&m_bCityNoHappy, "bCityNoHappy");
	pXML->GetChildXmlValByName(&m_bNoSupport, "bNoSupport");
	pXML->GetChildXmlValByName(&m_bCanPillage, "bCanPillage");
	pXML->GetChildXmlValByName(&m_bCannotPillage, "bCannotPillage");
	pXML->GetChildXmlValByName(&m_bCitySpy, "bCitySpy");
	pXML->GetChildXmlValByName(&m_bStartGoldenAge, "bStartGoldenAge");
	pXML->GetChildXmlValByName(&m_bNoDefenseBonus, "bNoDefenseBonus");
	pXML->GetChildXmlValByName(&m_bMoveImpassable, "bMoveImpassable");
	pXML->GetChildXmlValByName(&m_bClimbPeaks, "bClimbPeaks");
	pXML->GetChildXmlValByName(&m_bFlatMoveCost, "bFlatMoveCost");
	pXML->GetChildXmlValByName(&m_bIgnoreTerrainCosts, "bIgnoreTerrainCosts");
	pXML->GetChildXmlValByName(&m_bAttackNoWar, "bAttackNoWar");
	pXML->GetChildXmlValByName(&m_bAllowAttacks, "bAllowAttacks");
	pXML->GetChildXmlValByName(&m_bFirstStrikeVulnerable, "bFirstStrikeVulnerable");
	pXML->GetChildXmlValByName(&m_bAllowDefenseBonuses, "bAllowDefenseBonuses");
	pXML->GetChildXmlValByName(&m_bNonAbandon, "bNonAbandon");
	pXML->GetChildXmlValByName(&m_bIndependant, "bIndependant");
	pXML->GetChildXmlValByName(&m_bReligiousCommanderPromo, "bReligiousCommanderPromo"); //ReligiousCommander by BI 07/24/11
	pXML->GetChildXmlValByName(&m_bEffectProm, "bEffectProm");
		if (m_bEffectProm)        m_bGraphicalOnly = true;
	pXML->GetChildXmlValByName(&m_bStackEffect, "bStackEffect");
	pXML->GetChildXmlValByName(&m_bAutoAcquire, "bAutoAcquire");
	pXML->GetChildXmlValByName(&m_bMustMaintain, "bMustMaintain");
	pXML->GetChildXmlValByName(&m_bPrereqInCity, "PrereqInCity");
	pXML->GetChildXmlValByName(&m_bNoXP, "bNoXP");
	pXML->GetChildXmlValByName(&m_bPrereqInBorderEnemy, "PrereqInBorderEnemy");
	pXML->GetChildXmlValByName(&m_bPrereqInBorderRival, "PrereqInBorderRival");
	pXML->GetChildXmlValByName(&m_bPrereqInBorderTeam, "PrereqInBorderTeam");
	pXML->GetChildXmlValByName(&m_bPrereqInBorderSelf, "PrereqInBorderSelf");
	pXML->GetChildXmlValByName(&m_bPrereqInBorderNone, "PrereqInBorderNone");
	pXML->GetChildXmlValByName(&m_bAllowNULLUnitCombat, "PrereqbAllowNULLUnitCombat");
	pXML->GetChildXmlValByName(&m_iRandomApplyChance, "iPromotionRandomApplyChance");
	pXML->GetChildXmlValByName(&m_iAssetValue, "iAsset");
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(&m_iPowerValue, "iPower");
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(&m_iPowerAdd, "iPowerAdd");
	pXML->GetChildXmlValByName(&m_iPowerMult, "iPowerMult");
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iDamageOnRemove, "iDamageOnRemove");
	pXML->GetChildXmlValByName(szTextVal, "TempUnitCombat");
	m_iTempUnitCombat = pXML->FindInInfoClass(szTextVal);
	float fTemp = 0.0f;
	pXML->GetChildXmlValByName(&fTemp, "fFreeXPCap");
	m_iFreeXPCap = (int)(fTemp*100);
	pXML->GetChildXmlValByName(&m_fCasterXPRate, "fCasterXPRate");
	pXML->GetChildXmlValByName(&m_iDuration, "iPromotionDuration");
	pXML->GetChildXmlValByName(&m_iAirCombat, "iAirCombat");
	pXML->GetChildXmlValByName(&m_iAirCombatLimitBoost, "iAirCombatLimitBoost");
	pXML->GetChildXmlValByName(&m_iExtraDropRange, "iExtraDropRange");
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iPrereqBroadAlignment, "PrereqBroadAlignment");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iPrereqBroadEthicalAlignment, "PrereqBroadEthicalAlignment");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iSpellExtraRange, "iSpellExtraRange");
	pXML->GetChildXmlValByName(&m_iCombatConversionChance, "iCombatConversionChance");
	pXML->GetChildXmlValByName(&m_iCombatUnitGenerationChance, "iCombatUnitGenerationChance");
	pXML->GetChildXmlValByName(&m_iSlaveGenerationChance, "iSlaveGenerationChance");
	pXML->GetChildXmlValByName(&m_iGiftableXP, "iGiftableXP");
	pXML->GetChildXmlValByName(&m_iCombatExtraDuration, "iCombatExtraDuration");
	pXML->GetChildXmlValByName(&m_iDurationPerTurn, "iDurationPerTurn");
	pXML->GetChildXmlValByName(&m_iDurationAlter, "iDurationAlter");
	pXML->GetChildXmlValByName(&m_iChangeDuration, "iChangeDuration");
	pXML->GetChildXmlValByName(&m_iExtraSupport, "iExtraSupport");
	pXML->GetChildXmlValByName(&m_iChanceMiscast, "iChanceMiscast");
	pXML->GetChildXmlValByName(&m_iCombatDmgCapBoost, "iCombatDmgCapBoost");
	pXML->GetChildXmlValByName(&m_iCollateralLimitCap, "iCollateralLimitCap");
	pXML->GetChildXmlValByName(&m_iCollateralLimitBoost, "iCollateralLimitBoost");
	pXML->GetChildXmlValByName(&m_iCollateralTargetsLimit, "iCollateralTargetsLimit");
	pXML->GetChildXmlValByName(&m_iCollateralExtraTargets, "iCollateralExtraTargets");
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iFlankingLimitBoost, "iCollateralLimitBoost");
	pXML->GetChildXmlValByName(&m_iFlankingExtraTargets, "iCollateralExtraTargets");
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iHammerSacrifice, "iHammerSacrifice");
	pXML->GetChildXmlValByName(&m_iExtraHammerPerPop, "iExtraHammerPerPop");
	pXML->GetChildXmlValByName(&m_iFoodSacrifice, "iFoodSacrifice");
	pXML->GetChildXmlValByName(&m_iPopulationAdd, "iPopulationAdd");
	pXML->GetChildXmlValByName(&m_iBeakerSacrifice, "iBeakerSacrifice");
	pXML->GetChildXmlValByName(&m_iExtraBeakerPerPop, "iExtraBeakerPerPop");
	pXML->GetChildXmlValByName(&m_iGoldSacrifice, "iGoldSacrifice");
	pXML->GetChildXmlValByName(&m_iExtraGoldPerPop, "iExtraGoldPerPop");
	pXML->GetChildXmlValByName(&m_iCultureSacrifice, "iCultureSacrifice");
	pXML->GetChildXmlValByName(&m_iExtraCulturePerPop, "iExtraCulturePerPop");
	pXML->GetChildXmlValByName(&m_iPrereqMinAge, "PrereqMinAge");
	pXML->GetChildXmlValByName(&m_iPrereqMaxAge, "PrereqMaxAge");
	pXML->GetChildXmlValByName(&m_iGoldCost, "iGoldCost");
	pXML->GetChildXmlValByName(&m_iXPTranserRate, "iXPTranserRate");
	pXML->GetChildXmlValByName(&m_iPrereqTier, "PrereqTier");
	pXML->GetChildXmlValByName(&m_iPrereqWeaponTier, "PrereqWeaponTier");
	pXML->GetChildXmlValByName(m_szPyPostCombatLost, "PythonPostCombatLost");
	pXML->GetChildXmlValByName(m_szPyPostCombatWon, "PythonPostCombatWon");
/*************************************************************************************************/
/**	PyOnPromoTaken							   08/28/10								Valkrionn	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(m_szPyOnPromoTaken, "PyOnPromoTaken");
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(m_szNewName, "NewName");
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldsFromWin"))
	{
		pXML->SetYields(&m_piYieldFromWin);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else		pXML->InitList(&m_piYieldFromWin, NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldsForLoss"))
	{
		pXML->SetYields(&m_piYieldForLoss);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else		pXML->InitList(&m_piYieldForLoss, NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommercesFromWin"))
	{
		pXML->SetCommerce(&m_piCommerceFromWin);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else		pXML->InitList(&m_piCommerceFromWin, NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommercesForLoss"))
	{
		pXML->SetCommerce(&m_piCommerceForLoss);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else		pXML->InitList(&m_piCommerceForLoss, NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqReligions"))		pXML->SetIntWithChildList(&m_iNumPrereqReligions, &m_piPrereqReligions);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqTechANDs"))		pXML->SetIntWithChildList(&m_iNumPrereqTechANDs, &m_piPrereqTechANDs);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqTechORs"))		pXML->SetIntWithChildList(&m_iNumPrereqTechORs, &m_piPrereqTechORs);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqAlignments"))	pXML->SetIntWithChildList(&m_iNumPrereqAlignments, &m_piPrereqAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqEthicalAlignments"))	pXML->SetIntWithChildList(&m_iNumPrereqEthicalAlignments, &m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqFeatures"))		pXML->SetIntWithChildList(&m_iNumPrereqFeatures, &m_piPrereqFeatures);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqTerrains"))		pXML->SetIntWithChildList(&m_iNumPrereqTerrains, &m_piPrereqTerrains);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonusANDs"))		pXML->SetIntWithChildList(&m_iNumPrereqBonusANDs, &m_piPrereqBonusANDs);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonusORs"))		pXML->SetIntWithChildList(&m_iNumPrereqBonusORs, &m_piPrereqBonusORs);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqFeatANDs"))		pXML->SetIntWithChildList(&m_iNumPrereqFeatANDs, &m_piPrereqFeatANDs);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqFeatORs"))		pXML->SetIntWithChildList(&m_iNumPrereqFeatORs, &m_piPrereqFeatORs);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqFeatNOTs"))		pXML->SetIntWithChildList(&m_iNumPrereqFeatNOTs, &m_piPrereqFeatNOTs);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqCivilizations"))	pXML->SetStringWithChildList(&m_iNumPrereqCivilizations, &m_aszPrereqCivilizationsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqUnits"))			pXML->SetStringWithChildList(&m_iNumPrereqUnits, &m_aszPrereqUnitsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqCivics"))		pXML->SetStringWithChildList(&m_iNumPrereqCivics, &m_aszPrereqCivicsforPass3);
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SecondaryUnitCombats")) pXML->SetIntWithChildList(&m_iNumSecondaryUnitCombats, &m_piSecondaryUnitCombats);
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqImprovements"))	pXML->SetStringWithChildList(&m_iNumPrereqImprovements, &m_aszPrereqImprovementsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqCorporations"))	pXML->SetStringWithChildList(&m_iNumPrereqCorporations, &m_aszPrereqCorporationsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqTraits"))		pXML->SetStringWithChildList(&m_iNumPrereqTraits, &m_aszPrereqTraitsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBuildingANDs"))	pXML->SetStringWithChildList(&m_iNumPrereqBuildingANDs, &m_aszPrereqBuildingANDsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBuildingORs"))	pXML->SetStringWithChildList(&m_iNumPrereqBuildingORs, &m_aszPrereqBuildingORsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqEventANDs"))		pXML->SetStringWithChildList(&m_iNumPrereqEventANDs, &m_aszPrereqEventANDsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqEventORs"))		pXML->SetStringWithChildList(&m_iNumPrereqEventORs, &m_aszPrereqEventORsforPass3);
	pXML->GetChildXmlValByName(szTextVal, "Invisible");
	std::vector<CvString> token;
	szTextVal.getTokens(",", token);
	for(int i=0;i<(int)token.size();i++)
	{
		int iInvisibleType = pXML->FindInInfoClass(token[i]);
		if(iInvisibleType != NO_INVISIBLE)			m_aiInvisibleTypes.push_back(iInvisibleType);
	}
	pXML->GetChildXmlValByName(szTextVal, "SeeInvisible");
	std::vector<CvString> tokens;
	szTextVal.getTokens(",", tokens);
	for(int i=0;i<(int)tokens.size();i++)
	{
		int iInvisibleType = pXML->FindInInfoClass(tokens[i]);
		if(iInvisibleType != NO_INVISIBLE)			m_aiSeeInvisibleTypes.push_back(iInvisibleType);
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CityBonuses"))
	{
		int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (iNumSibs > 0)
		{
			m_iNumCityBonuses = iNumSibs;
			if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CityBonus"))
			{
				for (int iI = 0; iI < iNumSibs; iI++)
				{
					CityBonuses cbTemp;
					pXML->GetChildXmlValByName(&(cbTemp.bFullMap), "bFullMap", false);
					pXML->GetChildXmlValByName(&(cbTemp.bApplyEnemy), "bApplyEnemy", false);
					pXML->GetChildXmlValByName(&(cbTemp.bApplyRival), "bApplyRival", false);
					pXML->GetChildXmlValByName(&(cbTemp.bApplySelf), "bApplySelf", false);
					pXML->GetChildXmlValByName(&(cbTemp.bApplyTeam), "bApplyTeam", false);
					pXML->GetChildXmlValByName(&(cbTemp.fCulture), "fCulture", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fCrime), "fCrime", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fDefense), "fDefense", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fDiplo), "fDiplo", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fFood), "fFood", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fFreeXP), "fFreeXP", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fGold), "fGold", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fGPP), "fGPP", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fHappy), "fHappy", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fHealth), "fHealth", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fProduction), "fProduction", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fTradeRoutes), "fTradeRoutes", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fRitualAssist), "fRitualAssist", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fInfectCulture), "fInfectCulture", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fPotency), "fPotency", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fShielding), "fShielding", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fTrainXPCap), "fTrainXPCap", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fTrainXPRate), "fTrainXPRate", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.iBonusRange), "iBonusRange", 0);
					pXML->GetChildXmlValByName(&(cbTemp.fDecayRate), "fDecayRate", 0.0f);
					m_cbCityBonuses.push_back(cbTemp);
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))						break;
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqUnitTypesOnTile"))		pXML->SetStringWithChildList(&m_iNumPrereqUnitTypesOnTile, &m_aszPrereqUnitTypesOnTileforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqUnitTypesNOTOnTile"))	pXML->SetStringWithChildList(&m_iNumPrereqUnitTypesNOTOnTile, &m_aszPrereqUnitTypesNOTOnTileforPass3);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionBuilds"))				pXML->SetStringWithChildList(&m_iNumPromotionBuilds, &m_aszPromotionBuildsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionCannotBuilds"))		pXML->SetStringWithChildList(&m_iNumPromotionCannotBuilds, &m_aszPromotionCannotBuildsforPass3);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Affinities"))					pXML->SetStringWithChildList(&m_iNumAffinities, &m_aszAffinitiesforPass3);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqUnitClassesOnTile"))		pXML->SetIntWithChildList(&m_iNumPrereqUnitClassesOnTile, &m_piPrereqUnitClassesOnTile);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqUnitClassesNOTOnTile"))	pXML->SetIntWithChildList(&m_iNumPrereqUnitClassesNOTOnTile, &m_piPrereqUnitClassesNOTOnTile);
	pXML->GetChildXmlValByName(&m_iNoBadExplore, "iNoBadExplore");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Added by Kael 07/30/2007
	pXML->GetChildXmlValByName(&m_bAIControl, "bAIControl");
	pXML->GetChildXmlValByName(&m_bBoarding, "bBoarding");
	pXML->GetChildXmlValByName(&m_bOnlyDefensive, "bOnlyDefensive");
	pXML->GetChildXmlValByName(&m_bDispellable, "bDispellable");
	pXML->GetChildXmlValByName(&m_bDoubleFortifyBonus, "bDoubleFortifyBonus");
	pXML->GetChildXmlValByName(&m_bEquipment, "bEquipment");
	pXML->GetChildXmlValByName(&m_bFear, "bFear");
	pXML->GetChildXmlValByName(&m_bFlying, "bFlying");
	pXML->GetChildXmlValByName(&m_bPrereqAliveCapture, "bPrereqAliveCapture");
	pXML->GetChildXmlValByName(&m_bHeld, "bHeld");
	pXML->GetChildXmlValByName(&m_bHiddenNationality, "bHiddenNationality");
	pXML->GetChildXmlValByName(&m_bIgnoreBuildingDefense, "bIgnoreBuildingDefense");
	pXML->GetChildXmlValByName(&m_bImmortal, "bImmortal");
	pXML->GetChildXmlValByName(&m_bImmuneToCapture, "bImmuneToCapture");
	pXML->GetChildXmlValByName(&m_bImmuneToDefensiveStrike, "bImmuneToDefensiveStrike");
	pXML->GetChildXmlValByName(&m_bImmuneToFear, "bImmuneToFear");
	pXML->GetChildXmlValByName(&m_bImmuneToMagic, "bImmuneToMagic");
	pXML->GetChildXmlValByName(&m_bInvisible, "bInvisible");
	pXML->GetChildXmlValByName(&m_bMutation, "bMutation");
/*************************************************************************************************/
/**	Dynamic Mutation						06/15/10								Valkrionn	**/
/**																								**/
/**							New tags used by the Dynamic Mutation system						**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iMutationWeight, "iMutationWeight");
	pXML->GetChildXmlValByName(&m_iMutationMin, "iMutationMin", 1);
	pXML->GetChildXmlValByName(&m_iMutationMax, "iMutationMax", 1);
	pXML->GetChildXmlValByName(&m_iMutationMaxApplications, "iMutationMaxApplications", 1);
	pXML->GetChildXmlValByName(&m_bBadEffect, "bBadEffect");
/*************************************************************************************************/
/**	DynamicMutation								END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iMaxApplications, "iMaxApplications");
	pXML->SetVariableListTagPair(&m_piUnitCombat, "UnitCombats", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos(), -1);
	pXML->GetChildXmlValByName(&m_iAntiWithdrawal, "iAntiWithdrawal");
	pXML->GetChildXmlValByName(&m_iAntiFirstStrikes, "iAntiFirstStrikes");
	pXML->GetChildXmlValByName(&m_iRangedCombatPercent, "iRangedCombatPercent");
	pXML->GetChildXmlValByName(&m_iRangedCombatPercentGlobalCounter, "iRangedCombatPercentGlobalCounter");
	pXML->GetChildXmlValByName(&m_iRangedCombatPercentInBorders, "iRangedCombatPercentInBorders");
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bNotAlive, "bNotAlive");
	pXML->GetChildXmlValByName(&m_bPrereqAlive, "bPrereqAlive");
	pXML->GetChildXmlValByName(&m_bPrereqRevealed, "bPrereqRevealed");
	pXML->GetChildXmlValByName(&m_bPrereqHidden, "bPrereqHidden");
	pXML->GetChildXmlValByName(&m_bRace, "bRace");
	pXML->GetChildXmlValByName(&m_bGraphicalAddOnPromotion, "bGraphicalSwap");
	pXML->GetChildXmlValByName(&m_bRemovedByCasting, "bRemovedByCasting");
	pXML->GetChildXmlValByName(&m_bRemovedByCombat, "bRemovedByCombat");
	pXML->GetChildXmlValByName(&m_bRemovedWhenHealed, "bRemovedWhenHealed");
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(&m_bSeeInvisible, "bSeeInvisible");
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bTargetWeakestUnit, "bTargetWeakestUnit");
	pXML->GetChildXmlValByName(&m_bTargetWeakestUnitCounter, "bTargetWeakestUnitCounter");
	pXML->GetChildXmlValByName(&m_bTwincast, "bTwincast");
	pXML->GetChildXmlValByName(&m_bValidate, "bValidate");
	pXML->GetChildXmlValByName(&m_bWaterWalking, "bWaterWalking");
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iBetrayalChance, "iBetrayalChance");
	pXML->GetChildXmlValByName(&m_iBetterDefenderThanPercent, "iBetterDefenderThanPercent");
	pXML->GetChildXmlValByName(&m_iCasterResistModify, "iCasterResistModify");
	pXML->GetChildXmlValByName(&m_iCombatCapturePercent, "iCombatCapturePercent");
	pXML->GetChildXmlValByName(&m_iCombatHealPercent, "iCombatHealPercent");
	pXML->GetChildXmlValByName(&m_iCombatLimit, "iCombatLimit");
	pXML->GetChildXmlValByName(&m_iCombatPercentDefense, "iCombatPercentDefense");
	pXML->GetChildXmlValByName(&m_iCombatPercentGlobalCounter, "iCombatPercentGlobalCounter");
	pXML->GetChildXmlValByName(&m_iCombatPercentInBorders, "iCombatPercentInBorders");
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeChance, "iDefensiveStrikeChance");
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeDamage, "iDefensiveStrikeDamage");
	pXML->GetChildXmlValByName(&m_iExpireChance, "iExpireChance");
	pXML->GetChildXmlValByName(&m_iExtraCombatStr, "iExtraCombatStr");
	pXML->GetChildXmlValByName(&m_iExtraCombatDefense, "iExtraCombatDefense");
	pXML->GetChildXmlValByName(&m_iFreeXPPerTurn, "iFreeXPPerTurn");
	pXML->GetChildXmlValByName(&m_iFreeXPFromCombat, "iFreeXPFromCombat");
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(&m_iGoldFromCombat, "iGoldFromCombat");
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iGroupSize, "iGroupSize");
	pXML->GetChildXmlValByName(&m_iMinLevel, "iMinLevel");
/*************************************************************************************************/
/**	PrereqStrBoostSize						10/16/09								Valkrionn	**/
/**																								**/
/**					Allows a units StrBoost to be used as a promotion prereq					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqStrBoostSize, "iPrereqStrBoostSize");
/*************************************************************************************************/
/**	PrereqStrBoostSize							END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter, "iModifyGlobalCounter");
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounterOnCombat, "iModifyGlobalCounterOnCombat");
	pXML->GetChildXmlValByName(&m_iResistMagic, "iResistMagic");
	pXML->GetChildXmlValByName(&m_iSpellCasterXP, "iSpellCasterXP");
	pXML->GetChildXmlValByName(&m_iSpellDamageModify, "iSpellDamageModify");
	pXML->GetChildXmlValByName(&m_iWorkRateModify, "iWorkRateModify");
	pXML->GetChildXmlValByName(szTextVal, "CaptureUnitCombat");
	m_iCaptureUnitCombat = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BlockedSpellClass");
	m_iBlockedSpellClass = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BonusPrereq");
	m_iBonusPrereq = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(m_szPyPerTurn, "PyPerTurn");
	pXML->GetChildXmlValByName(m_szExtraArtType, "ExtraArtType");
	pXML->GetChildXmlValByName(m_szReplaceArtType, "ReplaceArtType");
	pXML->GetChildXmlValByName(szTextVal, "UnitArtStyleType");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iPromotionCombatMod, "iPromotionCombatMod");
	pXML->GetChildXmlValByName(&m_iReligionCombatMod, "iReligionCombatMod");//ReligionCombatBonus by BI 07/25/11
	pXML->SetVariableListTagPair(&m_piBonusAffinity, "BonusAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piDamageTypeCombat, "DamageTypeCombats", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
	pXML->SetVariableListTagPair(&m_piDamageTypeResist, "DamageTypeResists", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
//FfH: End Add
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bInquisition, "bInquisition");
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
	//PromotionClass
	pXML->GetChildXmlValByName(szTextVal, "PromotionClass");
	m_iPromotionClass = (PromotionClassTypes)GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "SpecialCargo");
	m_iSpecialCargo = (SpecialUnitTypes)GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DomainCargo");
	m_iDomainCargo = (DomainTypes)GC.getInfoTypeForString(szTextVal);

	return true;
}

bool CvPromotionInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	HotkeyInfo will call InfoBase for us, so if we need hotkeys, then we don't need Infobase	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq");
	m_iPrereqPromotion = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr1");
	m_iPrereqOrPromotion1 = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr2");
	m_iPrereqOrPromotion2 = GC.getInfoTypeForString(szTextVal);

//FfH: Modified by Kael 02/24/2008
	pXML->GetChildXmlValByName(szTextVal, "PromotionCombatApply");
	m_iPromotionCombatApply = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Cutting								30/01/12										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/**			Use PromotionExcludes instead, both faster and more flexible						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "PromotionImmune1");
	m_iPromotionImmune1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionImmune2");
	m_iPromotionImmune2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionImmune3");
	m_iPromotionImmune3 = pXML->FindInInfoClass(szTextVal);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PromotionRandomApply");
	m_iPromotionRandomApply = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionSummonPerk");
	m_iPromotionSummonPerk = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr3");
	m_iPromotionPrereqOr3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr4");
	m_iPromotionPrereqOr4 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqAnd");
	m_iPromotionPrereqAnd = pXML->FindInInfoClass(szTextVal);
	//PrereqUnitReligion by BI 07/24/11
	pXML->GetChildXmlValByName(szTextVal, "UnitReligionPrereq");
	m_iUnitReligionPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PromotionNextLevel");
	m_iPromotionNextLevel = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionCombatType");
	m_iPromotionCombatType = pXML->FindInInfoClass(szTextVal);

	//ReligionCombatBonus by BI 07/25/11
	pXML->GetChildXmlValByName(szTextVal, "ReligionCombatType");
	m_iReligionCombatType = pXML->FindInInfoClass(szTextVal);

//FfH: End Modify
/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		10/03/08								Xienwolf	**/
/**																								**/
/**					Second Pass to reference information within the same file					**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"MinionPromotions"))
		pXML->SetIntWithChildList(&m_iNumMinionPromotions, &m_piMinionPromotions);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CapturePromotions"))
		pXML->SetIntWithChildList(&m_iNumCapturePromotions, &m_piCapturePromotions);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommanderPromotions"))
		pXML->SetIntWithChildList(&m_iNumCommanderPromotions, &m_piCommanderPromotions);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SlavePromotions"))
		pXML->SetIntWithChildList(&m_iNumSlavePromotions, &m_piSlavePromotions);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"MasterPromotions"))
		pXML->SetIntWithChildList(&m_iNumMasterPromotions, &m_piMasterPromotions);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionExcludes"))
		pXML->SetIntWithChildList(&m_iNumPromotionExcludes, &m_piPromotionExcludes);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionReplacedBy"))
		pXML->SetIntWithChildList(&m_iNumPromotionReplacedBy, &m_piPromotionReplacedBy);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionOverwrites"))
		pXML->SetIntWithChildList(&m_iNumPromotionOverwrites, &m_piPromotionOverwrites);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionDegradesTo"))
		pXML->SetIntWithChildList(&m_iNumPromotionDegradesTo, &m_piPromotionDegradesTo);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionAllows"))
		pXML->SetIntWithChildList(&m_iNumPromotionAllows, &m_piPromotionAllows);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqPromotionsOnTile"))
		pXML->SetIntWithChildList(&m_iNumPrereqPromotionsOnTile, &m_piPrereqPromotionsOnTile);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqPromotionsNOTOnTile"))
		pXML->SetIntWithChildList(&m_iNumPrereqPromotionsNOTOnTile, &m_piPrereqPromotionsNOTOnTile);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	int iNumSibs;
	int iIndex;
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqPromotionORs"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				m_iNumPrereqPromotionORs = iNumSibs;
				pXML->Init2DIntList(&m_piiPrereqPromotionORs, iNumSibs, 1);
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					if (0 < iNumSibs)
					{
						for (int i=0;i<iNumSibs;i++)
						{
							pXML->GetChildXmlValByName(szTextVal, "PromotionType");
							iIndex = pXML->FindInInfoClass(szTextVal);

							if (iIndex > -1)
							{
								// Set the promotion value...
								m_piiPrereqPromotionORs[i][0] = iIndex;
								// and how many we need
								pXML->GetChildXmlValByName(&m_piiPrereqPromotionORs[i][1], "iPrereqApplications");
							}

							if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
							{
								break;
							}
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqPromotionANDs"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				m_iNumPrereqPromotionANDs = iNumSibs;
				pXML->Init2DIntList(&m_piiPrereqPromotionANDs, iNumSibs, 1);
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					if (0 < iNumSibs)
					{
						for (int i=0;i<iNumSibs;i++)
						{
							pXML->GetChildXmlValByName(szTextVal, "PromotionType");
							iIndex = pXML->FindInInfoClass(szTextVal);

							if (iIndex > -1)
							{
								// Set the promotion value...
								m_piiPrereqPromotionANDs[i][0] = iIndex;
								// and how many we need
								pXML->GetChildXmlValByName(&m_piiPrereqPromotionANDs[i][1], "iPrereqApplications");
							}

							if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
							{
								break;
							}
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PromotionCombatMods"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				m_iNumPromotionCombatMods = iNumSibs;
				pXML->Init2DIntList(&m_piiPromotionCombatMods, iNumSibs, 1);
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					if (0 < iNumSibs)
					{
						for (int i = 0; i < iNumSibs; i++)
						{
							pXML->GetChildXmlValByName(szTextVal, "PromotionType");
							iIndex = pXML->FindInInfoClass(szTextVal);

							if (iIndex > -1)
							{
								// Set the promotion value...
								m_piiPromotionCombatMods[i][0] = iIndex;
								// and how many we need
								pXML->GetChildXmlValByName(&m_piiPromotionCombatMods[i][1], "iCombatMod");
							}

							if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
							{
								break;
							}
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	/* original code
	pXML->SetVariableListTagPair(&m_piPrereqPromotionORs, "PrereqPromotionORs", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos(), 0);
	pXML->SetVariableListTagPair(&m_piPrereqPromotionANDs, "PrereqPromotionANDs", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos(), 0);
	*/
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/


	return true;
}


//FfH: Added by Kael 09/09/2007
bool CvPromotionInfo::readPass3()
{
/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		08/09/08								Xienwolf	**/
/**																								**/
/**					Third Pass to reference information which didn't exist before				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
/**								----  End Original Code  ----									**/
	m_piPrereqUnits = new int[m_iNumPrereqUnits];
	for(int iI = 0; iI < m_iNumPrereqUnits; iI++)
		m_piPrereqUnits[iI] = GC.getInfoTypeForString(m_aszPrereqUnitsforPass3[iI]);
	m_aszPrereqUnitsforPass3.clear();

	m_piPrereqCivilizations = new int[m_iNumPrereqCivilizations];
	for(int iI = 0; iI < m_iNumPrereqCivilizations; iI++)
		m_piPrereqCivilizations[iI] = GC.getInfoTypeForString(m_aszPrereqCivilizationsforPass3[iI]);
	m_aszPrereqCivilizationsforPass3.clear();

	m_piPrereqCivics = new int[m_iNumPrereqCivics];
	for(int iI = 0; iI < m_iNumPrereqCivics; iI++)
		m_piPrereqCivics[iI] = GC.getInfoTypeForString(m_aszPrereqCivicsforPass3[iI]);
	m_aszPrereqCivicsforPass3.clear();

	m_piPrereqImprovements = new int[m_iNumPrereqImprovements];
	for(int iI = 0; iI < m_iNumPrereqImprovements; iI++)
		m_piPrereqImprovements[iI] = GC.getInfoTypeForString(m_aszPrereqImprovementsforPass3[iI]);
	m_aszPrereqImprovementsforPass3.clear();

	m_piPrereqCorporations = new int[m_iNumPrereqCorporations];
	for(int iI = 0; iI < m_iNumPrereqCorporations; iI++)
		m_piPrereqCorporations[iI] = GC.getInfoTypeForString(m_aszPrereqCorporationsforPass3[iI]);
	m_aszPrereqCorporationsforPass3.clear();

	m_piPrereqTraits = new int[m_iNumPrereqTraits];
	for(int iI = 0; iI < m_iNumPrereqTraits; iI++)
		m_piPrereqTraits[iI] = GC.getInfoTypeForString(m_aszPrereqTraitsforPass3[iI]);
	m_aszPrereqTraitsforPass3.clear();

	m_piPrereqBuildingANDs = new int[m_iNumPrereqBuildingANDs];
	for(int iI = 0; iI < m_iNumPrereqBuildingANDs; iI++)
		m_piPrereqBuildingANDs[iI] = GC.getInfoTypeForString(m_aszPrereqBuildingANDsforPass3[iI]);
	m_aszPrereqBuildingANDsforPass3.clear();

	m_piPrereqBuildingORs = new int[m_iNumPrereqBuildingORs];
	for(int iI = 0; iI < m_iNumPrereqBuildingORs; iI++)
		m_piPrereqBuildingORs[iI] = GC.getInfoTypeForString(m_aszPrereqBuildingORsforPass3[iI]);
	m_aszPrereqBuildingORsforPass3.clear();

	m_piPrereqEventANDs = new int[m_iNumPrereqEventANDs];
	for(int iI = 0; iI < m_iNumPrereqEventANDs; iI++)
		m_piPrereqEventANDs[iI] = GC.getInfoTypeForString(m_aszPrereqEventANDsforPass3[iI]);
	m_aszPrereqEventANDsforPass3.clear();

	m_piPrereqEventORs = new int[m_iNumPrereqEventORs];
	for(int iI = 0; iI < m_iNumPrereqEventORs; iI++)
		m_piPrereqEventORs[iI] = GC.getInfoTypeForString(m_aszPrereqEventORsforPass3[iI]);
	m_aszPrereqEventORsforPass3.clear();

	m_piPrereqUnitTypesOnTile = new int[m_iNumPrereqUnitTypesOnTile];
	for(int iI = 0; iI < m_iNumPrereqUnitTypesOnTile; iI++)
		m_piPrereqUnitTypesOnTile[iI] = GC.getInfoTypeForString(m_aszPrereqUnitTypesOnTileforPass3[iI]);
	m_aszPrereqUnitTypesOnTileforPass3.clear();

	m_piPrereqUnitTypesNOTOnTile = new int[m_iNumPrereqUnitTypesNOTOnTile];
	for(int iI = 0; iI < m_iNumPrereqUnitTypesNOTOnTile; iI++)
		m_piPrereqUnitTypesNOTOnTile[iI] = GC.getInfoTypeForString(m_aszPrereqUnitTypesNOTOnTileforPass3[iI]);
	m_aszPrereqUnitTypesNOTOnTileforPass3.clear();
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	m_piPromotionBuilds = new int[m_iNumPromotionBuilds];
	for(int iI = 0; iI < m_iNumPromotionBuilds; iI++)
		m_piPromotionBuilds[iI] = GC.getInfoTypeForString(m_aszPromotionBuildsforPass3[iI]);
	m_aszPromotionBuildsforPass3.clear();

	m_piPromotionCannotBuilds = new int[m_iNumPromotionCannotBuilds];
	for(int iI = 0; iI < m_iNumPromotionCannotBuilds; iI++)
		m_piPromotionCannotBuilds[iI] = GC.getInfoTypeForString(m_aszPromotionCannotBuildsforPass3[iI]);
	m_aszPromotionCannotBuildsforPass3.clear();
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	m_piAffinities = new int[m_iNumAffinities];
	for(int iI = 0; iI < m_iNumAffinities; iI++)
		m_piAffinities[iI] = GC.getInfoTypeForString(m_aszAffinitiesforPass3[iI]);
	m_aszAffinitiesforPass3.clear();
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3[0] != "")
	{
		m_iUnitArtStyleType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	}
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iUnitArtStyleType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	m_piNoBadExploreImprovement = new int[GC.getNumImprovementInfos()];
	for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		m_piNoBadExploreImprovement[iI] = 0;
	}
	int iNumLoad = m_aiNoBadExploreImprovementsforPass3.size();
	for (int iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszNoBadExploreImprovementsforPass3[iI]) >= 0, "Warning, about to leak memory in CvTechInfo::readPass3");
		m_piNoBadExploreImprovement[GC.getInfoTypeForString(m_aszNoBadExploreImprovementsforPass3[iI])] += m_aiNoBadExploreImprovementsforPass3[iI];
	}
	m_aszNoBadExploreImprovementsforPass3.clear();
	m_aiNoBadExploreImprovementsforPass3.clear();

	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(PromotionInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvPromotionInfo::copyNonDefaults(CvPromotionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isLeader()								== false)				m_bLeader							= pClassInfo->isLeader();
	if (isEffectProm()							== false)				m_bEffectProm						= pClassInfo->isEffectProm();
	//Magic Rework
	if (getMagicalPower() == 0)				m_iMagicalPower = pClassInfo->getMagicalPower();
	//if (getDominionCapacity() == 0)				m_iDominionCapacity = pClassInfo->getDominionCapacity();
	//for (int i = 0; i < GC.getNumSpellClassInfos(); ++i)
	//{
	//	if (getSpellClassExtraPower(i) == 0)				m_piSpellClassExtraPower[i] = pClassInfo->getSpellClassExtraPower(i);
	//}
	if (m_bLeader || m_bEffectProm)		m_bGraphicalOnly = true;
	if (isBlitz()								== false)				m_bBlitz							= pClassInfo->isBlitz();
	if (isAmphib()								== false)				m_bAmphib							= pClassInfo->isAmphib();
	if (isRiver()								== false)				m_bRiver							= pClassInfo->isRiver();
	if (isEnemyRoute()							== false)				m_bEnemyRoute						= pClassInfo->isEnemyRoute();
	if (isAlwaysHeal()							== false)				m_bAlwaysHeal						= pClassInfo->isAlwaysHeal();
	if (isHillsDoubleMove()						== false)				m_bHillsDoubleMove					= pClassInfo->isHillsDoubleMove();
	if (isImmuneToFirstStrikes()				== false)				m_bImmuneToFirstStrikes				= pClassInfo->isImmuneToFirstStrikes();
	if (isTradeDefender() == false)				m_bTradeDefender = pClassInfo->isTradeDefender();
	if (isAIControl()							== false)				m_bAIControl						= pClassInfo->isAIControl();
	if (isBoarding()							== false)				m_bBoarding							= pClassInfo->isBoarding();
	if (isOnlyDefensive()						== false)				m_bOnlyDefensive					= pClassInfo->isOnlyDefensive();
	if (isDispellable()							== false)				m_bDispellable						= pClassInfo->isDispellable();
	if (isDoubleFortifyBonus()					== false)				m_bDoubleFortifyBonus				= pClassInfo->isDoubleFortifyBonus();
	if (isEquipment()							== false)				m_bEquipment						= pClassInfo->isEquipment();
	if (isFear()								== false)				m_bFear								= pClassInfo->isFear();
	if (isFlying()								== false)				m_bFlying							= pClassInfo->isFlying();
	if (isPrereqAliveCapture() == false)				m_bPrereqAliveCapture = pClassInfo->isPrereqAliveCapture();
	if (isHeld()								== false)				m_bHeld								= pClassInfo->isHeld();
	if (isHiddenNationality()					== false)				m_bHiddenNationality				= pClassInfo->isHiddenNationality();
	if (isIgnoreBuildingDefense()				== false)				m_bIgnoreBuildingDefense			= pClassInfo->isIgnoreBuildingDefense();
	if (isImmortal()							== false)				m_bImmortal							= pClassInfo->isImmortal();
	if (isImmuneToCapture()						== false)				m_bImmuneToCapture					= pClassInfo->isImmuneToCapture();
	if (isImmuneToDefensiveStrike()				== false)				m_bImmuneToDefensiveStrike			= pClassInfo->isImmuneToDefensiveStrike();
	if (isImmuneToFear()						== false)				m_bImmuneToFear						= pClassInfo->isImmuneToFear();
	if (isImmuneToMagic()						== false)				m_bImmuneToMagic					= pClassInfo->isImmuneToMagic();
	if (isInvisible()							== false)				m_bInvisible						= pClassInfo->isInvisible();
	if (isMutation()							== false)				m_bMutation							= pClassInfo->isMutation();
/*************************************************************************************************/
/**	Dynamic Mutation						06/15/10								Valkrionn	**/
/**																								**/
/**							New tags used by the Dynamic Mutation system						**/
/*************************************************************************************************/
	if (getMutationWeight()						== 0)					m_iMutationWeight					= pClassInfo->getMutationWeight();
	if (getMutationMin()						== 1)					m_iMutationMin						= pClassInfo->getMutationMin();
	if (getMutationMax()						== 1)					m_iMutationMax						= pClassInfo->getMutationMax();
	if (getMutationMaxApplications()			== 1)					m_iMutationMaxApplications			= pClassInfo->getMutationMaxApplications();
	if (isBadEffect()							== false)				m_bBadEffect						= pClassInfo->isBadEffect();
/*************************************************************************************************/
/**	DynamicMutation								END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	if (getMaxApplications()					== 1)					m_iMaxApplications					= pClassInfo->getMaxApplications();
	if (getAntiWithdrawal()						== 0)					m_iAntiWithdrawal					= pClassInfo->getAntiWithdrawal();
	if (getAntiFirstStrikes()					== 0)					m_iAntiFirstStrikes					= pClassInfo->getAntiFirstStrikes();
	if (getRangedCombatPercent()				== 0)					m_iRangedCombatPercent				= pClassInfo->getRangedCombatPercent();
	if (getRangedCombatPercentGlobalCounter()	== 0)					m_iRangedCombatPercentGlobalCounter	= pClassInfo->getRangedCombatPercentGlobalCounter();
	if (getRangedCombatPercentInBorders()		== 0)					m_iRangedCombatPercentInBorders		= pClassInfo->getRangedCombatPercentInBorders();
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	if (isNotAlive()							== false)				m_bNotAlive							= pClassInfo->isNotAlive();
	if (isPrereqAlive()							== false)				m_bPrereqAlive						= pClassInfo->isPrereqAlive();
	if (isPrereqRevealed() == false)				m_bPrereqRevealed = pClassInfo->isPrereqRevealed();
	if (isPrereqHidden() == false)				m_bPrereqHidden = pClassInfo->isPrereqHidden();
	if (isRace()								== false)				m_bRace								= pClassInfo->isRace();
	if (isGraphicalAddOnPromotion() == false)				m_bGraphicalAddOnPromotion = pClassInfo->isGraphicalAddOnPromotion();
	if (isRemovedByCasting()					== false)				m_bRemovedByCasting					= pClassInfo->isRemovedByCasting();
	if (isRemovedByCombat()						== false)				m_bRemovedByCombat					= pClassInfo->isRemovedByCombat();
	if (isRemovedWhenHealed()					== false)				m_bRemovedWhenHealed				= pClassInfo->isRemovedWhenHealed();
	if (isTargetWeakestUnit()					== false)				m_bTargetWeakestUnit				= pClassInfo->isTargetWeakestUnit();
	if (isTargetWeakestUnitCounter()			== false)				m_bTargetWeakestUnitCounter			= pClassInfo->isTargetWeakestUnitCounter();
	if (isTwincast()							== false)				m_bTwincast							= pClassInfo->isTwincast();
	if (isValidate()							== false)				m_bValidate							= pClassInfo->isValidate();
	if (isWaterWalking()						== false)				m_bWaterWalking						= pClassInfo->isWaterWalking();
	if (isCommunalProperty()					== false)				m_bCommunalProperty					= pClassInfo->isCommunalProperty();
	if (isNeverHostile()						== false)				m_bNeverHostile						= pClassInfo->isNeverHostile();
	if (isBlind()								== false)				m_bBlind							= pClassInfo->isBlind();
	if (isOverrideHelpText()					== false)				m_bOverrideHelpText					= pClassInfo->isOverrideHelpText();
	if (isRequirePermission()					== false)				m_bRequirePermission				= pClassInfo->isRequirePermission();
	if (isCannotCast()							== false)				m_bCannotCast						= pClassInfo->isCannotCast();
	if (isFreeUnit()							== false)				m_bFreeUnit							= pClassInfo->isFreeUnit();
	if (isNoSupply()							== false)				m_bNoSupply							= pClassInfo->isNoSupply();
	if (isTerritorial()							== false)				m_bTerritorial						= pClassInfo->isTerritorial();
	if (isRivalTerritoryExplore()				== false)				m_bRivalTerritoryExplore			= pClassInfo->isRivalTerritoryExplore();
	if (isRivalTerritoryBlock()					== false)				m_bRivalTerritoryBlock				= pClassInfo->isRivalTerritoryBlock();
	if (isPillageOnMove()						== false)				m_bPillageOnMove					= pClassInfo->isPillageOnMove();
	if (isSelfPillage()							== false)				m_bSelfPillage						= pClassInfo->isSelfPillage();
	if (isGetCasterXP()							== false)				m_bGetCasterXP						= pClassInfo->isGetCasterXP();
	if (isNonWarWeariness()						== false)				m_bNonWarWeariness					= pClassInfo->isNonWarWeariness();
	if (isNoMapReveal()							== false)				m_bNoMapReveal						= pClassInfo->isNoMapReveal();
	if (isCannotCapture()						== false)				m_bCannotCapture					= pClassInfo->isCannotCapture();
	if (isCityHappy()							== false)				m_bCityHappy						= pClassInfo->isCityHappy();
	if (isCityNoHappy()							== false)				m_bCityNoHappy						= pClassInfo->isCityNoHappy();
	if (isNoSupport()							== false)				m_bNoSupport						= pClassInfo->isNoSupport();
	if (isCanPillage()							== false)				m_bCanPillage						= pClassInfo->isCanPillage();
	if (isCannotPillage()						== false)				m_bCannotPillage					= pClassInfo->isCannotPillage();
	if (isCitySpy()								== false)				m_bCitySpy							= pClassInfo->isCitySpy();
	if (isStartGoldenAge()						== false)				m_bStartGoldenAge					= pClassInfo->isStartGoldenAge();
	if (isNoDefenseBonus()						== false)				m_bNoDefenseBonus					= pClassInfo->isNoDefenseBonus();
	if (isMoveImpassable()						== false)				m_bMoveImpassable					= pClassInfo->isMoveImpassable();
	if (isClimbPeaks()							== false)				m_bClimbPeaks						= pClassInfo->isClimbPeaks();
	if (isFlatMoveCost()						== false)				m_bFlatMoveCost						= pClassInfo->isFlatMoveCost();
	if (isIgnoreTerrainCosts()					== false)				m_bIgnoreTerrainCosts				= pClassInfo->isIgnoreTerrainCosts();
	if (isAttackNoWar()							== false)				m_bAttackNoWar						= pClassInfo->isAttackNoWar();
	if (isAllowAttacks()						== false)				m_bAllowAttacks						= pClassInfo->isAllowAttacks();
	if (isFirstStrikeVulnerable()				== false)				m_bFirstStrikeVulnerable			= pClassInfo->isFirstStrikeVulnerable();
	if (isAllowDefenseBonuses()					== false)				m_bAllowDefenseBonuses				= pClassInfo->isAllowDefenseBonuses();
	if (isNonAbandon()							== false)				m_bNonAbandon						= pClassInfo->isNonAbandon();
	if (isIndependant()							== false)				m_bIndependant						= pClassInfo->isIndependant();

	//religiousCommander by BI 07/24/11
	if (isReligiousCommanderPromo()							== false)				m_bReligiousCommanderPromo						= pClassInfo->isReligiousCommanderPromo();


	if (isStackEffect()							== false)				m_bStackEffect						= pClassInfo->isStackEffect();
	if (isAutoAcquire()							== false)				m_bAutoAcquire						= pClassInfo->isAutoAcquire();
	if (isMustMaintain()						== false)				m_bMustMaintain						= pClassInfo->isMustMaintain();
	if (isPrereqInCity()						== false)				m_bPrereqInCity						= pClassInfo->isPrereqInCity();
	if (isNoXP()								== false)				m_bNoXP								= pClassInfo->isNoXP();
	if (isPrereqInBorderEnemy()					== false)				m_bPrereqInBorderEnemy				= pClassInfo->isPrereqInBorderEnemy();
	if (isPrereqInBorderRival()					== false)				m_bPrereqInBorderRival				= pClassInfo->isPrereqInBorderRival();
	if (isPrereqInBorderTeam()					== false)				m_bPrereqInBorderTeam				= pClassInfo->isPrereqInBorderTeam();
	if (isPrereqInBorderSelf()					== false)				m_bPrereqInBorderSelf				= pClassInfo->isPrereqInBorderSelf();
	if (isPrereqInBorderNone()					== false)				m_bPrereqInBorderNone				= pClassInfo->isPrereqInBorderNone();
	if (isAllowNULLUnitCombat()					== false)				m_bAllowNULLUnitCombat				= pClassInfo->isAllowNULLUnitCombat();
/*************************************************************************************************/
/**	MobileCage								01/28/2010								Valkrionn	**/
/**																								**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	if (getLeashRange()							== -100)				m_iLeashRange						= pClassInfo->getLeashRange();
	if (getLeashChance()						== -1)					m_iLeashChance						= pClassInfo->getLeashChance();
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	if (isLeveledImmortality()					== false)				m_bLeveledImmortality				= pClassInfo->isLeveledImmortality();
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	if(isNonInfluence()							== false)				m_bNonInfluence						= pClassInfo->isNonInfluence();
	if(isInfluence()							== false)				m_bInfluence						= pClassInfo->isInfluence();
	if(getVictoryInfluenceModifier()			== 100)					m_iVictoryInfluenceModifier			= pClassInfo->getVictoryInfluenceModifier();
	if(getDefeatInfluenceModifier()				== 100)					m_iDefeatInfluenceModifier			= pClassInfo->getDefeatInfluenceModifier();
	if(getPillageInfluenceModifier()			== 100)					m_iPillageInfluenceModifier			= pClassInfo->getPillageInfluenceModifier();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	if(getExtraPerception()						== 0)					m_iExtraPerception					= pClassInfo->getExtraPerception();
	if (getInvisibleLevel() == 0)					m_iInvisibleLevel = pClassInfo->getInvisibleLevel();
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	if (getCommandLimit()						== 0)					m_iCommandLimit						= pClassInfo->getCommandLimit();
	if (getCommandRange()						== 0)					m_iCommandRange						= pClassInfo->getCommandRange();
	if (getCommandXPShareRate()					== 0)					m_iCommandXPShareRate				= pClassInfo->getCommandXPShareRate();
	if (getRandomApplyChance()					== 0)					m_iRandomApplyChance				= pClassInfo->getRandomApplyChance();
	if (getAssetValue()							== 0)					m_iAssetValue						= pClassInfo->getAssetValue();
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getPowerValue()							== 0)					m_iPowerValue						= pClassInfo->getPowerValue();
/**								----  End Original Code  ----									**/
	if (getPowerAdd()							== 0)					m_iPowerAdd							= pClassInfo->getPowerAdd();
	if (getPowerMult()							== 0)					m_iPowerMult						= pClassInfo->getPowerMult();
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	if (getDamageOnRemove()						== 0)					m_iDamageOnRemove					= pClassInfo->getDamageOnRemove();
	if (getTempUnitCombat()						== 0)					m_iTempUnitCombat					= pClassInfo->getTempUnitCombat();
	if (getFreeXPCap()							== 0)					m_iFreeXPCap						= pClassInfo->getFreeXPCap();
	if (getDuration()							== 0)					m_iDuration							= pClassInfo->getDuration();
	if (getAirCombat()							== 0)					m_iAirCombat						= pClassInfo->getAirCombat();
	if (getAirCombatLimitBoost()				== 0)					m_iAirCombatLimitBoost				= pClassInfo->getAirCombatLimitBoost();
	if (getExtraDropRange()						== 0)					m_iExtraDropRange					= pClassInfo->getExtraDropRange();
	if (getAlignmentModifier()					== 0)					m_iAlignmentModifier				= pClassInfo->getAlignmentModifier();
	if (getPrereqBroadAlignment()				== 0)					m_iPrereqBroadAlignment				= pClassInfo->getPrereqBroadAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getEthicalAlignmentModifier()			== 0)					m_iEthicalAlignmentModifier			= pClassInfo->getEthicalAlignmentModifier();
	if (getPrereqBroadEthicalAlignment()		== 0)					m_iPrereqBroadEthicalAlignment		= pClassInfo->getPrereqBroadEthicalAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getSpellExtraRange()					== 0)					m_iSpellExtraRange					= pClassInfo->getSpellExtraRange();
	if (getCombatConversionChance()				== 0)					m_iCombatConversionChance			= pClassInfo->getCombatConversionChance();
	if (getCombatUnitGenerationChance()			== 0)					m_iCombatUnitGenerationChance		= pClassInfo->getCombatUnitGenerationChance();
	if (getSlaveGenerationChance()				== 0)					m_iSlaveGenerationChance			= pClassInfo->getSlaveGenerationChance();
	if (getGiftableXP()							== 0)					m_iGiftableXP						= (float)pClassInfo->getGiftableXP()/100.0f;//Unfinished Field
	if (getCombatExtraDuration()				== 0)					m_iCombatExtraDuration				= pClassInfo->getCombatExtraDuration();
	if (getDurationPerTurn()					== 0)					m_iDurationPerTurn					= pClassInfo->getDurationPerTurn();
	if (getDurationAlter()						== 0)					m_iDurationAlter					= pClassInfo->getDurationAlter();
	if (getChangeDuration()						== 0)					m_iChangeDuration					= pClassInfo->getChangeDuration();
	if (getExtraSupport()						== 0)					m_iExtraSupport						= pClassInfo->getExtraSupport();
	if (getChanceMiscast()						== 0)					m_iChanceMiscast					= pClassInfo->getChanceMiscast();
	if (getCombatDmgCapBoost()					== 0)					m_iCombatDmgCapBoost				= pClassInfo->getCombatDmgCapBoost();
	if (getCollateralLimitCap()					== 0)					m_iCollateralLimitCap				= pClassInfo->getCollateralLimitCap();
	if (getCollateralLimitBoost()				== 0)					m_iCollateralLimitBoost				= pClassInfo->getCollateralLimitBoost();
	if (getCollateralTargetsLimit()				== 0)					m_iCollateralTargetsLimit			= pClassInfo->getCollateralTargetsLimit();
	if (getCollateralExtraTargets()				== 0)					m_iCollateralExtraTargets			= pClassInfo->getCollateralExtraTargets();

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	if (getFlankingLimitBoost()					== 0)					m_iFlankingLimitBoost				= pClassInfo->getFlankingLimitBoost();
	if (getFlankingExtraTargets()				== 0)					m_iFlankingExtraTargets				= pClassInfo->getFlankingExtraTargets();
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

	if (getHammerSacrifice()					== 0)					m_iHammerSacrifice					= pClassInfo->getHammerSacrifice();//Unfinished Field
	if (getExtraHammerPerPop()					== 0)					m_iExtraHammerPerPop				= pClassInfo->getExtraHammerPerPop();//Unfinished Field
	if (getFoodSacrifice()						== 0)					m_iFoodSacrifice					= pClassInfo->getFoodSacrifice();//Unfinished Field
	if (getPopulationAdd()						== 0)					m_iPopulationAdd					= pClassInfo->getPopulationAdd();//Unfinished Field
	if (getBeakerSacrifice()					== 0)					m_iBeakerSacrifice					= pClassInfo->getBeakerSacrifice();//Unfinished Field
	if (getExtraBeakerPerPop()					== 0)					m_iExtraBeakerPerPop				= pClassInfo->getExtraBeakerPerPop();//Unfinished Field
	if (getGoldSacrifice()						== 0)					m_iGoldSacrifice					= pClassInfo->getGoldSacrifice();//Unfinished Field
	if (getExtraGoldPerPop()					== 0)					m_iExtraGoldPerPop					= pClassInfo->getExtraGoldPerPop();//Unfinished Field
	if (getCultureSacrifice()					== 0)					m_iCultureSacrifice					= pClassInfo->getCultureSacrifice();//Unfinished Field
	if (getExtraCulturePerPop()					== 0)					m_iExtraCulturePerPop				= pClassInfo->getExtraCulturePerPop();//Unfinished Field
	if (getPrereqMinAge()						== 0)					m_iPrereqMinAge						= pClassInfo->getPrereqMinAge();
	if (getPrereqMaxAge()						== 0)					m_iPrereqMaxAge						= pClassInfo->getPrereqMaxAge();
	if (getGoldCost()							== 0)					m_iGoldCost							= pClassInfo->getGoldCost();
	if (getXPTranserRate()						== 0)					m_iXPTranserRate					= pClassInfo->getXPTranserRate();//Unfinished Field
	if (getPrereqTier()							== 0)					m_iPrereqTier						= pClassInfo->getPrereqTier();
	if (getPrereqWeaponTier()					== 0)					m_iPrereqWeaponTier					= pClassInfo->getPrereqWeaponTier();
	if (getNoBadExplore()						== 0)					m_iNoBadExplore						= pClassInfo->getNoBadExplore();
	if (getVisibilityChange()					== 0)					m_iVisibilityChange					= pClassInfo->getVisibilityChange();
	if (getMovesChange()						== 0)					m_iMovesChange						= pClassInfo->getMovesChange();
	if (getMoveDiscountChange()					== 0)					m_iMoveDiscountChange				= pClassInfo->getMoveDiscountChange();
	if (getAirRangeChange()						== 0)					m_iAirRangeChange					= pClassInfo->getAirRangeChange();
	if (getInterceptChange()					== 0)					m_iInterceptChange					= pClassInfo->getInterceptChange();
	if (getEvasionChange()						== 0)					m_iEvasionChange					= pClassInfo->getEvasionChange();
	if (getWithdrawalChange()					== 0)					m_iWithdrawalChange					= pClassInfo->getWithdrawalChange();
	if (getEnemyWithdrawalChange()				== 0)					m_iEnemyWithdrawalChange			= pClassInfo->getEnemyWithdrawalChange();
	if (getCargoChange()						== 0)					m_iCargoChange						= pClassInfo->getCargoChange();
	if (getCollateralDamageChange()				== 0)					m_iCollateralDamageChange			= pClassInfo->getCollateralDamageChange();
	if (getBombardRateChange()					== 0)					m_iBombardRateChange				= pClassInfo->getBombardRateChange();
	if (getFirstStrikesChange()					== 0)					m_iFirstStrikesChange				= pClassInfo->getFirstStrikesChange();
	if (getChanceFirstStrikesChange()			== 0)					m_iChanceFirstStrikesChange			= pClassInfo->getChanceFirstStrikesChange();
	if (getEnemyHealChange()					== 0)					m_iEnemyHealChange					= pClassInfo->getEnemyHealChange();
	if (getNeutralHealChange()					== 0)					m_iNeutralHealChange				= pClassInfo->getNeutralHealChange();
	if (getFriendlyHealChange()					== 0)					m_iFriendlyHealChange				= pClassInfo->getFriendlyHealChange();
	if (getSameTileHealChange()					== 0)					m_iSameTileHealChange				= pClassInfo->getSameTileHealChange();
	if (getAdjacentTileHealChange()				== 0)					m_iAdjacentTileHealChange			= pClassInfo->getAdjacentTileHealChange();
	if (getCombatPercent()						== 0)					m_iCombatPercent					= pClassInfo->getCombatPercent();
	if (getCityAttackPercent()					== 0)					m_iCityAttackPercent				= pClassInfo->getCityAttackPercent();
	if (getCityDefensePercent()					== 0)					m_iCityDefensePercent				= pClassInfo->getCityDefensePercent();
	if (getHillsAttackPercent()					== 0)					m_iHillsAttackPercent				= pClassInfo->getHillsAttackPercent();
	if (getHillsDefensePercent()				== 0)					m_iHillsDefensePercent				= pClassInfo->getHillsDefensePercent();
	if (getRevoltProtection()					== 0)					m_iRevoltProtection					= pClassInfo->getRevoltProtection();
	if (getCollateralDamageProtection()			== 0)					m_iCollateralDamageProtection		= pClassInfo->getCollateralDamageProtection();
	if (getPillageChange()						== 0)					m_iPillageChange					= pClassInfo->getPillageChange();
	if (getUpgradeDiscount()					== 0)					m_iUpgradeDiscount					= pClassInfo->getUpgradeDiscount();
	if (getExperiencePercent()					== 0)					m_iExperiencePercent				= pClassInfo->getExperiencePercent();
	if (getKamikazePercent()					== 0)					m_iKamikazePercent					= pClassInfo->getKamikazePercent();
	if (getAIWeight()							== 0)					m_iAIWeight							= pClassInfo->getAIWeight();
	if (getBetrayalChance()						== 0)					m_iBetrayalChance					= pClassInfo->getBetrayalChance();
	if (getBetterDefenderThanPercent()			== 0)					m_iBetterDefenderThanPercent		= pClassInfo->getBetterDefenderThanPercent();
	if (getCasterResistModify()					== 0)					m_iCasterResistModify				= pClassInfo->getCasterResistModify();
	if (getCombatCapturePercent()				== 0)					m_iCombatCapturePercent				= pClassInfo->getCombatCapturePercent();
	if (getCombatHealPercent()					== 0)					m_iCombatHealPercent				= pClassInfo->getCombatHealPercent();
	if (getCombatLimit()						== 0)					m_iCombatLimit						= pClassInfo->getCombatLimit();
	if (getCombatPercentDefense()				== 0)					m_iCombatPercentDefense				= pClassInfo->getCombatPercentDefense();
	if (getCombatPercentGlobalCounter()			== 0)					m_iCombatPercentGlobalCounter		= pClassInfo->getCombatPercentGlobalCounter();
	if (getCombatPercentInBorders()				== 0)					m_iCombatPercentInBorders			= pClassInfo->getCombatPercentInBorders();
	if (getDefensiveStrikeChance()				== 0)					m_iDefensiveStrikeChance			= pClassInfo->getDefensiveStrikeChance();
	if (getDefensiveStrikeDamage()				== 0)					m_iDefensiveStrikeDamage			= pClassInfo->getDefensiveStrikeDamage();
	if (getExpireChance()						== 0)					m_iExpireChance						= pClassInfo->getExpireChance();
	if (getExtraCombatStr()						== 0)					m_iExtraCombatStr					= pClassInfo->getExtraCombatStr();
	if (getExtraCombatDefense()					== 0)					m_iExtraCombatDefense				= pClassInfo->getExtraCombatDefense();
	if (getFreeXPPerTurn()						== 0)					m_iFreeXPPerTurn					= (float)pClassInfo->getFreeXPPerTurn()/100.0f;
	if (getFreeXPFromCombat()					== 0)					m_iFreeXPFromCombat					= (float)pClassInfo->getFreeXPFromCombat()/100.0f;
	if (getGroupSize()							== 0)					m_iGroupSize						= pClassInfo->getGroupSize();
	if (getMinLevel()							== 0)					m_iMinLevel							= pClassInfo->getMinLevel();
/*************************************************************************************************/
/**	PrereqStrBoostSize						10/16/09								Valkrionn	**/
/**																								**/
/**					Allows a units StrBoost to be used as a promotion prereq					**/
/*************************************************************************************************/
	if (getPrereqStrBoostSize()					== 0)					m_iPrereqStrBoostSize				= pClassInfo->getPrereqStrBoostSize();
/*************************************************************************************************/
/**	PrereqStrBoostSize							END												**/
/*************************************************************************************************/
	if (getModifyGlobalCounter()				== 0)					m_iModifyGlobalCounter				= pClassInfo->getModifyGlobalCounter();
	if (getModifyGlobalCounterOnCombat()		== 0)					m_iModifyGlobalCounterOnCombat		= pClassInfo->getModifyGlobalCounterOnCombat();
	if (getResistMagic()						== 0)					m_iResistMagic						= pClassInfo->getResistMagic();
	if (getSpellCasterXP()						== 0)					m_iSpellCasterXP					= (float)pClassInfo->getSpellCasterXP()/100.0f;
	if (getWorkRateModify()						== 0)					m_iWorkRateModify					= pClassInfo->getWorkRateModify();
	if (getCasterXPRate()						== 0.0f)				m_fCasterXPRate						= pClassInfo->getCasterXPRate();
	if (getPyPostCombatLost()					== cDefault)			m_szPyPostCombatLost				= pClassInfo->getPyPostCombatLost();
	if (getPyPostCombatWon()					== cDefault)			m_szPyPostCombatWon					= pClassInfo->getPyPostCombatWon();
/*************************************************************************************************/
/**	PyOnPromoTaken							   08/28/10								Valkrionn	**/
/*************************************************************************************************/
	if (getPyOnPromoTaken()						== cDefault)			m_szPyOnPromoTaken					= pClassInfo->getPyOnPromoTaken();
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	if (getPyOnRemove()							== cDefault)			m_szPyOnRemove						= pClassInfo->getPyOnRemove();
	if (getNewName()							== cDefault)			m_szNewName							= pClassInfo->getNewName();
	if (getSound()								== cDefault)			m_szSound							= pClassInfo->getSound();
	if (getPyPerTurn()							== cDefault)			m_szPyPerTurn						= pClassInfo->getPyPerTurn();
	if (getExtraArtType() == cDefault)			m_szExtraArtType = pClassInfo->getExtraArtType();
	if (getReplaceArtType() == cDefault)			m_szReplaceArtType = pClassInfo->getReplaceArtType();
	/*************************************************************************************************/
/**	Promotion PyHelp		 				07/09/10								Valkrionn	**/
/**																								**/
/**							Allows promotions to have dynamic help								**/
/*************************************************************************************************/
	if (getPythonHelp()							== cDefault)			m_szPyHelp							= pClassInfo->getPythonHelp();
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	if (getTechPrereq()							== NO_TECH)				m_iTechPrereq						= pClassInfo->getTechPrereq();
	if (getBonusPrereq()						== NO_BONUS)			m_iBonusPrereq						= pClassInfo->getBonusPrereq();
	if (getStateReligionPrereq()				== NO_RELIGION)			m_iStateReligionPrereq				= pClassInfo->getStateReligionPrereq();
	if (getCaptureUnitClass() == NO_UNITCLASS)			m_iCaptureUnitClass = pClassInfo->getCaptureUnitClass();
	if (getPromotionCombatMod()					== NO_PROMOTION)		m_iPromotionCombatMod				= pClassInfo->getPromotionCombatMod();

	//ReligionCombatBonus by BI 07/25/11
	if (getReligionCombatMod()					== NO_RELIGION)		m_iReligionCombatMod				= pClassInfo->getReligionCombatMod();

	if (getCaptureUnitCombat()					== NO_UNITCOMBAT)		m_iCaptureUnitCombat				= pClassInfo->getCaptureUnitCombat();
	if (getBlockedSpellClass() == NO_SPELLCLASS)		m_iBlockedSpellClass = pClassInfo->getBlockedSpellClass();
	if (getLayerAnimationPath()					== ANIMATIONPATH_NONE)	m_iLayerAnimationPath				= pClassInfo->getLayerAnimationPath();
	for (int j = 0; j < GC.getNumBonusInfos(); j++)
	{
		if (m_piBonusAffinity[j]				== 0)					m_piBonusAffinity[j]				= pClassInfo->getBonusAffinity(j);
	}
	for (int j = 0; j < GC.getNumDamageTypeInfos(); j++)
	{
		if (m_piDamageTypeResist[j]				== 0)					m_piDamageTypeResist[j]				= pClassInfo->getDamageTypeResist(j);
		if (m_piDamageTypeCombat[j]				== 0)					m_piDamageTypeCombat[j]				= pClassInfo->getDamageTypeCombat(j);
	}
	//for (int j = 0; j < GC.getNumImprovementInfos(); j++)
	//{
	//	if (m_piNoBadExploreImprovement[j] == 0)					m_piNoBadExploreImprovement[j] = pClassInfo->getNoBadExploreImprovement(j);

//	}
	for (int i = 0; i < pClassInfo->getNoBadExploreImprovementsVectorSize(); i++)
	{
		m_aszNoBadExploreImprovementsforPass3.push_back(pClassInfo->getNoBadExploreImprovementNamesVectorElement(i));
		m_aiNoBadExploreImprovementsforPass3.push_back(pClassInfo->getNoBadExploreImprovementValuesVectorElement(i));
	}

	for (int j = 0; j < GC.getNumTerrainInfos(); j++)
	{
		if (m_piTerrainAttackPercent[j]			== 0)					m_piTerrainAttackPercent[j]			= pClassInfo->getTerrainAttackPercent(j);
		if (m_piTerrainDefensePercent[j]		== 0)					m_piTerrainDefensePercent[j]		= pClassInfo->getTerrainDefensePercent(j);
		if (m_pbTerrainDoubleMove[j]			== false)				m_pbTerrainDoubleMove[j]			= pClassInfo->getTerrainDoubleMove(j);
		if (m_piPromotionTerrainCost[j]					== 0)					m_piPromotionTerrainCost[j]					= pClassInfo->getPromotionTerrainCost(j);	// GWS
	}
	for (int j = 0; j < GC.getNumFeatureInfos(); j++)
	{
		if (m_piFeatureAttackPercent[j]			== 0)					m_piFeatureAttackPercent[j]			= pClassInfo->getFeatureAttackPercent(j);
		if (m_piFeatureDefensePercent[j]		== 0)					m_piFeatureDefensePercent[j]		= pClassInfo->getFeatureDefensePercent(j);
		if (m_pbFeatureDoubleMove[j]			== false)				m_pbFeatureDoubleMove[j]			= pClassInfo->getFeatureDoubleMove(j);
		if (m_piPromotionFeatureCost[j]					== 0)					m_piPromotionFeatureCost[j]					= pClassInfo->getPromotionFeatureCost(j);	// GWS
	}
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvPromotionInfo
	if (m_iPromotionHillCost								== 0)					m_iPromotionHillCost							= pClassInfo->getPromotionHillCost();
	if (m_iPromotionPeakCost								== 0)					m_iPromotionPeakCost							= pClassInfo->getPromotionPeakCost();
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	for (int j = 0; j < GC.getNumUnitCombatInfos(); j++)
	{
		if (m_piUnitCombatModifierPercent[j]	== 0)					m_piUnitCombatModifierPercent[j]	= pClassInfo->getUnitCombatModifierPercent(j);

		// Upgraded Capture Rate by BI 08/16/11
		if (m_piUnitCombatCaptureRatePercent[j]	== 0)					m_piUnitCombatCaptureRatePercent[j]	= pClassInfo->getUnitCombatCaptureRatePercent(j);
		if (m_pbUnitCombatNonCapture[j] == 0)					m_pbUnitCombatNonCapture[j] = pClassInfo->isUnitCombatNonCapture(j);
		/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
		if (m_piUnitCombat[j]					== -1)					m_piUnitCombat[j]					= pClassInfo->getUnitCombatMaxApplications(j);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	}
	for (int j = 0; j < NUM_DOMAIN_TYPES; j++)
	{
		if (m_piDomainModifierPercent[j]		== 0)			m_piDomainModifierPercent[j]		= pClassInfo->getDomainModifierPercent(j);
	}
	for(int i=0;i<NUM_YIELD_TYPES;++i)
	{
		if (getYieldFromWin(i)					== 0)					m_piYieldFromWin[i]					= pClassInfo->getYieldFromWin(i);
		if (getYieldForLoss(i)					== 0)					m_piYieldForLoss[i]					= pClassInfo->getYieldForLoss(i);
	}
	for(int i=0;i<NUM_COMMERCE_TYPES;++i)
	{
		if (getCommerceFromWin(i)				== 0)					m_piCommerceFromWin[i]				= pClassInfo->getCommerceFromWin(i);
		if (getCommerceForLoss(i)				== 0)					m_piCommerceForLoss[i]				= pClassInfo->getCommerceForLoss(i);
	}
	if(pClassInfo->getNumPrereqReligions() > 0)
	{
		int* tempArray = new int[getNumPrereqReligions() + pClassInfo->getNumPrereqReligions()];
		for(int i = 0; i< getNumPrereqReligions(); ++i)
		{
			tempArray[i] = getPrereqReligion(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqReligions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqReligions();++j)
			{
				if(pClassInfo->getPrereqReligion(i) == getPrereqReligion(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqReligions()] = pClassInfo->getPrereqReligion(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqReligions);
		int iGoalSize = getNumPrereqReligions() + iNewItems;
		m_piPrereqReligions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqReligions[i] = tempArray[i];
			FAssertMsg(m_piPrereqReligions[i] < GC.getNumReligionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqReligions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqReligions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqTechANDs() > 0)
	{
		int* tempArray = new int[getNumPrereqTechANDs() + pClassInfo->getNumPrereqTechANDs()];
		for(int i = 0; i< getNumPrereqTechANDs(); ++i)
		{
			tempArray[i] = getPrereqTechAND(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqTechANDs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqTechANDs();++j)
			{
				if(pClassInfo->getPrereqTechAND(i) == getPrereqTechAND(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqTechANDs()] = pClassInfo->getPrereqTechAND(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqTechANDs);
		int iGoalSize = getNumPrereqTechANDs() + iNewItems;
		m_piPrereqTechANDs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqTechANDs[i] = tempArray[i];
			FAssertMsg(m_piPrereqTechANDs[i] < GC.getNumTechInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqTechANDs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqTechANDs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqTechORs() > 0)
	{
		int* tempArray = new int[getNumPrereqTechORs() + pClassInfo->getNumPrereqTechORs()];
		for(int i = 0; i< getNumPrereqTechORs(); ++i)
		{
			tempArray[i] = getPrereqTechOR(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqTechORs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqTechORs();++j)
			{
				if(pClassInfo->getPrereqTechOR(i) == getPrereqTechOR(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqTechORs()] = pClassInfo->getPrereqTechOR(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqTechORs);
		int iGoalSize = getNumPrereqTechORs() + iNewItems;
		m_piPrereqTechORs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqTechORs[i] = tempArray[i];
			FAssertMsg(m_piPrereqTechORs[i] < GC.getNumTechInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqTechORs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqTechORs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqAlignments() + pClassInfo->getNumPrereqAlignments()];
		for(int i = 0; i< getNumPrereqAlignments(); ++i)
		{
			tempArray[i] = getPrereqAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqAlignments();++j)
			{
				if(pClassInfo->getPrereqAlignment(i) == getPrereqAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqAlignments()] = pClassInfo->getPrereqAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqAlignments);
		int iGoalSize = getNumPrereqAlignments() + iNewItems;
		m_piPrereqAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqAlignments[i] < NUM_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if(pClassInfo->getNumPrereqEthicalAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqEthicalAlignments() + pClassInfo->getNumPrereqEthicalAlignments()];
		for(int i = 0; i< getNumPrereqEthicalAlignments(); ++i)
		{
			tempArray[i] = getPrereqEthicalAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqEthicalAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqEthicalAlignments();++j)
			{
				if(pClassInfo->getPrereqEthicalAlignment(i) == getPrereqEthicalAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqEthicalAlignments()] = pClassInfo->getPrereqEthicalAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
		int iGoalSize = getNumPrereqEthicalAlignments() + iNewItems;
		m_piPrereqEthicalAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqEthicalAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqEthicalAlignments[i] < NUM_ETHICAL_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqEthicalAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqEthicalAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if(pClassInfo->getNumPrereqFeatures() > 0)
	{
		int* tempArray = new int[getNumPrereqFeatures() + pClassInfo->getNumPrereqFeatures()];
		for(int i = 0; i< getNumPrereqFeatures(); ++i)
		{
			tempArray[i] = getPrereqFeature(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqFeatures(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqFeatures();++j)
			{
				if(pClassInfo->getPrereqFeature(i) == getPrereqFeature(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqFeatures()] = pClassInfo->getPrereqFeature(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqFeatures);
		int iGoalSize = getNumPrereqFeatures() + iNewItems;
		m_piPrereqFeatures = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqFeatures[i] = tempArray[i];
			FAssertMsg(m_piPrereqFeatures[i] < GC.getNumFeatureInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqFeatures[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqFeatures = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SecondaryUnitCombats")) pXML->SetIntWithChildList(&m_iNumSecondaryUnitCombats, &m_piSecondaryUnitCombats);
	if(pClassInfo->getNumSecondaryUnitCombats() > 0)
	{
		int* tempArray = new int[getNumSecondaryUnitCombats() + pClassInfo->getNumSecondaryUnitCombats()];
		for(int i = 0; i< getNumSecondaryUnitCombats(); ++i)
		{
			tempArray[i] = getSecondaryUnitCombats(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumSecondaryUnitCombats(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumSecondaryUnitCombats();++j)
			{
				if(pClassInfo->getSecondaryUnitCombats(i) == getSecondaryUnitCombats(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumSecondaryUnitCombats()] = pClassInfo->getSecondaryUnitCombats(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piSecondaryUnitCombats);
		int iGoalSize = getNumSecondaryUnitCombats() + iNewItems;
		m_piSecondaryUnitCombats = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piSecondaryUnitCombats[i] = tempArray[i];
			FAssertMsg(m_piSecondaryUnitCombats[i] < GC.getNumUnitCombatInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piSecondaryUnitCombats[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumSecondaryUnitCombats = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
	if(pClassInfo->getNumPrereqTerrains() > 0)
	{
		int* tempArray = new int[getNumPrereqTerrains() + pClassInfo->getNumPrereqTerrains()];
		for(int i = 0; i< getNumPrereqTerrains(); ++i)
		{
			tempArray[i] = getPrereqTerrain(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqTerrains(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqTerrains();++j)
			{
				if(pClassInfo->getPrereqTerrain(i) == getPrereqTerrain(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqTerrains()] = pClassInfo->getPrereqTerrain(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqTerrains);
		int iGoalSize = getNumPrereqTerrains() + iNewItems;
		m_piPrereqTerrains = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqTerrains[i] = tempArray[i];
			FAssertMsg(m_piPrereqTerrains[i] < GC.getNumTerrainInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqTerrains[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqTerrains = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqBonusANDs() > 0)
	{
		int* tempArray = new int[getNumPrereqBonusANDs() + pClassInfo->getNumPrereqBonusANDs()];
		for(int i = 0; i< getNumPrereqBonusANDs(); ++i)
		{
			tempArray[i] = getPrereqBonusAND(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqBonusANDs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqBonusANDs();++j)
			{
				if(pClassInfo->getPrereqBonusAND(i) == getPrereqBonusAND(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqBonusANDs()] = pClassInfo->getPrereqBonusAND(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqBonusANDs);
		int iGoalSize = getNumPrereqBonusANDs() + iNewItems;
		m_piPrereqBonusANDs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqBonusANDs[i] = tempArray[i];
			FAssertMsg(m_piPrereqBonusANDs[i] < GC.getNumBonusInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqBonusANDs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqBonusANDs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqBonusORs() > 0)
	{
		int* tempArray = new int[getNumPrereqBonusORs() + pClassInfo->getNumPrereqBonusORs()];
		for(int i = 0; i< getNumPrereqBonusORs(); ++i)
		{
			tempArray[i] = getPrereqBonusOR(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqBonusORs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqBonusORs();++j)
			{
				if(pClassInfo->getPrereqBonusOR(i) == getPrereqBonusOR(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqBonusORs()] = pClassInfo->getPrereqBonusOR(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqBonusORs);
		int iGoalSize = getNumPrereqBonusORs() + iNewItems;
		m_piPrereqBonusORs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqBonusORs[i] = tempArray[i];
			FAssertMsg(m_piPrereqBonusORs[i] < GC.getNumBonusInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqBonusORs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqBonusORs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqFeatANDs() > 0)
	{
		int* tempArray = new int[getNumPrereqFeatANDs() + pClassInfo->getNumPrereqFeatANDs()];
		for(int i = 0; i< getNumPrereqFeatANDs(); ++i)
		{
			tempArray[i] = getPrereqFeatAND(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqFeatANDs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqFeatANDs();++j)
			{
				if(pClassInfo->getPrereqFeatAND(i) == getPrereqFeatAND(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqFeatANDs()] = pClassInfo->getPrereqFeatAND(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqFeatANDs);
		int iGoalSize = getNumPrereqFeatANDs() + iNewItems;
		m_piPrereqFeatANDs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqFeatANDs[i] = tempArray[i];
			FAssertMsg(m_piPrereqFeatANDs[i] < GC.getNumFeatInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqFeatANDs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqFeatANDs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqFeatORs() > 0)
	{
		int* tempArray = new int[getNumPrereqFeatORs() + pClassInfo->getNumPrereqFeatORs()];
		for(int i = 0; i< getNumPrereqFeatORs(); ++i)
		{
			tempArray[i] = getPrereqFeatOR(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqFeatORs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqFeatORs();++j)
			{
				if(pClassInfo->getPrereqFeatOR(i) == getPrereqFeatOR(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqFeatORs()] = pClassInfo->getPrereqFeatOR(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqFeatORs);
		int iGoalSize = getNumPrereqFeatORs() + iNewItems;
		m_piPrereqFeatORs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqFeatORs[i] = tempArray[i];
			FAssertMsg(m_piPrereqFeatORs[i] < GC.getNumFeatInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqFeatORs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqFeatORs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqFeatNOTs() > 0)
	{
		int* tempArray = new int[getNumPrereqFeatNOTs() + pClassInfo->getNumPrereqFeatNOTs()];
		for(int i = 0; i< getNumPrereqFeatNOTs(); ++i)
		{
			tempArray[i] = getPrereqFeatNOT(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqFeatNOTs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqFeatNOTs();++j)
			{
				if(pClassInfo->getPrereqFeatNOT(i) == getPrereqFeatNOT(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqFeatNOTs()] = pClassInfo->getPrereqFeatNOT(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqFeatNOTs);
		int iGoalSize = getNumPrereqFeatNOTs() + iNewItems;
		m_piPrereqFeatNOTs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqFeatNOTs[i] = tempArray[i];
			FAssertMsg(m_piPrereqFeatNOTs[i] < GC.getNumFeatInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqFeatNOTs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqFeatNOTs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqUnitClassesOnTile() > 0)
	{
		int* tempArray = new int[getNumPrereqUnitClassesOnTile() + pClassInfo->getNumPrereqUnitClassesOnTile()];
		for(int i = 0; i< getNumPrereqUnitClassesOnTile(); ++i)
		{
			tempArray[i] = getPrereqUnitClassOnTile(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqUnitClassesOnTile(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqUnitClassesOnTile();++j)
			{
				if(pClassInfo->getPrereqUnitClassOnTile(i) == getPrereqUnitClassOnTile(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqUnitClassesOnTile()] = pClassInfo->getPrereqUnitClassOnTile(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqUnitClassesOnTile);
		int iGoalSize = getNumPrereqUnitClassesOnTile() + iNewItems;
		m_piPrereqUnitClassesOnTile = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqUnitClassesOnTile[i] = tempArray[i];
			FAssertMsg(m_piPrereqUnitClassesOnTile[i] < GC.getNumUnitClassInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqUnitClassesOnTile[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqUnitClassesOnTile = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqUnitClassesNOTOnTile() > 0)
	{
		int* tempArray = new int[getNumPrereqUnitClassesNOTOnTile() + pClassInfo->getNumPrereqUnitClassesNOTOnTile()];
		for(int i = 0; i< getNumPrereqUnitClassesNOTOnTile(); ++i)
		{
			tempArray[i] = getPrereqUnitClassNOTOnTile(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqUnitClassesNOTOnTile(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqUnitClassesNOTOnTile();++j)
			{
				if(pClassInfo->getPrereqUnitClassNOTOnTile(i) == getPrereqUnitClassNOTOnTile(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqUnitClassesNOTOnTile()] = pClassInfo->getPrereqUnitClassNOTOnTile(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqUnitClassesNOTOnTile);
		int iGoalSize = getNumPrereqUnitClassesNOTOnTile() + iNewItems;
		m_piPrereqUnitClassesNOTOnTile = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqUnitClassesNOTOnTile[i] = tempArray[i];
			FAssertMsg(m_piPrereqUnitClassesNOTOnTile[i] < GC.getNumUnitClassInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqUnitClassesNOTOnTile[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqUnitClassesNOTOnTile = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	for(int i=0; i<pClassInfo->getNumSeeInvisibleTypes(); i++)
	{
		int iSeeInvisibleType = pClassInfo->getSeeInvisibleType(i);
		if(iSeeInvisibleType != -1)
		{
			m_aiSeeInvisibleTypes.push_back(iSeeInvisibleType);
		}
	}
	for(int i=0; i<pClassInfo->getNumInvisibleTypes(); i++)
	{
		int iInvisibleType = pClassInfo->getInvisibleType(i);
		if(iInvisibleType != -1)
		{
			m_aiInvisibleTypes.push_back(iInvisibleType);
		}
	}
	for(int i=0;i<pClassInfo->getNumCityBonuses();++i)
	{
		CityBonuses cbTemp;
		cbTemp = pClassInfo->getCityBonus(i);
		m_cbCityBonuses.push_back(cbTemp);
		m_iNumCityBonuses++;
	}

	// Readpass2 stuff
	if (getPrereqPromotion()					== NO_PROMOTION)		m_iPrereqPromotion					= pClassInfo->getPrereqPromotion();
	if (getPrereqOrPromotion1()					== NO_PROMOTION)		m_iPrereqOrPromotion1				= pClassInfo->getPrereqOrPromotion1();
	if (getPrereqOrPromotion2()					== NO_PROMOTION)		m_iPrereqOrPromotion2				= pClassInfo->getPrereqOrPromotion2();
	if (getPromotionCombatApply()				== NO_PROMOTION)		m_iPromotionCombatApply				= pClassInfo->getPromotionCombatApply();
	if (getPromotionRandomApply()				== NO_PROMOTION)		m_iPromotionRandomApply				= pClassInfo->getPromotionRandomApply();
	if (getPromotionSummonPerk()				== NO_PROMOTION)		m_iPromotionSummonPerk				= pClassInfo->getPromotionSummonPerk();
	if (getPromotionPrereqOr3()					== NO_PROMOTION)		m_iPromotionPrereqOr3				= pClassInfo->getPromotionPrereqOr3();
	if (getPromotionPrereqOr4()					== NO_PROMOTION)		m_iPromotionPrereqOr4				= pClassInfo->getPromotionPrereqOr4();
	if (getPromotionPrereqAnd()					== NO_PROMOTION)		m_iPromotionPrereqAnd				= pClassInfo->getPromotionPrereqAnd();
//PrereqUnitReligion by BI 07/24/11
	if (getUnitReligionPrereq()					== NO_RELIGION)		m_iUnitReligionPrereq				= pClassInfo->getUnitReligionPrereq();

	if (getPromotionNextLevel()					== NO_PROMOTION)		m_iPromotionNextLevel				= pClassInfo->getPromotionNextLevel();
	if (getPromotionCombatType()				== NO_PROMOTION)		m_iPromotionCombatType				= pClassInfo->getPromotionCombatType();

	//ReligionCombatBonus by BI 07/25/11
	if (getReligionCombatType()				== NO_RELIGION)		m_iReligionCombatType				= pClassInfo->getReligionCombatType();
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
	if (isInquisition()						== false)				m_bInquisition					= pClassInfo->isInquisition();
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	/* original code
	if(!m_piPrereqPromotionORs)									pXML->InitList(&m_piPrereqPromotionORs, GC.getNumPromotionInfos(), 0);
	if(!m_piPrereqPromotionANDs)								pXML->InitList(&m_piPrereqPromotionANDs, GC.getNumPromotionInfos(), 0);
	*/
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	if(pClassInfo->getNumMinionPromotions() > 0)
	{
		int* tempArray = new int[getNumMinionPromotions() + pClassInfo->getNumMinionPromotions()];
		for(int i = 0; i< getNumMinionPromotions(); ++i)
		{
			tempArray[i] = getMinionPromotion(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumMinionPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumMinionPromotions();++j)
			{
				if(pClassInfo->getMinionPromotion(i) == getMinionPromotion(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumMinionPromotions()] = pClassInfo->getMinionPromotion(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piMinionPromotions);
		int iGoalSize = getNumMinionPromotions() + iNewItems;
		m_piMinionPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piMinionPromotions[i] = tempArray[i];
			FAssertMsg(m_piMinionPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piMinionPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumMinionPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if (pClassInfo->getNumCapturePromotions() > 0)
	{
		int* tempArray = new int[getNumCapturePromotions() + pClassInfo->getNumCapturePromotions()];
		for (int i = 0; i < getNumCapturePromotions(); ++i)
		{
			tempArray[i] = getCapturePromotion(i);
		}
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumCapturePromotions(); ++i)
		{
			bool bLoad = true;
			for (int j = 0; j < getNumCapturePromotions(); ++j)
			{
				if (pClassInfo->getCapturePromotion(i) == getCapturePromotion(j))
				{
					bLoad = false;
					break;
				}
			}
			if (bLoad)
			{
				tempArray[iNewItems + getNumCapturePromotions()] = pClassInfo->getCapturePromotion(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piCapturePromotions);
		int iGoalSize = getNumCapturePromotions() + iNewItems;
		m_piCapturePromotions = new int[iGoalSize];
		for (int i = 0; i < iGoalSize; ++i)
		{
			m_piCapturePromotions[i] = tempArray[i];
			FAssertMsg(m_piCapturePromotions[i] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piCapturePromotions[i] > -1, "Out of Bounds Array Melding");
		}
		m_iNumCapturePromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumCommanderPromotions() > 0)
	{
		int* tempArray = new int[getNumCommanderPromotions() + pClassInfo->getNumCommanderPromotions()];
		for(int i = 0; i< getNumCommanderPromotions(); ++i)
		{
			tempArray[i] = getCommanderPromotion(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumCommanderPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumCommanderPromotions();++j)
			{
				if(pClassInfo->getCommanderPromotion(i) == getCommanderPromotion(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumCommanderPromotions()] = pClassInfo->getCommanderPromotion(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piCommanderPromotions);
		int iGoalSize = getNumCommanderPromotions() + iNewItems;
		m_piCommanderPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piCommanderPromotions[i] = tempArray[i];
			FAssertMsg(m_piCommanderPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piCommanderPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumCommanderPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumSlavePromotions() > 0)
	{
		int* tempArray = new int[getNumSlavePromotions() + pClassInfo->getNumSlavePromotions()];
		for(int i = 0; i< getNumSlavePromotions(); ++i)
		{
			tempArray[i] = getSlavePromotion(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumSlavePromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumSlavePromotions();++j)
			{
				if(pClassInfo->getSlavePromotion(i) == getSlavePromotion(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumSlavePromotions()] = pClassInfo->getSlavePromotion(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piSlavePromotions);
		int iGoalSize = getNumSlavePromotions() + iNewItems;
		m_piSlavePromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piSlavePromotions[i] = tempArray[i];
			FAssertMsg(m_piSlavePromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piSlavePromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumSlavePromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumMasterPromotions() > 0)
	{
		int* tempArray = new int[getNumMasterPromotions() + pClassInfo->getNumMasterPromotions()];
		for(int i = 0; i< getNumMasterPromotions(); ++i)
		{
			tempArray[i] = getMasterPromotion(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumMasterPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumMasterPromotions();++j)
			{
				if(pClassInfo->getMasterPromotion(i) == getMasterPromotion(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumMasterPromotions()] = pClassInfo->getMasterPromotion(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piMasterPromotions);
		int iGoalSize = getNumMasterPromotions() + iNewItems;
		m_piMasterPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piMasterPromotions[i] = tempArray[i];
			FAssertMsg(m_piMasterPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piMasterPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumMasterPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionExcludes() > 0)
	{
		int* tempArray = new int[getNumPromotionExcludes() + pClassInfo->getNumPromotionExcludes()];
		for(int i = 0; i< getNumPromotionExcludes(); ++i)
		{
			tempArray[i] = getPromotionExcludes(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionExcludes(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionExcludes();++j)
			{
				if(pClassInfo->getPromotionExcludes(i) == getPromotionExcludes(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionExcludes()] = pClassInfo->getPromotionExcludes(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionExcludes);
		int iGoalSize = getNumPromotionExcludes() + iNewItems;
		m_piPromotionExcludes = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionExcludes[i] = tempArray[i];
			FAssertMsg(m_piPromotionExcludes[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionExcludes[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionExcludes = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionReplacedBy() > 0)
	{
		int* tempArray = new int[getNumPromotionReplacedBy() + pClassInfo->getNumPromotionReplacedBy()];
		for(int i = 0; i< getNumPromotionReplacedBy(); ++i)
		{
			tempArray[i] = getPromotionReplacedBy(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionReplacedBy(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionReplacedBy();++j)
			{
				if(pClassInfo->getPromotionReplacedBy(i) == getPromotionReplacedBy(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionReplacedBy()] = pClassInfo->getPromotionReplacedBy(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
		int iGoalSize = getNumPromotionReplacedBy() + iNewItems;
		m_piPromotionReplacedBy = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionReplacedBy[i] = tempArray[i];
			FAssertMsg(m_piPromotionReplacedBy[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionReplacedBy[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionReplacedBy = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionOverwrites() > 0)
	{
		int* tempArray = new int[getNumPromotionOverwrites() + pClassInfo->getNumPromotionOverwrites()];
		for(int i = 0; i< getNumPromotionOverwrites(); ++i)
		{
			tempArray[i] = getPromotionOverwrites(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionOverwrites(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionOverwrites();++j)
			{
				if(pClassInfo->getPromotionOverwrites(i) == getPromotionOverwrites(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionOverwrites()] = pClassInfo->getPromotionOverwrites(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionOverwrites);
		int iGoalSize = getNumPromotionOverwrites() + iNewItems;
		m_piPromotionOverwrites = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionOverwrites[i] = tempArray[i];
			FAssertMsg(m_piPromotionOverwrites[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionOverwrites[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionOverwrites = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionDegradesTo() > 0)
	{
		int* tempArray = new int[getNumPromotionDegradesTo() + pClassInfo->getNumPromotionDegradesTo()];
		for(int i = 0; i< getNumPromotionDegradesTo(); ++i)
		{
			tempArray[i] = getPromotionDegradesTo(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionDegradesTo(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionDegradesTo();++j)
			{
				if(pClassInfo->getPromotionDegradesTo(i) == getPromotionDegradesTo(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionDegradesTo()] = pClassInfo->getPromotionDegradesTo(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionDegradesTo);
		int iGoalSize = getNumPromotionDegradesTo() + iNewItems;
		m_piPromotionDegradesTo = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionDegradesTo[i] = tempArray[i];
			FAssertMsg(m_piPromotionDegradesTo[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionDegradesTo[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionDegradesTo = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionAllows() > 0)
	{
		int* tempArray = new int[getNumPromotionAllows() + pClassInfo->getNumPromotionAllows()];
		for(int i = 0; i< getNumPromotionAllows(); ++i)
		{
			tempArray[i] = getPromotionAllows(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionAllows(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionAllows();++j)
			{
				if(pClassInfo->getPromotionAllows(i) == getPromotionAllows(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionAllows()] = pClassInfo->getPromotionAllows(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionAllows);
		int iGoalSize = getNumPromotionAllows() + iNewItems;
		m_piPromotionAllows = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionAllows[i] = tempArray[i];
			FAssertMsg(m_piPromotionAllows[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionAllows[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionAllows = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqPromotionsOnTile() > 0)
	{
		int* tempArray = new int[getNumPrereqPromotionsOnTile() + pClassInfo->getNumPrereqPromotionsOnTile()];
		for(int i = 0; i< getNumPrereqPromotionsOnTile(); ++i)
		{
			tempArray[i] = getPrereqPromotionOnTile(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqPromotionsOnTile(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqPromotionsOnTile();++j)
			{
				if(pClassInfo->getPrereqPromotionOnTile(i) == getPrereqPromotionOnTile(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqPromotionsOnTile()] = pClassInfo->getPrereqPromotionOnTile(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqPromotionsOnTile);
		int iGoalSize = getNumPrereqPromotionsOnTile() + iNewItems;
		m_piPrereqPromotionsOnTile = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqPromotionsOnTile[i] = tempArray[i];
			FAssertMsg(m_piPrereqPromotionsOnTile[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqPromotionsOnTile[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqPromotionsOnTile = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqPromotionsNOTOnTile() > 0)
	{
		int* tempArray = new int[getNumPrereqPromotionsNOTOnTile() + pClassInfo->getNumPrereqPromotionsNOTOnTile()];
		for(int i = 0; i< getNumPrereqPromotionsNOTOnTile(); ++i)
		{
			tempArray[i] = getPrereqPromotionNOTOnTile(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqPromotionsNOTOnTile(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqPromotionsNOTOnTile();++j)
			{
				if(pClassInfo->getPrereqPromotionNOTOnTile(i) == getPrereqPromotionNOTOnTile(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqPromotionsNOTOnTile()] = pClassInfo->getPrereqPromotionNOTOnTile(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqPromotionsNOTOnTile);
		int iGoalSize = getNumPrereqPromotionsNOTOnTile() + iNewItems;
		m_piPrereqPromotionsNOTOnTile = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqPromotionsNOTOnTile[i] = tempArray[i];
			FAssertMsg(m_piPrereqPromotionsNOTOnTile[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqPromotionsNOTOnTile[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqPromotionsNOTOnTile = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}

	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getUnitArtStyleTypeVectorSize(); i++ )
	{
																		m_aszExtraXMLforPass3.push_back(	pClassInfo->getUnitArtStyleTypeVectorElement(i));
	}
	for(int i = 0; i < pClassInfo->getNumPrereqUnits(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqUnits();++j)
		{
			if(pClassInfo->getPrereqUnitsVectorElement(i) == getPrereqUnitsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqUnitsforPass3.push_back(	pClassInfo->getPrereqUnitsVectorElement(i));
			m_iNumPrereqUnits++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqCivilizations(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqCivilizations();++j)
		{
			if(pClassInfo->getPrereqCivilizationsVectorElement(i) == getPrereqCivilizationsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqCivilizationsforPass3.push_back(	pClassInfo->getPrereqCivilizationsVectorElement(i));
			m_iNumPrereqCivilizations++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqCivics(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqCivics();++j)
		{
			if(pClassInfo->getPrereqCivicsVectorElement(i) == getPrereqCivicsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqCivicsforPass3.push_back(	pClassInfo->getPrereqCivicsVectorElement(i));
			m_iNumPrereqCivics++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqImprovements(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqImprovements();++j)
		{
			if(pClassInfo->getPrereqImprovementsVectorElement(i) == getPrereqImprovementsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqImprovementsforPass3.push_back(	pClassInfo->getPrereqImprovementsVectorElement(i));
			m_iNumPrereqImprovements++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqCorporations(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqCorporations();++j)
		{
			if(pClassInfo->getPrereqCorporationsVectorElement(i) == getPrereqCorporationsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqCorporationsforPass3.push_back(	pClassInfo->getPrereqCorporationsVectorElement(i));
			m_iNumPrereqCorporations++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqTraits(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqTraits();++j)
		{
			if(pClassInfo->getPrereqTraitsVectorElement(i) == getPrereqTraitsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqTraitsforPass3.push_back(	pClassInfo->getPrereqTraitsVectorElement(i));
			m_iNumPrereqTraits++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqBuildingANDs(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqBuildingANDs();++j)
		{
			if(pClassInfo->getPrereqBuildingANDsVectorElement(i) == getPrereqBuildingANDsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqBuildingANDsforPass3.push_back(	pClassInfo->getPrereqBuildingANDsVectorElement(i));
			m_iNumPrereqBuildingANDs++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqBuildingORs(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqBuildingORs();++j)
		{
			if(pClassInfo->getPrereqBuildingORsVectorElement(i) == getPrereqBuildingORsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqBuildingORsforPass3.push_back(	pClassInfo->getPrereqBuildingORsVectorElement(i));
			m_iNumPrereqBuildingORs++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqEventANDs(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqEventANDs();++j)
		{
			if(pClassInfo->getPrereqEventANDsVectorElement(i) == getPrereqEventANDsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqEventANDsforPass3.push_back(	pClassInfo->getPrereqEventANDsVectorElement(i));
			m_iNumPrereqEventANDs++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqEventORs(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqEventORs();++j)
		{
			if(pClassInfo->getPrereqEventORsVectorElement(i) == getPrereqEventORsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqEventORsforPass3.push_back(	pClassInfo->getPrereqEventORsVectorElement(i));
			m_iNumPrereqEventORs++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqUnitTypesOnTile(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqUnitTypesOnTile();++j)
		{
			if(pClassInfo->getPrereqUnitTypesOnTileVectorElement(i) == getPrereqUnitTypesOnTileVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqUnitTypesOnTileforPass3.push_back(	pClassInfo->getPrereqUnitTypesOnTileVectorElement(i));
			m_iNumPrereqUnitTypesOnTile++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqUnitTypesNOTOnTile(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqUnitTypesNOTOnTile();++j)
		{
			if(pClassInfo->getPrereqUnitTypesNOTOnTileVectorElement(i) == getPrereqUnitTypesNOTOnTileVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqUnitTypesNOTOnTileforPass3.push_back(	pClassInfo->getPrereqUnitTypesNOTOnTileVectorElement(i));
			m_iNumPrereqUnitTypesNOTOnTile++;
		}
	}
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	for(int i = 0; i < pClassInfo->getNumPromotionBuilds(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPromotionBuilds();++j)
		{
			if(pClassInfo->getPromotionBuildsVectorElement(i) == getPromotionBuildsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPromotionBuildsforPass3.push_back(	pClassInfo->getPromotionBuildsVectorElement(i));
			m_iNumPromotionBuilds++;
		}
	}

	for(int i = 0; i < pClassInfo->getNumPromotionCannotBuilds(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPromotionCannotBuilds();++j)
		{
			if(pClassInfo->getPromotionCannotBuildsVectorElement(i) == getPromotionCannotBuildsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPromotionCannotBuildsforPass3.push_back(	pClassInfo->getPromotionCannotBuildsVectorElement(i));
			m_iNumPromotionCannotBuilds++;
		}
	}
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	for(int i = 0; i < pClassInfo->getNumAffinities(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumAffinities();++j)
		{
			if(pClassInfo->getAffinitiesVectorElement(i) == getAffinitiesVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszAffinitiesforPass3.push_back(	pClassInfo->getAffinitiesVectorElement(i));
			m_iNumAffinities++;
		}
	}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	//PromotionClass
	if (getPromotionClass() == NO_PROMOTIONCLASS) m_iPromotionClass = pClassInfo->getPromotionClass();
	if (getSpecialCargo() == NO_SPECIALUNIT) m_iSpecialCargo = pClassInfo->getSpecialCargo();
	if (getDomainCargo() == NO_DOMAIN) m_iDomainCargo = pClassInfo->getDomainCargo();

}

void CvPromotionInfo::copyNonDefaultsReadPass2(CvPromotionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getPrereqPromotion()		!= NO_PROMOTION)		m_iPrereqPromotion		= pClassInfo->getPrereqPromotion();
	if (bOver || pClassInfo->getPrereqOrPromotion1()	!= NO_PROMOTION)		m_iPrereqOrPromotion1	= pClassInfo->getPrereqOrPromotion1();
	if (bOver || pClassInfo->getPrereqOrPromotion2()	!= NO_PROMOTION)		m_iPrereqOrPromotion2	= pClassInfo->getPrereqOrPromotion2();
	if (bOver || pClassInfo->getPromotionCombatApply()	!= NO_PROMOTION)		m_iPromotionCombatApply = pClassInfo->getPromotionCombatApply();
/*************************************************************************************************/
/**	Cutting								30/01/12										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/**			Use PromotionExcludes instead, both faster and more flexible						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (bOver || pClassInfo->getPromotionImmune1()		!= NO_PROMOTION)		m_iPromotionImmune1		= pClassInfo->getPromotionImmune1();
	if (bOver || pClassInfo->getPromotionImmune2()		!= NO_PROMOTION)		m_iPromotionImmune2		= pClassInfo->getPromotionImmune2();
	if (bOver || pClassInfo->getPromotionImmune3()		!= NO_PROMOTION)		m_iPromotionImmune3		= pClassInfo->getPromotionImmune3();
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	if (bOver || pClassInfo->getPromotionRandomApply()	!= NO_PROMOTION)		m_iPromotionRandomApply	= pClassInfo->getPromotionRandomApply();
	if (bOver || pClassInfo->getPromotionSummonPerk()	!= NO_PROMOTION)		m_iPromotionSummonPerk	= pClassInfo->getPromotionSummonPerk();
	if (bOver || pClassInfo->getPromotionPrereqOr3()	!= NO_PROMOTION)		m_iPromotionPrereqOr3	= pClassInfo->getPromotionPrereqOr3();
	if (bOver || pClassInfo->getPromotionPrereqOr4()	!= NO_PROMOTION)		m_iPromotionPrereqOr4	= pClassInfo->getPromotionPrereqOr4();
	if (bOver || pClassInfo->getPromotionPrereqAnd()	!= NO_PROMOTION)		m_iPromotionPrereqAnd	= pClassInfo->getPromotionPrereqAnd();
	//PrereqUnitReligion by BI 07/24/11
	if (bOver || pClassInfo->getUnitReligionPrereq()	!= NO_RELIGION)		m_iUnitReligionPrereq	= pClassInfo->getUnitReligionPrereq();

	if (bOver || pClassInfo->getPromotionNextLevel()	!= NO_PROMOTION)		m_iPromotionNextLevel	= pClassInfo->getPromotionNextLevel();
	if (bOver || pClassInfo->getPromotionCombatType()	!= NO_PROMOTION)		m_iPromotionCombatType	= pClassInfo->getPromotionCombatType();

	//ReligionCombatBonus by BI 07/25/11
	if (bOver || pClassInfo->getReligionCombatType()	!= NO_RELIGION)		m_iReligionCombatType	= pClassInfo->getReligionCombatType();
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	if (pClassInfo->getNumPrereqPromotionORs() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPrereqPromotionORs() : getNumPrereqPromotionORs() + pClassInfo->getNumPrereqPromotionORs();
		int** tempArray = new int* [iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumPrereqPromotionORs(); ++i)
		{
			tempArray[i] = new int[1];
			tempArray[i][0] = pClassInfo->getPrereqPromotionORs(i);
			tempArray[i][1] = pClassInfo->getPrereqPromotionORs(i, true);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumPrereqPromotionORs(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumPrereqPromotionORs(); ++i)
				{
					if (getPrereqPromotionORs(i) == pClassInfo->getPrereqPromotionORs(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = new int[1];
					tempArray[iNewItems][0] = getPrereqPromotionORs(i);
					tempArray[iNewItems][1] = getPrereqPromotionORs(i, true);
					iNewItems++;
				}
			}

		}
		for (int i = 0; i < getNumPrereqPromotionORs(); i++)
		{
			SAFE_DELETE_ARRAY(m_piiPrereqPromotionORs[i]);
		}
		SAFE_DELETE_ARRAY(m_piiPrereqPromotionORs);
		iGoalSize = iNewItems;
		m_piiPrereqPromotionORs = new int* [iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piiPrereqPromotionORs[i] = new int[1];
			m_piiPrereqPromotionORs[i][0] = tempArray[i][0];
			m_piiPrereqPromotionORs[i][1] = tempArray[i][1];
			FAssertMsg(m_piiPrereqPromotionORs[i][0] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piiPrereqPromotionORs[i][0] > -1, "Out of Bounds Array Melding");
		}
		m_iNumPrereqPromotionORs = iGoalSize;
		for (int i = 0; i < iGoalSize; i++)
		{
			SAFE_DELETE_ARRAY(tempArray[i]);
		}
		SAFE_DELETE_ARRAY(tempArray);
	}

	if(pClassInfo->getNumPrereqPromotionANDs() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPrereqPromotionANDs() : getNumPrereqPromotionANDs() + pClassInfo->getNumPrereqPromotionANDs();
		int** tempArray = new int*[iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumPrereqPromotionANDs(); ++i)
		{
			tempArray[i] = new int[1];
			tempArray[i][0] = pClassInfo->getPrereqPromotionANDs(i);
			tempArray[i][1] = pClassInfo->getPrereqPromotionANDs(i, true);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumPrereqPromotionANDs(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumPrereqPromotionANDs(); ++i)
				{
					if (getPrereqPromotionANDs(i) == pClassInfo->getPrereqPromotionANDs(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = new int[1];
					tempArray[iNewItems][0] = getPrereqPromotionANDs(i);
					tempArray[iNewItems][1] = getPrereqPromotionANDs(i, true);
					iNewItems++;
				}
			}

		}
		for (int i = 0; i < getNumPrereqPromotionANDs(); i++)
		{
			SAFE_DELETE_ARRAY(m_piiPrereqPromotionANDs[i]);
		}
		SAFE_DELETE_ARRAY(m_piiPrereqPromotionANDs);
		iGoalSize = iNewItems;
		m_piiPrereqPromotionANDs = new int*[iGoalSize];
		for(int i = 0; i < iGoalSize; i++)
		{
			m_piiPrereqPromotionANDs[i] = new int[1];
			m_piiPrereqPromotionANDs[i][0] = tempArray[i][0];
			m_piiPrereqPromotionANDs[i][1] = tempArray[i][1];
			FAssertMsg(m_piiPrereqPromotionANDs[i][0] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piiPrereqPromotionANDs[i][0] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqPromotionANDs = iGoalSize;
		for (int i = 0; i < iGoalSize; i++)
		{
			SAFE_DELETE_ARRAY(tempArray[i]);
		}
		SAFE_DELETE_ARRAY(tempArray);
	}
	if (pClassInfo->getNumPromotionCombatMods() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionCombatMods() : getNumPromotionCombatMods() + pClassInfo->getNumPromotionCombatMods();
		int** tempArray = new int* [iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumPromotionCombatMods(); ++i)
		{
			tempArray[i] = new int[1];
			tempArray[i][0] = pClassInfo->getPromotionCombatMods(i);
			tempArray[i][1] = pClassInfo->getPromotionCombatMods(i, true);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumPromotionCombatMods(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumPromotionCombatMods(); ++i)
				{
					if (getPromotionCombatMods(i) == pClassInfo->getPromotionCombatMods(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = new int[1];
					tempArray[iNewItems][0] = getPromotionCombatMods(i);
					tempArray[iNewItems][1] = getPromotionCombatMods(i, true);
					iNewItems++;
				}
			}

		}
		for (int i = 0; i < getNumPromotionCombatMods(); i++)
		{
			SAFE_DELETE_ARRAY(m_piiPromotionCombatMods[i]);
		}
		SAFE_DELETE_ARRAY(m_piiPromotionCombatMods);
		iGoalSize = iNewItems;
		m_piiPromotionCombatMods = new int* [iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piiPromotionCombatMods[i] = new int[1];
			m_piiPromotionCombatMods[i][0] = tempArray[i][0];
			m_piiPromotionCombatMods[i][1] = tempArray[i][1];
			FAssertMsg(m_piiPromotionCombatMods[i][0] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piiPromotionCombatMods[i][0] > -1, "Out of Bounds Array Melding");
		}
		m_iNumPromotionCombatMods = iGoalSize;
		for (int i = 0; i < iGoalSize; i++)
		{
			SAFE_DELETE_ARRAY(tempArray[i]);
		}
		SAFE_DELETE_ARRAY(tempArray);
	}
	/* original code
	if(!m_piPrereqPromotionORs)											pXML->InitList(&m_piPrereqPromotionORs, GC.getNumPromotionInfos(), 0);
	if(!m_piPrereqPromotionANDs)										pXML->InitList(&m_piPrereqPromotionANDs, GC.getNumPromotionInfos(), 0);
	for (int i = 0; i < GC.getNumPromotionInfos(); ++i)
	{
		if(bOver || pClassInfo->getPrereqPromotionORs(i)		!= 0)		m_piPrereqPromotionORs[i]	= pClassInfo->getPrereqPromotionORs(i);
		if(bOver || pClassInfo->getPrereqPromotionANDs(i)		!= 0)		m_piPrereqPromotionANDs[i]	= pClassInfo->getPrereqPromotionANDs(i);
	}
	*/
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	if (pClassInfo->getNumMinionPromotions() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumMinionPromotions() : getNumMinionPromotions() + pClassInfo->getNumMinionPromotions();
		int* tempArray = new int [iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumMinionPromotions(); ++i)
		{
			tempArray[i] =  pClassInfo->getMinionPromotion(i);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumMinionPromotions(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumMinionPromotions(); ++i)
				{
					if (getMinionPromotion(i) == pClassInfo->getMinionPromotion(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] =  getMinionPromotion(i);
					iNewItems++;
				}
			}

		}
	
		SAFE_DELETE_ARRAY(m_piMinionPromotions);
		iGoalSize = iNewItems;
		m_piMinionPromotions = new int [iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piMinionPromotions[i] = tempArray[i];
			FAssertMsg(m_piMinionPromotions[i] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piMinionPromotions[i] > -1, "Out of Bounds Array Melding");
		}
		m_iNumMinionPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if (pClassInfo->getNumCapturePromotions() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumCapturePromotions() : getNumCapturePromotions() + pClassInfo->getNumCapturePromotions();
		int* tempArray = new int[iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumCapturePromotions(); ++i)
		{
			tempArray[i] = pClassInfo->getCapturePromotion(i);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumCapturePromotions(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumCapturePromotions(); ++i)
				{
					if (getCapturePromotion(i) == pClassInfo->getCapturePromotion(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = getCapturePromotion(i);
					iNewItems++;
				}
			}

		}

		SAFE_DELETE_ARRAY(m_piCapturePromotions);
		iGoalSize = iNewItems;
		m_piCapturePromotions = new int[iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piCapturePromotions[i] = tempArray[i];
			FAssertMsg(m_piCapturePromotions[i] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piCapturePromotions[i] > -1, "Out of Bounds Array Melding");
		}
		m_iNumCapturePromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if (pClassInfo->getNumCommanderPromotions() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumCommanderPromotions() : getNumCommanderPromotions() + pClassInfo->getNumCommanderPromotions();
		int* tempArray = new int[iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumCommanderPromotions(); ++i)
		{
			tempArray[i] = pClassInfo->getCommanderPromotion(i);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumCommanderPromotions(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumCommanderPromotions(); ++i)
				{
					if (getCommanderPromotion(i) == pClassInfo->getCommanderPromotion(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = getCommanderPromotion(i);
					iNewItems++;
				}
			}

		}

		SAFE_DELETE_ARRAY(m_piCommanderPromotions);
		iGoalSize = iNewItems;
		m_piCommanderPromotions = new int[iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piCommanderPromotions[i] = tempArray[i];
			FAssertMsg(m_piCommanderPromotions[i] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piCommanderPromotions[i] > -1, "Out of Bounds Array Melding");
		}
		m_iNumCommanderPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if (pClassInfo->getNumSlavePromotions() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumSlavePromotions() : getNumSlavePromotions() + pClassInfo->getNumSlavePromotions();
		int* tempArray = new int[iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumSlavePromotions(); ++i)
		{
			tempArray[i] = pClassInfo->getSlavePromotion(i);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumSlavePromotions(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumSlavePromotions(); ++i)
				{
					if (getSlavePromotion(i) == pClassInfo->getSlavePromotion(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = getSlavePromotion(i);
					iNewItems++;
				}
			}

		}

		SAFE_DELETE_ARRAY(m_piSlavePromotions);
		iGoalSize = iNewItems;
		m_piSlavePromotions = new int[iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piSlavePromotions[i] = tempArray[i];
			FAssertMsg(m_piSlavePromotions[i] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piSlavePromotions[i] > -1, "Out of Bounds Array Melding");
		}
		m_iNumSlavePromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if (pClassInfo->getNumMasterPromotions() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumMasterPromotions() : getNumMasterPromotions() + pClassInfo->getNumMasterPromotions();
		int* tempArray = new int[iGoalSize];
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumMasterPromotions(); ++i)
		{
			tempArray[i] = pClassInfo->getMasterPromotion(i);
			iNewItems++;
		}
		if (!bOver)
		{
			for (int i = 0; i < getNumMasterPromotions(); i++)
			{
				bool bLoad = true;
				for (int j = 0; i < pClassInfo->getNumMasterPromotions(); ++i)
				{
					if (getMasterPromotion(i) == pClassInfo->getMasterPromotion(j))
					{
						bLoad = false;
					}
				}
				if (bLoad)
				{
					tempArray[iNewItems] = getMasterPromotion(i);
					iNewItems++;
				}
			}

		}

		SAFE_DELETE_ARRAY(m_piMasterPromotions);
		iGoalSize = iNewItems;
		m_piMasterPromotions = new int[iGoalSize];
		for (int i = 0; i < iGoalSize; i++)
		{
			m_piMasterPromotions[i] = tempArray[i];
			FAssertMsg(m_piMasterPromotions[i] < GC.getNumPromotionInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piMasterPromotions[i] > -1, "Out of Bounds Array Melding");
		}
		m_iNumMasterPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionExcludes() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionExcludes() : getNumPromotionExcludes() + pClassInfo->getNumPromotionExcludes();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionExcludes(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionExcludes(i);
		}
		if (!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionExcludes();
			for(int i = 0; i< getNumPromotionExcludes(); ++i)
			{
				tempArray[i+iOffset] = getPromotionExcludes(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionExcludes);
		m_piPromotionExcludes = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionExcludes[i] = tempArray[i];
			FAssertMsg(m_piPromotionExcludes[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionExcludes[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionExcludes = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionReplacedBy() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionReplacedBy() : getNumPromotionReplacedBy() + pClassInfo->getNumPromotionReplacedBy();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionReplacedBy(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionReplacedBy(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionReplacedBy();
			for(int i = 0; i< getNumPromotionReplacedBy(); ++i)
			{
				tempArray[i+iOffset] = getPromotionReplacedBy(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
		m_piPromotionReplacedBy = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionReplacedBy[i] = tempArray[i];
			FAssertMsg(m_piPromotionReplacedBy[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionReplacedBy[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionReplacedBy = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionOverwrites() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionOverwrites() : getNumPromotionOverwrites() + pClassInfo->getNumPromotionOverwrites();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionOverwrites(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionOverwrites(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionOverwrites();
			for(int i = 0; i< getNumPromotionOverwrites(); ++i)
			{
				tempArray[i+iOffset] = getPromotionOverwrites(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionOverwrites);
		m_piPromotionOverwrites = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionOverwrites[i] = tempArray[i];
			FAssertMsg(m_piPromotionOverwrites[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionOverwrites[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionOverwrites = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionDegradesTo() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionDegradesTo() : getNumPromotionDegradesTo() + pClassInfo->getNumPromotionDegradesTo();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionDegradesTo(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionDegradesTo(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionDegradesTo();
			for(int i = 0; i< getNumPromotionDegradesTo(); ++i)
			{
				tempArray[i+iOffset] = getPromotionDegradesTo(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionDegradesTo);
		m_piPromotionDegradesTo = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionDegradesTo[i] = tempArray[i];
			FAssertMsg(m_piPromotionDegradesTo[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionDegradesTo[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionDegradesTo = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionAllows() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionAllows() : getNumPromotionAllows() + pClassInfo->getNumPromotionAllows();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionAllows(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionAllows(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionAllows();
			for(int i = 0; i< getNumPromotionAllows(); ++i)
			{
				tempArray[i+iOffset] = getPromotionAllows(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionAllows);
		m_piPromotionAllows = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionAllows[i] = tempArray[i];
			FAssertMsg(m_piPromotionAllows[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionAllows[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionAllows = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqPromotionsOnTile() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPrereqPromotionsOnTile() : getNumPrereqPromotionsOnTile() + pClassInfo->getNumPrereqPromotionsOnTile();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPrereqPromotionsOnTile(); ++i)
		{
			tempArray[i] = pClassInfo->getPrereqPromotionOnTile(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumPrereqPromotionsOnTile();
			for(int i = 0; i< getNumPrereqPromotionsOnTile(); ++i)
			{
				tempArray[i+iOffset] = getPrereqPromotionOnTile(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqPromotionsOnTile);
		m_piPrereqPromotionsOnTile = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqPromotionsOnTile[i] = tempArray[i];
			FAssertMsg(m_piPrereqPromotionsOnTile[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqPromotionsOnTile[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqPromotionsOnTile = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqPromotionsNOTOnTile() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPrereqPromotionsNOTOnTile() : getNumPrereqPromotionsNOTOnTile() + pClassInfo->getNumPrereqPromotionsNOTOnTile();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPrereqPromotionsNOTOnTile(); ++i)
		{
			tempArray[i] = pClassInfo->getPrereqPromotionNOTOnTile(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumPrereqPromotionsNOTOnTile();
			for(int i = 0; i< getNumPrereqPromotionsNOTOnTile(); ++i)
			{
				tempArray[i+iOffset] = getPrereqPromotionNOTOnTile(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqPromotionsNOTOnTile);
		m_piPrereqPromotionsNOTOnTile = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqPromotionsNOTOnTile[i] = tempArray[i];
			FAssertMsg(m_piPrereqPromotionsNOTOnTile[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqPromotionsNOTOnTile[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqPromotionsNOTOnTile = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//FfH Spell System: Added by Kael 07/23/2007
//======================================================================================================
//					CvSpellInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpellInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpellInfo::CvSpellInfo() :
/*************************************************************************************************/
/**	City Actions	(SpellInfos)			03/28/10								Grey Fox	**/
/*************************************************************************************************/
m_bCityAction(false),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
m_iPromotionPrereq1(NO_PROMOTION),
m_iPromotionPrereq2(NO_PROMOTION),
m_iUnitPrereq(NO_UNIT),
m_iUnitCombatPrereq(NO_UNITCOMBAT),
m_iUnitClassPrereq(NO_UNITCLASS),
m_iUnitInStackPrereq(NO_UNIT),
m_iUnitInStackTargetPrereq(NO_UNIT),
m_iBuildingPrereq(NO_BUILDING),
m_iBuildingTargetPrereq(NO_BUILDING),
m_iBuildingClassOwnedPrereq(NO_BUILDINGCLASS),
m_iCivilizationPrereq(NO_CIVILIZATION),
m_iCorporationPrereq(NO_CORPORATION),
m_iCorporationTargetPrereq(NO_CORPORATION),
m_iFeatureOrPrereq1(NO_FEATURE),
m_iFeatureOrPrereq2(NO_FEATURE),
m_iFeatureOrTargetPrereq1(NO_FEATURE),
m_iFeatureOrTargetPrereq2(NO_FEATURE),
m_iImprovementPrereq(NO_IMPROVEMENT),
m_iImprovementTargetPrereq(NO_IMPROVEMENT),
m_iPromotionInStackPrereq(NO_PROMOTION),
m_iPromotionInStackTargetPrereq(NO_PROMOTION),
m_iReligionPrereq(NO_RELIGION),
m_iStateReligionPrereq(NO_RELIGION),
m_iTechPrereq(NO_TECH),
m_iNumPrereqTraits(0),
m_piPrereqTraits(NULL),
m_iNumPromotionsPrereq(0),
m_piPromotionsPrereq(NULL),
m_iNumAddPromotions(0),
m_piAddPromotions(NULL),
m_iNumRemovePromotions(0),
m_piRemovePromotions(NULL),

/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_bPrereqAvailableCommander(false),
m_bPrereqNotAttacked(false),
m_bSetHasAttacked(false),
m_bRemoveHasAttacked(false),
m_bPrereqIsNOTMinion(false),
m_bPrereqIsMinion(false),
m_iPrereqBroadAlignment(0),
m_iAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iPrereqBroadEthicalAlignment(0),
m_iEthicalAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_bSummonMaster(false),
m_iPromotionDuration(-1),
m_szQuote(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_bAllowAI(false),
m_bAdjacentToWaterOnly(false),
m_bTargetAdjacentToWaterOnly(false),
m_bCasterMustBeAlive(false),
m_bCasterNoDuration(false),
m_bCausesWar(false),
m_bGlobal(false),
m_bInBordersOnly(false),
m_bInCityOnly(false),
m_bTargetInBordersOnly(false),
m_bTargetInCityOnly(false),
m_bPrereqSlaveTrade(false),
m_bResistable(false),
m_iAIWeight(0),
m_iCasterMinLevel(0),
m_bDisplayWhenDisabled(false),
m_bHasCasted(false),
m_bIgnoreHasCasted(false),
m_iDamage(0),
m_iDamageLimit(0),
m_iDamageType(NO_DAMAGE),
m_iRange(0),
m_iResistModify(0),
m_iAddPromotionType1(NO_PROMOTION),
m_iAddPromotionType2(NO_PROMOTION),
m_iAddPromotionType3(NO_PROMOTION),
m_iRemovePromotionType1(NO_PROMOTION),
m_iRemovePromotionType2(NO_PROMOTION),
m_iRemovePromotionType3(NO_PROMOTION),
m_bBuffCasterOnly(false),
m_iConvertUnitType(NO_UNIT),
m_iCreateBuildingType(NO_BUILDING),
m_iCreateFeatureType(NO_FEATURE),
m_iCreatePlotEffectType(NO_PLOT_EFFECT),
m_iRemovePlotEffectType(NO_PLOT_EFFECT),
m_iCreateImprovementType(NO_IMPROVEMENT),
m_iSpreadReligion(NO_RELIGION),
m_iCreateUnitType(NO_UNIT),
m_iCreateUnitNum(0),
m_bCopyCastersPromotions(false),
m_bPermanentUnitCreate(false),
m_iCreateUnitPromotion(NO_PROMOTION),
m_bImmuneTeam(false),
m_bImmuneNeutral(false),
m_bImmuneEnemy(false),
m_bImmuneFlying(false),
m_bImmuneNotAlive(false),
m_bAbility(false),
m_bDispel(false),
m_bPush(false),
m_bRemoveHasCasted(false),
m_bSacrificeCaster(false),
m_iChangePopulation(0),
m_iCost(0),
m_iCrimePrereq(0),
m_iDelay(0),
m_iImmobileTurns(0),
m_iMiscastChance(0),
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
m_bAutoCast(false),
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
//TargetedSpell 0924 blackimp
m_bTargeted(false),

m_iEffect(NO_EFFECT),
m_szSound(NULL),
m_iCommandType(NO_COMMAND),
//Magic Rework
m_iMagicalPowerPrereq(0),
m_pbSpellClass(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpellInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpellInfo::~CvSpellInfo()
{
	SAFE_DELETE_ARRAY(m_piPrereqTraits);
	SAFE_DELETE_ARRAY(m_piPromotionsPrereq);
	SAFE_DELETE_ARRAY(m_piAddPromotions);
	SAFE_DELETE_ARRAY(m_piRemovePromotions);


}

/*************************************************************************************************/
/**	City Actions	(SpellInfos)			03/28/10								Grey Fox	**/
/*************************************************************************************************/
bool CvSpellInfo::isCityAction() const
{
	return m_bCityAction;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

int CvSpellInfo::getPromotionPrereq1() const
{
	return m_iPromotionPrereq1;
}

int CvSpellInfo::getPromotionPrereq2() const
{
	return m_iPromotionPrereq2;
}

int CvSpellInfo::getUnitPrereq() const
{
	return m_iUnitPrereq;
}

int CvSpellInfo::getUnitCombatPrereq() const
{
	return m_iUnitCombatPrereq;
}

int CvSpellInfo::getUnitClassPrereq() const
{
	return m_iUnitClassPrereq;
}

int CvSpellInfo::getUnitInStackPrereq() const
{
	return m_iUnitInStackPrereq;
}

int CvSpellInfo::getUnitInStackTargetPrereq() const
{
	return m_iUnitInStackTargetPrereq;
}

int CvSpellInfo::getBuildingPrereq() const
{
	return m_iBuildingPrereq;
}

int CvSpellInfo::getBuildingTargetPrereq() const
{
	return m_iBuildingTargetPrereq;
}

int CvSpellInfo::getBuildingClassOwnedPrereq() const
{
	return m_iBuildingClassOwnedPrereq;
}

int CvSpellInfo::getCivilizationPrereq() const
{
	return m_iCivilizationPrereq;
}

int CvSpellInfo::getCorporationPrereq() const
{
	return m_iCorporationPrereq;
}
int CvSpellInfo::getCorporationTargetPrereq() const
{
	return m_iCorporationTargetPrereq;
}

int CvSpellInfo::getFeatureOrPrereq1() const
{
	return m_iFeatureOrPrereq1;
}

int CvSpellInfo::getFeatureOrPrereq2() const
{
	return m_iFeatureOrPrereq2;
}

int CvSpellInfo::getFeatureOrTargetPrereq1() const
{
	return m_iFeatureOrTargetPrereq1;
}

int CvSpellInfo::getFeatureOrTargetPrereq2() const
{
	return m_iFeatureOrTargetPrereq2;
}

int CvSpellInfo::getImprovementPrereq() const
{
	return m_iImprovementPrereq;
}

int CvSpellInfo::getImprovementTargetPrereq() const
{
	return m_iImprovementTargetPrereq;
}

int CvSpellInfo::getPromotionInStackPrereq() const
{
	return m_iPromotionInStackPrereq;
}

int CvSpellInfo::getPromotionInStackTargetPrereq() const
{
	return m_iPromotionInStackTargetPrereq;
}

int CvSpellInfo::getReligionPrereq() const
{
	return m_iReligionPrereq;
}

int CvSpellInfo::getStateReligionPrereq() const
{
	return m_iStateReligionPrereq;
}

int CvSpellInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}
int CvSpellInfo::getPrereqTrait(int iI) const { return (getNumPrereqTraits() > iI) ? m_piPrereqTraits[iI] : -1; }
int CvSpellInfo::getNumPrereqTraits() const { return m_iNumPrereqTraits; }
CvString CvSpellInfo::getPrereqTraitsVectorElement(int i) { return m_aszPrereqTraitsforPass3[i]; }
int CvSpellInfo::getPromotionPrereq(int iI) const { return (getNumPromotionsPrereq() > iI) ? m_piPromotionsPrereq[iI] : -1; }
int CvSpellInfo::getNumPromotionsPrereq() const { return m_iNumPromotionsPrereq; }
int CvSpellInfo::getAddPromotion(int iI) const { return (getNumAddPromotions() > iI) ? m_piAddPromotions[iI] : -1; }
int CvSpellInfo::getNumAddPromotions() const { return m_iNumAddPromotions; }
CvString CvSpellInfo::getAddPromotionsVectorElement(int i) { return m_aszAddPromotionsforPass3[i]; }
int CvSpellInfo::getRemovePromotion(int iI) const { return (getNumRemovePromotions() > iI) ? m_piRemovePromotions[iI] : -1; }
int CvSpellInfo::getNumRemovePromotions() const { return m_iNumRemovePromotions; }
CvString CvSpellInfo::getRemovePromotionsVectorElement(int i) { return m_aszRemovePromotionsforPass3[i]; }


/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
bool CvSpellInfo::isPrereqNotAttacked() const			{return m_bPrereqNotAttacked;}
bool CvSpellInfo::isSetHasAttacked() const				{return m_bSetHasAttacked;}
bool CvSpellInfo::isRemoveHasAttacked() const			{return m_bRemoveHasAttacked;}
const char* CvSpellInfo::getPythonHelp() const			{return m_szPyHelp;}
bool CvSpellInfo::isPrereqAvailableCommander() const	{return m_bPrereqAvailableCommander;}
bool CvSpellInfo::isPrereqIsNOTMinion() const			{return m_bPrereqIsNOTMinion;}
bool CvSpellInfo::isPrereqIsMinion() const				{return m_bPrereqIsMinion;}
int CvSpellInfo::getPrereqBroadAlignment() const		{return m_iPrereqBroadAlignment;}
int CvSpellInfo::getAlignmentModifier() const			{return m_iAlignmentModifier;}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvSpellInfo::getPrereqBroadEthicalAlignment() const	{return m_iPrereqBroadEthicalAlignment;}
int CvSpellInfo::getEthicalAlignmentModifier() const	{return m_iEthicalAlignmentModifier;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
bool CvSpellInfo::isSummonMaster() const				{return m_bSummonMaster;}
int CvSpellInfo::getPromotionDuration() const			{return m_iPromotionDuration;}
const TCHAR *CvSpellInfo::getQuote() const				{return m_szQuote;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
int CvSpellInfo::getRange() const
{
	return m_iRange;
}

int CvSpellInfo::getEffect() const
{
	return m_iEffect;
}

const TCHAR *CvSpellInfo::getSound() const
{
	return m_szSound;
}

bool CvSpellInfo::isAllowAI() const
{
	return m_bAllowAI;
}

bool CvSpellInfo::isAdjacentToWaterOnly() const
{
	return m_bAdjacentToWaterOnly;
}
bool CvSpellInfo::isTargetAdjacentToWaterOnly() const
{
	return m_bTargetAdjacentToWaterOnly;
}

bool CvSpellInfo::isCasterMustBeAlive() const
{
	return m_bCasterMustBeAlive;
}

bool CvSpellInfo::isCasterNoDuration() const
{
	return m_bCasterNoDuration;
}

bool CvSpellInfo::isCausesWar() const
{
	return m_bCausesWar;
}

bool CvSpellInfo::isGlobal() const
{
	return m_bGlobal;
}

bool CvSpellInfo::isInBordersOnly() const
{
	return m_bInBordersOnly;
}

bool CvSpellInfo::isInCityOnly() const
{
	return m_bInCityOnly;
}

bool CvSpellInfo::isTargetInBordersOnly() const
{
	return m_bTargetInBordersOnly;
}

bool CvSpellInfo::isTargetInCityOnly() const
{
	return m_bTargetInCityOnly;
}

bool CvSpellInfo::isPrereqSlaveTrade() const
{
	return m_bPrereqSlaveTrade;
}

bool CvSpellInfo::isBuffCasterOnly() const
{
	return m_bBuffCasterOnly;
}

bool CvSpellInfo::isCopyCastersPromotions() const
{
	return m_bCopyCastersPromotions;
}

bool CvSpellInfo::isAbility() const
{
	return m_bAbility;
}

bool CvSpellInfo::isDispel() const
{
	return m_bDispel;
}

bool CvSpellInfo::isDisplayWhenDisabled() const
{
	return m_bDisplayWhenDisabled;
}

bool CvSpellInfo::isHasCasted() const
{
	return m_bHasCasted;
}

bool CvSpellInfo::isIgnoreHasCasted() const
{
	return m_bIgnoreHasCasted;
}

bool CvSpellInfo::isImmuneTeam() const
{
	return m_bImmuneTeam;
}

bool CvSpellInfo::isImmuneNeutral() const
{
	return m_bImmuneNeutral;
}

bool CvSpellInfo::isImmuneEnemy() const
{
	return m_bImmuneEnemy;
}

bool CvSpellInfo::isImmuneFlying() const
{
	return m_bImmuneFlying;
}

bool CvSpellInfo::isImmuneNotAlive() const
{
	return m_bImmuneNotAlive;
}

bool CvSpellInfo::isPermanentUnitCreate() const
{
	return m_bPermanentUnitCreate;
}

bool CvSpellInfo::isPush() const
{
	return m_bPush;
}

bool CvSpellInfo::isRemoveHasCasted() const
{
	return m_bRemoveHasCasted;
}

bool CvSpellInfo::isResistable() const
{
	return m_bResistable;
}

bool CvSpellInfo::isSacrificeCaster() const
{
	return m_bSacrificeCaster;
}
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
bool CvSpellInfo::isAutoCast() const
{
	return m_bAutoCast;
}
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
//TargetedSpell 0924 blackimp
bool CvSpellInfo::isTargeted() const
{
	return m_bTargeted;
}

int CvSpellInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvSpellInfo::getCasterMinLevel() const
{
	return m_iCasterMinLevel;
}

int CvSpellInfo::getChangePopulation() const
{
	return m_iChangePopulation;
}

int CvSpellInfo::getCost() const
{
	return m_iCost;
}

int CvSpellInfo::getCrimePrereq() const
{
	return m_iCrimePrereq;
}

int CvSpellInfo::getDamage() const
{
	return m_iDamage;
}

int CvSpellInfo::getDamageLimit() const
{
	return m_iDamageLimit;
}

int CvSpellInfo::getDamageType() const
{
	return m_iDamageType;
}

int CvSpellInfo::getCreateUnitNum() const
{
	return m_iCreateUnitNum;
}

int CvSpellInfo::getAddPromotionType1() const
{
	return m_iAddPromotionType1;
}

int CvSpellInfo::getAddPromotionType2() const
{
	return m_iAddPromotionType2;
}

int CvSpellInfo::getAddPromotionType3() const
{
	return m_iAddPromotionType3;
}

int CvSpellInfo::getConvertUnitType() const
{
	return m_iConvertUnitType;
}

int CvSpellInfo::getCreateBuildingType() const
{
	return m_iCreateBuildingType;
}

int CvSpellInfo::getCreateFeatureType() const
{
	return m_iCreateFeatureType;
}

int CvSpellInfo::getCreatePlotEffectType() const
{
	return m_iCreatePlotEffectType;
}

int CvSpellInfo::getRemovePlotEffectType() const
{
	return m_iRemovePlotEffectType;
}

int CvSpellInfo::getCreateImprovementType() const
{
	return m_iCreateImprovementType;
}

int CvSpellInfo::getSpreadReligion() const
{
	return m_iSpreadReligion;
}

int CvSpellInfo::getDelay() const
{
	return m_iDelay;
}

int CvSpellInfo::getImmobileTurns() const
{
	return m_iImmobileTurns;
}

int CvSpellInfo::getMiscastChance() const
{
	return m_iMiscastChance;
}

int CvSpellInfo::getRemovePromotionType1() const
{
	return m_iRemovePromotionType1;
}

int CvSpellInfo::getRemovePromotionType2() const
{
	return m_iRemovePromotionType2;
}

int CvSpellInfo::getRemovePromotionType3() const
{
	return m_iRemovePromotionType3;
}

int CvSpellInfo::getResistModify() const
{
	return m_iResistModify;
}

int CvSpellInfo::getCreateUnitType() const
{
	return m_iCreateUnitType;
}

int CvSpellInfo::getCreateUnitPromotion() const
{
	return m_iCreateUnitPromotion;
}

const TCHAR *CvSpellInfo::getPyMiscast() const
{
	return m_szPyMiscast;
}

const TCHAR *CvSpellInfo::getPyResult() const
{
	return m_szPyResult;
}

const TCHAR *CvSpellInfo::getPyRequirement() const
{
	return m_szPyRequirement;
}

int CvSpellInfo::getCommandType() const
{
	return m_iCommandType;
}

void CvSpellInfo::setCommandType(int iNewType)
{
	m_iCommandType = iNewType;
}
//Magic Rework
int CvSpellInfo::getMagicalPowerPrereq() const
{
	return m_iMagicalPowerPrereq;
}
bool CvSpellInfo::isSpellClass(int i) const
{
	FAssertMsg(i < GC.getNumSpellClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbSpellClass ? m_pbSpellClass[i] : false;
}

void CvSpellInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

/*************************************************************************************************/
/**	City Actions	(SpellInfos)			03/28/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Read(&m_bCityAction);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Read(&m_iPromotionPrereq1);
	stream->Read(&m_iPromotionPrereq2);
	stream->Read(&m_iUnitPrereq);
	stream->Read(&m_iUnitCombatPrereq);
	stream->Read(&m_iUnitClassPrereq);
	stream->Read(&m_iUnitInStackPrereq);
	stream->Read(&m_iUnitInStackTargetPrereq);
	stream->Read(&m_iBuildingPrereq);
	stream->Read(&m_iBuildingTargetPrereq);
	stream->Read(&m_iBuildingClassOwnedPrereq);
	stream->Read(&m_iCivilizationPrereq);
	stream->Read(&m_iCorporationPrereq);
	stream->Read(&m_iCorporationTargetPrereq);
	stream->Read(&m_iFeatureOrPrereq1);
	stream->Read(&m_iFeatureOrPrereq2);
	stream->Read(&m_iFeatureOrTargetPrereq1);
	stream->Read(&m_iFeatureOrTargetPrereq2);
	stream->Read(&m_iImprovementPrereq);
	stream->Read(&m_iImprovementTargetPrereq);
	stream->Read(&m_iPromotionInStackPrereq);
	stream->Read(&m_iPromotionInStackTargetPrereq);
	stream->Read(&m_iReligionPrereq);
	stream->Read(&m_iStateReligionPrereq);
	stream->Read(&m_iTechPrereq);
	stream->Read(&m_iNumPrereqTraits);
	if (m_iNumPrereqTraits > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqTraits);
		m_piPrereqTraits = new int[m_iNumPrereqTraits];
		stream->Read(m_iNumPrereqTraits, m_piPrereqTraits);
	}
	stream->Read(&m_iNumPromotionsPrereq);
	if (m_iNumPromotionsPrereq > 0)
	{
		SAFE_DELETE_ARRAY(m_piPromotionsPrereq);
		m_piPromotionsPrereq = new int[m_iNumPromotionsPrereq];
		stream->Read(m_iNumPromotionsPrereq, m_piPromotionsPrereq);
	}
	stream->Read(&m_iNumAddPromotions);
	if (m_iNumAddPromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piAddPromotions);
		m_piAddPromotions = new int[m_iNumAddPromotions];
		stream->Read(m_iNumAddPromotions, m_piAddPromotions);
	}
	stream->Read(&m_iNumRemovePromotions);
	if (m_iNumRemovePromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piRemovePromotions);
		m_piRemovePromotions = new int[m_iNumRemovePromotions];
		stream->Read(m_iNumRemovePromotions, m_piRemovePromotions);
	}
/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_bPrereqNotAttacked);
	stream->Read(&m_bSetHasAttacked);
	stream->Read(&m_bRemoveHasAttacked);
	stream->Read(&m_bPrereqAvailableCommander);
	stream->Read(&m_bPrereqIsNOTMinion);
	stream->Read(&m_bPrereqIsMinion);
	stream->Read(&m_iPrereqBroadAlignment);
	stream->Read(&m_iAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBroadEthicalAlignment);
	stream->Read(&m_iEthicalAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_bSummonMaster);
	stream->Read(&m_iPromotionDuration);
	stream->ReadString(m_szQuote);
	stream->ReadString(m_szPyHelp);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	stream->Read(&m_bAllowAI);
	stream->Read(&m_bAdjacentToWaterOnly);
	stream->Read(&m_bTargetAdjacentToWaterOnly);
	stream->Read(&m_bCasterMustBeAlive);
	stream->Read(&m_bCasterNoDuration);
	stream->Read(&m_bCausesWar);
	stream->Read(&m_bGlobal);
	stream->Read(&m_bInBordersOnly);
	stream->Read(&m_bInCityOnly);
	stream->Read(&m_bTargetInBordersOnly);
	stream->Read(&m_bTargetInCityOnly);
	stream->Read(&m_bPrereqSlaveTrade);
	stream->Read(&m_bResistable);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iCasterMinLevel);
	stream->Read(&m_bDisplayWhenDisabled);
	stream->Read(&m_bHasCasted);
	stream->Read(&m_bIgnoreHasCasted);
	stream->Read(&m_iRange);
	stream->Read(&m_iResistModify);
	stream->Read(&m_iDamage);
	stream->Read(&m_iDamageLimit);
	stream->Read(&m_iDamageType);
	stream->Read(&m_iAddPromotionType1);
	stream->Read(&m_iAddPromotionType2);
	stream->Read(&m_iAddPromotionType3);
	stream->Read(&m_iRemovePromotionType1);
	stream->Read(&m_iRemovePromotionType2);
	stream->Read(&m_iRemovePromotionType3);
	stream->Read(&m_bBuffCasterOnly);
	stream->Read(&m_iConvertUnitType);
	stream->Read(&m_iCreateBuildingType);
	stream->Read(&m_iCreateFeatureType);
	stream->Read(&m_iCreatePlotEffectType);
	stream->Read(&m_iRemovePlotEffectType);
	stream->Read(&m_iCreateImprovementType);
	stream->Read(&m_iSpreadReligion);
	stream->Read(&m_iCreateUnitType);
	stream->Read(&m_iCreateUnitNum);
	stream->Read(&m_bCopyCastersPromotions);
	stream->Read(&m_bPermanentUnitCreate);
	stream->Read(&m_iCreateUnitPromotion);
	stream->Read(&m_bImmuneTeam);
	stream->Read(&m_bImmuneNeutral);
	stream->Read(&m_bImmuneEnemy);
	stream->Read(&m_bImmuneFlying);
	stream->Read(&m_bImmuneNotAlive);
	stream->Read(&m_bAbility);
	stream->Read(&m_bDispel);
	stream->Read(&m_bPush);
	stream->Read(&m_bRemoveHasCasted);
	stream->Read(&m_bSacrificeCaster);
	stream->Read(&m_iChangePopulation);
	stream->Read(&m_iCost);
	stream->Read(&m_iCrimePrereq);
	stream->Read(&m_iDelay);
	stream->Read(&m_iImmobileTurns);
	stream->Read(&m_iMiscastChance);
	stream->ReadString(m_szPyMiscast);
	stream->ReadString(m_szPyResult);
	stream->ReadString(m_szPyRequirement);
	stream->Read(&m_iEffect);
	stream->ReadString(m_szSound);
	stream->Read(&m_iCommandType);
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	stream->Read(&m_bAutoCast);
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
	//Magic Rework
	stream->Read(&m_iMagicalPowerPrereq);
	SAFE_DELETE_ARRAY(m_pbSpellClass);
	m_pbSpellClass = new bool[GC.getNumSpellClassInfos()];
	stream->Read(GC.getNumSpellClassInfos(), m_pbSpellClass);


}

void CvSpellInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

/*************************************************************************************************/
/**	City Actions	(SpellInfos)			03/28/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Write(m_bCityAction);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Write(m_iPromotionPrereq1);
	stream->Write(m_iPromotionPrereq2);
	stream->Write(m_iUnitPrereq);
	stream->Write(m_iUnitCombatPrereq);
	stream->Write(m_iUnitClassPrereq);
	stream->Write(m_iUnitInStackPrereq);
	stream->Write(m_iUnitInStackTargetPrereq);
	stream->Write(m_iBuildingPrereq);
	stream->Write(m_iBuildingTargetPrereq);
	stream->Write(m_iBuildingClassOwnedPrereq);
	stream->Write(m_iCivilizationPrereq);
	stream->Write(m_iCorporationPrereq);
	stream->Write(m_iCorporationTargetPrereq);
	stream->Write(m_iFeatureOrPrereq1);
	stream->Write(m_iFeatureOrPrereq2);
	stream->Write(m_iFeatureOrTargetPrereq1);
	stream->Write(m_iFeatureOrTargetPrereq2);
	stream->Write(m_iImprovementPrereq);
	stream->Write(m_iImprovementTargetPrereq);
	stream->Write(m_iPromotionInStackPrereq);
	stream->Write(m_iPromotionInStackTargetPrereq);
	stream->Write(m_iReligionPrereq);
	stream->Write(m_iStateReligionPrereq);
	stream->Write(m_iTechPrereq);

	stream->Write(m_iNumPrereqTraits);
	if (m_iNumPrereqTraits > 0)
		stream->Write(m_iNumPrereqTraits, m_piPrereqTraits);

	stream->Write(m_iNumPromotionsPrereq);
	if (m_iNumPromotionsPrereq > 0)
		stream->Write(m_iNumPromotionsPrereq, m_piPromotionsPrereq);
	
	stream->Write(m_iNumAddPromotions);
	if (m_iNumAddPromotions > 0)
		stream->Write(m_iNumAddPromotions, m_piAddPromotions);

	stream->Write(m_iNumRemovePromotions);
	if (m_iNumRemovePromotions > 0)
		stream->Write(m_iNumRemovePromotions, m_piRemovePromotions);

/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_bPrereqNotAttacked);
	stream->Write(m_bSetHasAttacked);
	stream->Write(m_bRemoveHasAttacked);
	stream->Write(m_bPrereqAvailableCommander);
	stream->Write(m_bPrereqIsNOTMinion);
	stream->Write(m_bPrereqIsMinion);
	stream->Write(m_iPrereqBroadAlignment);
	stream->Write(m_iAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBroadEthicalAlignment);
	stream->Write(m_iEthicalAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_bSummonMaster);
	stream->Write(m_iPromotionDuration);
	stream->WriteString(m_szQuote);
	stream->WriteString(m_szPyHelp);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	stream->Write(m_bAllowAI);
	stream->Write(m_bAdjacentToWaterOnly);
	stream->Write(m_bTargetAdjacentToWaterOnly);
	stream->Write(m_bCasterMustBeAlive);
	stream->Write(m_bCasterNoDuration);
	stream->Write(m_bCausesWar);
	stream->Write(m_bGlobal);
	stream->Write(m_bInBordersOnly);
	stream->Write(m_bInCityOnly);
	stream->Write(m_bTargetInBordersOnly);
	stream->Write(m_bTargetInCityOnly);
	stream->Write(m_bPrereqSlaveTrade);
	stream->Write(m_bResistable);
	stream->Write(m_iAIWeight);
	stream->Write(m_iCasterMinLevel);
	stream->Write(m_bDisplayWhenDisabled);
	stream->Write(m_bHasCasted);
	stream->Write(m_bIgnoreHasCasted);
	stream->Write(m_iRange);
	stream->Write(m_iResistModify);
	stream->Write(m_iDamage);
	stream->Write(m_iDamageLimit);
	stream->Write(m_iDamageType);
	stream->Write(m_iAddPromotionType1);
	stream->Write(m_iAddPromotionType2);
	stream->Write(m_iAddPromotionType3);
	stream->Write(m_iRemovePromotionType1);
	stream->Write(m_iRemovePromotionType2);
	stream->Write(m_iRemovePromotionType3);
	stream->Write(m_bBuffCasterOnly);
	stream->Write(m_iConvertUnitType);
	stream->Write(m_iCreateBuildingType);
	stream->Write(m_iCreateFeatureType);
	stream->Write(m_iCreatePlotEffectType);
	stream->Write(m_iRemovePlotEffectType);
	stream->Write(m_iCreateImprovementType);
	stream->Write(m_iSpreadReligion);
	stream->Write(m_iCreateUnitType);
	stream->Write(m_iCreateUnitNum);
	stream->Write(m_bCopyCastersPromotions);
	stream->Write(m_bPermanentUnitCreate);
	stream->Write(m_iCreateUnitPromotion);
	stream->Write(m_bImmuneTeam);
	stream->Write(m_bImmuneNeutral);
	stream->Write(m_bImmuneEnemy);
	stream->Write(m_bImmuneFlying);
	stream->Write(m_bImmuneNotAlive);
	stream->Write(m_bAbility);
	stream->Write(m_bDispel);
	stream->Write(m_bPush);
	stream->Write(m_bRemoveHasCasted);
	stream->Write(m_bSacrificeCaster);
	stream->Write(m_iChangePopulation);
	stream->Write(m_iCost);
	stream->Write(m_iCrimePrereq);
	stream->Write(m_iDelay);
	stream->Write(m_iImmobileTurns);
	stream->Write(m_iMiscastChance);
	stream->WriteString(m_szPyMiscast);
	stream->WriteString(m_szPyResult);
	stream->WriteString(m_szPyRequirement);
	stream->Write(m_iEffect);
	stream->WriteString(m_szSound);
	stream->Write(m_iCommandType);
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	stream->Write(m_bAutoCast);
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
	//Magic Rework
	stream->Write(m_iMagicalPowerPrereq);
	stream->Write(GC.getNumTraitInfos(), m_pbSpellClass);
}

bool CvSpellInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

/*************************************************************************************************/
/**	City Actions	(SpellInfos)			03/28/10								Grey Fox	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bCityAction, "bCityAction");
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq1");
	if (szTextVal != "") m_iPromotionPrereq1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq2");
	if (szTextVal != "") m_iPromotionPrereq2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitPrereq");
	if (szTextVal != "") m_iUnitPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitCombatPrereq");
	if (szTextVal != "") m_iUnitCombatPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitClassPrereq");
	if (szTextVal != "") m_iUnitClassPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitInStackPrereq");
	if (szTextVal != "") m_iUnitInStackPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitInStackTargetPrereq");
	if (szTextVal != "") m_iUnitInStackTargetPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BuildingPrereq");
	if (szTextVal != "") m_iBuildingPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BuildingTargetPrereq");
	if (szTextVal != "") m_iBuildingTargetPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BuildingClassOwnedPrereq");
	if (szTextVal != "") m_iBuildingClassOwnedPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CivilizationPrereq");
	if (szTextVal != "") m_iCivilizationPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CorporationPrereq");
	if (szTextVal != "") m_iCorporationPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CorporationTargetPrereq");
	if (szTextVal != "") m_iCorporationTargetPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureOrPrereq1");
	if (szTextVal != "") m_iFeatureOrPrereq1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureOrPrereq2");
	if (szTextVal != "") m_iFeatureOrPrereq2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureOrTargetPrereq1");
	if (szTextVal != "") m_iFeatureOrTargetPrereq1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureOrTargetPrereq2");
	if (szTextVal != "") m_iFeatureOrTargetPrereq2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ImprovementPrereq");
	if (szTextVal != "") m_iImprovementPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ImprovementTargetPrereq");
	if (szTextVal != "") m_iImprovementTargetPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionInStackPrereq");
	if (szTextVal != "") m_iPromotionInStackPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionInStackTargetPrereq");
	if (szTextVal != "") m_iPromotionInStackTargetPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ReligionPrereq");
	if (szTextVal != "") m_iReligionPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "StateReligionPrereq");
	if (szTextVal != "") m_iStateReligionPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	if (szTextVal != "") m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqTraits"))		pXML->SetStringWithChildList(&m_iNumPrereqTraits, &m_aszPrereqTraitsforPass3);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PromotionsPrereq"))
		pXML->SetIntWithChildList(&m_iNumPromotionsPrereq, &m_piPromotionsPrereq);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "AddPromotions"))		pXML->SetStringWithChildList(&m_iNumAddPromotions, &m_aszAddPromotionsforPass3);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "RemovePromotions"))		pXML->SetStringWithChildList(&m_iNumRemovePromotions, &m_aszRemovePromotionsforPass3);

/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bPrereqNotAttacked, "PrereqNotAttacked");
	pXML->GetChildXmlValByName(&m_bSetHasAttacked, "bSetHasAttacked");
	pXML->GetChildXmlValByName(&m_bRemoveHasAttacked, "bRemoveHasAttacked");
	pXML->GetChildXmlValByName(&m_bPrereqAvailableCommander, "PrereqAvailableCommander");
	pXML->GetChildXmlValByName(&m_bPrereqIsNOTMinion, "PrereqIsNOTMinion");
	pXML->GetChildXmlValByName(&m_bPrereqIsMinion, "PrereqIsMinion");
	pXML->GetChildXmlValByName(&m_iPrereqBroadAlignment, "iPrereqBroadAlignment");
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqBroadEthicalAlignment, "iPrereqBroadEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bSummonMaster, "bSummonMaster");
	pXML->GetChildXmlValByName(&m_iPromotionDuration, "iPromotionDuration", -1);
	pXML->GetChildXmlValByName(m_szQuote, "Quote");
	pXML->GetChildXmlValByName(m_szPyHelp, "PyHelp");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bAllowAI, "bAllowAI");
	pXML->GetChildXmlValByName(&m_bAdjacentToWaterOnly, "bAdjacentToWaterOnly");
	pXML->GetChildXmlValByName(&m_bTargetAdjacentToWaterOnly, "bTargetAdjacentToWaterOnly");
	pXML->GetChildXmlValByName(&m_bCasterMustBeAlive, "bCasterMustBeAlive");
	pXML->GetChildXmlValByName(&m_bCasterNoDuration, "bCasterNoDuration");
	pXML->GetChildXmlValByName(&m_bCausesWar, "bCausesWar");
	pXML->GetChildXmlValByName(&m_bGlobal, "bGlobal");
	pXML->GetChildXmlValByName(&m_bInBordersOnly, "bInBordersOnly");
	pXML->GetChildXmlValByName(&m_bInCityOnly, "bInCityOnly");
	pXML->GetChildXmlValByName(&m_bTargetInBordersOnly, "bTargetInBordersOnly");
	pXML->GetChildXmlValByName(&m_bTargetInCityOnly, "bTargetInCityOnly");
	pXML->GetChildXmlValByName(&m_bPrereqSlaveTrade, "bPrereqSlaveTrade");
	pXML->GetChildXmlValByName(&m_bResistable, "bResistable");
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iCasterMinLevel, "iCasterMinLevel");
	pXML->GetChildXmlValByName(&m_bDisplayWhenDisabled, "bDisplayWhenDisabled");
	pXML->GetChildXmlValByName(&m_bHasCasted, "bHasCasted");
	pXML->GetChildXmlValByName(&m_bIgnoreHasCasted, "bIgnoreHasCasted");
	pXML->GetChildXmlValByName(&m_iRange, "iRange");
	pXML->GetChildXmlValByName(&m_iResistModify, "iResistModify");

	pXML->GetChildXmlValByName(&m_iDamage, "iDamage");
	pXML->GetChildXmlValByName(&m_iDamageLimit, "iDamageLimit");
	pXML->GetChildXmlValByName(szTextVal, "DamageType");
	if (szTextVal != "") m_iDamageType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType1");
	if (szTextVal != "") m_iAddPromotionType1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType2");
	if (szTextVal != "") m_iAddPromotionType2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType3");
	if (szTextVal != "") m_iAddPromotionType3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotionType1");
	if (szTextVal != "") m_iRemovePromotionType1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotionType2");
	if (szTextVal != "") m_iRemovePromotionType2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotionType3");
	if (szTextVal != "") m_iRemovePromotionType3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bBuffCasterOnly, "bBuffCasterOnly");

	pXML->GetChildXmlValByName(szTextVal, "ConvertUnitType");
	if (szTextVal != "") m_iConvertUnitType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateBuildingType");
	if (szTextVal != "") m_iCreateBuildingType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateFeatureType");
	if (szTextVal != "") m_iCreateFeatureType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreatePlotEffectType");
	if (szTextVal != "") m_iCreatePlotEffectType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePlotEffectType");
	if (szTextVal != "") m_iRemovePlotEffectType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateImprovementType");
	if (szTextVal != "") m_iCreateImprovementType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "SpreadReligion");
	if (szTextVal != "") m_iSpreadReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "CreateUnitType");
	if (szTextVal != "") m_iCreateUnitType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iCreateUnitNum, "iCreateUnitNum");
	pXML->GetChildXmlValByName(&m_bCopyCastersPromotions, "bCopyCastersPromotions");
	pXML->GetChildXmlValByName(&m_bPermanentUnitCreate, "bPermanentUnitCreate");
	pXML->GetChildXmlValByName(szTextVal, "CreateUnitPromotion");
	if (szTextVal != "") m_iCreateUnitPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bImmuneTeam, "bImmuneTeam");
	pXML->GetChildXmlValByName(&m_bImmuneNeutral, "bImmuneNeutral");
	pXML->GetChildXmlValByName(&m_bImmuneEnemy, "bImmuneEnemy");
	pXML->GetChildXmlValByName(&m_bImmuneFlying, "bImmuneFlying");
	pXML->GetChildXmlValByName(&m_bImmuneNotAlive, "bImmuneNotAlive");
	pXML->GetChildXmlValByName(&m_bAbility, "bAbility");
	pXML->GetChildXmlValByName(&m_bDispel, "bDispel");
	pXML->GetChildXmlValByName(&m_bPush, "bPush");
	pXML->GetChildXmlValByName(&m_bRemoveHasCasted, "bRemoveHasCasted");
	pXML->GetChildXmlValByName(&m_bSacrificeCaster, "bSacrificeCaster");
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bAutoCast, "bIsAutoCastable");
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
	//TargetedSpell 0924 blackimp
	pXML->GetChildXmlValByName(&m_bTargeted, "bTargeted");

	pXML->GetChildXmlValByName(&m_iChangePopulation, "iChangePopulation");
	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_iCrimePrereq, "iCrimePrereq");
	pXML->GetChildXmlValByName(&m_iDelay, "iDelay");
	pXML->GetChildXmlValByName(&m_iImmobileTurns, "iImmobileTurns");
	pXML->GetChildXmlValByName(&m_iMiscastChance, "iMiscastChance");

	pXML->GetChildXmlValByName(m_szPyMiscast, "PyMiscast");
	pXML->GetChildXmlValByName(m_szPyResult, "PyResult");
	pXML->GetChildXmlValByName(m_szPyRequirement, "PyRequirement");
	pXML->GetChildXmlValByName(szTextVal, "Effect");
	if (szTextVal != "") m_iEffect = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(m_szSound, "Sound");
	//Magic Rework
	pXML->GetChildXmlValByName(&m_iMagicalPowerPrereq, "iMagicalPowerPrereq");
	pXML->SetVariableListTagPair(&m_pbSpellClass, "SpellClasses", sizeof(GC.getSpellClassInfo((SpellClassTypes)0)), GC.getNumSpellClassInfos());

	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(SpellInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
bool CvSpellInfo::readPass3()
{
	/*************************************************************************************************/
	/**	New Tag Defs	(PromotionInfos)		08/09/08								Xienwolf	**/
	/**																								**/
	/**					Third Pass to reference information which didn't exist before				**/
	/*************************************************************************************************/
	/**								---- Start Original Code ----									**
		if (m_aszExtraXMLforPass3.size() < 1)
		{
			FAssert(false);
			return false;
		}
	/**								----  End Original Code  ----									**/
	
	m_piPrereqTraits = new int[m_iNumPrereqTraits];
	for (int iI = 0; iI < m_iNumPrereqTraits; iI++)
		m_piPrereqTraits[iI] = GC.getInfoTypeForString(m_aszPrereqTraitsforPass3[iI]);
	m_aszPrereqTraitsforPass3.clear();

	m_piAddPromotions = new int[m_iNumAddPromotions];
	for (int iI = 0; iI < m_iNumAddPromotions; iI++)
		m_piAddPromotions[iI] = GC.getInfoTypeForString(m_aszAddPromotionsforPass3[iI]);
	m_aszAddPromotionsforPass3.clear();

	m_piRemovePromotions = new int[m_iNumRemovePromotions];
	for (int iI = 0; iI < m_iNumRemovePromotions; iI++)
		m_piRemovePromotions[iI] = GC.getInfoTypeForString(m_aszRemovePromotionsforPass3[iI]);
	m_aszRemovePromotionsforPass3.clear();

	return true;
}



void CvSpellInfo::copyNonDefaults(CvSpellInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

/*************************************************************************************************/
/**	City Actions	(SpellInfos)			03/28/10								Grey Fox	**/
/*************************************************************************************************/
	if (isCityAction()					== false)				m_bCityAction					= pClassInfo->isCityAction();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

	if (isPrereqAvailableCommander()	== false)				m_bPrereqAvailableCommander		= pClassInfo->isPrereqAvailableCommander();
	if (isPrereqIsNOTMinion()			== false)				m_bPrereqIsNOTMinion			= pClassInfo->isPrereqIsNOTMinion();
	if (isPrereqIsMinion()				== false)				m_bPrereqIsMinion				= pClassInfo->isPrereqIsMinion();
	if (isBuffCasterOnly()				== false)				m_bBuffCasterOnly				= pClassInfo->isBuffCasterOnly();
	if (isCopyCastersPromotions()		== false)				m_bCopyCastersPromotions		= pClassInfo->isCopyCastersPromotions();
	if (isPermanentUnitCreate()			== false)				m_bPermanentUnitCreate			= pClassInfo->isPermanentUnitCreate();
	if (isImmuneTeam()					== false)				m_bImmuneTeam					= pClassInfo->isImmuneTeam();
	if (isImmuneNeutral()				== false)				m_bImmuneNeutral				= pClassInfo->isImmuneNeutral();
	if (isImmuneEnemy()					== false)				m_bImmuneEnemy					= pClassInfo->isImmuneEnemy();
	if (isImmuneFlying()				== false)				m_bImmuneFlying					= pClassInfo->isImmuneFlying();
	if (isImmuneNotAlive()				== false)				m_bImmuneNotAlive				= pClassInfo->isImmuneNotAlive();
	if (isAbility()						== false)				m_bAbility						= pClassInfo->isAbility();
	if (isDispel()						== false)				m_bDispel						= pClassInfo->isDispel();
	if (isPush()						== false)				m_bPush							= pClassInfo->isPush();
	if (isRemoveHasCasted()				== false)				m_bRemoveHasCasted				= pClassInfo->isRemoveHasCasted();
	if (isSacrificeCaster()				== false)				m_bSacrificeCaster				= pClassInfo->isSacrificeCaster();
	if (isSummonMaster()				== false)				m_bSummonMaster					= pClassInfo->isSummonMaster();
	if (isAllowAI()						== false)				m_bAllowAI						= pClassInfo->isAllowAI();
	if (isAdjacentToWaterOnly()			== false)				m_bAdjacentToWaterOnly			= pClassInfo->isAdjacentToWaterOnly();
	if (isTargetAdjacentToWaterOnly() == false)				m_bTargetAdjacentToWaterOnly = pClassInfo->isTargetAdjacentToWaterOnly();
	if (isCasterMustBeAlive()			== false)				m_bCasterMustBeAlive			= pClassInfo->isCasterMustBeAlive();
	if (isCasterNoDuration()			== false)				m_bCasterNoDuration				= pClassInfo->isCasterNoDuration();
	if (isCausesWar()					== false)				m_bCausesWar					= pClassInfo->isCausesWar();
	if (isGlobal()						== false)				m_bGlobal						= pClassInfo->isGlobal();
	if (isInBordersOnly()				== false)				m_bInBordersOnly				= pClassInfo->isInBordersOnly();
	if (isInCityOnly()					== false)				m_bInCityOnly					= pClassInfo->isInCityOnly();
	if (isTargetInBordersOnly() == false)				m_bTargetInBordersOnly = pClassInfo->isTargetInBordersOnly();
	if (isTargetInCityOnly() == false)				m_bTargetInCityOnly = pClassInfo->isTargetInCityOnly();
	if (isPrereqSlaveTrade()			== false)				m_bPrereqSlaveTrade				= pClassInfo->isPrereqSlaveTrade();
	if (isResistable()					== false)				m_bResistable					= pClassInfo->isResistable();
	if (isDisplayWhenDisabled()			== false)				m_bDisplayWhenDisabled			= pClassInfo->isDisplayWhenDisabled();
	if (isHasCasted()					== false)				m_bHasCasted					= pClassInfo->isHasCasted();
	if (isIgnoreHasCasted()				== false)				m_bIgnoreHasCasted				= pClassInfo->isIgnoreHasCasted();
	if (isPrereqNotAttacked()			== false)				m_bPrereqNotAttacked			= pClassInfo->isPrereqNotAttacked();
	if (isSetHasAttacked()				== false)				m_bSetHasAttacked				= pClassInfo->isSetHasAttacked();
	if (isRemoveHasAttacked()			== false)				m_bRemoveHasAttacked			= pClassInfo->isRemoveHasAttacked();
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	if (isAutoCast()			== false)				m_bAutoCast			= pClassInfo->isAutoCast();
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
	//TargetedSpell 0924 blackimp
	if (isTargeted() == false)				m_bTargeted = pClassInfo->isTargeted();

	if (getPrereqBroadAlignment()		== 0)					m_iPrereqBroadAlignment			= pClassInfo->getPrereqBroadAlignment();
	if (getAlignmentModifier()			== 0)					m_iAlignmentModifier			= pClassInfo->getAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getPrereqBroadEthicalAlignment() == 0)					m_iPrereqBroadEthicalAlignment	= pClassInfo->getPrereqBroadEthicalAlignment();
	if (getEthicalAlignmentModifier()	== 0)					m_iEthicalAlignmentModifier		= pClassInfo->getEthicalAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getPromotionDuration()			== 0)					m_iPromotionDuration			= pClassInfo->getPromotionDuration();
	if (getAIWeight()					== 0)					m_iAIWeight						= pClassInfo->getAIWeight();
	if (getCasterMinLevel()				== 0)					m_iCasterMinLevel				= pClassInfo->getCasterMinLevel();
	if (getRange()						== 0)					m_iRange						= pClassInfo->getRange();
	if (getResistModify()				== 0)					m_iResistModify					= pClassInfo->getResistModify();
	if (getDamage()						== 0)					m_iDamage						= pClassInfo->getDamage();
	if (getDamageLimit()				== 0)					m_iDamageLimit					= pClassInfo->getDamageLimit();
	if (getCreateUnitNum()				== 0)					m_iCreateUnitNum				= pClassInfo->getCreateUnitNum();
	if (getChangePopulation()			== 0)					m_iChangePopulation				= pClassInfo->getChangePopulation();
	if (getCost()						== 0)					m_iCost							= pClassInfo->getCost();
	if (getCrimePrereq() == 0)					m_iCrimePrereq = pClassInfo->getCrimePrereq();
	if (getDelay()						== 0)					m_iDelay						= pClassInfo->getDelay();
	if (getImmobileTurns()				== 0)					m_iImmobileTurns				= pClassInfo->getImmobileTurns();
	if (getMiscastChance()				== 0)					m_iMiscastChance				= pClassInfo->getMiscastChance();
	if (getQuote()						== cDefault)			m_szQuote						= pClassInfo->getQuote();
	if (getSound()						== cDefault)			m_szSound						= pClassInfo->getSound();
	if (getPyMiscast()					== cDefault)			m_szPyMiscast					= pClassInfo->getPyMiscast();
	if (getPyResult()					== cDefault)			m_szPyResult					= pClassInfo->getPyResult();
	if (getPyRequirement()				== cDefault)			m_szPyRequirement				= pClassInfo->getPyRequirement();
	if (getPythonHelp()					== cDefault)			m_szPyHelp						= pClassInfo->getPythonHelp();
	if (getUnitPrereq()					== NO_UNIT)				m_iUnitPrereq					= pClassInfo->getUnitPrereq();
	if (getUnitInStackPrereq()			== NO_UNIT)				m_iUnitInStackPrereq			= pClassInfo->getUnitInStackPrereq();
	if (getUnitInStackTargetPrereq() == NO_UNIT)				m_iUnitInStackTargetPrereq = pClassInfo->getUnitInStackTargetPrereq();
	if (getCreateUnitType()				== NO_UNIT)				m_iCreateUnitType				= pClassInfo->getCreateUnitType();
	if (getUnitInStackPrereq()			== NO_UNIT)				m_iUnitInStackPrereq			= pClassInfo->getUnitInStackPrereq();
	if (getConvertUnitType()			== NO_UNIT)				m_iConvertUnitType				= pClassInfo->getConvertUnitType();
	if (getTechPrereq()					== NO_TECH)				m_iTechPrereq					= pClassInfo->getTechPrereq();
	if (getEffect()						== NO_EFFECT)			m_iEffect						= pClassInfo->getEffect();
	if (getDamageType()					== NO_DAMAGE)			m_iDamageType					= pClassInfo->getDamageType();
	if (getCreateFeatureType()			== NO_FEATURE)			m_iCreateFeatureType			= pClassInfo->getCreateFeatureType();
	if (getCreatePlotEffectType() == NO_PLOT_EFFECT)			m_iCreatePlotEffectType = pClassInfo->getCreatePlotEffectType();
	if (getRemovePlotEffectType() == NO_PLOT_EFFECT)			m_iRemovePlotEffectType = pClassInfo->getRemovePlotEffectType();
	if (getFeatureOrPrereq1()			== NO_FEATURE)			m_iFeatureOrPrereq1				= pClassInfo->getFeatureOrPrereq1();
	if (getFeatureOrPrereq2()			== NO_FEATURE)			m_iFeatureOrPrereq2				= pClassInfo->getFeatureOrPrereq2();
	if (getFeatureOrTargetPrereq1() == NO_FEATURE)			m_iFeatureOrTargetPrereq1 = pClassInfo->getFeatureOrTargetPrereq1();
	if (getFeatureOrTargetPrereq2() == NO_FEATURE)			m_iFeatureOrTargetPrereq2 = pClassInfo->getFeatureOrTargetPrereq2();
	if (getSpreadReligion()				== NO_RELIGION)			m_iSpreadReligion				= pClassInfo->getSpreadReligion();
	if (getReligionPrereq()				== NO_RELIGION)			m_iReligionPrereq				= pClassInfo->getReligionPrereq();
	if (getStateReligionPrereq()		== NO_RELIGION)			m_iStateReligionPrereq			= pClassInfo->getStateReligionPrereq();
	if (getCreateBuildingType()			== NO_BUILDING)			m_iCreateBuildingType			= pClassInfo->getCreateBuildingType();
	if (getBuildingPrereq()				== NO_BUILDING)			m_iBuildingPrereq				= pClassInfo->getBuildingPrereq();
	if (getBuildingTargetPrereq() == NO_BUILDING)			m_iBuildingTargetPrereq = pClassInfo->getBuildingTargetPrereq();
	if (getPromotionPrereq1()			== NO_PROMOTION)		m_iPromotionPrereq1				= pClassInfo->getPromotionPrereq1();
	if (getPromotionPrereq2()			== NO_PROMOTION)		m_iPromotionPrereq2				= pClassInfo->getPromotionPrereq2();
	if (getPromotionInStackPrereq()		== NO_PROMOTION)		m_iPromotionInStackPrereq		= pClassInfo->getPromotionInStackPrereq();
	if (getPromotionInStackTargetPrereq() == NO_PROMOTION)		m_iPromotionInStackTargetPrereq = pClassInfo->getPromotionInStackTargetPrereq();
	if (getCreateUnitPromotion()		== NO_PROMOTION)		m_iCreateUnitPromotion			= pClassInfo->getCreateUnitPromotion();
	if (getAddPromotionType1()			== NO_PROMOTION)		m_iAddPromotionType1			= pClassInfo->getAddPromotionType1();
	if (getAddPromotionType2()			== NO_PROMOTION)		m_iAddPromotionType2			= pClassInfo->getAddPromotionType2();
	if (getAddPromotionType3()			== NO_PROMOTION)		m_iAddPromotionType3			= pClassInfo->getAddPromotionType3();
	if (getRemovePromotionType1()		== NO_PROMOTION)		m_iRemovePromotionType1			= pClassInfo->getRemovePromotionType1();
	if (getRemovePromotionType2()		== NO_PROMOTION)		m_iRemovePromotionType2			= pClassInfo->getRemovePromotionType2();
	if (getRemovePromotionType3()		== NO_PROMOTION)		m_iRemovePromotionType3			= pClassInfo->getRemovePromotionType3();
	if (getUnitClassPrereq()			== NO_UNITCLASS)		m_iUnitClassPrereq				= pClassInfo->getUnitClassPrereq();
	if (getUnitCombatPrereq()			== NO_UNITCOMBAT)		m_iUnitCombatPrereq				= pClassInfo->getUnitCombatPrereq();
	if (getCorporationPrereq()			== NO_CORPORATION)		m_iCorporationPrereq			= pClassInfo->getCorporationPrereq();
	if (getCorporationTargetPrereq() == NO_CORPORATION)		m_iCorporationTargetPrereq = pClassInfo->getCorporationTargetPrereq();
	if (getCreateImprovementType()		== NO_IMPROVEMENT)		m_iCreateImprovementType		= pClassInfo->getCreateImprovementType();
	if (getImprovementPrereq()			== NO_IMPROVEMENT)		m_iImprovementPrereq			= pClassInfo->getImprovementPrereq();
	if (getImprovementTargetPrereq() == NO_IMPROVEMENT)		m_iImprovementTargetPrereq = pClassInfo->getImprovementTargetPrereq();
	if (getCivilizationPrereq()		== NO_CIVILIZATION)		m_iCivilizationPrereq			= pClassInfo->getCivilizationPrereq();
	//Magic Rework
	if (getMagicalPowerPrereq() == 0)				m_iMagicalPowerPrereq = pClassInfo->getMagicalPowerPrereq();
	for (int i = 0; i < GC.getNumSpellClassInfos(); ++i)
	{
		if (isSpellClass(i) == false)				m_pbSpellClass[i] = pClassInfo->isSpellClass(i);
	}
	
	if (getBuildingClassOwnedPrereq()	== NO_BUILDINGCLASS)	m_iBuildingClassOwnedPrereq		= pClassInfo->getBuildingClassOwnedPrereq();

	for (int i = 0; i < pClassInfo->getNumPrereqTraits(); ++i)
	{
		bool bLoad = true;
		for (int j = 0; j < getNumPrereqTraits(); ++j)
		{
			if (pClassInfo->getPrereqTraitsVectorElement(i) == getPrereqTraitsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if (bLoad)
		{
			m_aszPrereqTraitsforPass3.push_back(pClassInfo->getPrereqTraitsVectorElement(i));
			m_iNumPrereqTraits++;
		}
	}
	for (int i = 0; i < pClassInfo->getNumAddPromotions(); ++i)
	{
		bool bLoad = true;
		for (int j = 0; j < getNumAddPromotions(); ++j)
		{
			if (pClassInfo->getAddPromotionsVectorElement(i) == getAddPromotionsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if (bLoad)
		{
			m_aszAddPromotionsforPass3.push_back(pClassInfo->getAddPromotionsVectorElement(i));
			m_iNumAddPromotions++;
		}
	}
	for (int i = 0; i < pClassInfo->getNumRemovePromotions(); ++i)
	{
		bool bLoad = true;
		for (int j = 0; j < getNumRemovePromotions(); ++j)
		{
			if (pClassInfo->getRemovePromotionsVectorElement(i) == getRemovePromotionsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if (bLoad)
		{
			m_aszRemovePromotionsforPass3.push_back(pClassInfo->getRemovePromotionsVectorElement(i));
			m_iNumRemovePromotions++;
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvMissionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvMissionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvMissionInfo::CvMissionInfo() :
m_iTime(0),
m_iGoldCost(0),
m_bSound(false),
m_bTarget(false),
m_bBuild(false),
m_bVisible(false),
m_eEntityEvent(ENTITY_EVENT_NONE)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvMissionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvMissionInfo::~CvMissionInfo()
{
}

int CvMissionInfo::getTime() const
{
	return m_iTime;
}

int CvMissionInfo::getGoldCost() const
{
	return m_iGoldCost;
}

bool CvMissionInfo::isSound() const
{
	return m_bSound;
}

bool CvMissionInfo::isTarget() const
{
	return m_bTarget;
}

bool CvMissionInfo::isBuild() const
{
	return m_bBuild;
}

bool CvMissionInfo::getVisible() const
{
	return m_bVisible;
}

const TCHAR* CvMissionInfo::getWaypoint() const
{
	return m_szWaypoint;
}

EntityEventTypes CvMissionInfo::getEntityEvent() const
{
	return m_eEntityEvent;
}

bool CvMissionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTmp;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szWaypoint, "Waypoint");
	pXML->GetChildXmlValByName(&m_iGoldCost, "iGoldCost");
	pXML->GetChildXmlValByName(&m_iTime, "iTime");
	pXML->GetChildXmlValByName(&m_bSound, "bSound");
	pXML->GetChildXmlValByName(&m_bTarget, "bTarget");
	pXML->GetChildXmlValByName(&m_bBuild, "bBuild");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	if ( pXML->GetChildXmlValByName(szTmp, "EntityEventType") )
	{
		m_eEntityEvent = (EntityEventTypes)pXML->FindInInfoClass(szTmp);
	}
	else
	{
		m_eEntityEvent = ENTITY_EVENT_NONE;
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvMissionInfo::copyNonDefaults(CvMissionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getTime()				== 0)						m_iTime			= pClassInfo->getTime();
	if (getGoldCost()			== 0)						m_iGoldCost		= pClassInfo->getGoldCost();
	if (isSound()				== false)					m_bSound		= pClassInfo->isSound();
	if (isTarget()				== false)					m_bTarget		= pClassInfo->isTarget();
	if (isBuild()				== false)					m_bBuild		= pClassInfo->isBuild();
	if (getVisible()			== false)					m_bVisible		= pClassInfo->getVisible();
	if (getEntityEvent()		== ENTITY_EVENT_NONE)		m_eEntityEvent	= pClassInfo->getEntityEvent();
	if (getWaypoint()			== cDefault)				m_szWaypoint	= pClassInfo->getWaypoint();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvControlInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvControlInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvControlInfo::CvControlInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvControlInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvControlInfo::~CvControlInfo()
{
}

bool CvControlInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvControlInfo::copyNonDefaults(CvControlInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCommandInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCommandInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCommandInfo::CvCommandInfo() :
m_iAutomate(NO_AUTOMATE),
m_bConfirmCommand(false),
m_bVisible(false),
m_bAll(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCommandInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCommandInfo::~CvCommandInfo()
{
}

int CvCommandInfo::getAutomate() const
{
	return m_iAutomate;
}

void CvCommandInfo::setAutomate(int i)
{
	m_iAutomate = i;
}

bool CvCommandInfo::getConfirmCommand() const
{
	return m_bConfirmCommand;
}

bool CvCommandInfo::getVisible() const
{
	return m_bVisible;
}

bool CvCommandInfo::getAll() const
{
	return m_bAll;
}

bool CvCommandInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	if (pXML->GetChildXmlValByName(szTextVal, "Automate"))
	{
		setAutomate(GC.getTypesEnum(szTextVal));
	}

	pXML->GetChildXmlValByName(&m_bConfirmCommand, "bConfirmCommand");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");
	pXML->GetChildXmlValByName(&m_bAll, "bAll");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCommandInfo::copyNonDefaults(CvCommandInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getAutomate()		== NO_AUTOMATE)		setAutomate(		pClassInfo->getAutomate());
	if (getConfirmCommand()	== false)			m_bConfirmCommand	= pClassInfo->getConfirmCommand();
	if (getVisible()		== false)			m_bVisible			= pClassInfo->getVisible();
	if (getAll()			== false)			m_bAll				= pClassInfo->getAll();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAutomateInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAutomateInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAutomateInfo::CvAutomateInfo() :
m_iCommand(NO_COMMAND),
m_iAutomate(NO_AUTOMATE),
m_bConfirmCommand(false),
m_bVisible(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAutomateInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAutomateInfo::~CvAutomateInfo()
{
}

int CvAutomateInfo::getCommand() const
{
	return m_iCommand;
}

void CvAutomateInfo::setCommand(int i)
{
	m_iCommand = i;
}

int CvAutomateInfo::getAutomate() const
{
	return m_iAutomate;
}

void CvAutomateInfo::setAutomate(int i)
{
	m_iAutomate = i;
}

bool CvAutomateInfo::getConfirmCommand() const
{
	return m_bConfirmCommand;
}

bool CvAutomateInfo::getVisible() const
{
	return m_bVisible;
}

bool CvAutomateInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Command");
	setCommand(pXML->FindInInfoClass(szTextVal));

	pXML->GetChildXmlValByName(szTextVal, "Automate");
	setAutomate(GC.getTypesEnum(szTextVal));

	pXML->GetChildXmlValByName(&m_bConfirmCommand, "bConfirmCommand");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAutomateInfo::copyNonDefaults(CvAutomateInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getCommand()		== NO_COMMAND)		setCommand(			pClassInfo->getCommand());
	if (getAutomate()		== NO_AUTOMATE)		setAutomate(		pClassInfo->getAutomate());
	if (getConfirmCommand()	== false)			m_bConfirmCommand	= pClassInfo->getConfirmCommand();
	if (getVisible()		== false)			m_bVisible			= pClassInfo->getVisible();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvActionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvActionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvActionInfo::CvActionInfo() :
m_iOriginalIndex(-1),
m_eSubType(NO_ACTIONSUBTYPE)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvActionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvActionInfo::~CvActionInfo()
{
}

int CvActionInfo::getMissionData() const
{

	if	(
				(ACTIONSUBTYPE_BUILD == m_eSubType)				||
				(ACTIONSUBTYPE_RELIGION == m_eSubType)		||
				(ACTIONSUBTYPE_CORPORATION == m_eSubType)		||
				(ACTIONSUBTYPE_SPECIALIST == m_eSubType)	||
				(ACTIONSUBTYPE_BUILDING == m_eSubType)
			)
	{
		return m_iOriginalIndex;
	}

	return -1;
}

int CvActionInfo::getCommandData() const
{

	if	(
				(ACTIONSUBTYPE_PROMOTION == m_eSubType)	||
				(ACTIONSUBTYPE_UNIT == m_eSubType)

//FfH Spell System: Added by Kael 07/23/2007
				|| (ACTIONSUBTYPE_SPELL == m_eSubType)
//FfH: End Add

			)
	{
		return m_iOriginalIndex;
	}
	else if (ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getAutomate();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getAutomate();
	}

	return -1;
}

int CvActionInfo::getAutomateType() const
{

	if (ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getAutomate();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getAutomate();
	}

	return NO_AUTOMATE;
}

int CvActionInfo::getInterfaceModeType() const
{
	if (ACTIONSUBTYPE_INTERFACEMODE == m_eSubType)
	{
		return m_iOriginalIndex;
	}
	//TargetedSpell 0924 blackimp
	if (ACTIONSUBTYPE_SPELL == m_eSubType)
	{
		if (GC.getSpellInfo((SpellTypes)m_iOriginalIndex).isTargeted())
		{
			return INTERFACEMODE_TARGETED_SPELL;
		}
	}
	return NO_INTERFACEMODE;
}

int CvActionInfo::getMissionType() const
{
	if (ACTIONSUBTYPE_BUILD == m_eSubType)
	{
		return GC.getBuildInfo((BuildTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_RELIGION == m_eSubType)
	{
		return GC.getReligionInfo((ReligionTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_CORPORATION == m_eSubType)
	{
		return GC.getCorporationInfo((CorporationTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_SPECIALIST == m_eSubType)
	{
		return GC.getSpecialistInfo((SpecialistTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_BUILDING == m_eSubType)
	{
		return GC.getBuildingInfo((BuildingTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_MISSION == m_eSubType)
	{
		return m_iOriginalIndex;
	}

	return NO_MISSION;
}

int CvActionInfo::getCommandType() const
{
	if (ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return m_iOriginalIndex;
	}
	else if (ACTIONSUBTYPE_PROMOTION == m_eSubType)
	{
		return GC.getPromotionInfo((PromotionTypes)m_iOriginalIndex).getCommandType();
	}
	else if (ACTIONSUBTYPE_UNIT == m_eSubType)
	{
		return GC.getUnitInfo((UnitTypes)m_iOriginalIndex).getCommandType();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getCommand();
	}

//FfH Spell System: Added by Kael 07/23/2007
	else if (ACTIONSUBTYPE_SPELL == m_eSubType )
	{
		return GC.getSpellInfo((SpellTypes)m_iOriginalIndex).getCommandType();
	}
//FfH: End Add

	return NO_COMMAND;
}

int CvActionInfo::getControlType() const
{
	if (ACTIONSUBTYPE_CONTROL == m_eSubType)
	{
		return m_iOriginalIndex;
	}
	return -1;
}

int CvActionInfo::getOriginalIndex() const
{
	return m_iOriginalIndex;
}

void CvActionInfo::setOriginalIndex(int i)
{
	m_iOriginalIndex = i;
}

bool CvActionInfo::isConfirmCommand() const
{
	if	(ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getConfirmCommand();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getConfirmCommand();
	}

	return false;
}

bool CvActionInfo::isVisible() const
{

	if (ACTIONSUBTYPE_CONTROL == m_eSubType)
	{
		return false;
	}
	else if	(ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getVisible();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getVisible();
	}
	else if (ACTIONSUBTYPE_MISSION == m_eSubType)
	{
		return GC.getMissionInfo((MissionTypes)m_iOriginalIndex).getVisible();
	}
	else if (ACTIONSUBTYPE_INTERFACEMODE== m_eSubType)
	{
		return GC.getInterfaceModeInfo((InterfaceModeTypes)m_iOriginalIndex).getVisible();
	}

	return true;
}

ActionSubTypes CvActionInfo::getSubType() const
{
	return m_eSubType;
}

void CvActionInfo::setSubType(ActionSubTypes eSubType)
{
	m_eSubType = eSubType;
}

CvHotkeyInfo* CvActionInfo::getHotkeyInfo() const
{
	switch (getSubType())
	{
		case ACTIONSUBTYPE_INTERFACEMODE:
			return &GC.getInterfaceModeInfo((InterfaceModeTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_COMMAND:
			return &GC.getCommandInfo((CommandTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_BUILD:
			return &GC.getBuildInfo((BuildTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_PROMOTION:
			return &GC.getPromotionInfo((PromotionTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_UNIT:
			return &GC.getUnitInfo((UnitTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_RELIGION:
			return &GC.getReligionInfo((ReligionTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_CORPORATION:
			return &GC.getCorporationInfo((CorporationTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_SPECIALIST:
			return &GC.getSpecialistInfo((SpecialistTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_BUILDING:
			return &GC.getBuildingInfo((BuildingTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_CONTROL:
			return &GC.getControlInfo((ControlTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_AUTOMATE:
			return &GC.getAutomateInfo(getOriginalIndex());
			break;

//FfH Spell System: Added by Kael 07/23/2007
		case ACTIONSUBTYPE_SPELL:
			return &GC.getSpellInfo((SpellTypes)getOriginalIndex());
			break;
//FfH: End Add

		case ACTIONSUBTYPE_MISSION:
			return &GC.getMissionInfo((MissionTypes)getOriginalIndex());
			break;
	}

	FAssertMsg((0) ,"Unknown Action Subtype in CvActionInfo::getHotkeyInfo");
	return NULL;
}

const TCHAR* CvActionInfo::getType() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getType();
	}

	return NULL;
}

const wchar* CvActionInfo::getDescription() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getDescription();
	}

	return L"";
}

const wchar* CvActionInfo::getCivilopedia() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getCivilopedia();
	}

	return L"";
}

const wchar* CvActionInfo::getHelp() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHelp();
	}

	return L"";
}

const wchar* CvActionInfo::getStrategy() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getStrategy();
	}

	return L"";
}

const TCHAR* CvActionInfo::getButton() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getButton();
	}

	return NULL;
}

const wchar* CvActionInfo::getTextKeyWide() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getTextKeyWide();
	}

	return NULL;
}

int CvActionInfo::getActionInfoIndex() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getActionInfoIndex();
	}

	return -1;
}

int CvActionInfo::getHotKeyVal() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyVal();
	}

	return -1;
}

int CvActionInfo::getHotKeyPriority() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyPriority();
	}

	return -1;
}

int CvActionInfo::getHotKeyValAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyValAlt();
	}

	return -1;
}

int CvActionInfo::getHotKeyPriorityAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyPriorityAlt();
	}

	return -1;
}

int CvActionInfo::getOrderPriority() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getOrderPriority();
	}

	return -1;
}

bool CvActionInfo::isAltDown() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isAltDown();
	}

	return false;
}

bool CvActionInfo::isShiftDown() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isShiftDown();
	}

	return false;
}

bool CvActionInfo::isCtrlDown() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isCtrlDown();
	}

	return false;
}

bool CvActionInfo::isAltDownAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isAltDownAlt();
	}

	return false;
}

bool CvActionInfo::isShiftDownAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isShiftDownAlt();
	}

	return false;
}

bool CvActionInfo::isCtrlDownAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isCtrlDownAlt();
	}

	return false;
}

const TCHAR* CvActionInfo::getHotKey() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKey();
	}

	return NULL;
}

std::wstring CvActionInfo::getHotKeyDescription() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyDescription();
	}

	return L"";
}

//======================================================================================================
//					CvUnitInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvUnitInfo::CvUnitInfo() :
m_iAIWeight(0),
m_iProductionCost(0),
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**								Modifies Cost based on Population								**/
/*************************************************************************************************/
m_iCityPopCostModifier(0),
m_iEmpirePopCostModifier(0),
m_iNumCityCostModifier(0),
m_iPlayerPopCostModifier(0),
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
m_bNonInfluence(false),
m_bInfluence(false),
m_iVictoryInfluenceModifier(100),
m_iDefeatInfluenceModifier(100),
m_iPillageInfluenceModifier(100),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
m_iExtraPerception(0),
m_iInvisibleLevel(0),
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
m_iHurryCostModifier(0),
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iMinAreaSize(0),
m_iMoves(0),
m_iAirRange(0),
m_iAirUnitCap(0),
m_iDropRange(0),
m_iNukeRange(0),
m_iWorkRate(0),
m_iBaseDiscover(0),
m_iDiscoverMultiplier(0),
m_iBaseHurry(0),
m_iHurryMultiplier(0),
m_iBaseTrade(0),
m_iTradeMultiplier(0),
m_iGreatWorkCulture(0),
m_iEspionagePoints(0),
m_iCombat(0),
m_iCombatLimit(0),
m_iAirCombat(0),
m_iAirCombatLimit(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iXPValueAttack(0),
m_iXPValueDefense(0),
/**								----  End Original Code  ----									**/
m_iXPValueAttack(0.0f),
m_iXPValueDefense(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iFirstStrikes(0),
m_iChanceFirstStrikes(0),
m_iInterceptionProbability(0),
m_iEvasionProbability(0),
m_iWithdrawalProbability(0),
m_iEnemyWithdrawalProbability(0),
m_iCollateralDamage(0),
m_iCollateralDamageLimit(0),
m_iCollateralDamageMaxUnits(0),

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
m_iFlankingDamage(0),
m_iFlankingDamageLimit(0),
m_iFlankingDamageMaxUnits(0),
/*************************************************************************************************/
/**	Updated Flanking							END												**/
/*************************************************************************************************/
m_iCityAttackModifier(0),
m_iCityDefenseModifier(0),
m_iAnimalCombatModifier(0),
m_iHillsAttackModifier(0),
m_iHillsDefenseModifier(0),
m_iBombRate(0),
m_iBombardRate(0),
m_iSpecialCargo(0),
m_iDomainCargo(0),
m_iCargoSpace(0),
m_iConscriptionValue(0),
m_iCultureGarrisonValue(0),
m_iExtraCost(0),
m_iAssetValue(0),
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iPowerValue(0),
/**								----  End Original Code  ----									**/
m_iPowerAdd(0),
m_iPowerMult(0),
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/

m_iUnitClassType(NO_UNITCLASS),
m_iSecondaryUnitClassType(NO_UNITCLASS),
m_iSpecialUnitType(NO_SPECIALUNIT),
m_iUnitCaptureClassType(NO_UNITCLASS),
m_iUnitCombatType(NO_UNITCOMBAT),
m_iDomainType(NO_DOMAIN),
m_iDefaultUnitAIType(NO_UNITAI),
/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iInvisibleType(NO_INVISIBLE),
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
m_iAdvisorType(NO_ADVISOR),
m_iHolyCity(NO_RELIGION),
m_iReligionType(NO_RELIGION),
m_iStateReligion(NO_RELIGION),
m_iPrereqReligion(NO_RELIGION),
m_iPrereqCorporation(NO_CORPORATION),
m_iPrereqBuilding(NO_BUILDING),
m_iPrereqAndTech(NO_TECH),
m_iPrereqAndBonus(NO_BONUS),
m_iGroupSize(0),
m_iGroupDefinitions(0),
m_iUnitMeleeWaveSize(0),
m_iUnitRangedWaveSize(0),
m_iNumUnitNames(0),
m_iCommandType(NO_COMMAND),
m_bAnimal(false),
m_bFoodProduction(false),
m_bNoBadGoodies(false),
m_bOnlyDefensive(false),
m_bNoCapture(false),
m_bImmuneToCapture(false),
m_bQuickCombat(false),
m_bRivalTerritory(false),
m_bMilitaryHappiness(false),
m_bMilitarySupport(false),
m_bMilitaryProduction(false),
m_bPillage(false),
m_bReligiousCommander(false), //ReligiousCommander by BI 07/24/11
m_bSpy(false),
m_bSabotage(false),
m_bDestroy(false),
m_bStealPlans(false),
m_bInvestigate(false),
m_bCounterSpy(false),
m_bFound(false),
m_bGoldenAge(false),
m_bInvisible(false),
m_bFirstStrikeImmune(false),
m_bNoDefensiveBonus(false),
m_bIgnoreBuildingDefense(false),
m_bCanMoveImpassable(false),
m_bCanMoveAllTerrain(false),
m_bFlatMovementCost(false),
m_bIgnoreTerrainCost(false),
m_bNukeImmune(false),
m_bPrereqBonuses(false),
m_bPrereqReligion(false),
m_bMechanized(false),
m_bRenderBelowWater(false),
m_bRenderAlways(false),
m_bSuicide(false),
m_bLineOfSight(false),
m_bHiddenNationality(false),
m_bAlwaysHostile(false),
m_bNoRevealMap(false),
m_fUnitMaxSpeed(0.0f),
m_fUnitPadTime(0.0f),
/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
m_iNumUpgradeUnitClass(0),
m_piUpgradeUnitClass(NULL),
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/
m_pbTargetUnitClass(NULL),
m_pbTargetUnitCombat(NULL),
m_pbDefenderUnitClass(NULL),
m_pbDefenderUnitCombat(NULL),
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
// Old: m_piFlankingStrikeUnitClass(NULL),
m_piFlankingStrikeUnitCombat(NULL),
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
m_pbUnitAIType(NULL),
m_pbNotUnitAIType(NULL),
m_pbBuilds(NULL),
m_piReligionSpreads(NULL),
m_piCorporationSpreads(NULL),
m_piTerrainPassableTech(NULL),
m_piFeaturePassableTech(NULL),
m_pbGreatPeoples(NULL),
m_pbBuildings(NULL),
m_pbForceBuildings(NULL),
m_pbTerrainImpassable(NULL),
m_pbFeatureImpassable(NULL),
m_piPrereqAndTechs(NULL),
m_piPrereqOrBonuses(NULL),
m_piProductionTraits(NULL),
m_piFlavorValue(NULL),
m_piTerrainAttackModifier(NULL),
m_piTerrainDefenseModifier(NULL),
m_piFeatureAttackModifier(NULL),
m_piFeatureDefenseModifier(NULL),
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvUnitInfo
m_iUnitPeakCost(0),
m_iUnitHillCost(0),
m_piUnitTerrainCost(NULL),
m_piUnitFeatureCost(NULL),
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
m_piUnitClassAttackModifier(NULL),
m_piUnitClassDefenseModifier(NULL),
m_piUnitCombatModifier(NULL),
m_piUnitCombatCollateralImmune(NULL),
m_piDomainModifier(NULL),
m_piBonusProductionModifier(NULL),
m_piUnitGroupRequired(NULL),
m_pbTerrainNative(NULL),
m_pbFeatureNative(NULL),

/*************************************************************************************************/
/**	JRouteNative by Jeckel		imported by Valkrionn	09.28.09                        		**/
/*************************************************************************************************/
m_pbRouteNative(NULL),
m_pbRouteImpassable(NULL),
m_pbRouteIgnore(NULL),
m_piRouteSubstitute(NULL),
/*************************************************************************************************/
/**	JRouteNative    END                                                                   		**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
/**										Start Original Code										**
m_pbFreePromotions(NULL),
/**										End Original Code										**/
m_piFreePromotions(NULL),
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
m_paszEarlyArtDefineTags(NULL),
m_paszLateArtDefineTags(NULL),
m_paszMiddleArtDefineTags(NULL),
m_paszUnitNames(NULL),

/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iCommandLimit(0),
m_iCommandRange(0),
m_bFreeUnit(false),
m_bNoSupply(false),
m_bCommunalProperty(false),
m_bNeverHostile(false),
m_bBlind(false),
m_bJoinPop(false),
m_piYieldFromKill(NULL),
m_piCommerceFromKill(NULL),
m_iPrereqBroadAlignment(0),
m_iAlignmentModifier(0),
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
m_iAlignmentShift(0),
m_iAlignmentShiftModifier(0),
m_iAlignmentShiftTowardsNeutral(-1),
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
m_iLeaderExperience(0.0f),
m_bCanClimbPeaks(false),
m_pbAllowPromotion(NULL),
m_pbDenyPromotion(NULL),
m_szPyPerTurn(NULL),
m_iNumQuotes(0),
m_paszQuotes(NULL),
m_szQuote(NULL),
m_iNumImages(0),
m_paszImages(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
m_iAppearanceProb(0),
m_piAppearanceTechs(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Units: Added by Kael 08/04/2007
m_bAbandon(false),
m_bAutoRaze(false),
m_bDisableUpgradeTo(false),
m_bExplodeInCombat(false),
m_bFreeXP(false),
m_bImmortal(false),
m_bImmuneToDefensiveStrike(false),
m_bNeverObsolete(false),
m_bNoWarWeariness(false),
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
m_bPromotionBuild(false),
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
m_iCombatDefense(0),
m_iDefensiveStrikeChance(0),
m_iDefensiveStrikeDamage(0),
m_iDurationFromCombat(0),
m_iEnslavementChance(0),
m_iFreePromotionPick(0),
m_iGoldFromCombat(0),
m_iMinLevel(0),
m_iPopCost(0),
m_iMiscastChance(0),
m_iModifyGlobalCounter(0),
m_iDiploVoteType(NO_VOTESOURCE),
m_iEquipmentPromotion(NO_PROMOTION),
m_iPrereqAlignment(NO_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iPrereqBroadEthicalAlignment(0),
m_iEthicalAlignmentModifier(0),
m_iEthicalAlignmentShift(0),
m_iEthicalAlignmentShiftModifier(0),
m_iEthicalAlignmentShiftTowardsNeutral(-1),
m_iPrereqEthicalAlignment(NO_ETHICAL_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iPrereqBuildingClass(NO_BUILDINGCLASS),
m_iPrereqCivic(NO_CIVIC),
m_iPrereqGlobalCounter(0),
m_iPromotionFromCombat(NO_PROMOTION),
m_iTier(0),
m_iUnitConvertFromCombat(NO_UNIT),
m_iUnitConvertFromCombatChance(0),
m_iUnitCreateFromCombat(NO_UNIT),
m_iUnitCreateFromCombatChance(0),
m_iUpgradeCiv(NO_CIVILIZATION),
/*************************************************************************************************/
/**	Xienwolf Tweak							11/03/08											**/
/**																								**/
/**							Allows for Multiple sets of WeaponTiers								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iWeaponTier(0),
/**								----  End Original Code  ----									**/
m_iWeaponTierMax(0),
m_iWeaponTierMin(0),
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
m_iWithdrawlProbDefensive(0),
m_piBonusAffinity(NULL),
m_piDamageTypeCombat(NULL),
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
m_iNumAffinities(0),
m_piAffinities(NULL),
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
m_szImage(NULL),
//FfH: End Add
//Magic Rework
m_iMagicalPower(0)
//m_iDominionCapacity(0),
//m_piSpellClassExtraPower(NULL)

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvUnitInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvUnitInfo::~CvUnitInfo()
{

//FfH Damage Types: Added by Kael 08/23/2007
	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
//FfH: End Add
/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	SAFE_DELETE_ARRAY(m_pbUpgradeUnitClass);
/**								----  End Original Code  ----									**/
	SAFE_DELETE_ARRAY(m_piUpgradeUnitClass);
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbTargetUnitClass);
	SAFE_DELETE_ARRAY(m_pbTargetUnitCombat);
	SAFE_DELETE_ARRAY(m_pbDefenderUnitClass);
	SAFE_DELETE_ARRAY(m_pbDefenderUnitCombat);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	// Old: SAFE_DELETE_ARRAY(m_piFlankingStrikeUnitClass);
	SAFE_DELETE_ARRAY(m_piFlankingStrikeUnitCombat);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbUnitAIType);
	SAFE_DELETE_ARRAY(m_pbNotUnitAIType);
	SAFE_DELETE_ARRAY(m_pbBuilds);
	SAFE_DELETE_ARRAY(m_piReligionSpreads);
	SAFE_DELETE_ARRAY(m_piCorporationSpreads);
	SAFE_DELETE_ARRAY(m_piTerrainPassableTech);
	SAFE_DELETE_ARRAY(m_piFeaturePassableTech);
	SAFE_DELETE_ARRAY(m_pbGreatPeoples);
	SAFE_DELETE_ARRAY(m_pbBuildings);
	SAFE_DELETE_ARRAY(m_pbForceBuildings);
	SAFE_DELETE_ARRAY(m_pbTerrainImpassable);
	SAFE_DELETE_ARRAY(m_pbFeatureImpassable);
	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	SAFE_DELETE_ARRAY(m_piProductionTraits);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piTerrainAttackModifier);
	SAFE_DELETE_ARRAY(m_piTerrainDefenseModifier);
	SAFE_DELETE_ARRAY(m_piFeatureAttackModifier);
	SAFE_DELETE_ARRAY(m_piFeatureDefenseModifier);
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvUnitInfo
	SAFE_DELETE_ARRAY(m_piUnitTerrainCost);
	SAFE_DELETE_ARRAY(m_piUnitFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piUnitClassAttackModifier);
	SAFE_DELETE_ARRAY(m_piUnitClassDefenseModifier);
	SAFE_DELETE_ARRAY(m_piUnitCombatModifier);
	SAFE_DELETE_ARRAY(m_piUnitCombatCollateralImmune);
	SAFE_DELETE_ARRAY(m_piDomainModifier);
	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	SAFE_DELETE_ARRAY(m_piUnitGroupRequired);
/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piYieldFromKill);
	SAFE_DELETE_ARRAY(m_piCommerceFromKill);
	SAFE_DELETE_ARRAY(m_pbAllowPromotion);
	SAFE_DELETE_ARRAY(m_pbDenyPromotion);
	SAFE_DELETE_ARRAY(m_paszQuotes);
	SAFE_DELETE_ARRAY(m_paszImages);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAppearanceTechs);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbTerrainNative);
	SAFE_DELETE_ARRAY(m_pbFeatureNative);

/*************************************************************************************************/
/**	JRouteNative by Jeckel		imported by Valkrionn	09.28.09                        		**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbRouteNative);
	SAFE_DELETE_ARRAY(m_pbRouteImpassable);
	SAFE_DELETE_ARRAY(m_pbRouteIgnore);
	SAFE_DELETE_ARRAY(m_piRouteSubstitute);
/*************************************************************************************************/
/**	JRouteNative    END                                                                   		**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
/**										Start Original Code										**
	SAFE_DELETE_ARRAY(m_pbFreePromotions);
/**										End Original Code										**/
	SAFE_DELETE_ARRAY(m_piFreePromotions);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paszEarlyArtDefineTags);
	SAFE_DELETE_ARRAY(m_paszLateArtDefineTags);
	SAFE_DELETE_ARRAY(m_paszMiddleArtDefineTags);
	SAFE_DELETE_ARRAY(m_paszUnitNames);
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAffinities);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	//Magic Rework
	//SAFE_DELETE_ARRAY(m_piSpellClassExtraPower);

}

int CvUnitInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvUnitInfo::getProductionCost() const
{
	return m_iProductionCost;
}

/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**								Modifies Cost based on Population								**/
/*************************************************************************************************/
int CvUnitInfo::getCityPopCostModifier() const								{return m_iCityPopCostModifier;}
int CvUnitInfo::getEmpirePopCostModifier() const							{return m_iEmpirePopCostModifier;}
int CvUnitInfo::getNumCityCostModifier() const								{return m_iNumCityCostModifier;}
int CvUnitInfo::getPlayerPopCostModifier() const							{return m_iPlayerPopCostModifier;}
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/

/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
bool CvUnitInfo::isNonInfluence() const
{
	return m_bNonInfluence;
}

bool CvUnitInfo::isInfluence() const
{
	return m_bInfluence;
}

int CvUnitInfo::getVictoryInfluenceModifier() const
{
	return m_iVictoryInfluenceModifier;
}

int CvUnitInfo::getDefeatInfluenceModifier() const
{
	return m_iDefeatInfluenceModifier;
}

int CvUnitInfo::getPillageInfluenceModifier() const
{
	return m_iPillageInfluenceModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
int CvUnitInfo::getExtraPerception() const									{return m_iExtraPerception;}
int CvUnitInfo::getInvisibleLevel() const { return m_iInvisibleLevel; }
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

int CvUnitInfo::getHurryCostModifier() const
{
	return m_iHurryCostModifier;
}

int CvUnitInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvUnitInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvUnitInfo::getMinAreaSize() const
{
	return m_iMinAreaSize;
}

int CvUnitInfo::getMoves() const
{
	return m_iMoves;
}

int CvUnitInfo::getAirRange() const
{
	return m_iAirRange;
}

int CvUnitInfo::getAirUnitCap() const
{
	return m_iAirUnitCap;
}

int CvUnitInfo::getDropRange() const
{
	return m_iDropRange;
}

int CvUnitInfo::getNukeRange() const
{
	return m_iNukeRange;
}

int CvUnitInfo::getWorkRate() const
{
	return m_iWorkRate;
}

int CvUnitInfo::getBaseDiscover() const
{
	return m_iBaseDiscover;
}

int CvUnitInfo::getDiscoverMultiplier() const
{
	return m_iDiscoverMultiplier;
}

int CvUnitInfo::getBaseHurry() const
{
	return m_iBaseHurry;
}

int CvUnitInfo::getHurryMultiplier() const
{
	return m_iHurryMultiplier;
}

int CvUnitInfo::getBaseTrade() const
{
	return m_iBaseTrade;
}

int CvUnitInfo::getTradeMultiplier() const
{
	return m_iTradeMultiplier;
}

int CvUnitInfo::getGreatWorkCulture() const
{
	return m_iGreatWorkCulture;
}

int CvUnitInfo::getEspionagePoints() const
{
	return m_iEspionagePoints;
}

int CvUnitInfo::getCombat() const
{
	return m_iCombat;
}

void CvUnitInfo::setCombat(int iNum)
{
	m_iCombat = iNum;
}

int CvUnitInfo::getCombatLimit() const
{
/*************************************************************************************************/
/**	Higher hitpoints				28/01/11				Imported from wiser orcs by Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iCombatLimit;
/**								----  End Original Code  ----									**/
	return m_iCombatLimit * GC.getDefineINT("HIT_POINT_FACTOR"); // Wiser Orcs - Allow diffierent maximum HP for combat to work correctly.
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
}

int CvUnitInfo::getAirCombat() const
{
	return m_iAirCombat;
}

int CvUnitInfo::getAirCombatLimit() const
{
	return m_iAirCombatLimit;
}

int CvUnitInfo::getXPValueAttack() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iXPValueAttack;
/**								----  End Original Code  ----									**/
	return (int)(m_iXPValueAttack*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvUnitInfo::getXPValueDefense() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iXPValueDefense;
/**								----  End Original Code  ----									**/
	return (int)(m_iXPValueDefense*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvUnitInfo::getFirstStrikes() const
{
	return m_iFirstStrikes;
}

int CvUnitInfo::getChanceFirstStrikes() const
{
	return m_iChanceFirstStrikes;
}

int CvUnitInfo::getInterceptionProbability() const
{
	return m_iInterceptionProbability;
}

int CvUnitInfo::getEvasionProbability() const
{
	return m_iEvasionProbability;
}

int CvUnitInfo::getWithdrawalProbability() const
{
	return m_iWithdrawalProbability;
}

int CvUnitInfo::getEnemyWithdrawalProbability() const
{
	return m_iEnemyWithdrawalProbability;
}
int CvUnitInfo::getCollateralDamage() const
{
	return m_iCollateralDamage;
}

int CvUnitInfo::getCollateralDamageLimit() const
{
	return m_iCollateralDamageLimit;
}

int CvUnitInfo::getCollateralDamageMaxUnits() const
{
	return m_iCollateralDamageMaxUnits;
}
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/

int CvUnitInfo::getFlankingDamage() const
{
	return m_iFlankingDamage;
}

int CvUnitInfo::getFlankingDamageLimit() const
{
	return m_iFlankingDamageLimit;
}

int CvUnitInfo::getFlankingDamageMaxUnits() const
{
	return m_iFlankingDamageMaxUnits;
}
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

int CvUnitInfo::getCityAttackModifier() const
{
	return m_iCityAttackModifier;
}

int CvUnitInfo::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

int CvUnitInfo::getAnimalCombatModifier() const
{
	return m_iAnimalCombatModifier;
}

int CvUnitInfo::getHillsAttackModifier() const
{
	return m_iHillsAttackModifier;
}

int CvUnitInfo::getHillsDefenseModifier() const
{
	return m_iHillsDefenseModifier;
}

int CvUnitInfo::getBombRate() const
{
	return m_iBombRate;
}

int CvUnitInfo::getBombardRate() const
{
	return m_iBombardRate;
}

int CvUnitInfo::getSpecialCargo() const
{
	return m_iSpecialCargo;
}

int CvUnitInfo::getDomainCargo() const
{
	return m_iDomainCargo;
}

int CvUnitInfo::getCargoSpace() const
{
	return m_iCargoSpace;
}

int CvUnitInfo::getConscriptionValue() const
{
	return m_iConscriptionValue;
}

int CvUnitInfo::getCultureGarrisonValue() const
{
	return m_iCultureGarrisonValue;
}

int CvUnitInfo::getExtraCost() const
{
	return m_iExtraCost;
}

int CvUnitInfo::getAssetValue() const
{
	return m_iAssetValue;
}
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvUnitInfo::getPowerValue() const
{
	return m_iPowerValue;
}
/**								----  End Original Code  ----									**/
int CvUnitInfo::getPowerAdd() const
{
	return m_iPowerAdd;
}
int CvUnitInfo::getPowerMult() const
{
	return m_iPowerMult;
}
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/


int CvUnitInfo::getUnitClassType() const
{
	return m_iUnitClassType;
}

int CvUnitInfo::getSecondaryUnitClassType() const
{
	return m_iSecondaryUnitClassType;
}

int CvUnitInfo::getSpecialUnitType() const
{
	return m_iSpecialUnitType;
}

int CvUnitInfo::getUnitCaptureClassType() const
{
	return m_iUnitCaptureClassType;
}

int CvUnitInfo::getUnitCombatType() const
{
	return m_iUnitCombatType;
}

int CvUnitInfo::getDomainType() const
{
	return m_iDomainType;
}

int CvUnitInfo::getDefaultUnitAIType() const
{
	return m_iDefaultUnitAIType;
}

/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvUnitInfo::getInvisibleType() const
{
	return m_iInvisibleType;
}
/**								----  End Original Code  ----									**/
int CvUnitInfo::getInvisibleType(int i) const
{
	FAssert(i < (int)m_aiInvisibleTypes.size());
	return m_aiInvisibleTypes[i];
}
int CvUnitInfo::getNumInvisibleTypes() const    {return (int)m_aiInvisibleTypes.size();}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

int CvUnitInfo::getSeeInvisibleType(int i) const
{
	FAssert(i < (int)m_aiSeeInvisibleTypes.size());

	return m_aiSeeInvisibleTypes[i];
}

int CvUnitInfo::getNumSeeInvisibleTypes() const
{
	return (int)m_aiSeeInvisibleTypes.size();
}

int CvUnitInfo::getAdvisorType() const
{
	return m_iAdvisorType;
}

int CvUnitInfo::getHolyCity() const
{
	return m_iHolyCity;
}

int CvUnitInfo::getReligionType() const
{
	return m_iReligionType;
}

int CvUnitInfo::getStateReligion() const
{
	return m_iStateReligion;
}

int CvUnitInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}

int CvUnitInfo::getPrereqCorporation() const
{
	return m_iPrereqCorporation;
}

int CvUnitInfo::getPrereqBuilding() const
{
	return m_iPrereqBuilding;
}

int CvUnitInfo::getPrereqAndTech() const
{
	return m_iPrereqAndTech;
}

int CvUnitInfo::getPrereqAndBonus() const
{
	return m_iPrereqAndBonus;
}

int CvUnitInfo::getGroupSize() const// the initial number of individuals in the unit group
{
	return m_iGroupSize;
}

int CvUnitInfo::getGroupDefinitions() const// the number of UnitMeshGroups for this unit
{
	return m_iGroupDefinitions;
}

int CvUnitInfo::getMeleeWaveSize() const
{
	return m_iUnitMeleeWaveSize;
}

int CvUnitInfo::getRangedWaveSize() const
{
	return m_iUnitRangedWaveSize;
}

int CvUnitInfo::getNumUnitNames() const
{
	return m_iNumUnitNames;
}

bool CvUnitInfo::isAnimal() const
{
	return m_bAnimal;
}

bool CvUnitInfo::isFoodProduction() const
{
	return m_bFoodProduction;
}

bool CvUnitInfo::isNoBadGoodies() const
{
	return m_bNoBadGoodies;
}

bool CvUnitInfo::isOnlyDefensive() const
{
	return m_bOnlyDefensive;
}

bool CvUnitInfo::isCannotCapture() const
{
	return m_bNoCapture;
}

bool CvUnitInfo::isImmuneToCapture() const
{
	return m_bImmuneToCapture;
}

bool CvUnitInfo::isQuickCombat() const
{
	return m_bQuickCombat;
}

bool CvUnitInfo::isRivalTerritory() const
{
	return m_bRivalTerritory;
}

bool CvUnitInfo::isMilitaryHappiness() const
{
	return m_bMilitaryHappiness;
}

bool CvUnitInfo::isMilitarySupport() const
{
	return m_bMilitarySupport;
}

bool CvUnitInfo::isMilitaryProduction() const
{
	return m_bMilitaryProduction;
}

bool CvUnitInfo::isPillage() const
{
	return m_bPillage;
}

// ReligiousCommander by BI 07/24/11
bool CvUnitInfo::isReligiousCommander() const
{
	return m_bReligiousCommander;
}

bool CvUnitInfo::isSpy() const
{
	return m_bSpy;
}

bool CvUnitInfo::isSabotage() const
{
	return m_bSabotage;
}

bool CvUnitInfo::isDestroy() const
{
	return m_bDestroy;
}

bool CvUnitInfo::isStealPlans() const
{
	return m_bStealPlans;
}

bool CvUnitInfo::isInvestigate() const
{
	return m_bInvestigate;
}

bool CvUnitInfo::isCounterSpy() const
{
	return m_bCounterSpy;
}

bool CvUnitInfo::isFound() const
{
	return m_bFound;
}

bool CvUnitInfo::isGoldenAge() const
{
	return m_bGoldenAge;
}

bool CvUnitInfo::isInvisible() const
{
	return m_bInvisible;
}

void CvUnitInfo::setInvisible(bool bEnable)
{
	m_bInvisible = bEnable;
}

bool CvUnitInfo::isFirstStrikeImmune() const
{
	return m_bFirstStrikeImmune;
}

bool CvUnitInfo::isNoDefensiveBonus() const
{
	return m_bNoDefensiveBonus;
}

bool CvUnitInfo::isIgnoreBuildingDefense() const
{
	return m_bIgnoreBuildingDefense;
}

bool CvUnitInfo::isCanMoveImpassable() const
{
	return m_bCanMoveImpassable;
}

bool CvUnitInfo::isCanMoveAllTerrain() const
{
	return m_bCanMoveAllTerrain;
}

bool CvUnitInfo::isFlatMovementCost() const
{
	return m_bFlatMovementCost;
}

bool CvUnitInfo::isIgnoreTerrainCost() const
{
	return m_bIgnoreTerrainCost;
}

bool CvUnitInfo::isNukeImmune() const
{
	return m_bNukeImmune;
}

bool CvUnitInfo::isPrereqBonuses() const
{
	return m_bPrereqBonuses;
}

bool CvUnitInfo::isPrereqReligion() const
{
	return m_bPrereqReligion;
}

bool CvUnitInfo::isMechUnit() const
{
	return m_bMechanized;
}

bool CvUnitInfo::isRenderBelowWater() const
{
	return m_bRenderBelowWater;
}

bool CvUnitInfo::isRenderAlways() const
{
	return m_bRenderAlways;
}

bool CvUnitInfo::isSuicide() const
{
	return m_bSuicide;
}

bool CvUnitInfo::isLineOfSight() const
{
	return m_bLineOfSight;
}

bool CvUnitInfo::isHiddenNationality() const
{
	return m_bHiddenNationality;
}

bool CvUnitInfo::isAlwaysHostile() const
{
	return m_bAlwaysHostile;
}

bool CvUnitInfo::isNoRevealMap() const
{
	return m_bNoRevealMap;
}

float CvUnitInfo::getUnitMaxSpeed() const
{
	return m_fUnitMaxSpeed;
}

float CvUnitInfo::getUnitPadTime() const
{
	return m_fUnitPadTime;
}

int CvUnitInfo::getCommandType() const
{
	return m_iCommandType;
}

void CvUnitInfo::setCommandType(int iNewType)
{
	m_iCommandType = iNewType;
}

/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvUnitInfo::getCommandLimit() const							{return m_iCommandLimit;}
int CvUnitInfo::getCommandRange() const							{return m_iCommandRange;}
bool CvUnitInfo::isFreeUnit() const								{return m_bFreeUnit;}
bool CvUnitInfo::isNoSupply() const								{return m_bNoSupply;}
bool CvUnitInfo::isCommunalProperty() const						{return m_bCommunalProperty;}
bool CvUnitInfo::isNeverHostile() const							{return m_bNeverHostile;}
bool CvUnitInfo::isBlind() const								{return m_bBlind;}
bool CvUnitInfo::isJoinPop() const { return m_bJoinPop; }

int CvUnitInfo::getPrereqBroadAlignment() const					{return m_iPrereqBroadAlignment;}
int CvUnitInfo::getAlignmentModifier() const					{return m_iAlignmentModifier;}
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
int CvUnitInfo::getAlignmentShift() const                          {return m_iAlignmentShift;}
int CvUnitInfo::getAlignmentShiftModifier() const                  {return m_iAlignmentShiftModifier;}
int CvUnitInfo::getAlignmentShiftTowardsNeutral() const            {return m_iAlignmentShiftTowardsNeutral;}
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
const TCHAR *CvUnitInfo::getPyPerTurn() const					{return m_szPyPerTurn;}
int CvUnitInfo::getYieldFromKill(int i) const					{return m_piYieldFromKill ? m_piYieldFromKill[i] : -1;}
int CvUnitInfo::getCommerceFromKill(int i) const				{return m_piCommerceFromKill ? m_piCommerceFromKill[i] : -1;}
bool CvUnitInfo::isCanClimbPeaks() const
{
	return m_bCanClimbPeaks;
}
bool CvUnitInfo::isAllowPromotion(PromotionTypes eIndex) const  {return m_pbAllowPromotion[eIndex];}
bool CvUnitInfo::isDenyPromotion(PromotionTypes eIndex) const   {return m_pbDenyPromotion[eIndex];}
const TCHAR *CvUnitInfo::getPyDeath() const						{return m_szPyDeath;}
int CvUnitInfo::getNumQuotes() const							{return m_iNumQuotes;}
const TCHAR* CvUnitInfo::getQuotes(int i) const
{
	FAssertMsg(i < getNumQuotes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return (m_paszQuotes) ? m_paszQuotes[i] : NULL;
}
const TCHAR *CvUnitInfo::getQuote() const						{return m_szQuote;}
int CvUnitInfo::getNumImages() const							{return m_iNumImages;}
const TCHAR* CvUnitInfo::getImages(int i) const
{
	FAssertMsg(i < getNumImages(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return (m_paszImages) ? m_paszImages[i] : NULL;
}
int CvUnitInfo::getUpgradeCivVectorSize()						{return m_aszExtraXMLforPass3.size();}
CvString CvUnitInfo::getUpgradeCivVectorElement(int i)			{return m_aszExtraXMLforPass3[i];}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
int CvUnitInfo::getAppearanceProb() const                       {return m_iAppearanceProb;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Units: Added by Kael 08/04/2007
bool CvUnitInfo::isAbandon() const
{
	return m_bAbandon;
}

bool CvUnitInfo::isAutoRaze() const
{
	return m_bAutoRaze;
}

bool CvUnitInfo::isDisableUpgradeTo() const
{
	return m_bDisableUpgradeTo;
}

bool CvUnitInfo::isExplodeInCombat() const
{
	return m_bExplodeInCombat;
}

bool CvUnitInfo::isFreeXP() const
{
	return m_bFreeXP;
}

const TCHAR* CvUnitInfo::getImage() const
{
	return m_szImage;
}

bool CvUnitInfo::isImmortal() const
{
	return m_bImmortal;
}

bool CvUnitInfo::isImmuneToDefensiveStrike() const
{
	return m_bImmuneToDefensiveStrike;
}

bool CvUnitInfo::isNeverObsolete() const
{
	return m_bNeverObsolete;
}

bool CvUnitInfo::isNoWarWeariness() const
{
	return m_bNoWarWeariness;
}

/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
bool CvUnitInfo::isPromotionBuild() const
{
	return m_bPromotionBuild;
}
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/

int CvUnitInfo::getCombatDefense() const
{
	return m_iCombatDefense;
}

int CvUnitInfo::getDefensiveStrikeChance() const
{
	return m_iDefensiveStrikeChance;
}

int CvUnitInfo::getDefensiveStrikeDamage() const
{
	return m_iDefensiveStrikeDamage;
}

int CvUnitInfo::getDiploVoteType() const
{
	return m_iDiploVoteType;
}

int CvUnitInfo::getDurationFromCombat() const
{
	return m_iDurationFromCombat;
}

int CvUnitInfo::getEnslavementChance() const
{
	return m_iEnslavementChance;
}

int CvUnitInfo::getEquipmentPromotion() const
{
	return m_iEquipmentPromotion;
}

int CvUnitInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvUnitInfo::getPrereqBroadEthicalAlignment() const					  {return m_iPrereqBroadEthicalAlignment;}
int CvUnitInfo::getEthicalAlignmentModifier() const						  {return m_iEthicalAlignmentModifier;}
int CvUnitInfo::getEthicalAlignmentShift() const                          {return m_iEthicalAlignmentShift;}
int CvUnitInfo::getEthicalAlignmentShiftModifier() const                  {return m_iEthicalAlignmentShiftModifier;}
int CvUnitInfo::getEthicalAlignmentShiftTowardsNeutral() const            {return m_iEthicalAlignmentShiftTowardsNeutral;}
int CvUnitInfo::getPrereqEthicalAlignment() const                         {return m_iPrereqEthicalAlignment;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

int CvUnitInfo::getFreePromotionPick() const
{
	return m_iFreePromotionPick;
}

int CvUnitInfo::getGoldFromCombat() const
{
	return m_iGoldFromCombat;
}

int CvUnitInfo::getMinLevel() const
{
	return m_iMinLevel;
}

///PopCost

int CvUnitInfo::getPopCost() const
{
	return m_iPopCost;
}

int CvUnitInfo::getMiscastChance() const
{
	return m_iMiscastChance;
}

int CvUnitInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvUnitInfo::getPrereqGlobalCounter() const
{
	return m_iPrereqGlobalCounter;
}

int CvUnitInfo::getPrereqBuildingClass() const
{
	return m_iPrereqBuildingClass;
}

int CvUnitInfo::getPrereqCivic() const
{
	return m_iPrereqCivic;
}

int CvUnitInfo::getPromotionFromCombat() const
{
	return m_iPromotionFromCombat;
}
// PyPreCombat by BI 07/24/11
const TCHAR *CvUnitInfo::getPyPreCombat() const
{
	return m_szPyPreCombat;
}

const TCHAR *CvUnitInfo::getPyPostCombatLost() const
{
	return m_szPyPostCombatLost;
}

const TCHAR *CvUnitInfo::getPyPostCombatWon() const
{
	return m_szPyPostCombatWon;
}

int CvUnitInfo::getTier() const
{
	return m_iTier;
}

int CvUnitInfo::getUnitConvertFromCombat() const
{
	return m_iUnitConvertFromCombat;
}

int CvUnitInfo::getUnitConvertFromCombatChance() const
{
	return m_iUnitConvertFromCombatChance;
}

int CvUnitInfo::getUnitCreateFromCombat() const
{
	return m_iUnitCreateFromCombat;
}

int CvUnitInfo::getUnitCreateFromCombatChance() const
{
	return m_iUnitCreateFromCombatChance;
}

int CvUnitInfo::getUpgradeCiv() const
{
	return m_iUpgradeCiv;
}

/*************************************************************************************************/
/**	Xienwolf Tweak							11/03/08											**/
/**																								**/
/**							Allows for Multiple sets of WeaponTiers								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvUnitInfo::getWeaponTier() const
{
	return m_iWeaponTier;
}
/**								----  End Original Code  ----									**/
int CvUnitInfo::getWeaponTierMax() const    {return m_iWeaponTierMax;}
int CvUnitInfo::getWeaponTierMin() const    {return m_iWeaponTierMin;}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

int CvUnitInfo::getWithdrawlProbDefensive() const
{
	return m_iWithdrawlProbDefensive;
}

int CvUnitInfo::getBonusAffinity(int i) const
{
	return m_piBonusAffinity ? m_piBonusAffinity[i] : -1;
}

int CvUnitInfo::getDamageTypeCombat(int i) const
{
	return m_piDamageTypeCombat ? m_piDamageTypeCombat[i] : -1;
}
//FfH: End Add

// Arrays

int CvUnitInfo::getPrereqAndTechs(int i) const
{
	FAssertMsg(i < GC.getNUM_UNIT_AND_TECH_PREREQS(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;
}

int CvUnitInfo::getPrereqOrBonuses(int i) const
{
	FAssertMsg(i < GC.getNUM_UNIT_PREREQ_OR_BONUSES(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqOrBonuses ? m_piPrereqOrBonuses[i] : -1;
}

int CvUnitInfo::getProductionTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
}

/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
int CvUnitInfo::getAppearanceTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAppearanceTechs ? m_piAppearanceTechs[i] : -1;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

int CvUnitInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvUnitInfo::getTerrainAttackModifier(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainAttackModifier ? m_piTerrainAttackModifier[i] : -1;
}

int CvUnitInfo::getTerrainDefenseModifier(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainDefenseModifier ? m_piTerrainDefenseModifier[i] : -1;
}

int CvUnitInfo::getFeatureAttackModifier(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureAttackModifier ? m_piFeatureAttackModifier[i] : -1;
}

int CvUnitInfo::getFeatureDefenseModifier(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureDefenseModifier ? m_piFeatureDefenseModifier[i] : -1;
}

/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvUnitInfo Public
int CvUnitInfo::getUnitHillCost() const
{
	return m_iUnitHillCost;
}

int CvUnitInfo::getUnitPeakCost() const
{
	return m_iUnitPeakCost;
}

int CvUnitInfo::getUnitTerrainCost(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitTerrainCost ? m_piUnitTerrainCost[i] : -1;
}

int CvUnitInfo::getUnitFeatureCost(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitFeatureCost ? m_piUnitFeatureCost[i] : -1;
}
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/

int CvUnitInfo::getUnitClassAttackModifier(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitClassAttackModifier ? m_piUnitClassAttackModifier[i] : -1;
}

int CvUnitInfo::getUnitClassDefenseModifier(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitClassDefenseModifier ? m_piUnitClassDefenseModifier[i] : -1;
}

int CvUnitInfo::getUnitCombatModifier(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatModifier ? m_piUnitCombatModifier[i] : -1;
}

int CvUnitInfo::getUnitCombatCollateralImmune(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatCollateralImmune ? m_piUnitCombatCollateralImmune[i] : -1;
}

int CvUnitInfo::getDomainModifier(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDomainModifier ? m_piDomainModifier[i] : -1;
}

int CvUnitInfo::getBonusProductionModifier(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusProductionModifier ? m_piBonusProductionModifier[i] : -1;
}

int CvUnitInfo::getUnitGroupRequired(int i) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitGroupRequired ? m_piUnitGroupRequired[i] : NULL;
}
/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnitInfo::getUpgradeUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbUpgradeUnitClass ? m_pbUpgradeUnitClass[i] : false;
}
/**								----  End Original Code  ----									**/
int CvUnitInfo::getNumUpgradeUnitClass() const
{
	return m_iNumUpgradeUnitClass;
}

int CvUnitInfo::getUpgradeUnitClass(int i) const
{
	return (getNumUpgradeUnitClass() > i) ? m_piUpgradeUnitClass[i] : false;
}
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/

bool CvUnitInfo::getTargetUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTargetUnitClass ? m_pbTargetUnitClass[i] : false;
}

bool CvUnitInfo::getTargetUnitCombat(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTargetUnitCombat ? m_pbTargetUnitCombat[i] : false;
}

bool CvUnitInfo::getDefenderUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbDefenderUnitClass ? m_pbDefenderUnitClass[i] : false;
}

bool CvUnitInfo::getDefenderUnitCombat(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbDefenderUnitCombat ? m_pbDefenderUnitCombat[i] : false;
}

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
/* Old Code:
int CvUnitInfo::getFlankingStrikeUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlankingStrikeUnitClass ? m_piFlankingStrikeUnitClass[i] : -1;
}*/
int CvUnitInfo::getFlankingStrikeUnitCombat(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlankingStrikeUnitCombat ? m_piFlankingStrikeUnitCombat[i] : -1;
}
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

bool CvUnitInfo::getUnitAIType(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbUnitAIType ? m_pbUnitAIType[i] : false;
}

bool CvUnitInfo::getNotUnitAIType(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbNotUnitAIType ? m_pbNotUnitAIType[i] : false;
}

bool CvUnitInfo::getBuilds(int i) const
{
	FAssertMsg(i < GC.getNumBuildInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbBuilds ? m_pbBuilds[i] : false;
}

int CvUnitInfo::getReligionSpreads(int i) const
{
	FAssertMsg(i < GC.getNumReligionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piReligionSpreads ? m_piReligionSpreads[i] : -1;
}

int CvUnitInfo::getCorporationSpreads(int i) const
{
	FAssertMsg(i < GC.getNumCorporationInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCorporationSpreads ? m_piCorporationSpreads[i] : -1;
}

int CvUnitInfo::getTerrainPassableTech(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainPassableTech ? m_piTerrainPassableTech[i] : -1;
}

int CvUnitInfo::getFeaturePassableTech(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeaturePassableTech ? m_piFeaturePassableTech[i] : -1;
}

bool CvUnitInfo::getGreatPeoples(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbGreatPeoples ? m_pbGreatPeoples[i] : false;
}

bool CvUnitInfo::getBuildings(int i) const
{
	FAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbBuildings ? m_pbBuildings[i] : false;
}

bool CvUnitInfo::getForceBuildings(int i) const
{
	FAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbForceBuildings ? m_pbForceBuildings[i] : false;
}

bool CvUnitInfo::getTerrainImpassable(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainImpassable ? m_pbTerrainImpassable[i] : false;
}

bool CvUnitInfo::getFeatureImpassable(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureImpassable ? m_pbFeatureImpassable[i] : false;
}

bool CvUnitInfo::getTerrainNative(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainNative ? m_pbTerrainNative[i] : false;
}

bool CvUnitInfo::getFeatureNative(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureNative ? m_pbFeatureNative[i] : false;
}

/*************************************************************************************************/
/**	JRouteNative by Jeckel		imported by Valkrionn	09.28.09                        		**/
/*************************************************************************************************/
bool CvUnitInfo::getRouteNative(int iRouteType) const
{
	FAssertMsg(iRouteType < GC.getNumRouteInfos(), "Index out of bounds");
	FAssertMsg(iRouteType > -1, "Index out of bounds");
	return m_pbRouteNative ? m_pbRouteNative[iRouteType] : false;
}

bool CvUnitInfo::getRouteImpassable(int iRouteType) const
{
	FAssertMsg(iRouteType < GC.getNumRouteInfos(), "Index out of bounds");
	FAssertMsg(iRouteType > -1, "Index out of bounds");
	return m_pbRouteImpassable ? m_pbRouteImpassable[iRouteType] : false;
}

bool CvUnitInfo::getRouteIgnore(int iRouteType) const
{
	FAssertMsg(iRouteType < GC.getNumRouteInfos(), "Index out of bounds");
	FAssertMsg(iRouteType > -1, "Index out of bounds");
	return m_pbRouteIgnore ? m_pbRouteIgnore[iRouteType] : false;
}

int CvUnitInfo::getRouteSubstitute(int iRouteType) const
{
	FAssertMsg(iRouteType < GC.getNumRouteInfos(), "Index out of bounds");
	FAssertMsg(iRouteType > -1, "Index out of bounds");
	return m_piRouteSubstitute ? m_piRouteSubstitute[iRouteType] : -1;
}
/*************************************************************************************************/
/**	JRouteNative    END                                                                   		**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
int CvUnitInfo::getAffinities(int iI) const						{return (getNumAffinities() > iI)				? m_piAffinities[iI]					: -1;}
int CvUnitInfo::getNumAffinities() const						{return m_iNumAffinities;}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
/**										Start Original Code										**
bool CvUnitInfo::getFreePromotions(int i) const
{
	FAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFreePromotions ? m_pbFreePromotions[i] : false;
}
/**										End Original Code										**/

int CvUnitInfo::getNumFreePromotions(int i) const
{
	return m_piFreePromotions ? m_piFreePromotions[i] : 0;
}

bool CvUnitInfo::getFreePromotions(int i) const
{
	FAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFreePromotions ? getNumFreePromotions(i) > 0 : false;
}
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/

int CvUnitInfo::getLeaderPromotion() const
{
	return m_iLeaderPromotion;
}

int CvUnitInfo::getLeaderExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iLeaderExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iLeaderExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

//Magic Rework
int CvUnitInfo::getMagicalPower() const
{
	return m_iMagicalPower;
}
//int CvUnitInfo::getDominionCapacity() const
//{
//	return m_iDominionCapacity;
//}
//int CvUnitInfo::getSpellClassExtraPower(int i) const
//{
//	FAssertMsg(i < GC.getNumSpellClassInfos(), "Index out of bounds");
//	FAssertMsg(i > -1, "Index out of bounds");
//	return m_piSpellClassExtraPower ? m_piSpellClassExtraPower[i] : 0;
//}



const TCHAR* CvUnitInfo::getEarlyArtDefineTag(int i, UnitArtStyleTypes eStyle, int iPromo) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (NO_UNIT_ARTSTYLE != eStyle)
	{
		int iIndex = GC.getInfoTypeForString(getType());
		if (-1 != iIndex)
		{
			const TCHAR* pcTag = GC.getUnitArtStyleTypeInfo(eStyle).getEarlyArtDefineTag(i, iIndex, iPromo);
			if (NULL != pcTag)
			{
				return pcTag;
			}
		}
	}

	return (m_paszEarlyArtDefineTags) ? m_paszEarlyArtDefineTags[i] : NULL;
}

void CvUnitInfo::setEarlyArtDefineTag(int i, const TCHAR* szVal)
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszEarlyArtDefineTags[i] = szVal;
}

const TCHAR* CvUnitInfo::getLateArtDefineTag(int i, UnitArtStyleTypes eStyle) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (NO_UNIT_ARTSTYLE != eStyle)
	{
		int iIndex = GC.getInfoTypeForString(getType());
		if (-1 != iIndex)
		{
			const TCHAR* pcTag = GC.getUnitArtStyleTypeInfo(eStyle).getLateArtDefineTag(i, iIndex);
			if (NULL != pcTag)
			{
				return pcTag;
			}
		}

	}

	return (m_paszLateArtDefineTags) ? m_paszLateArtDefineTags[i] : NULL;
}

void CvUnitInfo::setLateArtDefineTag(int i, const TCHAR* szVal)
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszLateArtDefineTags[i] = szVal;
}

const TCHAR* CvUnitInfo::getMiddleArtDefineTag(int i, UnitArtStyleTypes eStyle) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (NO_UNIT_ARTSTYLE != eStyle)
	{
		int iIndex = GC.getInfoTypeForString(getType());
		if (-1 != iIndex)
		{
			const TCHAR* pcTag = GC.getUnitArtStyleTypeInfo(eStyle).getMiddleArtDefineTag(i, iIndex);
			if (NULL != pcTag)
			{
				return pcTag;
			}
		}

	}

	return (m_paszMiddleArtDefineTags) ? m_paszMiddleArtDefineTags[i] : NULL;
}

void CvUnitInfo::setMiddleArtDefineTag(int i, const TCHAR* szVal)
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszMiddleArtDefineTags[i] = szVal;
}

const TCHAR* CvUnitInfo::getUnitNames(int i) const
{
	FAssertMsg(i < getNumUnitNames(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return (m_paszUnitNames) ? m_paszUnitNames[i] : NULL;
}

const TCHAR* CvUnitInfo::getFormationType() const
{
	return m_szFormationType;
}

const TCHAR* CvUnitInfo::getButton() const
{
	return m_szArtDefineButton;
}

//FfH: Added by Kael 02/06/2009
const TCHAR* CvUnitInfo::getUnitStyleButton(int iProm) const
{
	return getArtInfo(0, NO_ERA, (UnitArtStyleTypes)GC.getPromotionInfo((PromotionTypes)iProm).getUnitArtStyleType())->getButton();
}
//FfH: End Add

void CvUnitInfo::updateArtDefineButton()
{
	m_szArtDefineButton = getArtInfo(0, NO_ERA, NO_UNIT_ARTSTYLE)->getButton();
}

const CvArtInfoUnit* CvUnitInfo::getArtInfo(int i, EraTypes eEra, UnitArtStyleTypes eStyle, int iPromo) const
{
	//if ((eEra > GC.getNumEraInfos() / 2) && !CvString(getLateArtDefineTag(i, eStyle)).empty())
	//{
	//	return ARTFILEMGR.getUnitArtInfo(getLateArtDefineTag(i, eStyle));
	//}
	//else if ((eEra > GC.getNumEraInfos() / 4) && !CvString(getMiddleArtDefineTag(i, eStyle)).empty())
	//{
	//	return ARTFILEMGR.getUnitArtInfo(getMiddleArtDefineTag(i, eStyle));
	//}
	//else
	//{
		return ARTFILEMGR.getUnitArtInfo(getEarlyArtDefineTag(i, eStyle, iPromo));
	//}
}

void CvUnitInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iAIWeight);
	stream->Read(&m_iProductionCost);
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**								Modifies Cost based on Population								**/
/*************************************************************************************************/
	stream->Read(&m_iCityPopCostModifier);
	stream->Read(&m_iEmpirePopCostModifier);
	stream->Read(&m_iNumCityCostModifier);
	stream->Read(&m_iPlayerPopCostModifier);
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Read(&m_bNonInfluence);
	stream->Read(&m_bInfluence);
	stream->Read(&m_iVictoryInfluenceModifier);
	stream->Read(&m_iDefeatInfluenceModifier);
	stream->Read(&m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Read(&m_iExtraPerception);
	stream->Read(&m_iInvisibleLevel);
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

	stream->Read(&m_iHurryCostModifier);
	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);
	stream->Read(&m_iMinAreaSize);
	stream->Read(&m_iMoves);
	stream->Read(&m_iAirRange);
	stream->Read(&m_iAirUnitCap);
	stream->Read(&m_iDropRange);
	stream->Read(&m_iNukeRange);
	stream->Read(&m_iWorkRate);
	stream->Read(&m_iBaseDiscover);
	stream->Read(&m_iDiscoverMultiplier);
	stream->Read(&m_iBaseHurry);
	stream->Read(&m_iHurryMultiplier);
	stream->Read(&m_iBaseTrade);
	stream->Read(&m_iTradeMultiplier);
	stream->Read(&m_iGreatWorkCulture);
	stream->Read(&m_iEspionagePoints);
	stream->Read(&m_iCombat);
	stream->Read(&m_iCombatLimit);
	stream->Read(&m_iAirCombat);
	stream->Read(&m_iAirCombatLimit);
	stream->Read(&m_iXPValueAttack);
	stream->Read(&m_iXPValueDefense);
	stream->Read(&m_iFirstStrikes);
	stream->Read(&m_iChanceFirstStrikes);
	stream->Read(&m_iInterceptionProbability);
	stream->Read(&m_iEvasionProbability);
	stream->Read(&m_iWithdrawalProbability);
	stream->Read(&m_iEnemyWithdrawalProbability);
	stream->Read(&m_iCollateralDamage);
	stream->Read(&m_iCollateralDamageLimit);
	stream->Read(&m_iCollateralDamageMaxUnits);

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	stream->Read(&m_iFlankingDamage);
	stream->Read(&m_iFlankingDamageLimit);
	stream->Read(&m_iFlankingDamageMaxUnits);
/*************************************************************************************************/
/**	Updated Flanking							END												**/
/*************************************************************************************************/

	stream->Read(&m_iCityAttackModifier);
	stream->Read(&m_iCityDefenseModifier);
	stream->Read(&m_iAnimalCombatModifier);
	stream->Read(&m_iHillsAttackModifier);
	stream->Read(&m_iHillsDefenseModifier);
	stream->Read(&m_iBombRate);
	stream->Read(&m_iBombardRate);
	stream->Read(&m_iSpecialCargo);
	stream->Read(&m_iDomainCargo);
	stream->Read(&m_iCargoSpace);
	stream->Read(&m_iConscriptionValue);
	stream->Read(&m_iCultureGarrisonValue);
	stream->Read(&m_iExtraCost);
	stream->Read(&m_iAssetValue);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iPowerValue);
/**								----  End Original Code  ----									**/
	stream->Read(&m_iPowerAdd);
	stream->Read(&m_iPowerMult);
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	stream->Read(&m_iUnitClassType);
	stream->Read(&m_iSecondaryUnitClassType);
	stream->Read(&m_iSpecialUnitType);
	stream->Read(&m_iUnitCaptureClassType);
	stream->Read(&m_iUnitCombatType);
	stream->Read(&m_iDomainType);
	stream->Read(&m_iDefaultUnitAIType);
/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iInvisibleType);
/**								----  End Original Code  ----									**/
	int iNumInvisTypes;
	stream->Read(&iNumInvisTypes);
	for(int i=0;i<iNumInvisTypes;i++)
	{
		int iInvisibleType;
		stream->Read(&iInvisibleType);
		m_aiInvisibleTypes.push_back(iInvisibleType);
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	int iNumInvisibleTypes;
	stream->Read(&iNumInvisibleTypes);
	for(int i=0;i<iNumInvisibleTypes;i++)
	{
		int iSeeInvisibleType;
		stream->Read(&iSeeInvisibleType);
		m_aiSeeInvisibleTypes.push_back(iSeeInvisibleType);
	}

	stream->Read(&m_iAdvisorType);
	stream->Read(&m_iHolyCity);
	stream->Read(&m_iReligionType);
	stream->Read(&m_iStateReligion);
	stream->Read(&m_iPrereqReligion);
	stream->Read(&m_iPrereqCorporation);
	stream->Read(&m_iPrereqBuilding);
	stream->Read(&m_iPrereqAndTech);
	stream->Read(&m_iPrereqAndBonus);
	stream->Read(&m_iGroupSize);
	stream->Read(&m_iGroupDefinitions);
	stream->Read(&m_iUnitMeleeWaveSize);
	stream->Read(&m_iUnitRangedWaveSize);
	stream->Read(&m_iNumUnitNames);
	stream->Read(&m_iCommandType);

	stream->Read(&m_bAnimal);
	stream->Read(&m_bFoodProduction);
	stream->Read(&m_bNoBadGoodies);
	stream->Read(&m_bOnlyDefensive);
	stream->Read(&m_bNoCapture);
	stream->Read(&m_bImmuneToCapture);
	stream->Read(&m_bQuickCombat);
	stream->Read(&m_bRivalTerritory);
	stream->Read(&m_bMilitaryHappiness);
	stream->Read(&m_bMilitarySupport);
	stream->Read(&m_bMilitaryProduction);
	stream->Read(&m_bPillage);
	stream->Read(&m_bReligiousCommander);  //ReligiousCommander by BI 07/24/11
	stream->Read(&m_bSpy);
	stream->Read(&m_bSabotage);
	stream->Read(&m_bDestroy);
	stream->Read(&m_bStealPlans);
	stream->Read(&m_bInvestigate);
	stream->Read(&m_bCounterSpy);
	stream->Read(&m_bFound);
	stream->Read(&m_bGoldenAge);
	stream->Read(&m_bInvisible);
	stream->Read(&m_bFirstStrikeImmune);
	stream->Read(&m_bNoDefensiveBonus);
	stream->Read(&m_bIgnoreBuildingDefense);
	stream->Read(&m_bCanMoveImpassable);
	stream->Read(&m_bCanMoveAllTerrain);
	stream->Read(&m_bFlatMovementCost);
	stream->Read(&m_bIgnoreTerrainCost);
	stream->Read(&m_bNukeImmune);
	stream->Read(&m_bPrereqBonuses);
	stream->Read(&m_bPrereqReligion);
	stream->Read(&m_bMechanized);
	stream->Read(&m_bRenderBelowWater);
	stream->Read(&m_bRenderAlways);
	stream->Read(&m_bSuicide);
	stream->Read(&m_bLineOfSight);
	stream->Read(&m_bHiddenNationality);
	stream->Read(&m_bAlwaysHostile);
	stream->Read(&m_bNoRevealMap);

	stream->Read(&m_fUnitMaxSpeed);
	stream->Read(&m_fUnitPadTime);

/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iCommandLimit);
	stream->Read(&m_iCommandRange);
	stream->Read(&m_bFreeUnit);
	stream->Read(&m_bNoSupply);
	stream->Read(&m_bCommunalProperty);
	stream->Read(&m_bNeverHostile);
	stream->Read(&m_bBlind);
	stream->Read(&m_bJoinPop);
	stream->Read(&m_iPrereqBroadAlignment);
	stream->Read(&m_iAlignmentModifier);
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	stream->Read(&m_iAlignmentShift);
	stream->Read(&m_iAlignmentShiftModifier);
	stream->Read(&m_iAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
	stream->ReadString(m_szPyPerTurn);
	SAFE_DELETE_ARRAY(m_piYieldFromKill);
	m_piYieldFromKill = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldFromKill);
	SAFE_DELETE_ARRAY(m_piCommerceFromKill);
	m_piCommerceFromKill = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceFromKill);
	stream->Read(&m_bCanClimbPeaks);
	SAFE_DELETE_ARRAY(m_pbAllowPromotion);
	m_pbAllowPromotion = new bool[GC.getNumPromotionInfos()];
	stream->Read(GC.getNumPromotionInfos(), m_pbAllowPromotion);
	SAFE_DELETE_ARRAY(m_pbDenyPromotion);
	m_pbDenyPromotion = new bool[GC.getNumPromotionInfos()];
	stream->Read(GC.getNumPromotionInfos(), m_pbDenyPromotion);
	stream->ReadString(m_szPyDeath);
	stream->ReadString(m_szQuote);
	stream->Read(&m_iNumQuotes);
	SAFE_DELETE_ARRAY(m_paszQuotes);
	m_paszQuotes = new CvString[m_iNumQuotes];
	stream->ReadString(m_iNumQuotes, m_paszQuotes);
	stream->Read(&m_iNumImages);
	SAFE_DELETE_ARRAY(m_paszImages);
	m_paszImages = new CvString[m_iNumImages];
	stream->ReadString(m_iNumImages, m_paszImages);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	stream->Read(&m_iAppearanceProb);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Units: Added by Kael 08/04/2007
	stream->Read(&m_bAbandon);
	stream->Read(&m_bAutoRaze);
	stream->Read(&m_bDisableUpgradeTo);
	stream->Read(&m_bExplodeInCombat);
	stream->Read(&m_bFreeXP);
	stream->Read(&m_bImmortal);
	stream->Read(&m_bImmuneToDefensiveStrike);
	stream->Read(&m_bNeverObsolete);
	stream->Read(&m_bNoWarWeariness);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	stream->Read(&m_bPromotionBuild);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
	stream->Read(&m_iCombatDefense);
	stream->Read(&m_iDefensiveStrikeChance);
	stream->Read(&m_iDefensiveStrikeDamage);
	stream->Read(&m_iDiploVoteType);
	stream->Read(&m_iDurationFromCombat);
	stream->Read(&m_iEnslavementChance);
	stream->Read(&m_iFreePromotionPick);
	stream->Read(&m_iGoldFromCombat);
	stream->Read(&m_iMinLevel);
	stream->Read(&m_iPopCost);
	stream->Read(&m_iMiscastChance);
	stream->Read(&m_iModifyGlobalCounter);
	stream->Read(&m_iEquipmentPromotion);
	stream->Read(&m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBroadEthicalAlignment);
	stream->Read(&m_iEthicalAlignmentModifier);
	stream->Read(&m_iEthicalAlignmentShift);
	stream->Read(&m_iEthicalAlignmentShiftModifier);
	stream->Read(&m_iEthicalAlignmentShiftTowardsNeutral);
	stream->Read(&m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBuildingClass);
	stream->Read(&m_iPrereqCivic);
	stream->Read(&m_iPrereqGlobalCounter);
	stream->Read(&m_iPromotionFromCombat);
	stream->Read(&m_iTier);
	stream->Read(&m_iUnitConvertFromCombat);
	stream->Read(&m_iUnitConvertFromCombatChance);
	stream->Read(&m_iUnitCreateFromCombat);
	stream->Read(&m_iUnitCreateFromCombatChance);
	stream->Read(&m_iUpgradeCiv);
/*************************************************************************************************/
/**	Xienwolf Tweak							11/03/08											**/
/**																								**/
/**							Allows for Multiple sets of WeaponTiers								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iWeaponTier);
/**								----  End Original Code  ----									**/
	stream->Read(&m_iWeaponTierMax);
	stream->Read(&m_iWeaponTierMin);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	stream->Read(&m_iWithdrawlProbDefensive);
	stream->ReadString(m_szImage);
	 //PyPreCombat by BI 07/24/11
	stream->ReadString(m_szPyPreCombat);

	stream->ReadString(m_szPyPostCombatLost);
	stream->ReadString(m_szPyPostCombatWon);

	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	m_piBonusAffinity = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusAffinity);

	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
	m_piDamageTypeCombat = new int[GC.getNumDamageTypeInfos()];
	stream->Read(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);
//FfH: End Add

	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	m_piPrereqAndTechs = new int[GC.getNUM_UNIT_AND_TECH_PREREQS()];
	stream->Read(GC.getNUM_UNIT_AND_TECH_PREREQS(), m_piPrereqAndTechs);

	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	m_piPrereqOrBonuses = new int[GC.getNUM_UNIT_PREREQ_OR_BONUSES()];
	stream->Read(GC.getNUM_UNIT_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);

	SAFE_DELETE_ARRAY(m_piProductionTraits);
	m_piProductionTraits = new int[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_piProductionTraits);

/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAppearanceTechs);
	m_piAppearanceTechs = new int[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_piAppearanceTechs);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piTerrainAttackModifier);
	m_piTerrainAttackModifier = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainAttackModifier);

	SAFE_DELETE_ARRAY(m_piTerrainDefenseModifier);
	m_piTerrainDefenseModifier = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainDefenseModifier);

	SAFE_DELETE_ARRAY(m_piFeatureAttackModifier);
	m_piFeatureAttackModifier = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureAttackModifier);

	SAFE_DELETE_ARRAY(m_piFeatureDefenseModifier);
	m_piFeatureDefenseModifier = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureDefenseModifier);

/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvUnitInfo
	stream->Read(&m_iUnitHillCost);
	stream->Read(&m_iUnitPeakCost);

	SAFE_DELETE_ARRAY(m_piUnitTerrainCost);
	m_piUnitTerrainCost = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piUnitTerrainCost);

	SAFE_DELETE_ARRAY(m_piUnitFeatureCost);
	m_piUnitFeatureCost = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piUnitFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piUnitClassAttackModifier);
	m_piUnitClassAttackModifier = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piUnitClassAttackModifier);

	SAFE_DELETE_ARRAY(m_piUnitClassDefenseModifier);
	m_piUnitClassDefenseModifier = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piUnitClassDefenseModifier);

	SAFE_DELETE_ARRAY(m_piUnitCombatModifier);
	m_piUnitCombatModifier = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatModifier);

	SAFE_DELETE_ARRAY(m_piUnitCombatCollateralImmune);
	m_piUnitCombatCollateralImmune = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatCollateralImmune);

	SAFE_DELETE_ARRAY(m_piDomainModifier);
	m_piDomainModifier = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainModifier);

	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	m_piBonusProductionModifier = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusProductionModifier);

	SAFE_DELETE_ARRAY(m_piUnitGroupRequired);
	m_piUnitGroupRequired = new int[m_iGroupDefinitions];
	stream->Read(m_iGroupDefinitions, m_piUnitGroupRequired);


/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	SAFE_DELETE_ARRAY(m_pbUpgradeUnitClass);
	m_pbUpgradeUnitClass = new bool[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_pbUpgradeUnitClass);
/**								----  End Original Code  ----									**/
	SAFE_DELETE_ARRAY(m_piUpgradeUnitClass);
	stream->Read(&m_iNumUpgradeUnitClass);
	if (m_iNumUpgradeUnitClass > 0)
	{
		m_piUpgradeUnitClass = new int[m_iNumUpgradeUnitClass];
		stream->Read(m_iNumUpgradeUnitClass, m_piUpgradeUnitClass);
	}
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_pbTargetUnitClass);
	m_pbTargetUnitClass = new bool[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_pbTargetUnitClass);

	SAFE_DELETE_ARRAY(m_pbTargetUnitCombat);
	m_pbTargetUnitCombat = new bool[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pbTargetUnitCombat);

	SAFE_DELETE_ARRAY(m_pbDefenderUnitClass);
	m_pbDefenderUnitClass = new bool[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_pbDefenderUnitClass);

	SAFE_DELETE_ARRAY(m_pbDefenderUnitCombat);
	m_pbDefenderUnitCombat = new bool[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pbDefenderUnitCombat);

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	/* Old Code:
	SAFE_DELETE_ARRAY(m_piFlankingStrikeUnitClass);
	m_piFlankingStrikeUnitClass = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piFlankingStrikeUnitClass); */
	SAFE_DELETE_ARRAY(m_piFlankingStrikeUnitCombat);
	m_piFlankingStrikeUnitCombat = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piFlankingStrikeUnitCombat);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_pbUnitAIType);
	m_pbUnitAIType = new bool[NUM_UNITAI_TYPES];
	stream->Read(NUM_UNITAI_TYPES, m_pbUnitAIType);

	SAFE_DELETE_ARRAY(m_pbNotUnitAIType);
	m_pbNotUnitAIType = new bool[NUM_UNITAI_TYPES];
	stream->Read(NUM_UNITAI_TYPES, m_pbNotUnitAIType);

	SAFE_DELETE_ARRAY(m_pbBuilds);
	m_pbBuilds = new bool[GC.getNumBuildInfos()];
	stream->Read(GC.getNumBuildInfos(), m_pbBuilds);

	SAFE_DELETE_ARRAY(m_piReligionSpreads);
	m_piReligionSpreads = new int[GC.getNumReligionInfos()];
	stream->Read(GC.getNumReligionInfos(), m_piReligionSpreads);

	SAFE_DELETE_ARRAY(m_piCorporationSpreads);
	m_piCorporationSpreads = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_piCorporationSpreads);

	SAFE_DELETE_ARRAY(m_piTerrainPassableTech);
	m_piTerrainPassableTech = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainPassableTech);

	SAFE_DELETE_ARRAY(m_piFeaturePassableTech);
	m_piFeaturePassableTech = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeaturePassableTech);

	SAFE_DELETE_ARRAY(m_pbGreatPeoples);
	m_pbGreatPeoples = new bool[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_pbGreatPeoples);

	SAFE_DELETE_ARRAY(m_pbBuildings);
	m_pbBuildings = new bool[GC.getNumBuildingInfos()];
	stream->Read(GC.getNumBuildingInfos(), m_pbBuildings);

	SAFE_DELETE_ARRAY(m_pbForceBuildings);
	m_pbForceBuildings = new bool[GC.getNumBuildingInfos()];
	stream->Read(GC.getNumBuildingInfos(), m_pbForceBuildings);

	SAFE_DELETE_ARRAY(m_pbTerrainNative);
	m_pbTerrainNative = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainNative);

	SAFE_DELETE_ARRAY(m_pbFeatureNative);
	m_pbFeatureNative = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureNative);

/*************************************************************************************************/
/**	JRouteNative by Jeckel		imported by Valkrionn	09.28.09                        		**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbRouteNative);
	m_pbRouteNative = new bool[GC.getNumRouteInfos()];
	stream->Read(GC.getNumRouteInfos(), m_pbRouteNative);

	SAFE_DELETE_ARRAY(m_pbRouteImpassable);
	m_pbRouteImpassable = new bool[GC.getNumRouteInfos()];
	stream->Read(GC.getNumRouteInfos(), m_pbRouteImpassable);

	SAFE_DELETE_ARRAY(m_pbRouteIgnore);
	m_pbRouteIgnore = new bool[GC.getNumRouteInfos()];
	stream->Read(GC.getNumRouteInfos(), m_pbRouteIgnore);

	SAFE_DELETE_ARRAY(m_piRouteSubstitute);
	m_piRouteSubstitute = new int[GC.getNumRouteInfos()];
	stream->Read(GC.getNumRouteInfos(), m_piRouteSubstitute);
/*************************************************************************************************/
/**	JRouteNative    END                                                                   		**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	stream->Read(&m_iNumAffinities);
	if (m_iNumAffinities > 0)
	{
		SAFE_DELETE_ARRAY(m_piAffinities);
		m_piAffinities = new int[m_iNumAffinities];
		stream->Read(m_iNumAffinities, m_piAffinities);
	}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_pbTerrainImpassable);
	m_pbTerrainImpassable = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainImpassable);

	SAFE_DELETE_ARRAY(m_pbFeatureImpassable);
	m_pbFeatureImpassable = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureImpassable);

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
/**										Start Original Code										**
	SAFE_DELETE_ARRAY(m_pbFreePromotions);
	m_pbFreePromotions = new bool[GC.getNumPromotionInfos()];
	stream->Read(GC.getNumPromotionInfos(), m_pbFreePromotions);
/**										End Original Code										**/
	SAFE_DELETE_ARRAY(m_piFreePromotions);
	m_piFreePromotions = new int[GC.getNumPromotionInfos()];
	stream->Read(GC.getNumPromotionInfos(), m_piFreePromotions);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/

	stream->Read(&m_iLeaderPromotion);
	stream->Read(&m_iLeaderExperience);

	SAFE_DELETE_ARRAY(m_paszEarlyArtDefineTags);
	m_paszEarlyArtDefineTags = new CvString [m_iGroupDefinitions];
	stream->ReadString(m_iGroupDefinitions, m_paszEarlyArtDefineTags);

	SAFE_DELETE_ARRAY(m_paszLateArtDefineTags);
	m_paszLateArtDefineTags = new CvString [m_iGroupDefinitions];
	stream->ReadString(m_iGroupDefinitions, m_paszLateArtDefineTags);

	SAFE_DELETE_ARRAY(m_paszMiddleArtDefineTags);
	m_paszMiddleArtDefineTags = new CvString [m_iGroupDefinitions];
	stream->ReadString(m_iGroupDefinitions, m_paszMiddleArtDefineTags);

	SAFE_DELETE_ARRAY(m_paszUnitNames);
	m_paszUnitNames = new CvString[m_iNumUnitNames];
	stream->ReadString(m_iNumUnitNames, m_paszUnitNames);

	stream->ReadString(m_szFormationType);

	updateArtDefineButton();

	//Magic Rework
	stream->Read(&m_iMagicalPower);
//	stream->Read(&m_iDominionCapacity);
//	SAFE_DELETE_ARRAY(m_piSpellClassExtraPower);
//	m_piSpellClassExtraPower = new int[GC.getNumSpellClassInfos()];
//	stream->Read(GC.getNumSpellClassInfos(), m_piSpellClassExtraPower);

}

void CvUnitInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iAIWeight);
	stream->Write(m_iProductionCost);
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**								Modifies Cost based on Population								**/
/*************************************************************************************************/
	stream->Write(m_iCityPopCostModifier);
	stream->Write(m_iEmpirePopCostModifier);
	stream->Write(m_iNumCityCostModifier);
	stream->Write(m_iPlayerPopCostModifier);
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Write(m_bNonInfluence);
	stream->Write(m_bInfluence);
	stream->Write(m_iVictoryInfluenceModifier);
	stream->Write(m_iDefeatInfluenceModifier);
	stream->Write(m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Write(m_iExtraPerception);
	stream->Write(m_iInvisibleLevel);
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

	stream->Write(m_iHurryCostModifier);
	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);
	stream->Write(m_iMinAreaSize);
	stream->Write(m_iMoves);
	stream->Write(m_iAirRange);
	stream->Write(m_iAirUnitCap);
	stream->Write(m_iDropRange);
	stream->Write(m_iNukeRange);
	stream->Write(m_iWorkRate);
	stream->Write(m_iBaseDiscover);
	stream->Write(m_iDiscoverMultiplier);
	stream->Write(m_iBaseHurry);
	stream->Write(m_iHurryMultiplier);
	stream->Write(m_iBaseTrade);
	stream->Write(m_iTradeMultiplier);
	stream->Write(m_iGreatWorkCulture);
	stream->Write(m_iEspionagePoints);
	stream->Write(m_iCombat);
	stream->Write(m_iCombatLimit);
	stream->Write(m_iAirCombat);
	stream->Write(m_iAirCombatLimit);
	stream->Write(m_iXPValueAttack);
	stream->Write(m_iXPValueDefense);
	stream->Write(m_iFirstStrikes);
	stream->Write(m_iChanceFirstStrikes);
	stream->Write(m_iInterceptionProbability);
	stream->Write(m_iEvasionProbability);
	stream->Write(m_iWithdrawalProbability);
	stream->Write(m_iEnemyWithdrawalProbability);
	stream->Write(m_iCollateralDamage);
	stream->Write(m_iCollateralDamageLimit);
	stream->Write(m_iCollateralDamageMaxUnits);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	stream->Write(m_iFlankingDamage);
	stream->Write(m_iFlankingDamageLimit);
	stream->Write(m_iFlankingDamageMaxUnits);
/*************************************************************************************************/
/**	Updated Flanking							END												**/
/*************************************************************************************************/
	stream->Write(m_iCityAttackModifier);
	stream->Write(m_iCityDefenseModifier);
	stream->Write(m_iAnimalCombatModifier);
	stream->Write(m_iHillsAttackModifier);
	stream->Write(m_iHillsDefenseModifier);
	stream->Write(m_iBombRate);
	stream->Write(m_iBombardRate);
	stream->Write(m_iSpecialCargo);
	stream->Write(m_iDomainCargo);
	stream->Write(m_iCargoSpace);
	stream->Write(m_iConscriptionValue);
	stream->Write(m_iCultureGarrisonValue);
	stream->Write(m_iExtraCost);
	stream->Write(m_iAssetValue);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iPowerValue);
/**								----  End Original Code  ----									**/
	stream->Write(m_iPowerAdd);
	stream->Write(m_iPowerMult);
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/

	stream->Write(m_iUnitClassType);
	stream->Write(m_iSecondaryUnitClassType);
	stream->Write(m_iSpecialUnitType);
	stream->Write(m_iUnitCaptureClassType);
	stream->Write(m_iUnitCombatType);
	stream->Write(m_iDomainType);
	stream->Write(m_iDefaultUnitAIType);
/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iInvisibleType);
/**								----  End Original Code  ----									**/
	stream->Write((int)m_aiInvisibleTypes.size());
	for(int iI=0;iI<(int)m_aiInvisibleTypes.size();iI++)
		stream->Write(m_aiInvisibleTypes[iI]);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	stream->Write((int)m_aiSeeInvisibleTypes.size());
	for(int i=0;i<(int)m_aiSeeInvisibleTypes.size();i++)
	{
		stream->Write(m_aiSeeInvisibleTypes[i]);
	}

	stream->Write(m_iAdvisorType);
	stream->Write(m_iHolyCity);
	stream->Write(m_iReligionType);
	stream->Write(m_iStateReligion);
	stream->Write(m_iPrereqReligion);
	stream->Write(m_iPrereqCorporation);
	stream->Write(m_iPrereqBuilding);
	stream->Write(m_iPrereqAndTech);
	stream->Write(m_iPrereqAndBonus);
	stream->Write(m_iGroupSize);
	stream->Write(m_iGroupDefinitions);
	stream->Write(m_iUnitMeleeWaveSize);
	stream->Write(m_iUnitRangedWaveSize);
	stream->Write(m_iNumUnitNames);
	stream->Write(m_iCommandType);

	stream->Write(m_bAnimal);
	stream->Write(m_bFoodProduction);
	stream->Write(m_bNoBadGoodies);
	stream->Write(m_bOnlyDefensive);
	stream->Write(m_bNoCapture);
	stream->Write(m_bImmuneToCapture);
	stream->Write(m_bQuickCombat);
	stream->Write(m_bRivalTerritory);
	stream->Write(m_bMilitaryHappiness);
	stream->Write(m_bMilitarySupport);
	stream->Write(m_bMilitaryProduction);
	stream->Write(m_bPillage);
	stream->Write(m_bReligiousCommander); //ReligiousCommander by BI 07/24/11
	stream->Write(m_bSpy);
	stream->Write(m_bSabotage);
	stream->Write(m_bDestroy);
	stream->Write(m_bStealPlans);
	stream->Write(m_bInvestigate);
	stream->Write(m_bCounterSpy);
	stream->Write(m_bFound);
	stream->Write(m_bGoldenAge);
	stream->Write(m_bInvisible);
	stream->Write(m_bFirstStrikeImmune);
	stream->Write(m_bNoDefensiveBonus);
	stream->Write(m_bIgnoreBuildingDefense);
	stream->Write(m_bCanMoveImpassable);
	stream->Write(m_bCanMoveAllTerrain);
	stream->Write(m_bFlatMovementCost);
	stream->Write(m_bIgnoreTerrainCost);
	stream->Write(m_bNukeImmune);
	stream->Write(m_bPrereqBonuses);
	stream->Write(m_bPrereqReligion);
	stream->Write(m_bMechanized);
	stream->Write(m_bRenderBelowWater);
	stream->Write(m_bRenderAlways);
	stream->Write(m_bSuicide);
	stream->Write(m_bLineOfSight);
	stream->Write(m_bHiddenNationality);
	stream->Write(m_bAlwaysHostile);
	stream->Write(m_bNoRevealMap);

	stream->Write(m_fUnitMaxSpeed);
	stream->Write(m_fUnitPadTime);

/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iCommandLimit);
	stream->Write(m_iCommandRange);
	stream->Write(m_bFreeUnit);
	stream->Write(m_bNoSupply);
	stream->Write(m_bCommunalProperty);
	stream->Write(m_bNeverHostile);
	stream->Write(m_bBlind);
	stream->Write(m_bJoinPop);
	stream->Write(m_iPrereqBroadAlignment);
	stream->Write(m_iAlignmentModifier);
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	stream->Write(m_iAlignmentShift);
	stream->Write(m_iAlignmentShiftModifier);
	stream->Write(m_iAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
	stream->WriteString(m_szPyPerTurn);
	stream->Write(NUM_YIELD_TYPES, m_piYieldFromKill);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceFromKill);
	stream->Write(m_bCanClimbPeaks);
	stream->Write(GC.getNumPromotionInfos(), m_pbAllowPromotion);
	stream->Write(GC.getNumPromotionInfos(), m_pbDenyPromotion);
	stream->WriteString(m_szPyDeath);
	stream->WriteString(m_szQuote);
	stream->Write(m_iNumQuotes);
	stream->WriteString(m_iNumQuotes, m_paszQuotes);
	stream->Write(m_iNumImages);
	stream->WriteString(m_iNumImages, m_paszImages);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	stream->Write(m_iAppearanceProb);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Units: Added by Kael 08/04/2007
	stream->Write(m_bAbandon);
	stream->Write(m_bAutoRaze);
	stream->Write(m_bDisableUpgradeTo);
	stream->Write(m_bExplodeInCombat);
	stream->Write(m_bFreeXP);
	stream->Write(m_bImmortal);
	stream->Write(m_bImmuneToDefensiveStrike);
	stream->Write(m_bNeverObsolete);
	stream->Write(m_bNoWarWeariness);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	stream->Write(m_bPromotionBuild);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
	stream->Write(m_iCombatDefense);
	stream->Write(m_iDefensiveStrikeChance);
	stream->Write(m_iDefensiveStrikeDamage);
	stream->Write(m_iDiploVoteType);
	stream->Write(m_iDurationFromCombat);
	stream->Write(m_iEnslavementChance);
	stream->Write(m_iFreePromotionPick);
	stream->Write(m_iGoldFromCombat);
	stream->Write(m_iMinLevel);
	stream->Write(m_iPopCost);
	stream->Write(m_iMiscastChance);
	stream->Write(m_iModifyGlobalCounter);
	stream->Write(m_iEquipmentPromotion);
	stream->Write(m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBroadEthicalAlignment);
	stream->Write(m_iEthicalAlignmentModifier);
	stream->Write(m_iEthicalAlignmentShift);
	stream->Write(m_iEthicalAlignmentShiftModifier);
	stream->Write(m_iEthicalAlignmentShiftTowardsNeutral);
	stream->Write(m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBuildingClass);
	stream->Write(m_iPrereqCivic);
	stream->Write(m_iPrereqGlobalCounter);
	stream->Write(m_iPromotionFromCombat);
	stream->Write(m_iTier);
	stream->Write(m_iUnitConvertFromCombat);
	stream->Write(m_iUnitConvertFromCombatChance);
	stream->Write(m_iUnitCreateFromCombat);
	stream->Write(m_iUnitCreateFromCombatChance);
	stream->Write(m_iUpgradeCiv);
/*************************************************************************************************/
/**	Xienwolf Tweak							11/03/08											**/
/**																								**/
/**							Allows for Multiple sets of WeaponTiers								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iWeaponTier);
/**								----  End Original Code  ----									**/
	stream->Write(m_iWeaponTierMax);
	stream->Write(m_iWeaponTierMin);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	stream->Write(m_iWithdrawlProbDefensive);
	stream->WriteString(m_szImage);
	stream->WriteString(m_szPyPreCombat);	// PyPreCombat by BI 07/24/11
	stream->WriteString(m_szPyPostCombatLost);
	stream->WriteString(m_szPyPostCombatWon);

	stream->Write(GC.getNumBonusInfos(), m_piBonusAffinity);
	stream->Write(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);
//FfH: End Add

	stream->Write(GC.getNUM_UNIT_AND_TECH_PREREQS(), m_piPrereqAndTechs);
	stream->Write(GC.getNUM_UNIT_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);
	stream->Write(GC.getNumTraitInfos(), m_piProductionTraits);
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	stream->Write(GC.getNumTechInfos(), m_piAppearanceTechs);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainAttackModifier);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainDefenseModifier);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureAttackModifier);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureDefenseModifier);
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvUnitInfo
	stream->Write(&m_iUnitHillCost);
	stream->Write(&m_iUnitPeakCost);
	stream->Write(GC.getNumTerrainInfos(), m_piUnitTerrainCost);
	stream->Write(GC.getNumFeatureInfos(), m_piUnitFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	stream->Write(GC.getNumUnitClassInfos(), m_piUnitClassAttackModifier);
	stream->Write(GC.getNumUnitClassInfos(), m_piUnitClassDefenseModifier);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatModifier);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatCollateralImmune);
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainModifier);
	stream->Write(GC.getNumBonusInfos(), m_piBonusProductionModifier);
	stream->Write(m_iGroupDefinitions, m_piUnitGroupRequired);

/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(GC.getNumUnitClassInfos(), m_pbUpgradeUnitClass);
/**								----  End Original Code  ----									**/
	stream->Write(m_iNumUpgradeUnitClass);
	if (m_iNumUpgradeUnitClass > 0)
		stream->Write(m_iNumUpgradeUnitClass, m_piUpgradeUnitClass);
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/

	stream->Write(GC.getNumUnitClassInfos(), m_pbTargetUnitClass);
	stream->Write(GC.getNumUnitCombatInfos(), m_pbTargetUnitCombat);
	stream->Write(GC.getNumUnitClassInfos(), m_pbDefenderUnitClass);
	stream->Write(GC.getNumUnitCombatInfos(), m_pbDefenderUnitCombat);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	// Old: stream->Write(GC.getNumUnitClassInfos(), m_piFlankingStrikeUnitClass);
	stream->Write(GC.getNumUnitCombatInfos(), m_piFlankingStrikeUnitCombat);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	stream->Write(NUM_UNITAI_TYPES, m_pbUnitAIType);
	stream->Write(NUM_UNITAI_TYPES, m_pbNotUnitAIType);
	stream->Write(GC.getNumBuildInfos(), m_pbBuilds);
	stream->Write(GC.getNumReligionInfos(), m_piReligionSpreads);
	stream->Write(GC.getNumCorporationInfos(), m_piCorporationSpreads);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainPassableTech);
	stream->Write(GC.getNumFeatureInfos(), m_piFeaturePassableTech);
	stream->Write(GC.getNumSpecialistInfos(), m_pbGreatPeoples);
	stream->Write(GC.getNumBuildingInfos(), m_pbBuildings);
	stream->Write(GC.getNumBuildingInfos(), m_pbForceBuildings);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainNative);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureNative);
/*************************************************************************************************/
/**	JRouteNative by Jeckel		imported by Valkrionn	09.28.09                        		**/
/*************************************************************************************************/
	stream->Write(GC.getNumRouteInfos(), m_pbRouteNative);
	stream->Write(GC.getNumRouteInfos(), m_pbRouteImpassable);
	stream->Write(GC.getNumRouteInfos(), m_pbRouteIgnore);
	stream->Write(GC.getNumRouteInfos(), m_piRouteSubstitute);
/*************************************************************************************************/
/**	JRouteNative    END                                                                   		**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	stream->Write(m_iNumAffinities);
	if (m_iNumAffinities > 0)
		stream->Write(m_iNumAffinities, m_piAffinities);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainImpassable);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureImpassable);
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
/**										Start Original Code										**
	stream->Write(GC.getNumPromotionInfos(), m_pbFreePromotions);
/**										End Original Code										**/
	stream->Write(GC.getNumPromotionInfos(), m_piFreePromotions);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	stream->Write(m_iLeaderPromotion);
	stream->Write(m_iLeaderExperience);

	stream->WriteString(m_iGroupDefinitions, m_paszEarlyArtDefineTags);
	stream->WriteString(m_iGroupDefinitions, m_paszLateArtDefineTags);
	stream->WriteString(m_iGroupDefinitions, m_paszMiddleArtDefineTags);
	stream->WriteString(m_iNumUnitNames, m_paszUnitNames);

	stream->WriteString(m_szFormationType);
	//Magic Rework
	stream->Write(m_iMagicalPower);
//	stream->Write(m_iDominionCapacity);
//	stream->Write(GC.getNumSpellClassInfos(), m_piSpellClassExtraPower);

}

//
// read from xml
//
bool CvUnitInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	int j=0;				//loop counter
	int k=0;				//loop counter
	int iNumSibs=0;				// the number of siblings the current xml node has
	int iIndexVal;

	pXML->GetChildXmlValByName(szTextVal, "Class");
	m_iUnitClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SecondaryClass");
	m_iSecondaryUnitClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Special");
	m_iSpecialUnitType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Capture");
	m_iUnitCaptureClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Combat");
	m_iUnitCombatType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Domain", "DOMAIN_LAND");
	m_iDomainType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DefaultUnitAI", "UNITAI_UNKNOWN");
	m_iDefaultUnitAIType = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "Invisible");
	m_iInvisibleType = pXML->FindInInfoClass(szTextVal);
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(szTextVal, "Invisible");
	std::vector<CvString> token;
	szTextVal.getTokens(",", token);
	for(int i=0;i<(int)token.size();i++)
	{
		int iInvisibleType = pXML->FindInInfoClass(token[i]);
		if(iInvisibleType != NO_INVISIBLE)
		{
			m_aiInvisibleTypes.push_back(iInvisibleType);
		}
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "SeeInvisible");
	std::vector<CvString> tokens;
	szTextVal.getTokens(",", tokens);
	for(int i=0;i<(int)tokens.size();i++)
	{
		int iInvisibleType = pXML->FindInInfoClass(tokens[i]);
		if(iInvisibleType != NO_INVISIBLE)
		{
			m_aiSeeInvisibleTypes.push_back(iInvisibleType);
		}
	}

	pXML->GetChildXmlValByName(szTextVal, "Advisor");
	m_iAdvisorType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bAnimal, "bAnimal");
	pXML->GetChildXmlValByName(&m_bFoodProduction, "bFood");
	pXML->GetChildXmlValByName(&m_bNoBadGoodies, "bNoBadGoodies");
	pXML->GetChildXmlValByName(&m_bOnlyDefensive, "bOnlyDefensive");
	pXML->GetChildXmlValByName(&m_bNoCapture, "bCannotCapture");
	pXML->GetChildXmlValByName(&m_bImmuneToCapture, "bImmuneToCapture");
	pXML->GetChildXmlValByName(&m_bQuickCombat, "bQuickCombat");
	pXML->GetChildXmlValByName(&m_bRivalTerritory, "bRivalTerritory");
	pXML->GetChildXmlValByName(&m_bMilitaryHappiness, "bMilitaryHappiness");
	pXML->GetChildXmlValByName(&m_bMilitarySupport, "bMilitarySupport");
	pXML->GetChildXmlValByName(&m_bMilitaryProduction, "bMilitaryProduction");
	pXML->GetChildXmlValByName(&m_bPillage, "bPillage");
	pXML->GetChildXmlValByName(&m_bReligiousCommander, "bReligiousCommander"); //ReligiousCommander by BI 07/24/11
	pXML->GetChildXmlValByName(&m_bSpy, "bSpy");
	pXML->GetChildXmlValByName(&m_bSabotage, "bSabotage");
	pXML->GetChildXmlValByName(&m_bDestroy, "bDestroy");
	pXML->GetChildXmlValByName(&m_bStealPlans, "bStealPlans");
	pXML->GetChildXmlValByName(&m_bInvestigate, "bInvestigate");
	pXML->GetChildXmlValByName(&m_bCounterSpy, "bCounterSpy");
	pXML->GetChildXmlValByName(&m_bFound, "bFound");
	pXML->GetChildXmlValByName(&m_bGoldenAge, "bGoldenAge");
	pXML->GetChildXmlValByName(&m_bInvisible, "bInvisible");
	pXML->GetChildXmlValByName(&m_bFirstStrikeImmune, "bFirstStrikeImmune");
	pXML->GetChildXmlValByName(&m_bNoDefensiveBonus, "bNoDefensiveBonus");
	pXML->GetChildXmlValByName(&m_bIgnoreBuildingDefense, "bIgnoreBuildingDefense");
	pXML->GetChildXmlValByName(&m_bCanMoveImpassable, "bCanMoveImpassable");
	pXML->GetChildXmlValByName(&m_bCanMoveAllTerrain, "bCanMoveAllTerrain");
	pXML->GetChildXmlValByName(&m_bFlatMovementCost, "bFlatMovementCost");
	pXML->GetChildXmlValByName(&m_bIgnoreTerrainCost, "bIgnoreTerrainCost");
	pXML->GetChildXmlValByName(&m_bNukeImmune, "bNukeImmune");
	pXML->GetChildXmlValByName(&m_bPrereqBonuses, "bPrereqBonuses");
	pXML->GetChildXmlValByName(&m_bPrereqReligion, "bPrereqReligion");
	pXML->GetChildXmlValByName(&m_bMechanized,"bMechanized",false);
	pXML->GetChildXmlValByName(&m_bRenderBelowWater,"bRenderBelowWater",false);
	pXML->GetChildXmlValByName(&m_bRenderAlways,"bRenderAlways",false);
	pXML->GetChildXmlValByName(&m_bSuicide,"bSuicide");
	pXML->GetChildXmlValByName(&m_bLineOfSight,"bLineOfSight",false);
	pXML->GetChildXmlValByName(&m_bHiddenNationality,"bHiddenNationality",false);
	pXML->GetChildXmlValByName(&m_bAlwaysHostile,"bAlwaysHostile",false);
	pXML->GetChildXmlValByName(&m_bNoRevealMap,"bNoRevealMap",false);

	//Magic Rework
	pXML->GetChildXmlValByName(&m_iMagicalPower, "iMagicalPower");
//	pXML->GetChildXmlValByName(&m_iDominionCapacity, "iDominionCapacity");
//	pXML->SetVariableListTagPair(&m_piSpellClassExtraPower, "SpellClassExtraPowers", sizeof(GC.getSpellClassInfo((SpellClassTypes)0)), GC.getNumSpellClassInfos());

/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->SetVariableListTagPair(&m_pbUpgradeUnitClass, "UnitClassUpgrades", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
/**								----  End Original Code  ----									**/
	//A little awkward way of handling it, make a proper function instead?
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UnitClassUpgrades"))
	{
		pXML->SetIntWithChildList(&m_iNumUpgradeUnitClass, &m_piUpgradeUnitClass);
	}
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_pbTargetUnitClass, "UnitClassTargets", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_pbTargetUnitCombat, "UnitCombatTargets", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pbDefenderUnitClass, "UnitClassDefenders", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_pbDefenderUnitCombat, "UnitCombatDefenders", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	// Old: pXML->SetVariableListTagPair(&m_piFlankingStrikeUnitClass, "FlankingStrikes", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_piFlankingStrikeUnitCombat, "FlankingStrikes", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_pbUnitAIType, "UnitAIs", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);
	pXML->SetVariableListTagPair(&m_pbNotUnitAIType, "NotUnitAIs", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);

	pXML->SetVariableListTagPair(&m_pbBuilds, "Builds", sizeof(GC.getBuildInfo((BuildTypes)0)), GC.getNumBuildInfos());

	pXML->SetVariableListTagPair(&m_piReligionSpreads, "ReligionSpreads", sizeof(GC.getReligionInfo((ReligionTypes)0)), GC.getNumReligionInfos());
	pXML->SetVariableListTagPair(&m_piCorporationSpreads, "CorporationSpreads", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());

	CvString* pszTemp = NULL;
	pXML->SetVariableListTagPair(&pszTemp, "TerrainPassableTechs", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	m_piTerrainPassableTech = new int[GC.getNumTerrainInfos()];
	for (int i = 0; i < GC.getNumTerrainInfos(); ++i)
	{
		m_piTerrainPassableTech[i] = pszTemp[i].IsEmpty() ? NO_TECH : pXML->FindInInfoClass(pszTemp[i]);
	}
	SAFE_DELETE_ARRAY(pszTemp);

	pXML->SetVariableListTagPair(&pszTemp, "FeaturePassableTechs", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	m_piFeaturePassableTech = new int[GC.getNumFeatureInfos()];
	for (int i = 0; i < GC.getNumFeatureInfos(); ++i)
	{
		m_piFeaturePassableTech[i] = pszTemp[i].IsEmpty() ? NO_TECH : pXML->FindInInfoClass(pszTemp[i]);
	}
	SAFE_DELETE_ARRAY(pszTemp);

	pXML->SetVariableListTagPair(&m_pbGreatPeoples, "GreatPeoples", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	pXML->SetVariableListTagPair(&m_pbBuildings, "Buildings", sizeof(GC.getBuildingInfo((BuildingTypes)0)), GC.getNumBuildingInfos());
	pXML->SetVariableListTagPair(&m_pbForceBuildings, "ForceBuildings", sizeof(GC.getBuildingInfo((BuildingTypes)0)), GC.getNumBuildingInfos());

	pXML->GetChildXmlValByName(szTextVal, "HolyCity");
	m_iHolyCity = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ReligionType");
	m_iReligionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StateReligion");
	m_iStateReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqCorporation");
	m_iPrereqCorporation = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqBuilding");
	m_iPrereqBuilding = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iPrereqAndTech = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechTypes"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_UNIT_AND_TECH_PREREQS()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_UNIT_AND_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_UNIT_AND_TECH_PREREQS()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (j=0;j<iNumSibs;j++)
					{
						m_piPrereqAndTechs[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_UNIT_AND_TECH_PREREQS(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "BonusType");
	m_iPrereqAndBonus = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonuses"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_UNIT_PREREQ_OR_BONUSES()),"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_UNIT_PREREQ_OR_BONUSES(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_UNIT_PREREQ_OR_BONUSES()) , "There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (j=0;j<iNumSibs;j++)
					{
						m_piPrereqOrBonuses[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_UNIT_PREREQ_OR_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piAppearanceTechs, "AppearanceTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());

	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iProductionCost, "iCost", -1);
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**								Modifies Cost based on Population								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iCityPopCostModifier, "iCityPopCostModifier");
	pXML->GetChildXmlValByName(&m_iEmpirePopCostModifier, "iEmpirePopCostModifier");
	pXML->GetChildXmlValByName(&m_iNumCityCostModifier, "iNumCityCostModifier");
	pXML->GetChildXmlValByName(&m_iPlayerPopCostModifier, "iPlayerPopCostModifier");
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bNonInfluence, "bNonInfluence");
	pXML->GetChildXmlValByName(&m_bInfluence, "bInfluence");
	pXML->GetChildXmlValByName(&m_iVictoryInfluenceModifier, "iVictoryInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iDefeatInfluenceModifier, "iDefeatInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iPillageInfluenceModifier, "iPillageInfluenceModifier", 100);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iExtraPerception, "iExtraPerception", 0);
	pXML->GetChildXmlValByName(&m_iInvisibleLevel, "iInvisibleLevel", 0);
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(&m_iHurryCostModifier, "iHurryCostModifier");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost", 100);
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");
	pXML->GetChildXmlValByName(&m_iMinAreaSize, "iMinAreaSize", -1);
	pXML->GetChildXmlValByName(&m_iMoves, "iMoves");
	pXML->GetChildXmlValByName(&m_iAirRange, "iAirRange");
	pXML->GetChildXmlValByName(&m_iAirUnitCap, "iAirUnitCap");
	pXML->GetChildXmlValByName(&m_iDropRange, "iDropRange");
	pXML->GetChildXmlValByName(&m_iNukeRange, "iNukeRange", -1);
	pXML->GetChildXmlValByName(&m_iWorkRate, "iWorkRate");
	pXML->GetChildXmlValByName(&m_iBaseDiscover, "iBaseDiscover");
	pXML->GetChildXmlValByName(&m_iDiscoverMultiplier, "iDiscoverMultiplier");
	pXML->GetChildXmlValByName(&m_iBaseHurry, "iBaseHurry");
	pXML->GetChildXmlValByName(&m_iHurryMultiplier, "iHurryMultiplier");
	pXML->GetChildXmlValByName(&m_iBaseTrade, "iBaseTrade");
	pXML->GetChildXmlValByName(&m_iTradeMultiplier, "iTradeMultiplier");
	pXML->GetChildXmlValByName(&m_iGreatWorkCulture, "iGreatWorkCulture");
	pXML->GetChildXmlValByName(&m_iEspionagePoints, "iEspionagePoints");

	pXML->SetVariableListTagPair(&m_pbTerrainImpassable, "TerrainImpassables", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos(), false);
	pXML->SetVariableListTagPair(&m_pbFeatureImpassable, "FeatureImpassables", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos(), false);

	pXML->GetChildXmlValByName(&m_iCombat, "iCombat");
	pXML->GetChildXmlValByName(&m_iCombatLimit, "iCombatLimit", 100);
	pXML->GetChildXmlValByName(&m_iAirCombat, "iAirCombat");
	pXML->GetChildXmlValByName(&m_iAirCombatLimit, "iAirCombatLimit");
	pXML->GetChildXmlValByName(&m_iXPValueAttack, "iXPValueAttack", 8);
	pXML->GetChildXmlValByName(&m_iXPValueDefense, "iXPValueDefense", 4);
	pXML->GetChildXmlValByName(&m_iFirstStrikes, "iFirstStrikes");
	pXML->GetChildXmlValByName(&m_iChanceFirstStrikes, "iChanceFirstStrikes");
	pXML->GetChildXmlValByName(&m_iInterceptionProbability, "iInterceptionProbability");
	pXML->GetChildXmlValByName(&m_iEvasionProbability, "iEvasionProbability");
	pXML->GetChildXmlValByName(&m_iWithdrawalProbability, "iWithdrawalProb");
	pXML->GetChildXmlValByName(&m_iEnemyWithdrawalProbability, "iEnemyWithdrawalProb");
	pXML->GetChildXmlValByName(&m_iCollateralDamage, "iCollateralDamage");
	pXML->GetChildXmlValByName(&m_iCollateralDamageLimit, "iCollateralDamageLimit");
	pXML->GetChildXmlValByName(&m_iCollateralDamageMaxUnits, "iCollateralDamageMaxUnits");

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iFlankingDamage, "iFlankingDamage");
	pXML->GetChildXmlValByName(&m_iFlankingDamageLimit, "iFlankingDamageLimit");
	pXML->GetChildXmlValByName(&m_iFlankingDamageMaxUnits, "iFlankingDamageMaxUnits");
/*************************************************************************************************/
/**	Updated Flanking							END												**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(&m_iCityAttackModifier, "iCityAttack");
	pXML->GetChildXmlValByName(&m_iCityDefenseModifier, "iCityDefense");
	pXML->GetChildXmlValByName(&m_iAnimalCombatModifier, "iAnimalCombat");
	pXML->GetChildXmlValByName(&m_iHillsAttackModifier, "iHillsAttack");
	pXML->GetChildXmlValByName(&m_iHillsDefenseModifier, "iHillsDefense");

	pXML->SetVariableListTagPair(&m_pbTerrainNative, "TerrainNatives", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureNative, "FeatureNatives", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	JRouteNative by Jeckel		imported by Valkrionn	09.28.09                        		**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_pbRouteNative, "RouteNatives", sizeof(GC.getRouteInfo((RouteTypes)0)), GC.getNumRouteInfos());
	pXML->SetVariableListTagPair(&m_pbRouteImpassable, "RouteImpassables", sizeof(GC.getRouteInfo((RouteTypes)0)), GC.getNumRouteInfos());
	pXML->SetVariableListTagPair(&m_pbRouteIgnore, "RouteIgnores", sizeof(GC.getRouteInfo((RouteTypes)0)), GC.getNumRouteInfos());
	/*pXML->SetVariableListTagPair(&m_piRouteSubstitute, "RouteSubstitutes", sizeof(GC.getRouteInfo((RouteTypes)0)), GC.getNumRouteInfos());
	for (int iI = 0; iI < GC.getNumRouteInfos(); iI++)
	{
		m_piRouteSubstitute[iI] = -1;
	}*/
	pXML->SetVariableListTagPair(&pszTemp, "RouteSubstitutes", sizeof(GC.getRouteInfo((RouteTypes)0)), GC.getNumRouteInfos());
	m_piRouteSubstitute = new int[GC.getNumRouteInfos()];
	for (int i = 0; i < GC.getNumRouteInfos(); ++i)
	{
		m_piRouteSubstitute[i] = pszTemp[i].IsEmpty() ? NO_ROUTE : pXML->FindInInfoClass(pszTemp[i]);
	}
	SAFE_DELETE_ARRAY(pszTemp);
/*************************************************************************************************/
/**	JRouteNative    END                                                                   		**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Affinities"))				pXML->SetIntWithChildList(&m_iNumAffinities, &m_piAffinities);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piTerrainAttackModifier, "TerrainAttacks", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piTerrainDefenseModifier, "TerrainDefenses", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piFeatureAttackModifier, "FeatureAttacks", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_piFeatureDefenseModifier, "FeatureDefenses", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvUnitInfo
	pXML->GetChildXmlValByName(&m_iUnitHillCost, "iHillMoveCost");
	pXML->GetChildXmlValByName(&m_iUnitPeakCost, "iPeakMoveCost");
	pXML->SetVariableListTagPair(&m_piUnitTerrainCost, "TerrainMoveCosts", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piUnitFeatureCost, "FeatureMoveCosts", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piUnitClassAttackModifier, "UnitClassAttackMods", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_piUnitClassDefenseModifier, "UnitClassDefenseMods", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());

	pXML->SetVariableListTagPair(&m_piUnitCombatModifier, "UnitCombatMods", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_piUnitCombatCollateralImmune, "UnitCombatCollateralImmunes", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_piDomainModifier, "DomainMods", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);

	pXML->SetVariableListTagPair(&m_piBonusProductionModifier, "BonusProductionModifiers", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());

	pXML->GetChildXmlValByName(&m_iBombRate, "iBombRate");
	pXML->GetChildXmlValByName(&m_iBombardRate, "iBombardRate");

	pXML->GetChildXmlValByName(szTextVal, "SpecialCargo");
	m_iSpecialCargo = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DomainCargo");
	m_iDomainCargo = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iCargoSpace, "iCargo");
	pXML->GetChildXmlValByName(&m_iConscriptionValue, "iConscription");
	pXML->GetChildXmlValByName(&m_iCultureGarrisonValue, "iCultureGarrison");
	pXML->GetChildXmlValByName(&m_iExtraCost, "iExtraCost");
	pXML->GetChildXmlValByName(&m_iTier,"iTier");
	pXML->GetChildXmlValByName(&m_iAssetValue, "iAsset", m_iCombat * m_iTier / 2);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(&m_iPowerValue, "iPower", m_iCombat * m_iTier);
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(&m_iPowerAdd, "iPowerAdd");
	pXML->GetChildXmlValByName(&m_iPowerMult, "iPowerMult");
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	// Read the mesh groups elements
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UnitMeshGroups") )
	{
		pXML->GetChildXmlValByName( &m_iGroupSize, "iGroupSize");
		m_iGroupDefinitions = iIndexVal = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "UnitMeshGroup");
		m_piUnitGroupRequired = new int[ iIndexVal ];
		pXML->GetChildXmlValByName( &m_iUnitMeleeWaveSize, "iMeleeWaveSize" );
		pXML->GetChildXmlValByName( &m_iUnitRangedWaveSize, "iRangedWaveSize" );
		pXML->GetChildXmlValByName( &m_fUnitMaxSpeed, "fMaxSpeed", 1.75);
		pXML->GetChildXmlValByName( &m_fUnitPadTime, "fPadTime", 1);
		m_paszEarlyArtDefineTags = new CvString[ iIndexVal ];
		m_paszLateArtDefineTags = new CvString[ iIndexVal ];
		m_paszMiddleArtDefineTags = new CvString[ iIndexVal ];

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "UnitMeshGroup"))
		{
			for ( k = 0; k < iIndexVal; k++ )
			{
				pXML->GetChildXmlValByName( &m_piUnitGroupRequired[k], "iRequired");
				pXML->GetChildXmlValByName(szTextVal, "EarlyArtDefineTag");
				setEarlyArtDefineTag(k, szTextVal);
				pXML->GetChildXmlValByName(szTextVal, "LateArtDefineTag");
				setLateArtDefineTag(k, szTextVal);
				pXML->GetChildXmlValByName(szTextVal, "MiddleArtDefineTag");
				setMiddleArtDefineTag(k, szTextVal);
				gDLL->getXMLIFace()->NextSibling(pXML->GetXML());
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(m_szFormationType, "FormationType", "FORMATION_TYPE_DEFAULT");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UniqueNames"))
	{
		pXML->SetStringList(&m_paszUnitNames, &m_iNumUnitNames);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
/**										Start Original Code										**
	pXML->SetVariableListTagPair(&m_pbFreePromotions, "FreePromotions", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos());
/**										End Original Code										**/
	pXML->SetVariableListTagPair(&m_piFreePromotions, "FreePromotions", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos());
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "LeaderPromotion");
	m_iLeaderPromotion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iLeaderExperience, "iLeaderExperience");

/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iCommandLimit,"iCommandLimit");
	pXML->GetChildXmlValByName(&m_iCommandRange,"iCommandRange");
	pXML->GetChildXmlValByName(&m_bFreeUnit,"bFreeUnit");
	pXML->GetChildXmlValByName(&m_bNoSupply,"bNoSupply");
	pXML->GetChildXmlValByName(&m_bCommunalProperty,"bCommunalProperty");
	pXML->GetChildXmlValByName(&m_bNeverHostile,"bNeverHostile");
	pXML->GetChildXmlValByName(&m_bBlind,"bBlind");
	pXML->GetChildXmlValByName(&m_bJoinPop, "bJoinPop");
	pXML->GetChildXmlValByName(&m_iPrereqBroadAlignment,"iPrereqBroadAlignment");
	pXML->GetChildXmlValByName(&m_iAlignmentModifier,"iAlignmentModifier");
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentShift, "iAlignmentShift");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftModifier, "iAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftTowardsNeutral, "iAlignmentShiftTowardsNeutral");
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(m_szPyPerTurn, "PyPerTurn");
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldsFromKill"))
	{
		pXML->SetYields(&m_piYieldFromKill);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldFromKill, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommercesFromKill"))
	{
		pXML->SetCommerce(&m_piCommerceFromKill);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceFromKill, NUM_COMMERCE_TYPES);
	}

	pXML->GetChildXmlValByName(&m_bCanClimbPeaks, "bCanClimbPeaks");
	pXML->InitList(&m_pbAllowPromotion, GC.getNumPromotionInfos());
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AllowPromotions"))
	{
		pXML->SetBoolFromChildList(GC.getNumPromotionInfos(), &m_pbAllowPromotion);
	}
	pXML->InitList(&m_pbDenyPromotion, GC.getNumPromotionInfos());
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"DenyPromotions"))
	{
		pXML->SetBoolFromChildList(GC.getNumPromotionInfos(), &m_pbDenyPromotion);
	}
	pXML->GetChildXmlValByName(m_szPyDeath, "PythonOnDeath");
	pXML->GetChildXmlValByName(m_szQuote, "Quote");
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Quotes"))
	{
		pXML->SetStringList(&m_paszQuotes, &m_iNumQuotes);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Images"))
	{
		pXML->SetStringList(&m_paszImages, &m_iNumImages);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAppearanceProb,"iAppearanceProb");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Units: Added by Kael 08/04/2007
	pXML->GetChildXmlValByName(&m_bAbandon,"bAbandon");
	pXML->GetChildXmlValByName(&m_bAutoRaze,"bAutoRaze");
	pXML->GetChildXmlValByName(&m_bDisableUpgradeTo,"bDisableUpgradeTo");
	pXML->GetChildXmlValByName(&m_bExplodeInCombat,"bExplodeInCombat");
	pXML->GetChildXmlValByName(&m_bFreeXP,"bFreeXP");
	pXML->GetChildXmlValByName(&m_bImmortal,"bImmortal");
	pXML->GetChildXmlValByName(&m_bImmuneToDefensiveStrike,"bImmuneToDefensiveStrike");
	pXML->GetChildXmlValByName(&m_bNeverObsolete,"bNeverObsolete");
	pXML->GetChildXmlValByName(&m_bNoWarWeariness,"bNoWarWeariness");
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bPromotionBuild,"bPromotionBuild");
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iCombatDefense,"iCombatDefense", m_iCombat);
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeChance,"iDefensiveStrikeChance");
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeDamage,"iDefensiveStrikeDamage");
	pXML->GetChildXmlValByName(&m_iDurationFromCombat,"iDurationFromCombat");
	pXML->GetChildXmlValByName(&m_iEnslavementChance,"iEnslavementChance");
	pXML->GetChildXmlValByName(&m_iFreePromotionPick,"iFreePromotionPick");
	pXML->GetChildXmlValByName(&m_iGoldFromCombat,"iGoldFromCombat");
	pXML->GetChildXmlValByName(&m_iMinLevel,"iMinLevel");
	pXML->GetChildXmlValByName(&m_iPopCost, "iPopCost");
	pXML->GetChildXmlValByName(&m_iMiscastChance,"iMiscastChance");
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter,"iModifyGlobalCounter");
	pXML->GetChildXmlValByName(szTextVal, "DiploVoteType");
	m_iDiploVoteType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EquipmentPromotion");
	m_iEquipmentPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqEthicalAlignment");
	m_iPrereqEthicalAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iPrereqBroadEthicalAlignment,"iPrereqBroadEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier,"iEthicalAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShift, "iEthicalAlignmentShift");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftModifier, "iEthicalAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftTowardsNeutral, "iEthicalAlignmentShiftTowardsNeutral");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqBuildingClass");
	m_iPrereqBuildingClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivic");
	m_iPrereqCivic = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionFromCombat");
	m_iPromotionFromCombat = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iPrereqGlobalCounter,"iPrereqGlobalCounter");
	pXML->GetChildXmlValByName(m_szImage, "Image");
	pXML->GetChildXmlValByName(&m_iUnitConvertFromCombatChance,"iUnitConvertFromCombatChance");
	pXML->GetChildXmlValByName(&m_iUnitCreateFromCombatChance,"iUnitCreateFromCombatChance");
	pXML->GetChildXmlValByName(szTextVal, "UpgradeCiv");
	m_aszExtraXMLforPass3.push_back(szTextVal);
/*************************************************************************************************/
/**	Xienwolf Tweak							11/03/08											**/
/**																								**/
/**							Allows for Multiple sets of WeaponTiers								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(&m_iWeaponTier,"iWeaponTier");
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(&m_iWeaponTierMax,"iWeaponTierMax");
	pXML->GetChildXmlValByName(&m_iWeaponTierMin,"iWeaponTierMin");
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iWithdrawlProbDefensive,"iWithdrawlProbDefensive");
	pXML->GetChildXmlValByName(m_szPyPreCombat, "PythonPreCombat");//PyPreCombat by BI 07/24/11

	pXML->GetChildXmlValByName(m_szPyPostCombatLost, "PythonPostCombatLost");
	pXML->GetChildXmlValByName(m_szPyPostCombatWon, "PythonPostCombatWon");
	pXML->SetVariableListTagPair(&m_piDamageTypeCombat, "DamageTypeCombats", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
	pXML->SetVariableListTagPair(&m_piBonusAffinity, "BonusAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
//FfH: End Add

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** if we're using a module, assuming the meshgroup isn't set, we update first after            **/
/** the copyNonDefaults method                                                                  **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	updateArtDefineButton();
/**								----  End Original Code  ----									**/
	if (m_iGroupSize != 0)
	{
		updateArtDefineButton();
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}

//FfH Units: Added by Kael 08/04/2007
bool CvUnitInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "UnitConvertFromCombat");
	m_iUnitConvertFromCombat = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitCreateFromCombat");
	m_iUnitCreateFromCombat = pXML->FindInInfoClass(szTextVal);

	return true;
}

bool CvUnitInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iUpgradeCiv = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iUpgradeCiv = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(UnitInfos)																	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitInfo::copyNonDefaults(CvUnitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if(isFreeUnit()							== false)			m_bFreeUnit							= pClassInfo->isFreeUnit();
	if(isNoSupply()							== false)			m_bNoSupply							= pClassInfo->isNoSupply();
	if(isAnimal()							== false)			m_bAnimal							= pClassInfo->isAnimal();
	if(isFoodProduction()					== false)			m_bFoodProduction					= pClassInfo->isFoodProduction();
	if(isNoBadGoodies()						== false)			m_bNoBadGoodies						= pClassInfo->isNoBadGoodies();
	if(isOnlyDefensive()					== false)			m_bOnlyDefensive					= pClassInfo->isOnlyDefensive();
	if(isCannotCapture()						== false)			m_bNoCapture						= pClassInfo->isCannotCapture();
	if (isImmuneToCapture() == false)			m_bImmuneToCapture = pClassInfo->isImmuneToCapture();
	if(isQuickCombat()						== false)			m_bQuickCombat						= pClassInfo->isQuickCombat();
	if(isRivalTerritory()					== false)			m_bRivalTerritory					= pClassInfo->isRivalTerritory();
	if(isMilitaryHappiness()				== false)			m_bMilitaryHappiness				= pClassInfo->isMilitaryHappiness();
	if(isMilitarySupport()					== false)			m_bMilitarySupport					= pClassInfo->isMilitarySupport();
	if(isMilitaryProduction()				== false)			m_bMilitaryProduction				= pClassInfo->isMilitaryProduction();
	if(isPillage()							== false)			m_bPillage							= pClassInfo->isPillage();

	//Magic Rework
	if (getMagicalPower() == 0)				m_iMagicalPower = pClassInfo->getMagicalPower();
//	if (getDominionCapacity() == 0)				m_iDominionCapacity = pClassInfo->getDominionCapacity();
//	for (int i = 0; i < GC.getNumSpellClassInfos(); ++i)
//	{
//		if (getSpellClassExtraPower(i) == 0)				m_piSpellClassExtraPower[i] = pClassInfo->getSpellClassExtraPower(i);
//	}

	//religiousCommander by BI 07/24/11
	if(isReligiousCommander()							== false)			m_bReligiousCommander							= pClassInfo->isReligiousCommander();


	if(isSpy()								== false)			m_bSpy								= pClassInfo->isSpy();
	if(isSabotage()							== false)			m_bSabotage							= pClassInfo->isSabotage();
	if(isDestroy()							== false)			m_bDestroy							= pClassInfo->isDestroy();
	if(isStealPlans()						== false)			m_bStealPlans						= pClassInfo->isStealPlans();
	if(isInvestigate()						== false)			m_bInvestigate						= pClassInfo->isInvestigate();
	if(isCounterSpy()						== false)			m_bCounterSpy						= pClassInfo->isCounterSpy();
	if(isFound()							== false)			m_bFound							= pClassInfo->isFound();
	if(isGoldenAge()						== false)			m_bGoldenAge						= pClassInfo->isGoldenAge();
	if(isInvisible()						== false)			m_bInvisible						= pClassInfo->isInvisible();
	if(isFirstStrikeImmune()				== false)			m_bFirstStrikeImmune				= pClassInfo->isFirstStrikeImmune();
	if(isNoDefensiveBonus()					== false)			m_bNoDefensiveBonus					= pClassInfo->isNoDefensiveBonus();
	if(isIgnoreBuildingDefense()			== false)			m_bIgnoreBuildingDefense			= pClassInfo->isIgnoreBuildingDefense();
	if(isCanMoveImpassable()				== false)			m_bCanMoveImpassable				= pClassInfo->isCanMoveImpassable();
	if(isCanMoveAllTerrain()				== false)			m_bCanMoveAllTerrain				= pClassInfo->isCanMoveAllTerrain();
	if(isFlatMovementCost()					== false)			m_bFlatMovementCost					= pClassInfo->isFlatMovementCost();
	if(isIgnoreTerrainCost()				== false)			m_bIgnoreTerrainCost				= pClassInfo->isIgnoreTerrainCost();
	if(isNukeImmune()						== false)			m_bNukeImmune						= pClassInfo->isNukeImmune();
	if(isPrereqBonuses()					== false)			m_bPrereqBonuses					= pClassInfo->isPrereqBonuses();
	if(isPrereqReligion()					== false)			m_bPrereqReligion					= pClassInfo->isPrereqReligion();
	if(isMechUnit()							== false)			m_bMechanized						= pClassInfo->isMechUnit();
	if(isRenderBelowWater()					== false)			m_bRenderBelowWater					= pClassInfo->isRenderBelowWater();
	if(isRenderAlways()						== false)			m_bRenderAlways						= pClassInfo->isRenderAlways();
	if(isSuicide()							== false)			m_bSuicide							= pClassInfo->isSuicide();
	if(isLineOfSight()						== false)			m_bLineOfSight						= pClassInfo->isLineOfSight();
	if(isHiddenNationality()				== false)			m_bHiddenNationality				= pClassInfo->isHiddenNationality();
	if(isAlwaysHostile()					== false)			m_bAlwaysHostile					= pClassInfo->isAlwaysHostile();
	if(isNoRevealMap()						== false)			m_bNoRevealMap						= pClassInfo->isNoRevealMap();
	if(isAbandon()							== false)			m_bAbandon							= pClassInfo->isAbandon();
	if(isAutoRaze()							== false)			m_bAutoRaze							= pClassInfo->isAutoRaze();
	if(isDisableUpgradeTo()					== false)			m_bDisableUpgradeTo					= pClassInfo->isDisableUpgradeTo();
	if(isExplodeInCombat()					== false)			m_bExplodeInCombat					= pClassInfo->isExplodeInCombat();
	if(isFreeXP()							== false)			m_bFreeXP							= pClassInfo->isFreeXP();
	if(isImmortal()							== false)			m_bImmortal							= pClassInfo->isImmortal();
	if(isImmuneToDefensiveStrike()			== false)			m_bImmuneToDefensiveStrike			= pClassInfo->isImmuneToDefensiveStrike();
	if(isNeverObsolete()					== false)			m_bNeverObsolete					= pClassInfo->isNeverObsolete();
	if(isNoWarWeariness()					== false)			m_bNoWarWeariness					= pClassInfo->isNoWarWeariness();
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	if(isPromotionBuild()					== false)			m_bPromotionBuild					= pClassInfo->isPromotionBuild();
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
	if(isCommunalProperty()					== false)			m_bCommunalProperty					= pClassInfo->isCommunalProperty();
	if(isNeverHostile()						== false)			m_bNeverHostile						= pClassInfo->isNeverHostile();
	if(isBlind()							== false)			m_bBlind							= pClassInfo->isBlind();
	if (isJoinPop() == false)			m_bJoinPop = pClassInfo->isJoinPop();
	if(isCanClimbPeaks()					== false)			m_bCanClimbPeaks					= pClassInfo->isCanClimbPeaks();
	if(getCommandLimit()					== 0)				m_iCommandLimit						= pClassInfo->getCommandLimit();
	if(getCommandRange()					== 0)				m_iCommandRange						= pClassInfo->getCommandRange();
	if(getDefensiveStrikeChance()			== 0)				m_iDefensiveStrikeChance			= pClassInfo->getDefensiveStrikeChance();
	if(getDefensiveStrikeDamage()			== 0)				m_iDefensiveStrikeDamage			= pClassInfo->getDefensiveStrikeDamage();
	if(getDurationFromCombat()				== 0)				m_iDurationFromCombat				= pClassInfo->getDurationFromCombat();
	if(getEnslavementChance()				== 0)				m_iEnslavementChance				= pClassInfo->getEnslavementChance();
	if(getFreePromotionPick()				== 0)				m_iFreePromotionPick				= pClassInfo->getFreePromotionPick();
	if(getGoldFromCombat()					== 0)				m_iGoldFromCombat					= pClassInfo->getGoldFromCombat();
	if(getMinLevel()						== 0)				m_iMinLevel							= pClassInfo->getMinLevel();
	if (getPopCost() == 0)				m_iPopCost = pClassInfo->getPopCost();
	if(getMiscastChance()					== 0)				m_iMiscastChance					= pClassInfo->getMiscastChance();
	if(getModifyGlobalCounter()				== 0)				m_iModifyGlobalCounter				= pClassInfo->getModifyGlobalCounter();
	if(getPrereqBroadAlignment()			== 0)				m_iPrereqBroadAlignment				= pClassInfo->getPrereqBroadAlignment();
	if(getAlignmentModifier()				== 0)				m_iAlignmentModifier				= pClassInfo->getAlignmentModifier();
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	if (getAlignmentShift()                 == 0)               m_iAlignmentShift                   = pClassInfo->getAlignmentShift();
	if (getAlignmentShiftModifier()         == 0)               m_iAlignmentShiftModifier           = pClassInfo->getAlignmentShiftModifier();
	if (getAlignmentShiftTowardsNeutral()   == -1)              m_iAlignmentShiftTowardsNeutral     = pClassInfo->getAlignmentShiftTowardsNeutral();
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	if(getAppearanceProb()                  == 0)               m_iAppearanceProb                   = pClassInfo->getAppearanceProb();
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	if(getPrereqGlobalCounter()				== 0)				m_iPrereqGlobalCounter				= pClassInfo->getPrereqGlobalCounter();
	if(getUnitConvertFromCombatChance()		== 0)				m_iUnitConvertFromCombatChance		= pClassInfo->getUnitConvertFromCombatChance();
	if(getUnitCreateFromCombatChance()		== 0)				m_iUnitCreateFromCombatChance		= pClassInfo->getUnitCreateFromCombatChance();
	if(getWeaponTierMax()					== 0)				m_iWeaponTierMax					= pClassInfo->getWeaponTierMax();
	if(getWeaponTierMin()					== 0)				m_iWeaponTierMin					= pClassInfo->getWeaponTierMin();
	if(getWithdrawlProbDefensive()			== 0)				m_iWithdrawlProbDefensive			= pClassInfo->getWithdrawlProbDefensive();
	if(getAIWeight()						== 0)				m_iAIWeight							= pClassInfo->getAIWeight();
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**						Modifies Cost based on Population and number of Cities					**/
/*************************************************************************************************/
	if(getCityPopCostModifier()				== 0)				m_iCityPopCostModifier				= pClassInfo->getCityPopCostModifier();
	if(getEmpirePopCostModifier()			== 0)				m_iEmpirePopCostModifier			= pClassInfo->getEmpirePopCostModifier();
	if(getNumCityCostModifier()				== 0)				m_iNumCityCostModifier				= pClassInfo->getNumCityCostModifier();
	if(getPlayerPopCostModifier()			== 0)				m_iPlayerPopCostModifier			= pClassInfo->getPlayerPopCostModifier();
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	if(isNonInfluence()						== false)			m_bNonInfluence						= pClassInfo->isNonInfluence();
	if(isInfluence()						== false)			m_bInfluence						= pClassInfo->isInfluence();
	if(getVictoryInfluenceModifier()		== 100)				m_iVictoryInfluenceModifier			= pClassInfo->getVictoryInfluenceModifier();
	if(getDefeatInfluenceModifier()			== 100)				m_iDefeatInfluenceModifier			= pClassInfo->getDefeatInfluenceModifier();
	if(getPillageInfluenceModifier()		== 100)				m_iPillageInfluenceModifier			= pClassInfo->getPillageInfluenceModifier();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	if(getExtraPerception()					== 0)				m_iExtraPerception					= pClassInfo->getExtraPerception();
	if (getInvisibleLevel() == 0)				m_iInvisibleLevel = pClassInfo->getInvisibleLevel();
	/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	if(getHurryCostModifier()				== 0)				m_iHurryCostModifier				= pClassInfo->getHurryCostModifier();
	if(getAdvancedStartCostIncrease()		== 0)				m_iAdvancedStartCostIncrease		= pClassInfo->getAdvancedStartCostIncrease();
	if(getMoves()							== 0)				m_iMoves							= pClassInfo->getMoves();
	if(getAirRange()						== 0)				m_iAirRange							= pClassInfo->getAirRange();
	if(getAirUnitCap()						== 0)				m_iAirUnitCap						= pClassInfo->getAirUnitCap();
	if(getDropRange()						== 0)				m_iDropRange						= pClassInfo->getDropRange();
	if(getWorkRate()						== 0)				m_iWorkRate							= pClassInfo->getWorkRate();
	if(getBaseDiscover()					== 0)				m_iBaseDiscover						= pClassInfo->getBaseDiscover();
	if(getDiscoverMultiplier()				== 0)				m_iDiscoverMultiplier				= pClassInfo->getDiscoverMultiplier();
	if(getBaseHurry()						== 0)				m_iBaseHurry						= pClassInfo->getBaseHurry();
	if(getHurryMultiplier()					== 0)				m_iHurryMultiplier					= pClassInfo->getHurryMultiplier();
	if(getBaseTrade()						== 0)				m_iBaseTrade						= pClassInfo->getBaseTrade();
	if(getTradeMultiplier()					== 0)				m_iTradeMultiplier					= pClassInfo->getTradeMultiplier();
	if(getGreatWorkCulture()				== 0)				m_iGreatWorkCulture					= pClassInfo->getGreatWorkCulture();
	if(getEspionagePoints()					== 0)				m_iEspionagePoints					= pClassInfo->getEspionagePoints();
	if(getAirCombat()						== 0)				m_iAirCombat						= pClassInfo->getAirCombat();
	if(getAirCombatLimit()					== 0)				m_iAirCombatLimit					= pClassInfo->getAirCombatLimit();
	if(getFirstStrikes()					== 0)				m_iFirstStrikes						= pClassInfo->getFirstStrikes();
	if(getChanceFirstStrikes()				== 0)				m_iChanceFirstStrikes				= pClassInfo->getChanceFirstStrikes();
	if(getInterceptionProbability()			== 0)				m_iInterceptionProbability			= pClassInfo->getInterceptionProbability();
	if(getEvasionProbability()				== 0)				m_iEvasionProbability				= pClassInfo->getEvasionProbability();
	if(getWithdrawalProbability()			== 0)				m_iWithdrawalProbability			= pClassInfo->getWithdrawalProbability();
	if(getEnemyWithdrawalProbability()		== 0)				m_iEnemyWithdrawalProbability		= pClassInfo->getEnemyWithdrawalProbability();
	if(getCollateralDamage()				== 0)				m_iCollateralDamage					= pClassInfo->getCollateralDamage();
	if(getCollateralDamageLimit()			== 0)				m_iCollateralDamageLimit			= pClassInfo->getCollateralDamageLimit();
	if(getCollateralDamageMaxUnits()		== 0)				m_iCollateralDamageMaxUnits			= pClassInfo->getCollateralDamageMaxUnits();

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	if(getFlankingDamage()					== 0)				m_iFlankingDamage					= pClassInfo->getFlankingDamage();
	if(getFlankingDamageLimit()				== 0)				m_iFlankingDamageLimit				= pClassInfo->getFlankingDamageLimit();
	if(getFlankingDamageMaxUnits()			== 0)				m_iFlankingDamageMaxUnits			= pClassInfo->getFlankingDamageMaxUnits();
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

	if(getCityAttackModifier()				== 0)				m_iCityAttackModifier				= pClassInfo->getCityAttackModifier();
	if(getCityDefenseModifier()				== 0)				m_iCityDefenseModifier				= pClassInfo->getCityDefenseModifier();
	if(getAnimalCombatModifier()			== 0)				m_iAnimalCombatModifier				= pClassInfo->getAnimalCombatModifier();
	if(getHillsAttackModifier()				== 0)				m_iHillsAttackModifier				= pClassInfo->getHillsAttackModifier();
	if(getHillsDefenseModifier()			== 0)				m_iHillsDefenseModifier				= pClassInfo->getHillsDefenseModifier();
	if(getBombRate()						== 0)				m_iBombRate							= pClassInfo->getBombRate();
	if(getBombardRate()						== 0)				m_iBombardRate						= pClassInfo->getBombardRate();
	if(getCargoSpace()						== 0)				m_iCargoSpace						= pClassInfo->getCargoSpace();
	if(getConscriptionValue()				== 0)				m_iConscriptionValue				= pClassInfo->getConscriptionValue();
	if(getCultureGarrisonValue()			== 0)				m_iCultureGarrisonValue				= pClassInfo->getCultureGarrisonValue();
	if(getExtraCost()						== 0)				m_iExtraCost						= pClassInfo->getExtraCost();
	if(getLeaderExperience()				== 0)				m_iLeaderExperience					= (float)(pClassInfo->getLeaderExperience()/100.0);
	if(getNukeRange()						== -1)				m_iNukeRange						= pClassInfo->getNukeRange();
	if(getProductionCost()					== -1)				m_iProductionCost					= pClassInfo->getProductionCost();
	if(getMinAreaSize()						== -1)				m_iMinAreaSize						= pClassInfo->getMinAreaSize();
	if(getAdvancedStartCost()				== 100)				m_iAdvancedStartCost				= pClassInfo->getAdvancedStartCost();
	if(getCombatLimit()						== 100)				m_iCombatLimit						= pClassInfo->getCombatLimit();
	if(getXPValueAttack()					== 8.0f)			m_iXPValueAttack					= (float)(pClassInfo->getXPValueAttack()/100.0);
	if(getXPValueDefense()					== 4.0f)			m_iXPValueDefense					= (float)(pClassInfo->getXPValueDefense()/100.0);
	if(m_szFormationType == "FORMATION_TYPE_DEFAULT")			m_szFormationType					= pClassInfo->getFormationType();
	if(getPyPerTurn()						== cDefault)		m_szPyPerTurn						= pClassInfo->getPyPerTurn();
	if(getPyDeath()							== cDefault)		m_szPyDeath							= pClassInfo->getPyDeath();
	if(getQuote()							== cDefault)		m_szQuote							= pClassInfo->getQuote();
	if(getImage()							== cDefault)		m_szImage							= pClassInfo->getImage();
	if(getPyPreCombat()				== cDefault)		m_szPyPreCombat				= pClassInfo->getPyPreCombat();//PyPreCombat by BI 07/24/11
	if(getPyPostCombatLost()				== cDefault)		m_szPyPostCombatLost				= pClassInfo->getPyPostCombatLost();
	if(getPyPostCombatWon()					== cDefault)		m_szPyPostCombatWon					= pClassInfo->getPyPostCombatWon();
	if(getPrereqAndTech()					== NO_TECH)			m_iPrereqAndTech					= pClassInfo->getPrereqAndTech();
	if(getPrereqAndBonus()					== NO_BONUS)		m_iPrereqAndBonus					= pClassInfo->getPrereqAndBonus();
	if(getPrereqCivic()						== NO_CIVIC)		m_iPrereqCivic						= pClassInfo->getPrereqCivic();
	if(getDomainCargo()						== NO_DOMAIN)		m_iDomainCargo						= pClassInfo->getDomainCargo();
	if(getAdvisorType()						== NO_ADVISOR)		m_iAdvisorType						= pClassInfo->getAdvisorType();
	if(getDomainType()						== DOMAIN_LAND)		m_iDomainType						= pClassInfo->getDomainType();
	if(getHolyCity()						== NO_RELIGION)		m_iHolyCity							= pClassInfo->getHolyCity();
	if(getReligionType()					== NO_RELIGION)		m_iReligionType						= pClassInfo->getReligionType();
	if(getStateReligion()					== NO_RELIGION)		m_iStateReligion					= pClassInfo->getStateReligion();
	if(getPrereqReligion()					== NO_RELIGION)		m_iPrereqReligion					= pClassInfo->getPrereqReligion();
	if(getPrereqBuilding()					== NO_BUILDING)		m_iPrereqBuilding					= pClassInfo->getPrereqBuilding();
	if(getLeaderPromotion()					== NO_PROMOTION)	m_iLeaderPromotion					= pClassInfo->getLeaderPromotion();
	if(getEquipmentPromotion()				== NO_PROMOTION)	m_iEquipmentPromotion				= pClassInfo->getEquipmentPromotion();
	if(getPromotionFromCombat()				== NO_PROMOTION)	m_iPromotionFromCombat				= pClassInfo->getPromotionFromCombat();
	if(getUnitClassType()					== NO_UNITCLASS)	m_iUnitClassType					= pClassInfo->getUnitClassType();
	if (getSecondaryUnitClassType() == NO_UNITCLASS)	m_iSecondaryUnitClassType = pClassInfo->getSecondaryUnitClassType();
	if(getUnitCaptureClassType()			== NO_UNITCLASS)	m_iUnitCaptureClassType				= pClassInfo->getUnitCaptureClassType();
	if(getPrereqAlignment()					== NO_ALIGNMENT)	m_iPrereqAlignment					= pClassInfo->getPrereqAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if(getPrereqBroadEthicalAlignment()			  == 0)			m_iPrereqBroadEthicalAlignment			= pClassInfo->getPrereqBroadEthicalAlignment();
	if(getEthicalAlignmentModifier()			  == 0)			m_iEthicalAlignmentModifier				= pClassInfo->getEthicalAlignmentModifier();
	if(getEthicalAlignmentShift()                 == 0)         m_iEthicalAlignmentShift                = pClassInfo->getEthicalAlignmentShift();
	if(getEthicalAlignmentShiftModifier()         == 0)         m_iEthicalAlignmentShiftModifier        = pClassInfo->getEthicalAlignmentShiftModifier();
	if(getEthicalAlignmentShiftTowardsNeutral()   == -1)        m_iEthicalAlignmentShiftTowardsNeutral  = pClassInfo->getEthicalAlignmentShiftTowardsNeutral();
	if(getPrereqEthicalAlignment()	== NO_ETHICAL_ALIGNMENT)    m_iPrereqEthicalAlignment				= pClassInfo->getPrereqEthicalAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if(getUnitCombatType()					== NO_UNITCOMBAT)	m_iUnitCombatType					= pClassInfo->getUnitCombatType();
	if(getDiploVoteType()					== NO_VOTESOURCE)	m_iDiploVoteType					= pClassInfo->getDiploVoteType();
	if(getPrereqCorporation()				== NO_CORPORATION)	m_iPrereqCorporation				= pClassInfo->getPrereqCorporation();
	if(getSpecialCargo()					== NO_SPECIALUNIT)	m_iSpecialCargo						= pClassInfo->getSpecialCargo();
	if(getSpecialUnitType()					== NO_SPECIALUNIT)	m_iSpecialUnitType					= pClassInfo->getSpecialUnitType();
	if(getDefaultUnitAIType()				== UNITAI_UNKNOWN)	m_iDefaultUnitAIType				= pClassInfo->getDefaultUnitAIType();
	if(getPrereqBuildingClass()				== NO_BUILDINGCLASS)m_iPrereqBuildingClass				= pClassInfo->getPrereqBuildingClass();
	//This next bit is massively messy due to a non-constant default value, I think this should work though...
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	//check if the value in this module is using a default
	bool bNewDefaultAsset = (getCombat()*getTier()/2==getAssetValue());
	bool bOldDefaultAsset = (pClassInfo->getCombat()*pClassInfo->getTier()/2==pClassInfo->getAssetValue());
	bool bNewDefaultPower = (getCombat()*getTier()==getPowerValue());
	bool bOldDefaultPower = (pClassInfo->getCombat()*pClassInfo->getTier()==pClassInfo->getPowerValue());
	bool bNewDefaultDefense = (getCombatDefense()==getCombat());
	bool bOldDefaultDefense = (pClassInfo->getCombatDefense()==pClassInfo->getCombat());
	if(getTier()							== 0)				m_iTier								= pClassInfo->getTier();
	//Combat Wasn't Entered, so all 3 of these should be 0, unless they were entered.  If 0, use old, if not, use new
	if(getCombat()							== 0)
	{
																m_iCombat							= pClassInfo->getCombat();
		if(getCombatDefense()				== 0)				m_iCombatDefense					= pClassInfo->getCombatDefense();
		if(getAssetValue()					== 0)				m_iAssetValue						= pClassInfo->getAssetValue();
		if(getPowerValue()					== 0)				m_iPowerValue						= pClassInfo->getPowerValue();
	}
	//Combat WAS entered, so if these are default values they were NOT entered and should be carried if previously unique
	else
	{
		if(bNewDefaultDefense && !bOldDefaultDefense)			m_iCombatDefense					= pClassInfo->getCombatDefense();
		if(bNewDefaultAsset && !bOldDefaultAsset)				m_iAssetValue						= pClassInfo->getAssetValue();
		if(bNewDefaultPower && !bOldDefaultPower)				m_iPowerValue						= pClassInfo->getPowerValue();
	}
/**								----  End Original Code  ----									**/
	//check if the value in this module is using a default
	bool bNewDefaultAsset = (getCombat()*getTier()/2==getAssetValue());
	bool bOldDefaultAsset = (pClassInfo->getCombat()*pClassInfo->getTier()/2==pClassInfo->getAssetValue());
	bool bNewDefaultDefense = (getCombatDefense()==getCombat());
	bool bOldDefaultDefense = (pClassInfo->getCombatDefense()==pClassInfo->getCombat());
	if(getTier()							== 0)				m_iTier								= pClassInfo->getTier();
	//Combat Wasn't Entered, so both of these should be 0, unless they were entered.  If 0, use old, if not, use new
	if(getCombat()							== 0)
	{
																m_iCombat							= pClassInfo->getCombat();
		if(getCombatDefense()				== 0)				m_iCombatDefense					= pClassInfo->getCombatDefense();
		if(getAssetValue()					== 0)				m_iAssetValue						= pClassInfo->getAssetValue();
	}
	//Combat WAS entered, so if these are default values they were NOT entered and should be carried if previously unique
	else
	{
		if(bNewDefaultDefense && !bOldDefaultDefense)			m_iCombatDefense					= pClassInfo->getCombatDefense();
		if(bNewDefaultAsset && !bOldDefaultAsset)				m_iAssetValue						= pClassInfo->getAssetValue();
	}
	if (getPowerMult()						== 0)				m_iPowerMult						= pClassInfo->getPowerMult();
	if (getPowerAdd()						== 0)				m_iPowerAdd							= pClassInfo->getPowerAdd();
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	for ( int i = 0; i < GC.getNumUnitClassInfos(); i++)
	{
		if(getUpgradeUnitClass(i)			== false)			m_pbUpgradeUnitClass[i]				= pClassInfo->getUpgradeUnitClass(i);
/**								----  End Original Code  ----									**/
	if(pClassInfo->getNumUpgradeUnitClass() > 0)
	{
		int* tempArray = new int[getNumUpgradeUnitClass() + pClassInfo->getNumUpgradeUnitClass()];
		for(int i = 0; i< getNumUpgradeUnitClass(); ++i)
		{
			tempArray[i] = getUpgradeUnitClass(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumUpgradeUnitClass(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumUpgradeUnitClass();++j)
			{
				if(pClassInfo->getUpgradeUnitClass(i) == getUpgradeUnitClass(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumUpgradeUnitClass()] = pClassInfo->getUpgradeUnitClass(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piUpgradeUnitClass);
		int iGoalSize = getNumUpgradeUnitClass() + iNewItems;
		m_piUpgradeUnitClass = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piUpgradeUnitClass[i] = tempArray[i];
			FAssertMsg(m_piUpgradeUnitClass[i] < GC.getNumUnitClassInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piUpgradeUnitClass[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumUpgradeUnitClass = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}

	for ( int i = 0; i < GC.getNumUnitClassInfos(); i++)
	{
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/
		if(getTargetUnitClass(i)			== false)			m_pbTargetUnitClass[i]				= pClassInfo->getTargetUnitClass(i);
		if(getDefenderUnitClass(i)			== false)			m_pbDefenderUnitClass[i]			= pClassInfo->getDefenderUnitClass(i);
		if(getUnitClassAttackModifier(i)	== false)			m_piUnitClassAttackModifier[i]		= pClassInfo->getUnitClassAttackModifier(i);
		if(getUnitClassDefenseModifier(i)	== false)			m_piUnitClassDefenseModifier[i]		= pClassInfo->getUnitClassDefenseModifier(i);
	}
	for ( int i = 0; i < GC.getNumUnitCombatInfos(); i++)
	{
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
		// Old Code: if(getFlankingStrikeUnitClass(i)	== false)			m_piFlankingStrikeUnitClass[i]		= pClassInfo->getFlankingStrikeUnitClass(i);
		if(getFlankingStrikeUnitCombat(i)	== false)			m_piFlankingStrikeUnitCombat[i]		= pClassInfo->getFlankingStrikeUnitCombat(i);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
		if(getTargetUnitCombat(i)			== false)			m_pbTargetUnitCombat[i]				= pClassInfo->getTargetUnitCombat(i);
		if(getDefenderUnitCombat(i)			== false)			m_pbDefenderUnitCombat[i]			= pClassInfo->getDefenderUnitCombat(i);
		if(getUnitCombatModifier(i)			== false)			m_piUnitCombatModifier[i]			= pClassInfo->getUnitCombatModifier(i);
		if(getUnitCombatCollateralImmune(i)	== false)			m_piUnitCombatCollateralImmune[i]	= pClassInfo->getUnitCombatCollateralImmune(i);
	}
	for ( int i = 0; i < NUM_UNITAI_TYPES; i++)
	{
		if(getUnitAIType(i)					== false)			m_pbUnitAIType[i]					= pClassInfo->getUnitAIType(i);
		if(getNotUnitAIType(i)				== false)			m_pbNotUnitAIType[i]				= pClassInfo->getNotUnitAIType(i);
	}
	for ( int i = 0; i < GC.getNumBuildInfos(); i++)
	{
		if(getBuilds(i)						== false)			m_pbBuilds[i]						= pClassInfo->getBuilds(i);
	}
	for ( int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		if(getBuildings(i)					== false)			m_pbBuildings[i]					= pClassInfo->getBuildings(i);
		if(getForceBuildings(i)				== false)			m_pbForceBuildings[i]				= pClassInfo->getForceBuildings(i);
	}
	for ( int i = 0; i < GC.getNumReligionInfos(); i++)
	{
		if(getReligionSpreads(i)			== false)			m_piReligionSpreads[i]				= pClassInfo->getReligionSpreads(i);
	}
	for ( int i = 0; i < GC.getNumCorporationInfos(); i++)
	{
		if(getCorporationSpreads(i)			== false)			m_piCorporationSpreads[i]			= pClassInfo->getCorporationSpreads(i);
	}
	for ( int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if(getProductionTraits(i)			== false)			m_piProductionTraits[i]				= pClassInfo->getProductionTraits(i);
	}
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	for ( int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if(getAppearanceTechs(i)			== false)			m_piAppearanceTechs[i]				= pClassInfo->getAppearanceTechs(i);
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	for ( int i = 0; i < GC.getNumFlavorTypes(); i++)
	{
		if(getFlavorValue(i)				== false)			m_piFlavorValue[i]					= pClassInfo->getFlavorValue(i);
	}
	for ( int i = 0; i < GC.getNumSpecialistInfos(); i++)
	{
		if(getGreatPeoples(i)				== false)			m_pbGreatPeoples[i]					= pClassInfo->getGreatPeoples(i);
	}
	for ( int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if(getTerrainImpassable(i)			== false)			m_pbTerrainImpassable[i]			= pClassInfo->getTerrainImpassable(i);
		if(getTerrainNative(i)				== false)			m_pbTerrainNative[i]				= pClassInfo->getTerrainNative(i);
		if(getTerrainAttackModifier(i)		== 0)				m_piTerrainAttackModifier[i]		= pClassInfo->getTerrainAttackModifier(i);
		if(getTerrainDefenseModifier(i)		== 0)				m_piTerrainDefenseModifier[i]		= pClassInfo->getTerrainDefenseModifier(i);
		if(getTerrainPassableTech(i)		== NO_TECH)			m_piTerrainPassableTech[i]			= pClassInfo->getTerrainPassableTech(i);
		if(getUnitTerrainCost(i)			== 0)				m_piUnitTerrainCost[i]				= pClassInfo->getUnitTerrainCost(i);	// GWS
	}
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if(getFeatureImpassable(i)			== false)			m_pbFeatureImpassable[i]			= pClassInfo->getFeatureImpassable(i);
		if(getFeatureNative(i)				== false)			m_pbFeatureNative[i]				= pClassInfo->getFeatureNative(i);
		if(getFeatureAttackModifier(i)		== 0)				m_piFeatureAttackModifier[i]		= pClassInfo->getFeatureAttackModifier(i);
		if(getFeatureDefenseModifier(i)		== 0)				m_piFeatureDefenseModifier[i]		= pClassInfo->getFeatureDefenseModifier(i);
		if(getFeaturePassableTech(i)		== NO_TECH)			m_piFeaturePassableTech[i]			= pClassInfo->getFeaturePassableTech(i);
		if(getUnitFeatureCost(i)			== 0)				m_piUnitFeatureCost[i]				= pClassInfo->getUnitFeatureCost(i);	// GWS
	}
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
// CvUnitInfo
	if (getUnitHillCost()					== 0)					m_iUnitHillCost					= pClassInfo->getUnitHillCost();
	if (getUnitPeakCost()					== 0)					m_iUnitPeakCost					= pClassInfo->getUnitPeakCost();
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	for ( int i = 0; i < NUM_DOMAIN_TYPES; i++)
	{
		if(getDomainModifier(i)				== 0)				m_piDomainModifier[i]				= pClassInfo->getDomainModifier(i);
	}
	for ( int i = 0; i < GC.getNumBonusInfos(); i++)
	{
		if(getBonusProductionModifier(i)	== 0)				m_piBonusProductionModifier[i]		= pClassInfo->getBonusProductionModifier(i);
		if(getBonusAffinity(i)				== 0)				m_piBonusAffinity[i]				= pClassInfo->getBonusAffinity(i);
	}
	for ( int i = 0; i < GC.getNumPromotionInfos(); i++)
	{
		if(isAllowPromotion((PromotionTypes)i)== false)			m_pbAllowPromotion[i]				= pClassInfo->isAllowPromotion((PromotionTypes)i);
		if(isDenyPromotion((PromotionTypes)i)== false)			m_pbDenyPromotion[i]				= pClassInfo->isDenyPromotion((PromotionTypes)i);
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
/**										Start Original Code										**
		if(getFreePromotions(i)				== false)			m_pbFreePromotions[i]				= pClassInfo->getFreePromotions(i);
/**										End Original Code										**/
		if (getFreePromotions(i)			== false)			m_piFreePromotions[i]				= pClassInfo->getNumFreePromotions(i);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	}
	for ( int i = 0; i < GC.getNUM_UNIT_AND_TECH_PREREQS(); i++)
	{
		if(getPrereqAndTechs(i)				== NO_TECH)			m_piPrereqAndTechs[i]				= pClassInfo->getPrereqAndTechs(i);
	}
	for ( int i = 0; i < GC.getNUM_UNIT_PREREQ_OR_BONUSES(); i++)
	{
		if(getPrereqOrBonuses(i)			== NO_BONUS)		m_piPrereqOrBonuses[i]				= pClassInfo->getPrereqOrBonuses(i);
	}
	for(int i=0;i<NUM_YIELD_TYPES;++i)
	{
		if(getYieldFromKill(i)				== 0)				m_piYieldFromKill[i]				= pClassInfo->getYieldFromKill(i);
	}
	for(int i=0;i<NUM_COMMERCE_TYPES;++i)
	{
		if(getCommerceFromKill(i)			== 0)				m_piCommerceFromKill[i]				= pClassInfo->getCommerceFromKill(i);
	}
	for(int i=0;i<GC.getNumDamageTypeInfos();++i)
	{
		if(getDamageTypeCombat(i)			== 0)				m_piDamageTypeCombat[i]				= pClassInfo->getDamageTypeCombat(i);
	}
	for(int i=0; i < pClassInfo->getNumSeeInvisibleTypes(); i++)
	{
		int iSeeInvisibleType =																	pClassInfo->getSeeInvisibleType(i);
		if(iSeeInvisibleType != -1)
		{
			bool bLoad = true;
			for(int j=0;j<getNumSeeInvisibleTypes();j++)
			{
				if(getSeeInvisibleType(j) == iSeeInvisibleType)
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
															m_aiSeeInvisibleTypes.push_back(	iSeeInvisibleType);
			}
		}
	}
	for(int i=0; i < pClassInfo->getNumInvisibleTypes(); i++)
	{
		int iInvisibleType =																	pClassInfo->getInvisibleType(i);
		if(iInvisibleType != -1)
		{
			bool bLoad = true;
			for(int j=0;j<getNumInvisibleTypes();j++)
			{
				if(getInvisibleType(j) == iInvisibleType)
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
															m_aiInvisibleTypes.push_back(		iInvisibleType);
			}
		}
	}
	// For the Meshgroups I assume the XML holding the largest GroupSize is the most completed(most fancy) and we want to keep that one
	if(getGroupSize() < pClassInfo->getGroupSize() )
	{
																m_iGroupSize						= pClassInfo->getGroupSize();
																m_iGroupDefinitions					= pClassInfo->getGroupDefinitions();
																m_iUnitMeleeWaveSize				= pClassInfo->getMeleeWaveSize();
																m_iUnitRangedWaveSize				= pClassInfo->getRangedWaveSize();
																m_fUnitMaxSpeed						= pClassInfo->getUnitMaxSpeed();
																m_fUnitPadTime						= pClassInfo->getUnitPadTime();

		//Delete old Arrays for initializing a new one
		SAFE_DELETE(m_piUnitGroupRequired)
		SAFE_DELETE(m_paszEarlyArtDefineTags)
		SAFE_DELETE(m_paszLateArtDefineTags)
		SAFE_DELETE(m_paszMiddleArtDefineTags)
		m_piUnitGroupRequired = new int[ m_iGroupDefinitions ];
		m_paszEarlyArtDefineTags = new CvString[ m_iGroupDefinitions ];
		m_paszLateArtDefineTags = new CvString[ m_iGroupDefinitions ];
		m_paszMiddleArtDefineTags = new CvString[ m_iGroupDefinitions ];
		for ( int i = 0; i < m_iGroupDefinitions; i++ )
		{
																m_piUnitGroupRequired[i]			= pClassInfo->getUnitGroupRequired(i);
																setEarlyArtDefineTag(i,				pClassInfo->getEarlyArtDefineTag(i, NO_UNIT_ARTSTYLE));
																setLateArtDefineTag(i,				pClassInfo->getLateArtDefineTag(i, NO_UNIT_ARTSTYLE));
																setMiddleArtDefineTag(i,			pClassInfo->getMiddleArtDefineTag(i, NO_UNIT_ARTSTYLE));
		}
	}
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	if(pClassInfo->getNumAffinities() > 0)
	{
		int* tempArray = new int[getNumAffinities() + pClassInfo->getNumAffinities()];
		for(int i = 0; i< getNumAffinities(); ++i)
		{
			tempArray[i] = getAffinities(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumAffinities(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumAffinities();++j)
			{
				if(pClassInfo->getAffinities(i) == getAffinities(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumAffinities()] = pClassInfo->getAffinities(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piAffinities);
		int iGoalSize = getNumAffinities() + iNewItems;
		m_piAffinities = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piAffinities[i] = tempArray[i];
			FAssertMsg(m_piAffinities[i] < GC.getNumAffinityInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piAffinities[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumAffinities = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	if ( pClassInfo->getNumUnitNames() != 0 )
	{
		std::vector<CvString> NewNames;
		CvString LoadName;
		for(int i = 0; i < pClassInfo->getNumUnitNames(); ++i)
		{
			bool bLoad = true;
			for(int j = 0; i < getNumUnitNames(); ++i)
			{
				if(pClassInfo->getUnitNames(i) == cDefault || pClassInfo->getUnitNames(i) == getUnitNames(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				NewNames.push_back(pClassInfo->getUnitNames(i));
			}
		}
		for(int i = 0; i < getNumUnitNames(); ++i)
		{
			NewNames.push_back(getUnitNames(i));
		}
		m_iNumUnitNames = NewNames.size();
		SAFE_DELETE(m_paszUnitNames);
		m_paszUnitNames = new CvString[getNumUnitNames()];
		for(int i = 0; i < getNumUnitNames(); ++i)
		{
			m_paszUnitNames[i] = NewNames[i];
		}
		NewNames.clear();
	}
	if ( pClassInfo->getNumQuotes() != 0 )
	{
		std::vector<CvString> NewQuotes;
		CvString LoadQuote;
		for(int i = 0; i < pClassInfo->getNumQuotes(); ++i)
		{
			bool bLoad = true;
			for(int j = 0; i < getNumQuotes(); ++i)
			{
				if(pClassInfo->getQuotes(i) == cDefault || pClassInfo->getQuotes(i) == getQuotes(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				NewQuotes.push_back(pClassInfo->getQuotes(i));
			}
		}
		for(int i = 0; i < getNumQuotes(); ++i)
		{
			NewQuotes.push_back(getQuotes(i));
		}
		m_iNumQuotes = NewQuotes.size();
		SAFE_DELETE(m_paszQuotes);
		m_paszQuotes = new CvString[getNumQuotes()];
		for(int i = 0; i < getNumQuotes(); ++i)
		{
			m_paszQuotes[i] = NewQuotes[i];
		}
		NewQuotes.clear();
	}
	if ( pClassInfo->getNumImages() != 0 )
	{
		std::vector<CvString> NewImages;
		CvString LoadImage;
		for(int i = 0; i < pClassInfo->getNumImages(); ++i)
		{
			bool bLoad = true;
			for(int j = 0; i < getNumImages(); ++i)
			{
				if(pClassInfo->getImages(i) == cDefault || pClassInfo->getImages(i) == getImages(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				NewImages.push_back(pClassInfo->getImages(i));
			}
		}
		for(int i = 0; i < getNumImages(); ++i)
		{
			NewImages.push_back(getImages(i));
		}
		m_iNumImages = NewImages.size();
		SAFE_DELETE(m_paszImages);
		m_paszImages = new CvString[getNumImages()];
		for(int i = 0; i < getNumImages(); ++i)
		{
			m_paszImages[i] = NewImages[i];
		}
		NewImages.clear();
	}

	updateArtDefineButton();

	// Readpass2 stuff
	if (getUnitConvertFromCombat() == -1)						m_iUnitConvertFromCombat			= pClassInfo->getUnitConvertFromCombat();
	if (getUnitCreateFromCombat() == -1)						m_iUnitCreateFromCombat				= pClassInfo->getUnitCreateFromCombat();

	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getUpgradeCivVectorSize(); i++ )
	{
														m_aszExtraXMLforPass3.push_back(		pClassInfo->getUpgradeCivVectorElement(i));
	}
}
void CvUnitInfo::copyNonDefaultsReadPass2(CvUnitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getUnitConvertFromCombat()	!= -1)	m_iUnitConvertFromCombat			= pClassInfo->getUnitConvertFromCombat();
	if (bOver || pClassInfo->getUnitCreateFromCombat()	!= -1)	m_iUnitCreateFromCombat				= pClassInfo->getUnitCreateFromCombat();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvUnitFormationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitFormationInfo()
//
//  \brief		Default Constructor
//
//------------------------------------------------------------------------------------------------------
CvUnitFormationInfo::CvUnitFormationInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitFormationInfo()
//
//  \brief		Destructor
//
//------------------------------------------------------------------------------------------------------
CvUnitFormationInfo::~CvUnitFormationInfo()
{
}

const TCHAR* CvUnitFormationInfo::getFormationType() const
{
	return m_szFormationType;
}

const std::vector<EntityEventTypes> & CvUnitFormationInfo::getEventTypes() const
{
	return m_vctEventTypes;
}

int CvUnitFormationInfo::getNumUnitEntries() const
{
	return m_vctUnitEntries.size();
}

const CvUnitEntry &CvUnitFormationInfo::getUnitEntry(int index) const
{
	return m_vctUnitEntries[index];
}

void CvUnitFormationInfo::addUnitEntry(const CvUnitEntry &unitEntry)
{
	m_vctUnitEntries.push_back(unitEntry);
}

int CvUnitFormationInfo::getNumGreatUnitEntries() const
{
	return m_vctGreatUnitEntries.size();
}

const CvUnitEntry &CvUnitFormationInfo::getGreatUnitEntry(int index) const
{
	return m_vctGreatUnitEntries[index];
}

int CvUnitFormationInfo::getNumSiegeUnitEntries() const
{
	return m_vctSiegeUnitEntries.size();
}

const CvUnitEntry &CvUnitFormationInfo::getSiegeUnitEntry(int index) const
{
	return m_vctSiegeUnitEntries[index];
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitFormationInfo()
//
//  \brief		Reads from XML
//
//------------------------------------------------------------------------------------------------------
bool CvUnitFormationInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	int iIndex;
	bool bNextSibling;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szFormationType, "FormationType");

	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "EventMaskList" ))
	{
		if ( gDLL->getXMLIFace()->SetToChild( pXML->GetXML() ) )
		{
			pXML->GetXmlVal( szTextVal );
			do
			{
				iIndex = pXML->FindInInfoClass(szTextVal);
				if ( iIndex != -1 )
					m_vctEventTypes.push_back( (EntityEventTypes)iIndex );
				bNextSibling = pXML->GetNextXmlVal( szTextVal );
			}
			while( bNextSibling );
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// Read the entries
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "UnitEntry" ) )
	{
		do
		{
			CvUnitEntry unitEntry;
			pXML->GetChildXmlValByName(szTextVal, "UnitEntryType");
			if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Position" ) )
			{
				pXML->GetChildXmlValByName( &unitEntry.m_position.x, "x");
				pXML->GetChildXmlValByName( &unitEntry.m_position.y, "y");
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
			pXML->GetChildXmlValByName( &unitEntry.m_fRadius, "PositionRadius");
			pXML->GetChildXmlValByName( &unitEntry.m_fFacingDirection, "Direction");
			pXML->GetChildXmlValByName( &unitEntry.m_fFacingVariance, "DirVariation");

			if(szTextVal.CompareNoCase("Unit") == 0)
				m_vctUnitEntries.push_back(unitEntry);
			else if(szTextVal.CompareNoCase("General") == 0)
				m_vctGreatUnitEntries.push_back(unitEntry);
			else if(szTextVal.CompareNoCase("Siege") == 0)
				m_vctSiegeUnitEntries.push_back(unitEntry);
			else
			{
				FAssertMsg(false, "[Jason] Unknown unit formation entry type.");
			}
		}
		while ( gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "UnitEntry"));
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	FAssertMsg(m_vctGreatUnitEntries.size() > 0, "[Jason] Formation missing great general entry.");
	FAssertMsg(m_vctSiegeUnitEntries.size() > 0, "[Jason] Formation missing siege tower entry.");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitFormationInfo::copyNonDefaults(CvUnitFormationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getFormationType()	== cDefault)	m_szFormationType					= pClassInfo->getFormationType();
	for ( int i = 0; i < pClassInfo->getNumEventTypes(); i++ )
	{
											m_vctEventTypes.push_back(			pClassInfo->getEventType(i));
	}
	for ( int i = 0; i < pClassInfo->getNumUnitEntries(); i++ )
	{
											m_vctUnitEntries.push_back(			pClassInfo->getUnitEntry(i));
	}
	for ( int i = 0; i < pClassInfo->getNumGreatUnitEntries(); i++ )
	{
											m_vctGreatUnitEntries.push_back(	pClassInfo->getGreatUnitEntry(i));
	}
	for ( int i = 0; i < pClassInfo->getNumSiegeUnitEntries(); i++ )
	{
											m_vctSiegeUnitEntries.push_back(	pClassInfo->getSiegeUnitEntry(i));
	}
}
int CvUnitFormationInfo::getNumEventTypes() const							{return m_vctEventTypes.size();}
const EntityEventTypes &CvUnitFormationInfo::getEventType(int index) const	{return m_vctEventTypes[index];}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvSpecialUnitInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpecialUnitInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialUnitInfo::CvSpecialUnitInfo() :
m_bValid(false),
m_bCityLoad(false),
m_pbCarrierUnitAITypes(NULL),
m_piProductionTraits(NULL),
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
m_piAppearanceTechs(NULL)
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpecialUnitInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialUnitInfo::~CvSpecialUnitInfo()
{
	SAFE_DELETE_ARRAY(m_pbCarrierUnitAITypes);
	SAFE_DELETE_ARRAY(m_piProductionTraits);
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAppearanceTechs);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
}

bool CvSpecialUnitInfo::isValid() const
{
	return m_bValid;
}

bool CvSpecialUnitInfo::isCityLoad() const
{
	return m_bCityLoad;
}

// Arrays

bool CvSpecialUnitInfo::isCarrierUnitAIType(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCarrierUnitAITypes ? m_pbCarrierUnitAITypes[i] : -1;
}

int CvSpecialUnitInfo::getProductionTraits(int i) const
{
//	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
//	FAssertMsg(i > -1, "Index out of bounds");
//	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
	return 0;
}

/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
int CvSpecialUnitInfo::getAppearanceTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAppearanceTechs ? m_piAppearanceTechs[i] : -1;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

bool CvSpecialUnitInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bValid, "bValid");
	pXML->GetChildXmlValByName(&m_bCityLoad, "bCityLoad");

	pXML->SetVariableListTagPair(&m_pbCarrierUnitAITypes, "CarrierUnitAITypes", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);

//	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piAppearanceTechs, "AppearanceTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpecialUnitInfo::copyNonDefaults(CvSpecialUnitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isValid()						== false)		m_bValid					= pClassInfo->isValid();
	if (isCityLoad()					== false)		m_bCityLoad					= pClassInfo->isCityLoad();
	for ( int i = 0; i < NUM_UNITAI_TYPES; i++ )
	{
		if (m_pbCarrierUnitAITypes[i]	== false)		m_pbCarrierUnitAITypes[i]	= pClassInfo->isCarrierUnitAIType(i);
	}
	for ( int i = 0; i < GC.getNumTraitInfos(); i++ )
	{
		if ( m_piProductionTraits[i]	== 0)			m_piProductionTraits[i]		= pClassInfo->getProductionTraits(i);
	}
/*************************************************************************************************/
/** Feral Animals			  				10/19/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	for ( int i = 0; i < GC.getNumTechInfos(); i++ )
	{
		if ( m_piAppearanceTechs[i]		== 0)			m_piAppearanceTechs[i]		= pClassInfo->getAppearanceTechs(i);
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCivicOptionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCivicOptionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCivicOptionInfo::CvCivicOptionInfo() :
m_pabTraitNoUpkeep(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCivicOptionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCivicOptionInfo::~CvCivicOptionInfo()
{
	SAFE_DELETE_ARRAY(m_pabTraitNoUpkeep);
}

bool CvCivicOptionInfo::getTraitNoUpkeep(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabTraitNoUpkeep ? m_pabTraitNoUpkeep[i] : false;
}

bool CvCivicOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->SetVariableListTagPair(&m_pabTraitNoUpkeep, "TraitNoUpkeeps", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCivicOptionInfo::copyNonDefaults(CvCivicOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	for ( int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if ( m_pabTraitNoUpkeep[i]	== false)		m_pabTraitNoUpkeep[i]	= pClassInfo->getTraitNoUpkeep(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCivicInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCivicInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCivicInfo::CvCivicInfo() :
m_iCivicOptionType(NO_CIVICOPTION),
m_iAnarchyLength(0),
m_iCrimePerTurn(0),
m_iUpkeep(0),
m_iAIWeight(0),
m_iGreatPeopleRateModifier(0),
m_iGreatGeneralRateModifier(0),
m_iDomesticGreatGeneralRateModifier(0),
m_iStateReligionGreatPeopleRateModifier(0),
m_iDistanceMaintenanceModifier(0),
m_iNumCitiesMaintenanceModifier(0),
m_iCorporationMaintenanceModifier(0),
m_iExtraHealth(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iFreeExperience(0),
/**								----  End Original Code  ----									**/
m_iFreeExperience(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iWorkerSpeedModifier(0),
m_iImprovementUpgradeRateModifier(0),
m_iMilitaryProductionModifier(0),
m_iBaseFreeUnits(0),
m_iBaseFreeMilitaryUnits(0),
m_iFreeUnitsPopulationPercent(0),
m_iFreeMilitaryUnitsPopulationPercent(0),
m_iGoldPerUnit(0),
m_iGoldPerMilitaryUnit(0),
m_iHappyPerMilitaryUnit(0),
m_iLargestCityHappiness(0),
m_iWarWearinessModifier(0),
m_iFreeSpecialist(0),
m_iTradeRoutes(0),
m_iTechPrereq(NO_TECH),
m_iCivicPercentAnger(0),
m_iMaxConscript(0),
m_iStateReligionHappiness(0),
m_iNonStateReligionHappiness(0),
m_iStateReligionUnitProductionModifier(0),
m_iStateReligionBuildingProductionModifier(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iStateReligionFreeExperience(0),
/**								----  End Original Code  ----									**/
m_iStateReligionFreeExperience(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iExpInBorderModifier(0),
m_bMilitaryFoodProduction(false),
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
m_bFixedBorders(false),
m_bInfluenceAllowed(false),
m_iVictoryInfluenceModifier(100),
m_iDefeatInfluenceModifier(100),
m_iPillageInfluenceModifier(100),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
m_bNoUnhealthyPopulation(false),
m_bBuildingOnlyHealthy(false),
m_bNoForeignTrade(false),
m_bNoCorporations(false),
m_bNoForeignCorporations(false),
m_bStateReligion(false),
m_bNoNonStateReligionSpread(false),
m_piYieldModifier(NULL),
m_piCapitalYieldModifier(NULL),
m_piTradeYieldModifier(NULL),
m_piForeignTradeYieldModifier(NULL),
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
m_piTradeCommerceModifier(NULL),
m_piForeignTradeCommerceModifier(NULL),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
m_piCommerceChange(NULL),
m_piCommerceModifier(NULL),
m_piCapitalCommerceModifier(NULL),
m_piSpecialistExtraCommerce(NULL),
m_paiBuildingHappinessChanges(NULL),
m_paiBuildingHealthChanges(NULL),
m_paiFeatureHappinessChanges(NULL),
m_paiSpecialistCrimeChanges(NULL),
m_pabHurry(NULL),
m_pabSpecialBuildingNotRequired(NULL),
m_pabSpecialistValid(NULL),
m_pabSpecialistUnlimited(NULL),
m_piSpecialistCount(NULL),
m_piFreeSpecialistCount(NULL),
m_ppiImprovementYieldChanges(NULL),

/*************************************************************************************************/
/**	New Tag Defs	(CivicInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iAlignmentModifier(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
m_iAlignmentShift(0),
m_iAlignmentShiftModifier(0),
m_iAlignmentShiftTowardsNeutral(-1),
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
//FfH Civics: Added by Kael 08/11/2007
m_bCompassionHigh(false),
m_bCompassionLow(false),
m_bHidden(false),
m_bNoDiplomacyWithEnemies(false),
m_bPrereqWar(false),
m_iAttitudeShareMod(0),
m_iCoastalTradeRoutes(0),
m_iEnslavementChance(0),
m_iFoodConsumptionPerPopulation(0),
m_iBlockAlignment(NO_ALIGNMENT),
m_iPrereqAlignment(NO_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iEthicalAlignmentModifier(0),
m_iEthicalAlignmentShift(0),
m_iEthicalAlignmentShiftModifier(0),
m_iEthicalAlignmentShiftTowardsNeutral(-1),
m_iBlockEthicalAlignment(NO_ETHICAL_ALIGNMENT),
m_iPrereqEthicalAlignment(NO_ETHICAL_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iPrereqCivilization(NO_CIVILIZATION),
m_iPrereqReligion(NO_RELIGION)
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
,m_iCityCapModifier(0)
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
,m_iMaxCultureLevel(NO_CULTURELEVEL)
,m_bExpandBeyondPlotRadius(false)
,m_bCapitalNoCultureCap(false)
,m_bGovCenterNoCultureCap(false)
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/
,m_bOverflowProduction(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCivicInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCivicInfo::~CvCivicInfo()
{
	int iI;

	SAFE_DELETE_ARRAY(m_piYieldModifier);
	SAFE_DELETE_ARRAY(m_piCapitalYieldModifier);
	SAFE_DELETE_ARRAY(m_piTradeYieldModifier);
	SAFE_DELETE_ARRAY(m_piForeignTradeYieldModifier);
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piTradeCommerceModifier);
	SAFE_DELETE_ARRAY(m_piForeignTradeCommerceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piCommerceChange);
	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	SAFE_DELETE_ARRAY(m_piCapitalCommerceModifier);
	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	SAFE_DELETE_ARRAY(m_paiBuildingHappinessChanges);
	SAFE_DELETE_ARRAY(m_paiBuildingHealthChanges);
	SAFE_DELETE_ARRAY(m_paiFeatureHappinessChanges);
	SAFE_DELETE_ARRAY(m_paiSpecialistCrimeChanges);
	SAFE_DELETE_ARRAY(m_pabHurry);
	SAFE_DELETE_ARRAY(m_pabSpecialBuildingNotRequired);
	SAFE_DELETE_ARRAY(m_piSpecialistCount);
	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	SAFE_DELETE_ARRAY(m_pabSpecialistValid);
	SAFE_DELETE_ARRAY(m_pabSpecialistUnlimited);
	if (m_ppiImprovementYieldChanges != NULL)
	{
		for (iI=0;iI<GC.getNumImprovementInfos();iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges);
	}
}

int CvCivicInfo::getCivicOptionType() const
{
	return m_iCivicOptionType;
}

int CvCivicInfo::getAnarchyLength() const
{
	return m_iAnarchyLength;
}

int CvCivicInfo::getCrimePerTurn() const
{
	return m_iCrimePerTurn;
}

int CvCivicInfo::getUpkeep() const
{
	return m_iUpkeep;
}

int CvCivicInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvCivicInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvCivicInfo::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

int CvCivicInfo::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

int CvCivicInfo::getStateReligionGreatPeopleRateModifier() const
{
	return m_iStateReligionGreatPeopleRateModifier;
}

int CvCivicInfo::getDistanceMaintenanceModifier() const
{
	return m_iDistanceMaintenanceModifier;
}

int CvCivicInfo::getNumCitiesMaintenanceModifier() const
{
	return m_iNumCitiesMaintenanceModifier;
}

int CvCivicInfo::getCorporationMaintenanceModifier() const
{
	return m_iCorporationMaintenanceModifier;
}

int CvCivicInfo::getExtraHealth() const
{
	return m_iExtraHealth;
}

int CvCivicInfo::getFreeExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iFreeExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iFreeExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvCivicInfo::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}

int CvCivicInfo::getImprovementUpgradeRateModifier() const
{
	return m_iImprovementUpgradeRateModifier;
}

int CvCivicInfo::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}

int CvCivicInfo::getBaseFreeUnits() const
{
	return m_iBaseFreeUnits;
}

int CvCivicInfo::getBaseFreeMilitaryUnits() const
{
	return m_iBaseFreeMilitaryUnits;
}

int CvCivicInfo::getFreeUnitsPopulationPercent() const
{
	return m_iFreeUnitsPopulationPercent;
}

int CvCivicInfo::getFreeMilitaryUnitsPopulationPercent() const
{
	return m_iFreeMilitaryUnitsPopulationPercent;
}

int CvCivicInfo::getGoldPerUnit() const
{
	return m_iGoldPerUnit;
}

int CvCivicInfo::getGoldPerMilitaryUnit() const
{
	return m_iGoldPerMilitaryUnit;
}

int CvCivicInfo::getHappyPerMilitaryUnit() const
{
	return m_iHappyPerMilitaryUnit;
}

int CvCivicInfo::getLargestCityHappiness() const
{
	return m_iLargestCityHappiness;
}

int CvCivicInfo::getWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

int CvCivicInfo::getFreeSpecialist() const
{
	return m_iFreeSpecialist;
}

int CvCivicInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvCivicInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvCivicInfo::getCivicPercentAnger() const
{
	return m_iCivicPercentAnger;
}

int CvCivicInfo::getMaxConscript() const
{
	return m_iMaxConscript;
}

int CvCivicInfo::getStateReligionHappiness() const
{
	return m_iStateReligionHappiness;
}

int CvCivicInfo::getNonStateReligionHappiness() const
{
	return m_iNonStateReligionHappiness;
}

int CvCivicInfo::getStateReligionUnitProductionModifier() const
{
	return m_iStateReligionUnitProductionModifier;
}

int CvCivicInfo::getStateReligionBuildingProductionModifier() const
{
	return m_iStateReligionBuildingProductionModifier;
}

int CvCivicInfo::getStateReligionFreeExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iStateReligionFreeExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iStateReligionFreeExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvCivicInfo::getExpInBorderModifier() const
{
	return m_iExpInBorderModifier;
}

bool CvCivicInfo::isMilitaryFoodProduction() const
{
	return m_bMilitaryFoodProduction;
}

/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
bool CvCivicInfo::isFixedBorders() const
{
	return m_bFixedBorders;
}

bool CvCivicInfo::isInfluenceAllowed() const
{
	return m_bInfluenceAllowed;
}

int CvCivicInfo::getVictoryInfluenceModifier() const
{
	return m_iVictoryInfluenceModifier;
}

int CvCivicInfo::getDefeatInfluenceModifier() const
{
	return m_iDefeatInfluenceModifier;
}

int CvCivicInfo::getPillageInfluenceModifier() const
{
	return m_iPillageInfluenceModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

bool CvCivicInfo::isNoUnhealthyPopulation() const
{
	return m_bNoUnhealthyPopulation;
}

bool CvCivicInfo::isBuildingOnlyHealthy() const
{
	return m_bBuildingOnlyHealthy;
}

bool CvCivicInfo::isNoForeignTrade() const
{
	return m_bNoForeignTrade;
}

bool CvCivicInfo::isNoCorporations() const
{
	return m_bNoCorporations;
}

bool CvCivicInfo::isNoForeignCorporations() const
{
	return m_bNoForeignCorporations;
}

bool CvCivicInfo::isStateReligion() const
{
	return m_bStateReligion;
}

bool CvCivicInfo::isNoNonStateReligionSpread() const
{
	return m_bNoNonStateReligionSpread;
}

const wchar* CvCivicInfo::getWeLoveTheKing()
{
	return m_szWeLoveTheKingKey;
}

void CvCivicInfo::setWeLoveTheKingKey(const TCHAR* szVal)
{
	m_szWeLoveTheKingKey = szVal;
}

/*************************************************************************************************/
/**	New Tag Defs	(CivicInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvCivicInfo::getAlignmentModifier() const						{return m_iAlignmentModifier;}
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
int CvCivicInfo::getAlignmentShift() const                          {return m_iAlignmentShift;}
int CvCivicInfo::getAlignmentShiftModifier() const                  {return m_iAlignmentShiftModifier;}
int CvCivicInfo::getAlignmentShiftTowardsNeutral() const            {return m_iAlignmentShiftTowardsNeutral;}
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
const wchar* CvCivicInfo::getWeLoveTheKingKey()						{return m_szWeLoveTheKingKey;}
int CvCivicInfo::getPrereqCivilizationVectorSize()					{return m_aszExtraXMLforPass3.size();}
CvString CvCivicInfo::getPrereqCivilizationVectorElement(int i)		{return m_aszExtraXMLforPass3[i];}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Civics: Added by Kael 08/11/2007
bool CvCivicInfo::isCompassionHigh() const
{
	return m_bCompassionHigh;
}

bool CvCivicInfo::isCompassionLow() const
{
	return m_bCompassionLow;
}

bool CvCivicInfo::isHidden() const
{
	return m_bHidden;
}

bool CvCivicInfo::isNoDiplomacyWithEnemies() const
{
	return m_bNoDiplomacyWithEnemies;
}

bool CvCivicInfo::isPrereqWar() const
{
	return m_bPrereqWar;
}

int CvCivicInfo::getAttitudeShareMod() const
{
	return m_iAttitudeShareMod;
}

int CvCivicInfo::getCoastalTradeRoutes() const
{
	return m_iCoastalTradeRoutes;
}

int CvCivicInfo::getEnslavementChance() const
{
	return m_iEnslavementChance;
}

int CvCivicInfo::getFoodConsumptionPerPopulation() const
{
	return m_iFoodConsumptionPerPopulation;
}

int CvCivicInfo::getBlockAlignment() const
{
	return m_iBlockAlignment;
}

int CvCivicInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvCivicInfo::getEthicalAlignmentModifier() const				{return m_iEthicalAlignmentModifier;}
int CvCivicInfo::getEthicalAlignmentShift() const                   {return m_iEthicalAlignmentShift;}
int CvCivicInfo::getEthicalAlignmentShiftModifier() const           {return m_iEthicalAlignmentShiftModifier;}
int CvCivicInfo::getEthicalAlignmentShiftTowardsNeutral() const     {return m_iEthicalAlignmentShiftTowardsNeutral;}
int CvCivicInfo::getBlockEthicalAlignment() const                   {return m_iBlockEthicalAlignment;}
int CvCivicInfo::getPrereqEthicalAlignment() const                  {return m_iPrereqEthicalAlignment;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

int CvCivicInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

int CvCivicInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
int CvCivicInfo::getCityCapModifier() const
{
	return m_iCityCapModifier;
}
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
int CvCivicInfo::getMaxCultureLevel() const
{
	return m_iMaxCultureLevel;
}

bool CvCivicInfo::isExpandBeyondPlotRadius() const
{
	return m_bExpandBeyondPlotRadius;
}

bool CvCivicInfo::isCapitalNoCultureCap() const
{
	return m_bCapitalNoCultureCap;
}

bool CvCivicInfo::isGovCenterNoCultureCap() const
{
	return m_bGovCenterNoCultureCap;
}
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/

bool CvCivicInfo::isOverflowProduction() const
{
	return m_bOverflowProduction;
}

// Arrays

int CvCivicInfo::getYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldModifier ? m_piYieldModifier[i] : -1;
}

int* CvCivicInfo::getYieldModifierArray() const
{
	return m_piYieldModifier;
}

int CvCivicInfo::getCapitalYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCapitalYieldModifier ? m_piCapitalYieldModifier[i] : -1;
}

int* CvCivicInfo::getCapitalYieldModifierArray() const
{
	return m_piCapitalYieldModifier;
}

int CvCivicInfo::getTradeYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTradeYieldModifier ? m_piTradeYieldModifier[i] : -1;
}

int* CvCivicInfo::getTradeYieldModifierArray() const
{
	return m_piTradeYieldModifier;
}

int CvCivicInfo::getForeignTradeYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piForeignTradeYieldModifier ? m_piForeignTradeYieldModifier[i] : -1;
}

int* CvCivicInfo::getForeignTradeYieldModifierArray() const
{
	return m_piForeignTradeYieldModifier;
}

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
int CvCivicInfo::getTradeCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTradeCommerceModifier ? m_piTradeCommerceModifier[i] : -1;
}

int* CvCivicInfo::getTradeCommerceModifierArray() const
{
	return m_piTradeCommerceModifier;
}

int CvCivicInfo::getForeignTradeCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piForeignTradeCommerceModifier ? m_piForeignTradeCommerceModifier[i] : -1;
}

int* CvCivicInfo::getForeignTradeCommerceModifierArray() const
{
	return m_piForeignTradeCommerceModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

int CvCivicInfo::getCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceChange ? m_piCommerceChange[i] : -1;
}

int* CvCivicInfo::getCommerceChangeArray() const
{
	return m_piCommerceChange;
}

int CvCivicInfo::getCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceModifier ? m_piCommerceModifier[i] : -1;
}

int* CvCivicInfo::getCommerceModifierArray() const
{
	return m_piCommerceModifier;
}

int CvCivicInfo::getCapitalCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCapitalCommerceModifier ? m_piCapitalCommerceModifier[i] : -1;
}

int* CvCivicInfo::getCapitalCommerceModifierArray() const
{
	return m_piCapitalCommerceModifier;
}

int CvCivicInfo::getSpecialistExtraCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSpecialistExtraCommerce ? m_piSpecialistExtraCommerce[i] : -1;
}

int* CvCivicInfo::getSpecialistExtraCommerceArray() const
{
	return m_piSpecialistExtraCommerce;
}

int CvCivicInfo::getBuildingHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiBuildingHappinessChanges ? m_paiBuildingHappinessChanges[i] : -1;
}

int CvCivicInfo::getBuildingHealthChanges(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiBuildingHealthChanges ? m_paiBuildingHealthChanges[i] : -1;
}

int CvCivicInfo::getFeatureHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureHappinessChanges ? m_paiFeatureHappinessChanges[i] : -1;
}

int CvCivicInfo::getSpecialistCrimeChanges(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiSpecialistCrimeChanges ? m_paiSpecialistCrimeChanges[i] : -1;
}

bool CvCivicInfo::isHurry(int i) const
{
	FAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabHurry ? m_pabHurry[i] : false;
}

bool CvCivicInfo::isSpecialBuildingNotRequired(int i) const
{
	FAssertMsg(i < GC.getNumSpecialBuildingInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabSpecialBuildingNotRequired ? m_pabSpecialBuildingNotRequired[i] : false;
}

bool CvCivicInfo::isSpecialistValid(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabSpecialistValid ? m_pabSpecialistValid[i] : false;
}

int CvCivicInfo::getSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSpecialistCount ? m_piSpecialistCount[i] : 0;
}

int CvCivicInfo::getFreeSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFreeSpecialistCount ? m_piFreeSpecialistCount[i] : 0;
}


bool CvCivicInfo::isSpecialistUnlimited(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabSpecialistUnlimited ? m_pabSpecialistUnlimited[i] : false;
}
int CvCivicInfo::getImprovementYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiImprovementYieldChanges[i][j];
}

void CvCivicInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iCivicOptionType);
	stream->Read(&m_iAnarchyLength);
	stream->Read(&m_iCrimePerTurn);
	stream->Read(&m_iUpkeep);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iGreatPeopleRateModifier);
	stream->Read(&m_iGreatGeneralRateModifier);
	stream->Read(&m_iDomesticGreatGeneralRateModifier);
	stream->Read(&m_iStateReligionGreatPeopleRateModifier);
	stream->Read(&m_iDistanceMaintenanceModifier);
	stream->Read(&m_iNumCitiesMaintenanceModifier);
	stream->Read(&m_iCorporationMaintenanceModifier);
	stream->Read(&m_iExtraHealth);
	stream->Read(&m_iFreeExperience);
	stream->Read(&m_iWorkerSpeedModifier);
	stream->Read(&m_iImprovementUpgradeRateModifier);
	stream->Read(&m_iMilitaryProductionModifier);
	stream->Read(&m_iBaseFreeUnits);
	stream->Read(&m_iBaseFreeMilitaryUnits);
	stream->Read(&m_iFreeUnitsPopulationPercent);
	stream->Read(&m_iFreeMilitaryUnitsPopulationPercent);
	stream->Read(&m_iGoldPerUnit);
	stream->Read(&m_iGoldPerMilitaryUnit);
	stream->Read(&m_iHappyPerMilitaryUnit);
	stream->Read(&m_iLargestCityHappiness);
	stream->Read(&m_iWarWearinessModifier);
	stream->Read(&m_iFreeSpecialist);
	stream->Read(&m_iTradeRoutes);
	stream->Read(&m_iTechPrereq);
	stream->Read(&m_iCivicPercentAnger);
	stream->Read(&m_iMaxConscript);
	stream->Read(&m_iStateReligionHappiness);
	stream->Read(&m_iNonStateReligionHappiness);
	stream->Read(&m_iStateReligionUnitProductionModifier);
	stream->Read(&m_iStateReligionBuildingProductionModifier);
	stream->Read(&m_iStateReligionFreeExperience);
	stream->Read(&m_iExpInBorderModifier);

	stream->Read(&m_bMilitaryFoodProduction);
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Read(&m_bFixedBorders);
	stream->Read(&m_bInfluenceAllowed);
	stream->Read(&m_iVictoryInfluenceModifier);
	stream->Read(&m_iDefeatInfluenceModifier);
	stream->Read(&m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Read(&m_bNoUnhealthyPopulation);
	stream->Read(&m_bBuildingOnlyHealthy);
	stream->Read(&m_bNoForeignTrade);
	stream->Read(&m_bNoCorporations);
	stream->Read(&m_bNoForeignCorporations);
	stream->Read(&m_bStateReligion);
	stream->Read(&m_bNoNonStateReligionSpread);

/*************************************************************************************************/
/**	New Tag Defs	(CivicInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iAlignmentModifier);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	stream->Read(&m_iAlignmentShift);
	stream->Read(&m_iAlignmentShiftModifier);
	stream->Read(&m_iAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
//FfH Civics: Added by Kael 08/11/2007
	stream->Read(&m_bCompassionHigh);
	stream->Read(&m_bCompassionLow);
	stream->Read(&m_bHidden);
	stream->Read(&m_bNoDiplomacyWithEnemies);
	stream->Read(&m_bPrereqWar);
	stream->Read(&m_iAttitudeShareMod);
	stream->Read(&m_iCoastalTradeRoutes);
	stream->Read(&m_iEnslavementChance);
	stream->Read(&m_iFoodConsumptionPerPopulation);
	stream->Read(&m_iBlockAlignment);
	stream->Read(&m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iEthicalAlignmentModifier);
	stream->Read(&m_iEthicalAlignmentShift);
	stream->Read(&m_iEthicalAlignmentShiftModifier);
	stream->Read(&m_iEthicalAlignmentShiftTowardsNeutral);
	stream->Read(&m_iBlockEthicalAlignment);
	stream->Read(&m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqCivilization);
	stream->Read(&m_iPrereqReligion);
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	stream->Read(&m_iCityCapModifier);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
	stream->Read(&m_iMaxCultureLevel);
	stream->Read(&m_bExpandBeyondPlotRadius);
	stream->Read(&m_bCapitalNoCultureCap);
	stream->Read(&m_bGovCenterNoCultureCap);
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/

	stream->Read(&m_bOverflowProduction);

	// Arrays

	SAFE_DELETE_ARRAY(m_piYieldModifier);
	m_piYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldModifier);

	SAFE_DELETE_ARRAY(m_piCapitalYieldModifier);
	m_piCapitalYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piCapitalYieldModifier);

	SAFE_DELETE_ARRAY(m_piTradeYieldModifier);
	m_piTradeYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piTradeYieldModifier);

	SAFE_DELETE_ARRAY(m_piForeignTradeYieldModifier);
	m_piForeignTradeYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piForeignTradeYieldModifier);

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piTradeCommerceModifier);
	m_piTradeCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piTradeCommerceModifier);

	SAFE_DELETE_ARRAY(m_piForeignTradeCommerceModifier);
	m_piForeignTradeCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piForeignTradeCommerceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
		
	SAFE_DELETE_ARRAY(m_piCommerceChange);
	m_piCommerceChange = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceChange);

	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	m_piCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceModifier);

	SAFE_DELETE_ARRAY(m_piCapitalCommerceModifier);
	m_piCapitalCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCapitalCommerceModifier);

	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	m_piSpecialistExtraCommerce = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);

	SAFE_DELETE_ARRAY(m_paiBuildingHappinessChanges);
	m_paiBuildingHappinessChanges = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_paiBuildingHappinessChanges);

	SAFE_DELETE_ARRAY(m_paiBuildingHealthChanges);
	m_paiBuildingHealthChanges = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_paiBuildingHealthChanges);

	SAFE_DELETE_ARRAY(m_paiFeatureHappinessChanges);
	m_paiFeatureHappinessChanges = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_paiFeatureHappinessChanges);

	SAFE_DELETE_ARRAY(m_paiSpecialistCrimeChanges);
	m_paiSpecialistCrimeChanges = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_paiSpecialistCrimeChanges);

	SAFE_DELETE_ARRAY(m_pabHurry);
	m_pabHurry = new bool[GC.getNumHurryInfos()];
	stream->Read(GC.getNumHurryInfos(), m_pabHurry);

	SAFE_DELETE_ARRAY(m_pabSpecialBuildingNotRequired);
	m_pabSpecialBuildingNotRequired = new bool[GC.getNumSpecialBuildingInfos()];
	stream->Read(GC.getNumSpecialBuildingInfos(), m_pabSpecialBuildingNotRequired);

	SAFE_DELETE_ARRAY(m_pabSpecialistValid);
	m_pabSpecialistValid = new bool[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_pabSpecialistValid);

	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	m_piFreeSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);

	SAFE_DELETE_ARRAY(m_piSpecialistCount);
	m_piSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piSpecialistCount);
	
	SAFE_DELETE_ARRAY(m_pabSpecialistUnlimited);
	m_pabSpecialistUnlimited = new bool[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_pabSpecialistUnlimited);

	int i;
	if (m_ppiImprovementYieldChanges != NULL)
	{
		for(i=0;i<GC.getNumImprovementInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[i]);
		}
		SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges);
	}
	m_ppiImprovementYieldChanges = new int*[GC.getNumImprovementInfos()];
	for(i=0;i<GC.getNumImprovementInfos();i++)
	{
		m_ppiImprovementYieldChanges[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppiImprovementYieldChanges[i]);
	}

	stream->ReadString(m_szWeLoveTheKingKey);
}

void CvCivicInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iCivicOptionType);
	stream->Write(m_iAnarchyLength);
	stream->Write(m_iCrimePerTurn);
	stream->Write(m_iUpkeep);
	stream->Write(m_iAIWeight);
	stream->Write(m_iGreatPeopleRateModifier);
	stream->Write(m_iGreatGeneralRateModifier);
	stream->Write(m_iDomesticGreatGeneralRateModifier);
	stream->Write(m_iStateReligionGreatPeopleRateModifier);
	stream->Write(m_iDistanceMaintenanceModifier);
	stream->Write(m_iNumCitiesMaintenanceModifier);
	stream->Write(m_iCorporationMaintenanceModifier);
	stream->Write(m_iExtraHealth);
	stream->Write(m_iFreeExperience);
	stream->Write(m_iWorkerSpeedModifier);
	stream->Write(m_iImprovementUpgradeRateModifier);
	stream->Write(m_iMilitaryProductionModifier);
	stream->Write(m_iBaseFreeUnits);
	stream->Write(m_iBaseFreeMilitaryUnits);
	stream->Write(m_iFreeUnitsPopulationPercent);
	stream->Write(m_iFreeMilitaryUnitsPopulationPercent);
	stream->Write(m_iGoldPerUnit);
	stream->Write(m_iGoldPerMilitaryUnit);
	stream->Write(m_iHappyPerMilitaryUnit);
	stream->Write(m_iLargestCityHappiness);
	stream->Write(m_iWarWearinessModifier);
	stream->Write(m_iFreeSpecialist);
	stream->Write(m_iTradeRoutes);
	stream->Write(m_iTechPrereq);
	stream->Write(m_iCivicPercentAnger);
	stream->Write(m_iMaxConscript);
	stream->Write(m_iStateReligionHappiness);
	stream->Write(m_iNonStateReligionHappiness);
	stream->Write(m_iStateReligionUnitProductionModifier);
	stream->Write(m_iStateReligionBuildingProductionModifier);
	stream->Write(m_iStateReligionFreeExperience);
	stream->Write(m_iExpInBorderModifier);

	stream->Write(m_bMilitaryFoodProduction);
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Write(m_bFixedBorders);
	stream->Write(m_bInfluenceAllowed);
	stream->Write(m_iVictoryInfluenceModifier);
	stream->Write(m_iDefeatInfluenceModifier);
	stream->Write(m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Write(m_bNoUnhealthyPopulation);
	stream->Write(m_bBuildingOnlyHealthy);
	stream->Write(m_bNoForeignTrade);
	stream->Write(m_bNoCorporations);
	stream->Write(m_bNoForeignCorporations);
	stream->Write(m_bStateReligion);
	stream->Write(m_bNoNonStateReligionSpread);

/*************************************************************************************************/
/**	New Tag Defs	(CivicInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iAlignmentModifier);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	stream->Write(m_iAlignmentShift);
	stream->Write(m_iAlignmentShiftModifier);
	stream->Write(m_iAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
//FfH Civics: Added by Kael 08/11/2007
	stream->Write(m_bCompassionHigh);
	stream->Write(m_bCompassionLow);
	stream->Write(m_bHidden);
	stream->Write(m_bNoDiplomacyWithEnemies);
	stream->Write(m_bPrereqWar);
	stream->Write(m_iAttitudeShareMod);
	stream->Write(m_iCoastalTradeRoutes);
	stream->Write(m_iEnslavementChance);
	stream->Write(m_iFoodConsumptionPerPopulation);
	stream->Write(m_iBlockAlignment);
	stream->Write(m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iEthicalAlignmentModifier);
	stream->Write(m_iEthicalAlignmentShift);
	stream->Write(m_iEthicalAlignmentShiftModifier);
	stream->Write(m_iEthicalAlignmentShiftTowardsNeutral);
	stream->Write(m_iBlockEthicalAlignment);
	stream->Write(m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iPrereqCivilization);
	stream->Write(m_iPrereqReligion);
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	stream->Write(m_iCityCapModifier);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
	stream->Write(m_iMaxCultureLevel);
	stream->Write(m_bExpandBeyondPlotRadius);
	stream->Write(m_bCapitalNoCultureCap);
	stream->Write(m_bGovCenterNoCultureCap);
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/
	
	stream->Write(m_bOverflowProduction);

	// Arrays

	stream->Write(NUM_YIELD_TYPES, m_piYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piCapitalYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piTradeYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piForeignTradeYieldModifier);
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	stream->Write(NUM_COMMERCE_TYPES, m_piTradeCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piForeignTradeCommerceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceChange);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piCapitalCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);
	stream->Write(GC.getNumBuildingClassInfos(), m_paiBuildingHappinessChanges);
	stream->Write(GC.getNumBuildingClassInfos(), m_paiBuildingHealthChanges);
	stream->Write(GC.getNumFeatureInfos(), m_paiFeatureHappinessChanges);
	stream->Write(GC.getNumSpecialistInfos(), m_paiSpecialistCrimeChanges);
	stream->Write(GC.getNumHurryInfos(), m_pabHurry);
	stream->Write(GC.getNumSpecialBuildingInfos(), m_pabSpecialBuildingNotRequired);
	stream->Write(GC.getNumSpecialistInfos(), m_pabSpecialistValid);
	stream->Write(GC.getNumSpecialistInfos(), m_pabSpecialistUnlimited);
	stream->Write(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);
	stream->Write(GC.getNumSpecialistInfos(), m_piSpecialistCount);

	int i;
	for(i=0;i<GC.getNumImprovementInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppiImprovementYieldChanges[i]);
	}

	stream->WriteString(m_szWeLoveTheKingKey);
}

bool CvCivicInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j;
	int iNumSibs=0;				// the number of siblings the current xml node has
	int iIndex;

	pXML->GetChildXmlValByName(szTextVal, "CivicOptionType");
	m_iCivicOptionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iAnarchyLength, "iAnarchyLength");
	
	pXML->GetChildXmlValByName(&m_iCrimePerTurn, "iCrimePerTurn");

	pXML->GetChildXmlValByName(szTextVal, "Upkeep");
	m_iUpkeep = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iGreatGeneralRateModifier, "iGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iDomesticGreatGeneralRateModifier, "iDomesticGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iStateReligionGreatPeopleRateModifier, "iStateReligionGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iDistanceMaintenanceModifier, "iDistanceMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iNumCitiesMaintenanceModifier, "iNumCitiesMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iCorporationMaintenanceModifier, "iCorporationMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iExtraHealth, "iExtraHealth");
	pXML->GetChildXmlValByName(&m_iFreeExperience, "iFreeExperience");
	pXML->GetChildXmlValByName(&m_iWorkerSpeedModifier, "iWorkerSpeedModifier");
	pXML->GetChildXmlValByName(&m_iImprovementUpgradeRateModifier, "iImprovementUpgradeRateModifier");
	pXML->GetChildXmlValByName(&m_iMilitaryProductionModifier, "iMilitaryProductionModifier");
	pXML->GetChildXmlValByName(&m_iBaseFreeUnits, "iBaseFreeUnits");
	pXML->GetChildXmlValByName(&m_iBaseFreeMilitaryUnits, "iBaseFreeMilitaryUnits");
	pXML->GetChildXmlValByName(&m_iFreeUnitsPopulationPercent, "iFreeUnitsPopulationPercent");
	pXML->GetChildXmlValByName(&m_iFreeMilitaryUnitsPopulationPercent, "iFreeMilitaryUnitsPopulationPercent");
	pXML->GetChildXmlValByName(&m_iGoldPerUnit, "iGoldPerUnit");
	pXML->GetChildXmlValByName(&m_iGoldPerMilitaryUnit, "iGoldPerMilitaryUnit");
	pXML->GetChildXmlValByName(&m_iHappyPerMilitaryUnit, "iHappyPerMilitaryUnit");
	pXML->GetChildXmlValByName(&m_bMilitaryFoodProduction, "bMilitaryFoodProduction");
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bFixedBorders, "bFixedBorders");
	pXML->GetChildXmlValByName(&m_bInfluenceAllowed, "bInfluenceAllowed");
	pXML->GetChildXmlValByName(&m_iVictoryInfluenceModifier, "iVictoryInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iDefeatInfluenceModifier, "iDefeatInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iPillageInfluenceModifier, "iPillageInfluenceModifier", 100);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iMaxConscript, "iMaxConscript");
	pXML->GetChildXmlValByName(&m_bNoUnhealthyPopulation, "bNoUnhealthyPopulation");
	pXML->GetChildXmlValByName(&m_bBuildingOnlyHealthy, "bBuildingOnlyHealthy");
	pXML->GetChildXmlValByName(&m_iLargestCityHappiness, "iLargestCityHappiness");
	pXML->GetChildXmlValByName(&m_iWarWearinessModifier, "iWarWearinessModifier");
	pXML->GetChildXmlValByName(&m_iFreeSpecialist, "iFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_bNoForeignTrade, "bNoForeignTrade");
	pXML->GetChildXmlValByName(&m_bNoCorporations, "bNoCorporations");
	pXML->GetChildXmlValByName(&m_bNoForeignCorporations, "bNoForeignCorporations");
	pXML->GetChildXmlValByName(&m_iCivicPercentAnger, "iCivicPercentAnger");
	pXML->GetChildXmlValByName(&m_bStateReligion, "bStateReligion");
	pXML->GetChildXmlValByName(&m_bNoNonStateReligionSpread, "bNoNonStateReligionSpread");
	pXML->GetChildXmlValByName(&m_iStateReligionHappiness, "iStateReligionHappiness");
	pXML->GetChildXmlValByName(&m_iNonStateReligionHappiness, "iNonStateReligionHappiness");
	pXML->GetChildXmlValByName(&m_iStateReligionUnitProductionModifier, "iStateReligionUnitProductionModifier");
	pXML->GetChildXmlValByName(&m_iStateReligionBuildingProductionModifier, "iStateReligionBuildingProductionModifier");
	pXML->GetChildXmlValByName(&m_iStateReligionFreeExperience, "iStateReligionFreeExperience");
	pXML->GetChildXmlValByName(&m_iExpInBorderModifier, "iExpInBorderModifier");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
	{
		pXML->SetYields(&m_piYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CapitalYieldModifiers"))
	{
		pXML->SetYields(&m_piCapitalYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCapitalYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TradeYieldModifiers"))
	{
		pXML->SetYields(&m_piTradeYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piTradeYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ForeignTradeYieldModifiers"))
	{
		pXML->SetYields(&m_piForeignTradeYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piForeignTradeYieldModifier, NUM_YIELD_TYPES);
	}

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TradeCommerceModifiers"))
	{
		pXML->SetCommerce(&m_piTradeCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piTradeCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ForeignTradeCommerceModifiers"))
	{
		pXML->SetCommerce(&m_piForeignTradeCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piForeignTradeCommerceModifier, NUM_COMMERCE_TYPES);
	}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChanges"))
	{
		pXML->SetCommerce(&m_piCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceChange, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CapitalCommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCapitalCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCapitalCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistExtraCommerces"))
	{
		pXML->SetCommerce(&m_piSpecialistExtraCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piSpecialistExtraCommerce, NUM_COMMERCE_TYPES);
	}

	pXML->SetVariableListTagPair(&m_pabHurry, "Hurrys", sizeof(GC.getHurryInfo((HurryTypes)0)), GC.getNumHurryInfos());
	pXML->SetVariableListTagPair(&m_pabSpecialBuildingNotRequired, "SpecialBuildingNotRequireds", sizeof(GC.getSpecialBuildingInfo((SpecialBuildingTypes)0)), GC.getNumSpecialBuildingInfos());
	pXML->SetVariableListTagPair(&m_pabSpecialistValid, "SpecialistValids", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_pabSpecialistUnlimited, "SpecialistUnlimiteds", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_piFreeSpecialistCount, "FreeSpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_piSpecialistCount, "SpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	pXML->SetVariableListTagPair(&m_paiBuildingHappinessChanges, "BuildingHappinessChanges", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_paiBuildingHealthChanges, "BuildingHealthChanges", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_paiFeatureHappinessChanges, "FeatureHappinessChanges", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_paiSpecialistCrimeChanges, "SpecialistCrimeChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	// initialize the boolean list to the correct size and all the booleans to false
	FAssertMsg((GC.getNumImprovementInfos() > 0) && (NUM_YIELD_TYPES) > 0,"either the number of improvement infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiImprovementYieldChanges, GC.getNumImprovementInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiImprovementYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiImprovementYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "WeLoveTheKing");
	setWeLoveTheKingKey(szTextVal);

/*************************************************************************************************/
/**	New Tag Defs	(CivicInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentShift, "iAlignmentShift");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftModifier, "iAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftTowardsNeutral, "iAlignmentShiftTowardsNeutral");
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
//FfH Civics: Added by Kael 08/11/2007
	pXML->GetChildXmlValByName(&m_bCompassionHigh, "bCompassionHigh");
	pXML->GetChildXmlValByName(&m_bCompassionLow, "bCompassionLow");
	pXML->GetChildXmlValByName(&m_bHidden, "bHidden");
	pXML->GetChildXmlValByName(&m_bNoDiplomacyWithEnemies, "bNoDiplomacyWithEnemies");
	pXML->GetChildXmlValByName(&m_bPrereqWar, "bPrereqWar");
	pXML->GetChildXmlValByName(&m_iAttitudeShareMod, "iAttitudeShareMod");
	pXML->GetChildXmlValByName(&m_iCoastalTradeRoutes, "iCoastalTradeRoutes");
	pXML->GetChildXmlValByName(&m_iEnslavementChance, "iEnslavementChance");
	pXML->GetChildXmlValByName(&m_iFoodConsumptionPerPopulation, "iFoodConsumptionPerPopulation");
	pXML->GetChildXmlValByName(szTextVal, "BlockAlignment");
	m_iBlockAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShift, "iEthicalAlignmentShift");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftModifier, "iEthicalAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftTowardsNeutral, "iEthicalAlignmentShiftTowardsNeutral");
	pXML->GetChildXmlValByName(szTextVal, "BlockEthicalAlignment");
	m_iBlockEthicalAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqEthicalAlignment");
	m_iPrereqEthicalAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iCityCapModifier, "iCityCapModifier");
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "MaxCultureLevel");
	m_iMaxCultureLevel = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bExpandBeyondPlotRadius, "bExpandBeyondPlotRadius");
	pXML->GetChildXmlValByName(&m_bCapitalNoCultureCap, "bCapitalNoCultureCap");
	pXML->GetChildXmlValByName(&m_bGovCenterNoCultureCap, "bGovCenterNoCultureCap");
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(&m_bOverflowProduction, "bOverflowProduction");

	return true;
}

//FfH Civics: Added by Kael 08/11/2007
bool CvCivicInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(CivicInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCivicInfo::copyNonDefaults(CvCivicInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isNoForeignTrade()								== false)			m_bNoForeignTrade							= pClassInfo->isNoForeignTrade();
	if (isNoCorporations()								== false)			m_bNoCorporations							= pClassInfo->isNoCorporations();
	if (isNoForeignCorporations()						== false)			m_bNoForeignCorporations					= pClassInfo->isNoForeignCorporations();
	if (isMilitaryFoodProduction()						== false)			m_bMilitaryFoodProduction					= pClassInfo->isMilitaryFoodProduction();
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	if (isFixedBorders()								== false)			m_bFixedBorders								= pClassInfo->isFixedBorders();
	if (isInfluenceAllowed()							== false)			m_bInfluenceAllowed							= pClassInfo->isInfluenceAllowed();
	if (getVictoryInfluenceModifier()					== 100)				m_iVictoryInfluenceModifier					= pClassInfo->getVictoryInfluenceModifier();
	if (getDefeatInfluenceModifier()					== 100)				m_iDefeatInfluenceModifier					= pClassInfo->getDefeatInfluenceModifier();
	if (getPillageInfluenceModifier()					== 100)				m_iPillageInfluenceModifier					= pClassInfo->getPillageInfluenceModifier();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	if (isNoUnhealthyPopulation()						== false)			m_bNoUnhealthyPopulation					= pClassInfo->isNoUnhealthyPopulation();
	if (isBuildingOnlyHealthy()							== false)			m_bBuildingOnlyHealthy						= pClassInfo->isBuildingOnlyHealthy();
	if (isStateReligion()								== false)			m_bStateReligion							= pClassInfo->isStateReligion();
	if (isNoNonStateReligionSpread()					== false)			m_bNoNonStateReligionSpread					= pClassInfo->isNoNonStateReligionSpread();
	if (getAnarchyLength()								== 0)				m_iAnarchyLength							= pClassInfo->getAnarchyLength();
	if (getCrimePerTurn() == 0)				m_iCrimePerTurn = pClassInfo->getCrimePerTurn();
	if (getAIWeight()									== 0)				m_iAIWeight									= pClassInfo->getAIWeight();
	if (getGreatPeopleRateModifier()					== 0)				m_iGreatPeopleRateModifier					= pClassInfo->getGreatPeopleRateModifier();
	if (getGreatGeneralRateModifier()					== 0)				m_iGreatGeneralRateModifier					= pClassInfo->getGreatGeneralRateModifier();
	if (getDomesticGreatGeneralRateModifier()			== 0)				m_iDomesticGreatGeneralRateModifier			= pClassInfo->getDomesticGreatGeneralRateModifier();
	if (getStateReligionGreatPeopleRateModifier()		== 0)				m_iStateReligionGreatPeopleRateModifier		= pClassInfo->getStateReligionGreatPeopleRateModifier();
	if (getDistanceMaintenanceModifier()				== 0)				m_iDistanceMaintenanceModifier				= pClassInfo->getDistanceMaintenanceModifier();
	if (getNumCitiesMaintenanceModifier()				== 0)				m_iNumCitiesMaintenanceModifier				= pClassInfo->getNumCitiesMaintenanceModifier();
	if (getCorporationMaintenanceModifier()				== 0)				m_iCorporationMaintenanceModifier			= pClassInfo->getCorporationMaintenanceModifier();
	if (getExtraHealth()								== 0)				m_iExtraHealth								= pClassInfo->getExtraHealth();
	if (getFreeExperience()								== 0)				m_iFreeExperience							= (float)(pClassInfo->getFreeExperience()/100.0);
	if (getWorkerSpeedModifier()						== 0)				m_iWorkerSpeedModifier						= pClassInfo->getWorkerSpeedModifier();
	if (getImprovementUpgradeRateModifier()				== 0)				m_iImprovementUpgradeRateModifier			= pClassInfo->getImprovementUpgradeRateModifier();
	if (getMilitaryProductionModifier()					== 0)				m_iMilitaryProductionModifier				= pClassInfo->getMilitaryProductionModifier();
	if (getBaseFreeUnits()								== 0)				m_iBaseFreeUnits							= pClassInfo->getBaseFreeUnits();
	if (getBaseFreeMilitaryUnits()						== 0)				m_iBaseFreeMilitaryUnits					= pClassInfo->getBaseFreeMilitaryUnits();
	if (getFreeUnitsPopulationPercent()					== 0)				m_iFreeUnitsPopulationPercent				= pClassInfo->getFreeUnitsPopulationPercent();
	if (getFreeMilitaryUnitsPopulationPercent()			== 0)				m_iFreeMilitaryUnitsPopulationPercent		= pClassInfo->getFreeMilitaryUnitsPopulationPercent();
	if (getGoldPerUnit()								== 0)				m_iGoldPerUnit								= pClassInfo->getGoldPerUnit();
	if (getGoldPerMilitaryUnit()						== 0)				m_iGoldPerMilitaryUnit						= pClassInfo->getGoldPerMilitaryUnit();
	if (getHappyPerMilitaryUnit()						== 0)				m_iHappyPerMilitaryUnit						= pClassInfo->getHappyPerMilitaryUnit();
	if (getMaxConscript()								== 0)				m_iMaxConscript								= pClassInfo->getMaxConscript();
	if (getLargestCityHappiness()						== 0)				m_iLargestCityHappiness						= pClassInfo->getLargestCityHappiness();
	if (getWarWearinessModifier()						== 0)				m_iWarWearinessModifier						= pClassInfo->getWarWearinessModifier();
	if (getFreeSpecialist()								== 0)				m_iFreeSpecialist							= pClassInfo->getFreeSpecialist();
	if (getCivicPercentAnger()							== 0)				m_iCivicPercentAnger						= pClassInfo->getCivicPercentAnger();
	if (getTradeRoutes()								== 0)				m_iTradeRoutes								= pClassInfo->getTradeRoutes();
	if (getStateReligionHappiness()						== 0)				m_iStateReligionHappiness					= pClassInfo->getStateReligionHappiness();
	if (getNonStateReligionHappiness()					== 0)				m_iNonStateReligionHappiness				= pClassInfo->getNonStateReligionHappiness();
	if (getStateReligionUnitProductionModifier()		== 0)				m_iStateReligionUnitProductionModifier		= pClassInfo->getStateReligionUnitProductionModifier();
	if (getStateReligionBuildingProductionModifier()	== 0)				m_iStateReligionBuildingProductionModifier	= pClassInfo->getStateReligionBuildingProductionModifier();
	if (getStateReligionFreeExperience()				== 0)				m_iStateReligionFreeExperience				= (float)(pClassInfo->getStateReligionFreeExperience()/100.0);
	if (getExpInBorderModifier()						== 0)				m_iExpInBorderModifier						= pClassInfo->getExpInBorderModifier();
	if (getWeLoveTheKingKey()							== wDefault)		m_szWeLoveTheKingKey						= pClassInfo->getWeLoveTheKingKey();
	if (getTechPrereq()									== NO_TECH)			m_iTechPrereq								= pClassInfo->getTechPrereq();
	if (getUpkeep()										== NO_UPKEEP)		m_iUpkeep									= pClassInfo->getUpkeep();
	if (getCivicOptionType()							== NO_CIVICOPTION)	m_iCivicOptionType							= pClassInfo->getCivicOptionType();

	if (isOverflowProduction()							== false)			m_bOverflowProduction						= pClassInfo->isOverflowProduction();

	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_piYieldModifier[i]						== 0)				m_piYieldModifier[i]						= pClassInfo->getYieldModifier(i);
		if (m_piCapitalYieldModifier[i]					== 0)				m_piCapitalYieldModifier[i]					= pClassInfo->getCapitalYieldModifier(i);
		if (m_piTradeYieldModifier[i]					== 0)				m_piTradeYieldModifier[i]					= pClassInfo->getTradeYieldModifier(i);
		if (m_piForeignTradeYieldModifier[i]			== 0)				m_piForeignTradeYieldModifier[i]		    = pClassInfo->getForeignTradeYieldModifier(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
		if (m_piTradeCommerceModifier[i]				== 0)				m_piTradeCommerceModifier[i]				= pClassInfo->getTradeCommerceModifier(i);
		if (m_piForeignTradeCommerceModifier[i]			== 0)				m_piForeignTradeCommerceModifier[i]			= pClassInfo->getForeignTradeCommerceModifier(i);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
		if (m_piCommerceChange[i]						== 0)				m_piCommerceChange[i]						= pClassInfo->getCommerceChange(i);
		if (m_piCommerceModifier[i]						== 0)				m_piCommerceModifier[i]						= pClassInfo->getCommerceModifier(i);
		if (m_piCapitalCommerceModifier[i]				== 0)				m_piCapitalCommerceModifier[i]				= pClassInfo->getCapitalCommerceModifier(i);
		if (m_piSpecialistExtraCommerce[i]				== 0)				m_piSpecialistExtraCommerce[i]				= pClassInfo->getSpecialistExtraCommerce(i);
	}
	for ( int i = 0; i < GC.getNumHurryInfos(); i++ )
	{
		if (m_pabHurry[i]								== false)			m_pabHurry[i]								= pClassInfo->isHurry(i);
	}
	for ( int i = 0; i < GC.getNumSpecialBuildingInfos(); i++ )
	{
		if (m_pabSpecialBuildingNotRequired[i]			== false)			m_pabSpecialBuildingNotRequired[i]			= pClassInfo->isSpecialBuildingNotRequired(i);
	}
	for ( int i = 0; i < GC.getNumSpecialistInfos(); i++ )
	{
		if (m_pabSpecialistValid[i]						== false)			m_pabSpecialistValid[i]						= pClassInfo->isSpecialistValid(i);
		if (m_pabSpecialistUnlimited[i] == false)			m_pabSpecialistUnlimited[i] = pClassInfo->isSpecialistUnlimited(i);
		if (m_piFreeSpecialistCount[i] == 0)				m_piFreeSpecialistCount[i] = pClassInfo->getFreeSpecialistCount(i);
		if (m_piSpecialistCount[i]						== 0)				m_piSpecialistCount[i]						= pClassInfo->getSpecialistCount(i);
		if (m_paiSpecialistCrimeChanges[i] == 0)				m_paiSpecialistCrimeChanges[i] = pClassInfo->getSpecialistCrimeChanges(i);
	}

	for ( int i = 0; i < GC.getNumBuildingClassInfos(); i++ )
	{
		if (m_paiBuildingHappinessChanges[i]			== 0)				m_paiBuildingHappinessChanges[i]			= pClassInfo->getBuildingHappinessChanges(i);
		if (m_paiBuildingHealthChanges[i]				== 0)				m_paiBuildingHealthChanges[i]				= pClassInfo->getBuildingHealthChanges(i);
	}
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++ )
	{
		if (m_paiFeatureHappinessChanges[i]				== 0)				m_paiFeatureHappinessChanges[i]				= pClassInfo->getFeatureHappinessChanges(i);
	}
	for ( int i = 0; i < GC.getNumImprovementInfos(); i++ )
	{
		for ( int j = 0; j < NUM_YIELD_TYPES; j++ )
		{
			if (m_ppiImprovementYieldChanges[i][j]		== 0)				m_ppiImprovementYieldChanges[i][j]			= pClassInfo->getImprovementYieldChanges(i,j);
		}
	}
	if (isCompassionHigh()								== false)			m_bCompassionHigh							= pClassInfo->isCompassionHigh();
	if (isCompassionLow()								== false)			m_bCompassionLow							= pClassInfo->isCompassionLow();
	if (isHidden()										== false)			m_bHidden									= pClassInfo->isHidden();
	if (isNoDiplomacyWithEnemies()						== false)			m_bNoDiplomacyWithEnemies					= pClassInfo->isNoDiplomacyWithEnemies();
	if (isPrereqWar()									== false)			m_bPrereqWar								= pClassInfo->isPrereqWar();
	if (getAlignmentModifier()							== 0)				m_iAlignmentModifier						= pClassInfo->getAlignmentModifier();
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	if (getAlignmentShift()                             == 0)               m_iAlignmentShift                           = pClassInfo->getAlignmentShift();
	if (getAlignmentShiftModifier()                     == 0)               m_iAlignmentShiftModifier                   = pClassInfo->getAlignmentShiftModifier();
	if (getAlignmentShiftTowardsNeutral()               == -1)              m_iAlignmentShiftTowardsNeutral             = pClassInfo->getAlignmentShiftTowardsNeutral();
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
	if (getAttitudeShareMod()							== 0)				m_iAttitudeShareMod							= pClassInfo->getAttitudeShareMod();
	if (getCoastalTradeRoutes()							== 0)				m_iCoastalTradeRoutes						= pClassInfo->getCoastalTradeRoutes();
	if (getEnslavementChance()							== 0)				m_iEnslavementChance						= pClassInfo->getEnslavementChance();
	if (getFoodConsumptionPerPopulation()				== 0)				m_iFoodConsumptionPerPopulation				= pClassInfo->getFoodConsumptionPerPopulation();
	if (getBlockAlignment()								== NO_ALIGNMENT)	m_iBlockAlignment							= pClassInfo->getBlockAlignment();
	if (getPrereqAlignment()							== NO_ALIGNMENT)	m_iPrereqAlignment							= pClassInfo->getPrereqAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getBlockEthicalAlignment()				== NO_ETHICAL_ALIGNMENT)	m_iBlockEthicalAlignment					= pClassInfo->getBlockEthicalAlignment();
	if (getPrereqEthicalAlignment()				== NO_ETHICAL_ALIGNMENT)	m_iPrereqEthicalAlignment					= pClassInfo->getPrereqEthicalAlignment();
	if (getEthicalAlignmentModifier()					== 0)				m_iEthicalAlignmentModifier					= pClassInfo->getEthicalAlignmentModifier();
	if (getEthicalAlignmentShift()                      == 0)               m_iEthicalAlignmentShift                    = pClassInfo->getEthicalAlignmentShift();
	if (getEthicalAlignmentShiftModifier()              == 0)               m_iEthicalAlignmentShiftModifier            = pClassInfo->getEthicalAlignmentShiftModifier();
	if (getEthicalAlignmentShiftTowardsNeutral()        == -1)              m_iEthicalAlignmentShiftTowardsNeutral      = pClassInfo->getEthicalAlignmentShiftTowardsNeutral();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getPrereqReligion()								== NO_RELIGION)		m_iPrereqReligion							= pClassInfo->getPrereqReligion();

	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getPrereqCivilizationVectorSize(); i++ )
	{
																			m_aszExtraXMLforPass3.push_back(			pClassInfo->getPrereqCivilizationVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvDiplomacyInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvDiplomacyInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyInfo::CvDiplomacyInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDiplomacyInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyInfo::~CvDiplomacyInfo()
{
	uninit();
}

// note - Response member vars allocated by CvXmlLoadUtility
void CvDiplomacyInfo::uninit()
{
	for (std::vector<CvDiplomacyResponse*>::iterator it = m_pResponses.begin(); it != m_pResponses.end(); ++it)
	{
		SAFE_DELETE(*it);
	}
	m_pResponses.clear();
}

const CvDiplomacyResponse& CvDiplomacyInfo::getResponse(int iNum) const
{
	return *(m_pResponses[iNum]);
}

int CvDiplomacyInfo::getNumResponses() const
{
	return m_pResponses.size();
}

bool CvDiplomacyInfo::getCivilizationTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getCivilizationTypes(j);
}

bool CvDiplomacyInfo::getLeaderHeadTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getLeaderHeadTypes(j);
}

bool CvDiplomacyInfo::getAttitudeTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getAttitudeTypes(j);
}

bool CvDiplomacyInfo::getDiplomacyPowerTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getDiplomacyPowerTypes(j);
}

int CvDiplomacyInfo::getNumDiplomacyText(int i) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pResponses[i]->getNumDiplomacyText();
}

const TCHAR* CvDiplomacyInfo::getDiplomacyText(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < getNumDiplomacyText(i), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getDiplomacyText(j);
}

void CvDiplomacyInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	int iNumResponses;
	stream->Read(&iNumResponses);

	// Arrays

	uninit();
	for (int uiIndex = 0; uiIndex < iNumResponses; ++uiIndex)
	{
		CvDiplomacyResponse* pResponse = new CvDiplomacyResponse;
		pResponse->read(stream);
		m_pResponses.push_back(pResponse);
	}
}

void CvDiplomacyInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	int iNumResponses = m_pResponses.size();
	stream->Write(iNumResponses);

	// Arrays

	for (int uiIndex = 0; uiIndex < iNumResponses; ++uiIndex)
	{
		m_pResponses[uiIndex]->write(stream);
	}
}

bool CvDiplomacyInfo::read(CvXMLLoadUtility* pXML)
{
	int i;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	uninit();
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Responses") )
	{
		int iNewResponses = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "Response");

		gDLL->getXMLIFace()->SetToChild(pXML->GetXML());

		for (i = 0; i < iNewResponses; i++)
		{
			CvDiplomacyResponse* pNewResponse = new CvDiplomacyResponse;
			pNewResponse->read(pXML);
			m_pResponses.push_back(pNewResponse);

			if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
			{
				break;
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	Haven't looked this over yet, but none of it should have been altered, so I hope it works	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvDiplomacyInfo::copyNonDefaults(CvXMLLoadUtility* pXML)
{
	// We have 6 possibilities in civ what this might be
	// 1) Text
	// 2) Leadertype + Text
	// 3) Attitude + Text
	// 4) Power + Text
	// 5) Leadertype + Attitude + Text
	// 6) Leadertype + Power + Text
	// Civilizations aren't used thus far...No idea why firaxis added this to the XML
	int iCase = 0; //no Case

	// Read the New Responses
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Responses") )
	{
		int iNewResponses = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "Response");

		gDLL->getXMLIFace()->SetToChild(pXML->GetXML());

		for (int i = 0; i < iNewResponses; i++)
		{
			CvDiplomacyResponse* pNewResponse = new CvDiplomacyResponse;
			pNewResponse->read(pXML);
			int iResponses = m_pResponses.size();

			// Check if the new
			bool bLeaderHeadTypes = false;
			for ( int j = 0; j < GC.getNumLeaderHeadInfos(); j++ )
			{
				if (pNewResponse->getLeaderHeadTypes(j))
				{
					bLeaderHeadTypes = true;
					break;
				}
			}
			bool bAttitudeTypes = false;
			for ( int j = 0; j < NUM_ATTITUDE_TYPES; j++ )
			{
				if (pNewResponse->getAttitudeTypes(j))
				{
					bAttitudeTypes = true;
					break;
				}
			}
			bool bPowerTypes = false;
			for ( int j = 0; j < NUM_DIPLOMACYPOWER_TYPES; j++ )
			{
				if (pNewResponse->getDiplomacyPowerTypes(j))
				{
					bPowerTypes = true;
					break;
				}
			}

			// Check which case we have
			if ( !(bLeaderHeadTypes || bAttitudeTypes || bPowerTypes) ) iCase = 1;
			else if ( bLeaderHeadTypes && !( bAttitudeTypes || bPowerTypes) ) iCase = 2;
			else if ( bAttitudeTypes && !( bLeaderHeadTypes || bPowerTypes) ) iCase = 3;
			else if ( bPowerTypes && !( bLeaderHeadTypes || bAttitudeTypes) ) iCase = 4;
			else if ( bLeaderHeadTypes && bAttitudeTypes && !bPowerTypes ) iCase = 5;
			else if ( bLeaderHeadTypes && bPowerTypes && !bAttitudeTypes ) iCase = 6;
			else FAssertMsg(false, "A new case with an added Diplomacy XML but already exists?" );

			// Find ResponseIndex(if already exists)
			bool bIsIndex =  false;
			int iIndex = 0;
			bIsIndex = FindResponseIndex(pNewResponse, iCase, &iIndex);

			if (bIsIndex)
			{
				// Check the Previous Values of this class and copy them to the Diplomacies Response
				pNewResponse->UpdateDiplomacies(this, iIndex);

				//Delete old vector info(only for this response)
				//DeleteResponseOnly(m_pResponses, getResponse(iIndex));
				m_pResponses.erase(m_pResponses.begin() + iIndex);
			}

			//apply new vector info
			m_pResponses.push_back(pNewResponse);

			if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
			{
				break;
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
}
bool CvDiplomacyInfo::FindResponseIndex(CvDiplomacyResponse* pNewResponse, int iCase, int* iIndex)
{
	// We have 6 possibilities in civ what this might be
	// 1) Text
	// 2) Leadertype + Text
	// 3) Attitude + Text
	// 4) Power + Text
	// 5) Leadertype + Attitude + Text
	// 6) Leadertype + Power + Text

	if ( getNumResponses() == 1 )
	{
		iIndex = 0;
		return true;
	}

	// Text
	if ( iCase == 1 )
	{
		bool bOnlyText = true;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) ) bOnlyText = false;
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bOnlyText = false;
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bOnlyText = false;
			}
			if ( bOnlyText )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Leaderheads + Text
	if ( iCase == 2 )
	{
		bool bOnlyLeaderheads = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) && pNewResponse->getLeaderHeadTypes(iElement) ) bOnlyLeaderheads = true;
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bOnlyLeaderheads = false;
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bOnlyLeaderheads = false;
			}
			if ( bOnlyLeaderheads )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Attitude + Text
	if ( iCase == 3 )
	{
		bool bOnlyAttitudeTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) && pNewResponse->getAttitudeTypes(iElement)) bOnlyAttitudeTypes = true;
			}
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) ) bOnlyAttitudeTypes = false;
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bOnlyAttitudeTypes = false;
			}
			if ( bOnlyAttitudeTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Power + Text
	if ( iCase == 4 )
	{
		bool bOnlyDiplomacyPowerTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) && pNewResponse->getDiplomacyPowerTypes(iElement) ) bOnlyDiplomacyPowerTypes = true;
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bOnlyDiplomacyPowerTypes = false;
			}
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) ) bOnlyDiplomacyPowerTypes = false;
			}

			if ( bOnlyDiplomacyPowerTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Leadertype + Attitude + Text
	if ( iCase == 5 )
	{
		bool bLeaderAttitudeTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) && pNewResponse->getLeaderHeadTypes(iElement) )
				{
					for ( int iiElement = 0; iiElement < NUM_ATTITUDE_TYPES; ++iiElement )
					{
						if ( getAttitudeTypes(i, iiElement) && pNewResponse->getAttitudeTypes(iiElement) ) bLeaderAttitudeTypes = true;
					}
				}
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bLeaderAttitudeTypes = false;
			}

			if ( bLeaderAttitudeTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Leadertype + Power + Text
	if ( iCase == 6 )
	{
		bool bLeaderDiplomacyPowerTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) && pNewResponse->getLeaderHeadTypes(iElement) )
				{
					for ( int iiElement = 0; iiElement < NUM_DIPLOMACYPOWER_TYPES; ++iiElement )
					{
						if ( getDiplomacyPowerTypes(i, iiElement) && pNewResponse->getDiplomacyPowerTypes(iiElement) ) bLeaderDiplomacyPowerTypes = true;
					}
				}
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bLeaderDiplomacyPowerTypes = false;
			}

			if ( bLeaderDiplomacyPowerTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	return false;  //This means there was no index, hence it's a new one and needs to be added to the vector
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvUnitClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvUnitClassInfo::CvUnitClassInfo() :
m_iMaxGlobalInstances(0),
m_iMaxTeamInstances(0),
m_iMaxPlayerInstances(0),
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**						Modifies Cost based on Population and number of Cities					**/
/*************************************************************************************************/
m_bCountCitiesAsUnit(false),
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
m_iInstanceCostModifier(0),
/*************************************************************************************************/
/**	New Tag Defs	(UnitClassInfos)		10/18/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_bUnique(false),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_iDefaultUnitIndex(NO_UNIT)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvUnitClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvUnitClassInfo::~CvUnitClassInfo()
{
}

int CvUnitClassInfo::getMaxGlobalInstances() const
{
	return m_iMaxGlobalInstances;
}

int CvUnitClassInfo::getMaxTeamInstances() const
{
	return m_iMaxTeamInstances;
}

int CvUnitClassInfo::getMaxPlayerInstances() const
{
	return m_iMaxPlayerInstances;
}

/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**						Modifies Cost based on Population and number of Cities					**/
/*************************************************************************************************/
int CvUnitClassInfo::isCountCitiesAsUnit() const
{
	return m_bCountCitiesAsUnit;
}
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/

int CvUnitClassInfo::getInstanceCostModifier() const
{
	return m_iInstanceCostModifier;
}

int CvUnitClassInfo::getDefaultUnitIndex() const
{
	return m_iDefaultUnitIndex;
}

void CvUnitClassInfo::setDefaultUnitIndex(int i)
{
	m_iDefaultUnitIndex = i;
}

/*************************************************************************************************/
/**	New Tag Defs	(UnitClassInfos)		10/18/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
bool CvUnitClassInfo::isUnique() const
{
	return m_bUnique;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
int CvUnitClassInfo::getDefaultUnitIndexVector()
{
	return m_aszExtraXMLforPass3.size();
}
CvString CvUnitClassInfo::getDefaultUnitIndexVectorElement(int i)
{
	return m_aszExtraXMLforPass3[i];
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
bool CvUnitClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iMaxGlobalInstances, "iMaxGlobalInstances");
	pXML->GetChildXmlValByName(&m_iMaxTeamInstances, "iMaxTeamInstances");
	pXML->GetChildXmlValByName(&m_iMaxPlayerInstances, "iMaxPlayerInstances");
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**						Modifies Cost based on Population and number of Cities					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bCountCitiesAsUnit, "bCountCitiesAsUnit");
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iInstanceCostModifier, "iInstanceCostModifier");
/*************************************************************************************************/
/**	New Tag Defs	(UnitClassInfos)		10/18/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bUnique, "bUnique");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "DefaultUnit");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	return true;
}

bool CvUnitClassInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**																								**/
/**	Earlier work with the m_asz list has reverse listed it, the last value to be read is listed	**/
/**	first.  So by checking all values for the first non-NULL case, we keep the spirit of WoC	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
/*
	m_iDefaultUnitIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iDefaultUnitIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(UnitClassInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitClassInfo::copyNonDefaults(CvUnitClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getMaxGlobalInstances()		== 0)		m_iMaxGlobalInstances					= pClassInfo->getMaxGlobalInstances();
	if (getMaxTeamInstances()		== 0)		m_iMaxTeamInstances						= pClassInfo->getMaxTeamInstances();
	if (getMaxPlayerInstances()		== 0)		m_iMaxPlayerInstances					= pClassInfo->getMaxPlayerInstances();
/*************************************************************************************************/
/**	WeightedCost							 1/30/2010								Valkrionn	**/
/**																								**/
/**						Modifies Cost based on Population and number of Cities					**/
/*************************************************************************************************/
	if (isCountCitiesAsUnit()		== 0)		m_bCountCitiesAsUnit					= pClassInfo->isCountCitiesAsUnit();
/*************************************************************************************************/
/**	WeightedCost								END												**/
/*************************************************************************************************/
	if (getInstanceCostModifier()	== 0)		m_iInstanceCostModifier					= pClassInfo->getInstanceCostModifier();
	if (isUnique()					== false)	m_bUnique								= pClassInfo->isUnique();
	for ( int i = 0; i < pClassInfo->getDefaultUnitIndexVector(); i++ )
	{
											m_aszExtraXMLforPass3.push_back(		pClassInfo->getDefaultUnitIndexVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvBuildingInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBuildingInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingInfo::CvBuildingInfo() :
m_iBuildingClassType(NO_BUILDINGCLASS),
m_iVictoryPrereq(NO_VICTORY),
m_iFreeStartEra(NO_ERA),
m_iMaxStartEra(NO_ERA),
m_iObsoleteTech(NO_TECH),
m_iPrereqAndTech(NO_TECH),
m_iNoBonus(NO_BONUS),
m_iPowerBonus(NO_BONUS),
m_iFreeBonus(NO_BONUS),
m_iNumFreeBonuses(0),
m_iMinLevelAccess(0),
m_iFreeBuildingClass(NO_BUILDINGCLASS),
m_iParentBuildingClass(NO_BUILDINGCLASS),
m_iFreePromotion(NO_PROMOTION),
m_iCivicOption(NO_CIVICOPTION),
m_iAIWeight(0),
m_iProductionCost(0),
m_iHurryCostModifier(0),
m_iHurryAngerModifier(0),
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iMinAreaSize(0),
m_iNumCitiesPrereq(0),
m_iNumTeamsPrereq(0),
m_iUnitLevelPrereq(0),
m_iMinLatitude(0),
m_iMaxLatitude(90),
m_iGreatPeopleRateModifier(0),
m_iGreatGeneralRateModifier(0),
m_iDomesticGreatGeneralRateModifier(0),
m_iGlobalGreatPeopleRateModifier(0),
m_iAnarchyModifier(0),
m_iGoldenAgeModifier(0),
m_iGlobalHurryModifier(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iFreeExperience(0),
m_iGlobalFreeExperience(0),
/**								----  End Original Code  ----									**/
m_iFreeExperience(0.0f),
m_iGlobalFreeExperience(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iFoodKept(0),
m_iAirlift(0),
m_iAirModifier(0),
m_iAirUnitCapacity(0),
m_iNukeModifier(0),
m_iNukeExplosionRand(0),
m_iFreeSpecialist(0),
m_iAreaFreeSpecialist(0),
m_iGlobalFreeSpecialist(0),
m_iHappiness(0),
m_iAreaHappiness(0),
m_iGlobalHappiness(0),
m_iStateReligionHappiness(0),
m_iWorkerSpeedModifier(0),
m_iMilitaryProductionModifier(0),
m_iSpaceProductionModifier(0),
m_iGlobalSpaceProductionModifier(0),
m_iTradeRoutes(0),
m_iCoastalTradeRoutes(0),
m_iGlobalTradeRoutes(0),
m_iTradeRouteModifier(0),
m_iForeignTradeRouteModifier(0),
m_iAssetValue(0),
m_iPowerValue(0),
m_iSpecialBuildingType(NO_SPECIALBUILDING),
m_iAdvisorType(NO_ADVISOR),
m_iHolyCity(NO_RELIGION),
m_iReligionType(NO_RELIGION),
m_iStateReligion(NO_RELIGION),
m_iPrereqReligion(NO_RELIGION),
m_iPrereqFlag(NO_FLAG),
m_iPrereqCorporation(NO_CORPORATION),
m_iPrereqCivic(NO_CIVIC),
m_iFoundsCorporation(NO_CORPORATION),
m_iGlobalReligionCommerce(0),
m_iGlobalCorporationCommerce(0),
m_iPrereqAndBonus(NO_BONUS),
m_iGreatPeopleUnitClass(NO_UNITCLASS),
m_iGreatPeopleRateChange(0),
m_iConquestProbability(0),
m_iMaintenanceModifier(0),
m_iWarWearinessModifier(0),
m_iGlobalWarWearinessModifier(0),
m_iEnemyWarWearinessModifier(0),
m_iHealRateChange(0),
m_iHealth(0),
m_iAreaHealth(0),
m_iGlobalHealth(0),
m_iGlobalPopulationChange(0),
m_iFreeTechs(0),
m_iDefenseModifier(0),
m_iBombardDefenseModifier(0),
m_iAllCityDefenseModifier(0),
m_iEspionageDefenseModifier(0),
m_iMissionType(NO_MISSION),
m_iVoteSourceType(NO_VOTESOURCE),
m_fVisibilityPriority(0.0f),
m_bTeamShare(false),
m_bWater(false),
m_bRiver(false),
m_bPower(false),
m_bDirtyPower(false),
m_bAreaCleanPower(false),
m_bAreaBorderObstacle(false),
m_bForceTeamVoteEligible(false),
m_bCapital(false),
m_bGovernmentCenter(false),
m_bGoldenAge(false),
m_bMapCentering(false),
m_bNoUnhappiness(false),
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
m_bFixedBorders(false),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
m_bNoForeignTradeRoutes(false),
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/* MultiBonus							  08/26/10									Valkrionn    */
/*                                                                                               */
/*				Causes certain building tags to use each instance of a resource                  */
/*************************************************************************************************/
m_bUseMultiBonuses(false),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
m_bNoUnhealthyPopulation(false),
m_bBuildingOnlyHealthy(false),
m_bNeverCapture(false),
m_bNukeImmune(false),
m_bPrereqReligion(false),
m_bCenterInCity(false),
m_bStateReligion(false),
m_bAllowsNukes(false),
m_piPrereqAndTechs(NULL),
m_piPrereqOrBonuses(NULL),
m_piProductionTraits(NULL),
m_piHappinessTraits(NULL),
m_piSeaPlotYieldChange(NULL),
m_piRiverPlotYieldChange(NULL),
m_piGlobalSeaPlotYieldChange(NULL),
m_piYieldChange(NULL),
m_piYieldModifier(NULL),
m_piPowerYieldModifier(NULL),
m_piAreaYieldModifier(NULL),
m_piGlobalYieldModifier(NULL),
m_piCommerceChange(NULL),
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
m_piTradeYieldModifier(NULL),
m_piTradeCommerceModifier(NULL),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
m_piObsoleteSafeCommerceChange(NULL),
m_piCommerceChangeDoubleTime(NULL),
m_piCommerceModifier(NULL),
m_piGlobalCommerceModifier(NULL),
m_piSpecialistExtraCommerce(NULL),
m_piStateReligionCommerce(NULL),
m_piCommerceHappiness(NULL),
m_piReligionChange(NULL),
m_piSpecialistCount(NULL),
m_piFreeSpecialistCount(NULL),
m_piBonusHealthChanges(NULL),
m_piBonusHappinessChanges(NULL),
m_piBonusProductionModifier(NULL),
m_piUnitCombatFreeExperience(NULL),
m_piDomainFreeExperience(NULL),
m_piDomainProductionModifier(NULL),
m_piBuildingHappinessChanges(NULL),
m_piPrereqNumOfBuildingClass(NULL),
m_piPrereqBuildingClassAtRange(NULL),
m_piBuildingExclude(NULL),
m_piFlavorValue(NULL),
m_piImprovementFreeSpecialist(NULL),
m_pbCommerceFlexible(NULL),
m_pbCommerceChangeOriginalOwner(NULL),
m_pbBuildingClassNeededInCity(NULL),
m_ppaiSpecialistYieldChange(NULL),
m_ppaiBonusYieldModifier(NULL),
m_ppaiBonusCommerceModifier(NULL),
/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
m_piPrereqAlignments(NULL),
m_piPrereqEthicalAlignments(NULL),
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(BuildingInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iEquipmentPromotion(NO_PROMOTION),
m_iPrereqBroadAlignment(0),
/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
m_iNumPrereqAlignments(0),
m_iNumPrereqEthicalAlignments(0),
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
m_iAlignmentModifier(0),
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
m_iAlignmentShift(0),
m_iAlignmentShiftModifier(0),
m_iAlignmentShiftTowardsNeutral(-1),
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iPrereqBroadEthicalAlignment(0),
m_iEthicalAlignmentModifier(0),
m_iEthicalAlignmentShift(0),
m_iEthicalAlignmentShiftModifier(0),
m_iEthicalAlignmentShiftTowardsNeutral(-1),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//Crime
m_iPrereqCrime(0),
m_iMinCrime(0),
m_bAutoBuild(false),
m_bMustMaintain(false),
m_bCrimeEffect(false),
m_iPerCrimeEffectHappyChange(0),
m_iPerCrimeEffectHealthChange(0),
m_piPerCrimeEffectYieldChange(NULL),
m_piPerCrimeEffectCommerceChange(NULL),

m_iPotency(0),
m_iShielding(0),
m_pafPotencyAffinity(NULL),
m_paiPotencyBonusPrereq(NULL),
m_pafShieldingAffinity(NULL),
m_paiShieldingBonusPrereq(NULL),
m_pafTrainXPCap(NULL),
m_pafTrainXPRate(NULL),
m_pafPerCrimeTrainXPCap(NULL),
m_pafPerCrimeTrainXPRate(NULL),
m_pafGlobalPotencyAffinity(NULL),
m_paiGlobalPotencyBonusPrereq(NULL),
m_pafGlobalShieldingAffinity(NULL),
m_paiGlobalShieldingBonusPrereq(NULL),
m_pafGlobalTrainXPCap(NULL),
m_pafGlobalTrainXPRate(NULL),

m_iNumPrereqTeamBuildingClassANDs(0),
m_iNumPrereqTeamBuildingClassNOTs(0),
m_iNumPrereqTeamBuildingClassORs(0),
m_piPrereqTeamBuildingClassANDs(NULL),
m_piPrereqTeamBuildingClassNOTs(NULL),
m_piPrereqTeamBuildingClassORs(NULL),

m_iNumPrereqGlobalBuildingClassANDs(0),
m_iNumPrereqGlobalBuildingClassNOTs(0),
m_iNumPrereqGlobalBuildingClassORs(0),
m_piPrereqGlobalBuildingClassANDs(NULL),
m_piPrereqGlobalBuildingClassNOTs(NULL),
m_piPrereqGlobalBuildingClassORs(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Buildings: Added by Kael 08/04/2007
m_bApplyFreePromotionOnMove(false),
m_bEquipment(false),
m_bHideUnits(false),
m_bNoCivicAnger(false),
m_bRequiresCaster(false),
/*************************************************************************************************/
/**	Aqueduct 	Orbis new tags 	 	Ahwaric		09/09/09	Ahwaric		**/
/*************************************************************************************************/
m_bCarriesFreshWater(false),
m_bPrereqNoFreshWater(false),
/*************************************************************************************************/
/**	Aqueduct END 									**/
/*************************************************************************************************/
m_bSeeInvisible(false),
m_bUnhappyProduction(false),
m_iCrime(0),
m_iFreePromotionPick(0),
m_iFreeBonus2(NO_BONUS),
m_iFreeBonus3(NO_BONUS),
m_iGlobalResistEnemyModify(0),
m_iGlobalResistModify(0),
m_iModifyGlobalCounter(0),
m_iPlotRadius(0),
m_iPrereqTrait(NO_TRAIT),
m_iPrereqTrait2(NO_TRAIT),
m_iRemovePromotion(NO_PROMOTION),
m_iResistMagic(0),
m_ppaiSpecialistCommerceChange(NULL)
//FfH: End Add

/*************************************************************************************************/
/**	GWSLocalSpecialist																	Milaga	**/
/** Buildings can change give bonuses to specialists in only one city							**/
/*************************************************************************************************/
,m_paaiLocalSpecialistYieldChange(NULL)
,m_paaiLocalSpecialistCommerceChange(NULL)
,m_paiLocalSpecialistHappinessChange(NULL)
,m_paiLocalSpecialistHealthChange(NULL)
, m_paiLocalSpecialistCrimeChange(NULL)
,m_paiLocalSpecialistGPPChange(NULL)
/*************************************************************************************************/
/**	GWSLocalSpecialist																		END	**/
/*************************************************************************************************/

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
,m_iCityCapModifier(0)
,m_iGlobalCityCapModifier(0)
/*************************************************************************************************/
/** END                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
,m_bNoCultureCap(false)
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/
 // PerPopEffect
	, m_iNumPerPopBonuses(0)
	, m_cbPerPopBonuses(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBuildingInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingInfo::~CvBuildingInfo()
{
	//PerPopEffect
	m_cbPerPopBonuses.clear();

	//Crime
	SAFE_DELETE_ARRAY(m_piPerCrimeEffectYieldChange);
	SAFE_DELETE_ARRAY(m_piPerCrimeEffectCommerceChange);

	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	SAFE_DELETE_ARRAY(m_piProductionTraits);
	SAFE_DELETE_ARRAY(m_piHappinessTraits);
	SAFE_DELETE_ARRAY(m_piSeaPlotYieldChange);
	SAFE_DELETE_ARRAY(m_piRiverPlotYieldChange);
	SAFE_DELETE_ARRAY(m_piGlobalSeaPlotYieldChange);
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piYieldModifier);
	SAFE_DELETE_ARRAY(m_piPowerYieldModifier);
	SAFE_DELETE_ARRAY(m_piAreaYieldModifier);
	SAFE_DELETE_ARRAY(m_piGlobalYieldModifier);
	SAFE_DELETE_ARRAY(m_piCommerceChange);
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piTradeYieldModifier);
	SAFE_DELETE_ARRAY(m_piTradeCommerceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piObsoleteSafeCommerceChange);
	SAFE_DELETE_ARRAY(m_piCommerceChangeDoubleTime);
	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	SAFE_DELETE_ARRAY(m_piGlobalCommerceModifier);
	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	SAFE_DELETE_ARRAY(m_piStateReligionCommerce);
	SAFE_DELETE_ARRAY(m_piCommerceHappiness);
	SAFE_DELETE_ARRAY(m_piReligionChange);
	SAFE_DELETE_ARRAY(m_piSpecialistCount);
	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	SAFE_DELETE_ARRAY(m_piBonusHealthChanges);
	SAFE_DELETE_ARRAY(m_piBonusHappinessChanges);
	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	SAFE_DELETE_ARRAY(m_piUnitCombatFreeExperience);
	SAFE_DELETE_ARRAY(m_piDomainFreeExperience);
	SAFE_DELETE_ARRAY(m_piDomainProductionModifier);
	SAFE_DELETE_ARRAY(m_piBuildingHappinessChanges);
	SAFE_DELETE_ARRAY(m_piPrereqNumOfBuildingClass);
	SAFE_DELETE_ARRAY(m_piPrereqBuildingClassAtRange);
	SAFE_DELETE_ARRAY(m_piBuildingExclude);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piImprovementFreeSpecialist);
	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);
	SAFE_DELETE_ARRAY(m_pbCommerceChangeOriginalOwner);
	SAFE_DELETE_ARRAY(m_pbBuildingClassNeededInCity);
/*************************************************************************************************/
/**	New Tag Defs	(BuildingInfos)			11/08/08								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pafPotencyAffinity);
	SAFE_DELETE_ARRAY(m_paiPotencyBonusPrereq);
	SAFE_DELETE_ARRAY(m_pafShieldingAffinity);
	SAFE_DELETE_ARRAY(m_paiShieldingBonusPrereq);
	SAFE_DELETE_ARRAY(m_pafTrainXPCap);
	SAFE_DELETE_ARRAY(m_pafTrainXPRate);
	SAFE_DELETE_ARRAY(m_pafPerCrimeTrainXPCap);
	SAFE_DELETE_ARRAY(m_pafPerCrimeTrainXPRate);

	SAFE_DELETE_ARRAY(m_pafGlobalPotencyAffinity);
	SAFE_DELETE_ARRAY(m_paiGlobalPotencyBonusPrereq);
	SAFE_DELETE_ARRAY(m_pafGlobalShieldingAffinity);
	SAFE_DELETE_ARRAY(m_paiGlobalShieldingBonusPrereq);
	SAFE_DELETE_ARRAY(m_pafGlobalTrainXPCap);
	SAFE_DELETE_ARRAY(m_pafGlobalTrainXPRate);
	SAFE_DELETE_ARRAY(m_piPrereqTeamBuildingClassANDs);
	SAFE_DELETE_ARRAY(m_piPrereqTeamBuildingClassNOTs);
	SAFE_DELETE_ARRAY(m_piPrereqTeamBuildingClassORs);
	SAFE_DELETE_ARRAY(m_piPrereqGlobalBuildingClassANDs);
	SAFE_DELETE_ARRAY(m_piPrereqGlobalBuildingClassNOTs);
	SAFE_DELETE_ARRAY(m_piPrereqGlobalBuildingClassORs);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	if (m_ppaiSpecialistYieldChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange);
	}

	if (m_ppaiBonusYieldModifier != NULL)
	{
		for(int i=0;i<GC.getNumBonusInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier);
	}
	if (m_ppaiBonusCommerceModifier != NULL)
	{
		for (int i = 0; i < GC.getNumBonusInfos(); i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiBonusCommerceModifier[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiBonusCommerceModifier);
	}

//FfH: Added by Kael 11/06/2007
	if (m_ppaiSpecialistCommerceChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange);
	}
//FfH: End Add

/*************************************************************************************************/
/**	GWSLocalSpecialist																	Milaga	**/
/** Buildings can change give bonuses to specialists in only one city							**/
/*************************************************************************************************/
	if (m_paaiLocalSpecialistYieldChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_paaiLocalSpecialistYieldChange[i]);
		}
		SAFE_DELETE_ARRAY(m_paaiLocalSpecialistYieldChange);
	}
	if (m_paaiLocalSpecialistCommerceChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_paaiLocalSpecialistCommerceChange[i]);
		}
		SAFE_DELETE_ARRAY(m_paaiLocalSpecialistCommerceChange);
	}
	SAFE_DELETE_ARRAY(m_paiLocalSpecialistHappinessChange);
	SAFE_DELETE_ARRAY(m_paiLocalSpecialistHealthChange);
	SAFE_DELETE_ARRAY(m_paiLocalSpecialistCrimeChange);
	SAFE_DELETE_ARRAY(m_paiLocalSpecialistGPPChange);
/*************************************************************************************************/
/**	GWSLocalSpecialist																		END	**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqAlignments);
	SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
}

int CvBuildingInfo::getBuildingClassType() const
{
	return m_iBuildingClassType;
}

int CvBuildingInfo::getVictoryPrereq() const
{
	return m_iVictoryPrereq;
}

int CvBuildingInfo::getFreeStartEra() const
{
	return m_iFreeStartEra;
}

int CvBuildingInfo::getMaxStartEra() const
{
	return m_iMaxStartEra;
}

int CvBuildingInfo::getObsoleteTech() const
{
	return m_iObsoleteTech;
}

int CvBuildingInfo::getPrereqAndTech() const
{
	return m_iPrereqAndTech;
}

int CvBuildingInfo::getNoBonus() const
{
	return m_iNoBonus;
}

int CvBuildingInfo::getPowerBonus() const
{
	return m_iPowerBonus;
}

int CvBuildingInfo::getFreeBonus() const
{
	return m_iFreeBonus;
}

int CvBuildingInfo::getNumFreeBonuses() const
{
	return m_iNumFreeBonuses;
}

int CvBuildingInfo::getMinLevelAccess() const
{
	return m_iMinLevelAccess;
}

int CvBuildingInfo::getFreeBuildingClass() const
{
	return m_iFreeBuildingClass;
}

int CvBuildingInfo::getParentBuildingClass() const
{
	return m_iParentBuildingClass;
}

void CvBuildingInfo::setNumFreeBuildingClass(int i)
{
	m_iFreeBuildingClass = i;
}

int CvBuildingInfo::getFreePromotion() const
{
	return m_iFreePromotion;
}

int CvBuildingInfo::getCivicOption() const
{
	return m_iCivicOption;
}

int CvBuildingInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvBuildingInfo::getProductionCost() const
{
	return m_iProductionCost;
}

int CvBuildingInfo::getHurryCostModifier() const
{
	return m_iHurryCostModifier;
}

int CvBuildingInfo::getHurryAngerModifier() const
{
	return m_iHurryAngerModifier;
}

int CvBuildingInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvBuildingInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvBuildingInfo::getMinAreaSize() const
{
	return m_iMinAreaSize;
}

int CvBuildingInfo::getNumCitiesPrereq() const
{
	return m_iNumCitiesPrereq;
}

int CvBuildingInfo::getNumTeamsPrereq() const
{
	return m_iNumTeamsPrereq;
}

int CvBuildingInfo::getUnitLevelPrereq() const
{
	return m_iUnitLevelPrereq;
}

int CvBuildingInfo::getMinLatitude() const
{
	return m_iMinLatitude;
}

int CvBuildingInfo::getMaxLatitude() const
{
	return m_iMaxLatitude;
}

int CvBuildingInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvBuildingInfo::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

int CvBuildingInfo::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

int CvBuildingInfo::getGlobalGreatPeopleRateModifier() const
{
	return m_iGlobalGreatPeopleRateModifier;
}

int CvBuildingInfo::getAnarchyModifier() const
{
	return m_iAnarchyModifier;
}

int CvBuildingInfo::getGoldenAgeModifier() const
{
	return m_iGoldenAgeModifier;
}

int CvBuildingInfo::getGlobalHurryModifier() const
{
	return m_iGlobalHurryModifier;
}

int CvBuildingInfo::getFreeExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iFreeExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iFreeExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvBuildingInfo::getGlobalFreeExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iGlobalFreeExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iGlobalFreeExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvBuildingInfo::getFoodKept() const
{
	return m_iFoodKept;
}

int CvBuildingInfo::getAirlift() const
{
	return m_iAirlift;
}

int CvBuildingInfo::getAirModifier() const
{
	return m_iAirModifier;
}

int CvBuildingInfo::getAirUnitCapacity() const
{
	return m_iAirUnitCapacity;
}

int CvBuildingInfo::getNukeModifier() const
{
	return m_iNukeModifier;
}

int CvBuildingInfo::getNukeExplosionRand() const
{
	return m_iNukeExplosionRand;
}

int CvBuildingInfo::getFreeSpecialist() const
{
	return m_iFreeSpecialist;
}

int CvBuildingInfo::getAreaFreeSpecialist() const
{
	return m_iAreaFreeSpecialist;
}

int CvBuildingInfo::getGlobalFreeSpecialist() const
{
	return m_iGlobalFreeSpecialist;
}

int CvBuildingInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvBuildingInfo::getAreaHappiness() const
{
	return m_iAreaHappiness;
}

int CvBuildingInfo::getGlobalHappiness() const
{
	return m_iGlobalHappiness;
}

int CvBuildingInfo::getStateReligionHappiness() const
{
	return m_iStateReligionHappiness;
}

int CvBuildingInfo::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}

int CvBuildingInfo::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}

int CvBuildingInfo::getRitualProductionModifier() const
{
	return m_iSpaceProductionModifier;
}

int CvBuildingInfo::getGlobalRitualProductionModifier() const
{
	return m_iGlobalSpaceProductionModifier;
}

int CvBuildingInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvBuildingInfo::getCoastalTradeRoutes() const
{
	return m_iCoastalTradeRoutes;
}

int CvBuildingInfo::getGlobalTradeRoutes() const
{
	return m_iGlobalTradeRoutes;
}

int CvBuildingInfo::getTradeRouteModifier() const
{
	return m_iTradeRouteModifier;
}

int CvBuildingInfo::getForeignTradeRouteModifier() const
{
	return m_iForeignTradeRouteModifier;
}

int CvBuildingInfo::getAssetValue() const
{
	return m_iAssetValue;
}

int CvBuildingInfo::getPowerValue() const
{
	return m_iPowerValue;
}

int CvBuildingInfo::getSpecialBuildingType() const
{
	return m_iSpecialBuildingType;
}

int CvBuildingInfo::getAdvisorType() const
{
	return m_iAdvisorType;
}

int CvBuildingInfo::getHolyCity() const
{
	return m_iHolyCity;
}

int CvBuildingInfo::getReligionType() const
{
	return m_iReligionType;
}

int CvBuildingInfo::getStateReligion() const
{
	return m_iStateReligion;
}

int CvBuildingInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}

int CvBuildingInfo::getPrereqFlag() const
{
	return m_iPrereqFlag;
}

int CvBuildingInfo::getPrereqCorporation() const
{
	return m_iPrereqCorporation;
}

int CvBuildingInfo::getPrereqCivic() const
{
	return m_iPrereqCivic;
}
int CvBuildingInfo::getFoundsCorporation() const
{
	return m_iFoundsCorporation;
}

int CvBuildingInfo::getGlobalReligionCommerce() const
{
	return m_iGlobalReligionCommerce;
}

int CvBuildingInfo::getGlobalCorporationCommerce() const
{
	return m_iGlobalCorporationCommerce;
}

int CvBuildingInfo::getPrereqAndBonus() const
{
	return m_iPrereqAndBonus;
}

int CvBuildingInfo::getGreatPeopleUnitClass() const
{
	return m_iGreatPeopleUnitClass;
}

int CvBuildingInfo::getGreatPeopleRateChange() const
{
	return m_iGreatPeopleRateChange;
}

int CvBuildingInfo::getConquestProbability() const
{
	return m_iConquestProbability;
}

int CvBuildingInfo::getMaintenanceModifier() const
{
	return m_iMaintenanceModifier;
}

int CvBuildingInfo::getWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

int CvBuildingInfo::getGlobalWarWearinessModifier() const
{
	return m_iGlobalWarWearinessModifier;
}

int CvBuildingInfo::getEnemyWarWearinessModifier() const
{
	return m_iEnemyWarWearinessModifier;
}

int CvBuildingInfo::getHealRateChange() const
{
	return m_iHealRateChange;
}

int CvBuildingInfo::getHealth() const
{
	return m_iHealth;
}

int CvBuildingInfo::getAreaHealth() const
{
	return m_iAreaHealth;
}

int CvBuildingInfo::getGlobalHealth() const
{
	return m_iGlobalHealth;
}

int CvBuildingInfo::getGlobalPopulationChange() const
{
	return m_iGlobalPopulationChange;
}

int CvBuildingInfo::getFreeTechs() const
{
	return m_iFreeTechs;
}

int CvBuildingInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

int CvBuildingInfo::getBombardDefenseModifier() const
{
	return m_iBombardDefenseModifier;
}

int CvBuildingInfo::getAllCityDefenseModifier() const
{
	return m_iAllCityDefenseModifier;
}

int CvBuildingInfo::getEspionageDefenseModifier() const
{
	return m_iEspionageDefenseModifier;
}

int CvBuildingInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvBuildingInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

int CvBuildingInfo::getVoteSourceType() const
{
	return m_iVoteSourceType;
}

float CvBuildingInfo::getVisibilityPriority() const
{
	return m_fVisibilityPriority;
}

bool CvBuildingInfo::isTeamShare() const
{
	return m_bTeamShare;
}

bool CvBuildingInfo::isWater() const
{
	return m_bWater;
}

bool CvBuildingInfo::isRiver() const
{
	return m_bRiver;
}

bool CvBuildingInfo::isPower() const
{
	return m_bPower;
}

bool CvBuildingInfo::isDirtyPower() const
{
	return m_bDirtyPower;
}

bool CvBuildingInfo::isAreaCleanPower() const
{
	return m_bAreaCleanPower;
}

bool CvBuildingInfo::isAreaBorderObstacle() const
{
	return m_bAreaBorderObstacle;
}

bool CvBuildingInfo::isForceTeamVoteEligible() const
{
	return m_bForceTeamVoteEligible;
}

bool CvBuildingInfo::isCapital() const
{
	return m_bCapital;
}

bool CvBuildingInfo::isGovernmentCenter() const
{
	return m_bGovernmentCenter;
}

bool CvBuildingInfo::isGoldenAge() const
{
	return m_bGoldenAge;
}

bool CvBuildingInfo::isMapCentering() const
{
	return m_bMapCentering;
}

bool CvBuildingInfo::isNoUnhappiness() const
{
	return m_bNoUnhappiness;
}

/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
bool CvBuildingInfo::isFixedBorders() const
{
	return m_bFixedBorders;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
bool CvBuildingInfo::isNoForeignTradeRoutes() const                            {return m_bNoForeignTradeRoutes;}
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/* MultiBonus							  06/08/10									Valkrionn    */
/*                                                                                               */
/*				Causes certain building tags to use each instance of a resource                  */
/*************************************************************************************************/
bool CvBuildingInfo::isUseMultiBonuses() const									{return m_bUseMultiBonuses;}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

bool CvBuildingInfo::isNoUnhealthyPopulation() const
{
	return m_bNoUnhealthyPopulation;
}

bool CvBuildingInfo::isBuildingOnlyHealthy() const
{
	return m_bBuildingOnlyHealthy;
}

bool CvBuildingInfo::isNeverCapture() const
{
	return m_bNeverCapture;
}

bool CvBuildingInfo::isNukeImmune() const
{
	return m_bNukeImmune;
}

bool CvBuildingInfo::isPrereqReligion() const
{
	return m_bPrereqReligion;
}

bool CvBuildingInfo::isCenterInCity() const
{
	return m_bCenterInCity;
}

bool CvBuildingInfo::isStateReligion() const
{
	return m_bStateReligion;
}

bool CvBuildingInfo::isAllowsNukes() const
{
	return m_bAllowsNukes;
}

const TCHAR* CvBuildingInfo::getConstructSound() const
{
	return m_szConstructSound;
}

void CvBuildingInfo::setConstructSound(const TCHAR* szVal)
{
	m_szConstructSound = szVal;
}

const TCHAR* CvBuildingInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvBuildingInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

const TCHAR* CvBuildingInfo::getMovieDefineTag() const
{
	return m_szMovieDefineTag;
}

void CvBuildingInfo::setMovieDefineTag(const TCHAR* szVal)
{
	m_szMovieDefineTag = szVal;
}

/*************************************************************************************************/
/**	New Tag Defs	(BuildingInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvBuildingInfo::getEquipmentPromotion() const					{return m_iEquipmentPromotion;}
/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
int CvBuildingInfo::getPrereqAlignment(int iI) const					{return (getNumPrereqAlignments() > iI)		? m_piPrereqAlignments[iI]						: -1;}
int CvBuildingInfo::getNumPrereqAlignments() const						{return m_iNumPrereqAlignments;}
int CvBuildingInfo::getPrereqEthicalAlignment(int iI) const			{return (getNumPrereqEthicalAlignments() > iI)		? m_piPrereqEthicalAlignments[iI]		: -1;}
int CvBuildingInfo::getNumPrereqEthicalAlignments() const				{return m_iNumPrereqEthicalAlignments;}
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
int CvBuildingInfo::getAlignmentModifier() const					{return m_iAlignmentModifier;}
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
int CvBuildingInfo::getAlignmentShift() const                       {return m_iAlignmentShift;}
int CvBuildingInfo::getAlignmentShiftModifier() const               {return m_iAlignmentShiftModifier;}
int CvBuildingInfo::getAlignmentShiftTowardsNeutral() const         {return m_iAlignmentShiftTowardsNeutral;}
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
int CvBuildingInfo::getPrereqBroadAlignment() const					{return m_iPrereqBroadAlignment;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvBuildingInfo::getEthicalAlignmentModifier() const				{return m_iEthicalAlignmentModifier;}
int CvBuildingInfo::getEthicalAlignmentShift() const                {return m_iEthicalAlignmentShift;}
int CvBuildingInfo::getEthicalAlignmentShiftModifier() const        {return m_iEthicalAlignmentShiftModifier;}
int CvBuildingInfo::getEthicalAlignmentShiftTowardsNeutral() const  {return m_iEthicalAlignmentShiftTowardsNeutral;}
int CvBuildingInfo::getPrereqBroadEthicalAlignment() const			{return m_iPrereqBroadEthicalAlignment;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//Crime

int CvBuildingInfo::getPrereqCrime() const { return m_iPrereqCrime; }
int CvBuildingInfo::getMinCrime() const { return m_iMinCrime; }
bool CvBuildingInfo::isAutoBuild() const { return m_bAutoBuild; }
bool CvBuildingInfo::isMustMaintain() const { return m_bMustMaintain; }
bool CvBuildingInfo::isCrimeEffect() const { return m_bCrimeEffect; }
int CvBuildingInfo::getPerCrimeEffectHappyChange() const { return m_iPerCrimeEffectHappyChange; }
int CvBuildingInfo::getPerCrimeEffectHealthChange() const { return m_iPerCrimeEffectHealthChange; }
int CvBuildingInfo::getPerCrimeEffectCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPerCrimeEffectCommerceChange ? m_piPerCrimeEffectCommerceChange[i] : -1;
}

int* CvBuildingInfo::getPerCrimeEffectCommerceChangeArray() const
{
	return m_piPerCrimeEffectCommerceChange;
}
int CvBuildingInfo::getPerCrimeEffectYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPerCrimeEffectYieldChange ? m_piPerCrimeEffectYieldChange[i] : -1;
}

int* CvBuildingInfo::getPerCrimeEffectYieldChangeArray() const
{
	return m_piPerCrimeEffectYieldChange;
}

int CvBuildingInfo::getPotency() const								{return m_iPotency;}
float CvBuildingInfo::getPotencyAffinity(int iI) const				{return m_pafPotencyAffinity[iI];}
int CvBuildingInfo::getPotencyBonusPrereq(int iI) const				{return m_paiPotencyBonusPrereq[iI];}
int CvBuildingInfo::getShielding() const							{return m_iShielding;}
float CvBuildingInfo::getShieldingAffinity(int iI) const			{return m_pafShieldingAffinity[iI];}
int CvBuildingInfo::getShieldingBonusPrereq(int iI) const			{return m_paiShieldingBonusPrereq[iI];}
int CvBuildingInfo::getTrainXPCap(int iI) const						{return (int)(m_pafTrainXPCap[iI]*100);}
float CvBuildingInfo::getTrainXPRate(int iI) const					{return m_pafTrainXPRate[iI];}
float CvBuildingInfo::getPerCrimeTrainXPCap(int iI) const { return (m_pafPerCrimeTrainXPCap[iI] * 100); }
float CvBuildingInfo::getPerCrimeTrainXPRate(int iI) const { return m_pafPerCrimeTrainXPRate[iI]; }
int CvBuildingInfo::getGlobalPotency() const						{return m_iGlobalPotency;}
float CvBuildingInfo::getGlobalPotencyAffinity(int iI) const		{return m_pafGlobalPotencyAffinity[iI];}
int CvBuildingInfo::getGlobalPotencyBonusPrereq(int iI) const		{return m_paiGlobalPotencyBonusPrereq[iI];}
int CvBuildingInfo::getGlobalShielding() const						{return m_iGlobalShielding;}
float CvBuildingInfo::getGlobalShieldingAffinity(int iI) const		{return m_pafGlobalShieldingAffinity[iI];}
int CvBuildingInfo::getGlobalShieldingBonusPrereq(int iI) const		{return m_paiGlobalShieldingBonusPrereq[iI];}
int CvBuildingInfo::getGlobalTrainXPCap(int iI) const				{return (int)(m_pafGlobalTrainXPCap[iI]*100);}
float CvBuildingInfo::getGlobalTrainXPRate(int iI) const			{return m_pafGlobalTrainXPRate[iI];}
int CvBuildingInfo::getPrereqTeamBuildingClassAND(int iI) const		{return m_piPrereqTeamBuildingClassANDs[iI];}
int CvBuildingInfo::getNumPrereqTeamBuildingClassANDs() const		{return m_iNumPrereqTeamBuildingClassANDs;}
int CvBuildingInfo::getPrereqTeamBuildingClassNOT(int iI) const		{return m_piPrereqTeamBuildingClassNOTs[iI];}
int CvBuildingInfo::getNumPrereqTeamBuildingClassNOTs() const		{return m_iNumPrereqTeamBuildingClassNOTs;}
int CvBuildingInfo::getPrereqTeamBuildingClassOR(int iI) const		{return m_piPrereqTeamBuildingClassORs[iI];}
int CvBuildingInfo::getNumPrereqTeamBuildingClassORs() const		{return m_iNumPrereqTeamBuildingClassORs;}
int CvBuildingInfo::getPrereqGlobalBuildingClassAND(int iI) const	{return m_piPrereqGlobalBuildingClassANDs[iI];}
int CvBuildingInfo::getNumPrereqGlobalBuildingClassANDs() const		{return m_iNumPrereqGlobalBuildingClassANDs;}
int CvBuildingInfo::getPrereqGlobalBuildingClassNOT(int iI) const	{return m_piPrereqGlobalBuildingClassNOTs[iI];}
int CvBuildingInfo::getNumPrereqGlobalBuildingClassNOTs() const		{return m_iNumPrereqGlobalBuildingClassNOTs;}
int CvBuildingInfo::getPrereqGlobalBuildingClassOR(int iI) const	{return m_piPrereqGlobalBuildingClassORs[iI];}
int CvBuildingInfo::getNumPrereqGlobalBuildingClassORs() const		{return m_iNumPrereqGlobalBuildingClassORs;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Buildings: Added by Kael 08/04/2007
bool CvBuildingInfo::isApplyFreePromotionOnMove() const
{
	return m_bApplyFreePromotionOnMove;
}

bool CvBuildingInfo::isEquipment() const
{
	return m_bEquipment;
}

bool CvBuildingInfo::isHideUnits() const
{
	return m_bHideUnits;
}

bool CvBuildingInfo::isNoCivicAnger() const
{
	return m_bNoCivicAnger;
}

bool CvBuildingInfo::isRequiresCaster() const
{
	return m_bRequiresCaster;
}

/*************************************************************************************************/
/**	Aqueduct 	Orbis new tags 	 	Ahwaric		09/09/09	Ahwaric		**/
/*************************************************************************************************/
bool CvBuildingInfo::isCarriesFreshWater() const
{
	return m_bCarriesFreshWater;
}
bool CvBuildingInfo::isPrereqNoFreshWater() const
{
	return m_bPrereqNoFreshWater;
}
/*************************************************************************************************/
/**	Aqueduct END 									**/
/*************************************************************************************************/

bool CvBuildingInfo::isSeeInvisible() const
{
	return m_bSeeInvisible;
}

bool CvBuildingInfo::isUnhappyProduction() const
{
	return m_bUnhappyProduction;
}

int CvBuildingInfo::getCrime() const
{
	return m_iCrime;
}

int CvBuildingInfo::getFreePromotionPick() const
{
	return m_iFreePromotionPick;
}

int CvBuildingInfo::getFreeBonus2() const
{
	return m_iFreeBonus2;
}

int CvBuildingInfo::getFreeBonus3() const
{
	return m_iFreeBonus3;
}

int CvBuildingInfo::getGlobalResistEnemyModify() const
{
	return m_iGlobalResistEnemyModify;
}

int CvBuildingInfo::getGlobalResistModify() const
{
	return m_iGlobalResistModify;
}

int CvBuildingInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvBuildingInfo::getPlotRadius() const
{
	return m_iPlotRadius;
}

int CvBuildingInfo::getPrereqTrait() const
{
	return m_iPrereqTrait;
}
int CvBuildingInfo::getPrereqTrait2() const
{
	return m_iPrereqTrait2;
}

int CvBuildingInfo::getRemovePromotion() const
{
	return m_iRemovePromotion;
}

int CvBuildingInfo::getResistMagic() const
{
	return m_iResistMagic;
}

int CvBuildingInfo::getSpecialistCommerceChange(int i, int j) const
{
	return m_ppaiSpecialistCommerceChange ? m_ppaiSpecialistCommerceChange[i][j] : -1;
}

int* CvBuildingInfo::getSpecialistCommerceChangeArray(int i) const
{
	return m_ppaiSpecialistCommerceChange[i];
}
//FfH: End Add

/*************************************************************************************************/
/**	GWSLocalSpecialist																	Milaga	**/
/** Buildings can change give bonuses to specialists in only one city							**/
/*************************************************************************************************/
int CvBuildingInfo::getLocalSpecialistYieldChange(int iSpecialist, int iYield) const
{
	return m_paaiLocalSpecialistYieldChange ? m_paaiLocalSpecialistYieldChange[iSpecialist][iYield] : -1;
}

int* CvBuildingInfo::getLocalSpecialistYieldChangeArray(int iSpecialist) const
{
	return m_paaiLocalSpecialistYieldChange[iSpecialist];
}

int CvBuildingInfo::getLocalSpecialistCommerceChange(int iSpecialist, int iYield) const
{
	return m_paaiLocalSpecialistCommerceChange ? m_paaiLocalSpecialistCommerceChange[iSpecialist][iYield] : -1;
}

int* CvBuildingInfo::getLocalSpecialistCommerceChangeArray(int iSpecialist) const
{
	return m_paaiLocalSpecialistCommerceChange[iSpecialist];
}

int CvBuildingInfo::getLocalSpecialistHappinessChange(int iSpecialist) const
{
	return m_paiLocalSpecialistHappinessChange ? m_paiLocalSpecialistHappinessChange[iSpecialist] : -1;
}

int CvBuildingInfo::getLocalSpecialistHealthChange(int iSpecialist) const
{
	return m_paiLocalSpecialistHealthChange ? m_paiLocalSpecialistHealthChange[iSpecialist] : -1;
}
int CvBuildingInfo::getLocalSpecialistCrimeChange(int iSpecialist) const
{
	return m_paiLocalSpecialistCrimeChange ? m_paiLocalSpecialistCrimeChange[iSpecialist] : -1;
}

int CvBuildingInfo::getLocalSpecialistGPPChange(int iSpecialist) const
{
	return m_paiLocalSpecialistGPPChange ? m_paiLocalSpecialistGPPChange[iSpecialist] : -1;
}

/*************************************************************************************************/
/**	GWSLocalSpecialist																		END	**/
/*************************************************************************************************/

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
int CvBuildingInfo::getCityCapModifier() const
{
	return m_iCityCapModifier;
}

int CvBuildingInfo::getGlobalCityCapModifier() const
{
	return m_iGlobalCityCapModifier;
}
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
bool CvBuildingInfo::isNoCultureCap() const
{
	return m_bNoCultureCap;
}
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/

// Arrays

int CvBuildingInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int* CvBuildingInfo::getYieldChangeArray() const
{
	return m_piYieldChange;
}

int CvBuildingInfo::getYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldModifier ? m_piYieldModifier[i] : -1;
}

int* CvBuildingInfo::getYieldModifierArray() const
{
	return m_piYieldModifier;
}

int CvBuildingInfo::getPowerYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPowerYieldModifier ? m_piPowerYieldModifier[i] : -1;
}

int* CvBuildingInfo::getPowerYieldModifierArray() const
{
	return m_piPowerYieldModifier;
}

int CvBuildingInfo::getAreaYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAreaYieldModifier ? m_piAreaYieldModifier[i] : -1;
}

int* CvBuildingInfo::getAreaYieldModifierArray() const
{
	return m_piAreaYieldModifier;
}

int CvBuildingInfo::getGlobalYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGlobalYieldModifier ? m_piGlobalYieldModifier[i] : -1;
}

int* CvBuildingInfo::getGlobalYieldModifierArray() const
{
	return m_piGlobalYieldModifier;
}

int CvBuildingInfo::getSeaPlotYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSeaPlotYieldChange ? m_piSeaPlotYieldChange[i] : -1;
}

int* CvBuildingInfo::getSeaPlotYieldChangeArray() const
{
	return m_piSeaPlotYieldChange;
}

int CvBuildingInfo::getRiverPlotYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverPlotYieldChange ? m_piRiverPlotYieldChange[i] : -1;
}

int* CvBuildingInfo::getRiverPlotYieldChangeArray() const
{
	return m_piRiverPlotYieldChange;
}

int CvBuildingInfo::getGlobalSeaPlotYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGlobalSeaPlotYieldChange ? m_piGlobalSeaPlotYieldChange[i] : -1;
}

int* CvBuildingInfo::getGlobalSeaPlotYieldChangeArray() const
{
	return m_piGlobalSeaPlotYieldChange;
}

int CvBuildingInfo::getCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceChange ? m_piCommerceChange[i] : -1;
}

int* CvBuildingInfo::getCommerceChangeArray() const
{
	return m_piCommerceChange;
}

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
int CvBuildingInfo::getTradeYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTradeYieldModifier ? m_piTradeYieldModifier[i] : -1;
}

int* CvBuildingInfo::getTradeYieldModifierArray() const
{
	return m_piTradeYieldModifier;
}

int CvBuildingInfo::getTradeCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTradeCommerceModifier ? m_piTradeCommerceModifier[i] : -1;
}

int* CvBuildingInfo::getTradeCommerceModifierArray() const
{
	return m_piTradeCommerceModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

int CvBuildingInfo::getObsoleteSafeCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piObsoleteSafeCommerceChange ? m_piObsoleteSafeCommerceChange[i] : -1;
}

int* CvBuildingInfo::getObsoleteSafeCommerceChangeArray() const
{
	return m_piObsoleteSafeCommerceChange;
}

int CvBuildingInfo::getCommerceChangeDoubleTime(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceChangeDoubleTime ? m_piCommerceChangeDoubleTime[i] : -1;
}

int CvBuildingInfo::getCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceModifier ? m_piCommerceModifier[i] : -1;
}

int* CvBuildingInfo::getCommerceModifierArray() const
{
	return m_piCommerceModifier;
}

int CvBuildingInfo::getGlobalCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGlobalCommerceModifier ? m_piGlobalCommerceModifier[i] : -1;
}

int* CvBuildingInfo::getGlobalCommerceModifierArray() const
{
	return m_piGlobalCommerceModifier;
}

int CvBuildingInfo::getSpecialistExtraCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSpecialistExtraCommerce ? m_piSpecialistExtraCommerce[i] : -1;
}

int* CvBuildingInfo::getSpecialistExtraCommerceArray() const
{
	return m_piSpecialistExtraCommerce;
}

int CvBuildingInfo::getStateReligionCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piStateReligionCommerce ? m_piStateReligionCommerce[i] : -1;
}

int* CvBuildingInfo::getStateReligionCommerceArray() const
{
	return m_piStateReligionCommerce;
}

int CvBuildingInfo::getCommerceHappiness(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceHappiness ? m_piCommerceHappiness[i] : -1;
}

int CvBuildingInfo::getReligionChange(int i) const
{
	FAssertMsg(i < GC.getNumReligionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piReligionChange ? m_piReligionChange[i] : -1;
}

int CvBuildingInfo::getSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSpecialistCount ? m_piSpecialistCount[i] : -1;
}

int CvBuildingInfo::getFreeSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFreeSpecialistCount ? m_piFreeSpecialistCount[i] : -1;
}

int CvBuildingInfo::getBonusHealthChanges(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusHealthChanges ? m_piBonusHealthChanges[i] : -1;
}

int CvBuildingInfo::getBonusHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusHappinessChanges ? m_piBonusHappinessChanges[i] : -1;
}

int CvBuildingInfo::getBonusProductionModifier(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusProductionModifier ? m_piBonusProductionModifier[i] : -1;
}

int CvBuildingInfo::getUnitCombatFreeExperience(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_piUnitCombatFreeExperience ? m_piUnitCombatFreeExperience[i] : -1;
/**								----  End Original Code  ----									**/
	return m_piUnitCombatFreeExperience ? (int)(m_piUnitCombatFreeExperience[i]*100) : -1;
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvBuildingInfo::getDomainFreeExperience(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_piDomainFreeExperience ? m_piDomainFreeExperience[i] : -1;
/**								----  End Original Code  ----									**/
	return m_piDomainFreeExperience ? (int)(m_piDomainFreeExperience[i]*100) : -1;
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvBuildingInfo::getDomainProductionModifier(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDomainProductionModifier ? m_piDomainProductionModifier[i] : -1;
}

int CvBuildingInfo::getPrereqAndTechs(int i) const
{
	FAssertMsg(i < GC.getNUM_BUILDING_AND_TECH_PREREQS(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;
}

int CvBuildingInfo::getPrereqOrBonuses(int i) const
{
	FAssertMsg(i < GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqOrBonuses ? m_piPrereqOrBonuses[i] : -1;
}

int CvBuildingInfo::getProductionTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
}

int CvBuildingInfo::getHappinessTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHappinessTraits ? m_piHappinessTraits[i] : -1;
}

int CvBuildingInfo::getBuildingHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBuildingHappinessChanges ? m_piBuildingHappinessChanges[i] : -1;
}

int CvBuildingInfo::getPrereqNumOfBuildingClass(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqNumOfBuildingClass ? m_piPrereqNumOfBuildingClass[i] : -1;
}
int CvBuildingInfo::getPrereqBuildingClassAtRange(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqBuildingClassAtRange ? m_piPrereqBuildingClassAtRange[i] : 0;
}

int CvBuildingInfo::getBuildingExclude(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBuildingExclude ? m_piBuildingExclude[i] : 0;
}

int CvBuildingInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvBuildingInfo::getImprovementFreeSpecialist(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piImprovementFreeSpecialist ? m_piImprovementFreeSpecialist[i] : -1;
}

bool CvBuildingInfo::isCommerceFlexible(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCommerceFlexible ? m_pbCommerceFlexible[i] : false;
}

bool CvBuildingInfo::isCommerceChangeOriginalOwner(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCommerceChangeOriginalOwner ? m_pbCommerceChangeOriginalOwner[i] : false;
}

bool CvBuildingInfo::isBuildingClassNeededInCity(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbBuildingClassNeededInCity ? m_pbBuildingClassNeededInCity[i] : false;
}

int CvBuildingInfo::getSpecialistYieldChange(int i, int j) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppaiSpecialistYieldChange ? m_ppaiSpecialistYieldChange[i][j] : -1;
}

int* CvBuildingInfo::getSpecialistYieldChangeArray(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppaiSpecialistYieldChange[i];
}

int CvBuildingInfo::getBonusYieldModifier(int i, int j) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppaiBonusYieldModifier ? m_ppaiBonusYieldModifier[i][j] : -1;
}

int* CvBuildingInfo::getBonusYieldModifierArray(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppaiBonusYieldModifier[i];
}

int CvBuildingInfo::getBonusCommerceModifier(int i, int j) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppaiBonusCommerceModifier ? m_ppaiBonusCommerceModifier[i][j] : -1;
}

int* CvBuildingInfo::getBonusCommerceModifierArray(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppaiBonusCommerceModifier[i];
}
//PerPopEffect
int CvBuildingInfo::getNumPerPopBonuses() const { return m_iNumPerPopBonuses; }
CityBonuses CvBuildingInfo::getPerPopBonus(int iI) const
{
	int iCount = 0;
	CityBonuses cbTemp;
	for (std::list<CityBonuses>::const_iterator iter = m_cbPerPopBonuses.begin(); iter != m_cbPerPopBonuses.end(); ++iter)
	{
		if (iCount == iI)
		{
			cbTemp = *iter;
			break;
		}
		iCount++;
	}
	return cbTemp;
}
std::list<CityBonuses> CvBuildingInfo::listPerPopBonuses() { return m_cbPerPopBonuses; }

const TCHAR* CvBuildingInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	Could do this during the CopyNonDefaults comparison, but may prove handy elsewhere later	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoBuilding * pBuildingArtInfo;
	pBuildingArtInfo = getArtInfo();
	if (pBuildingArtInfo != NULL)
	{
		return pBuildingArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

const CvArtInfoBuilding* CvBuildingInfo::getArtInfo() const
{
	return ARTFILEMGR.getBuildingArtInfo(getArtDefineTag());
}

const CvArtInfoMovie* CvBuildingInfo::getMovieInfo() const
{
	const TCHAR* pcTag = getMovieDefineTag();
	if (NULL != pcTag && 0 != _tcscmp(pcTag, "NONE"))
	{
		return ARTFILEMGR.getMovieArtInfo(pcTag);
	}
	else
	{
		return NULL;
	}
}

const TCHAR* CvBuildingInfo::getMovie() const
{
	const CvArtInfoMovie* pArt;
	pArt = getMovieInfo();
	if (pArt != NULL)
	{
		return pArt->getPath();
	}
	else
	{
		return NULL;
	}
}

const char* CvBuildingInfo::getPythonHelp() const { return m_szPyHelp; }


//
// serialization
//
void CvBuildingInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iBuildingClassType);
	stream->Read(&m_iVictoryPrereq);
	stream->Read(&m_iFreeStartEra);
	stream->Read(&m_iMaxStartEra);
	stream->Read(&m_iObsoleteTech);
	stream->Read(&m_iPrereqAndTech);
	stream->Read(&m_iNoBonus);
	stream->Read(&m_iPowerBonus);
	stream->Read(&m_iFreeBonus);
	stream->Read(&m_iNumFreeBonuses);
	stream->Read(&m_iMinLevelAccess);
	stream->Read(&m_iFreeBuildingClass);
	stream->Read(&m_iParentBuildingClass);
	stream->Read(&m_iFreePromotion);
	stream->Read(&m_iCivicOption);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iProductionCost);
	stream->Read(&m_iHurryCostModifier);
	stream->Read(&m_iHurryAngerModifier);
	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);
	stream->Read(&m_iMinAreaSize);
	stream->Read(&m_iNumCitiesPrereq);
	stream->Read(&m_iNumTeamsPrereq);
	stream->Read(&m_iUnitLevelPrereq);
	stream->Read(&m_iMinLatitude);
	stream->Read(&m_iMaxLatitude);
	stream->Read(&m_iGreatPeopleRateModifier);
	stream->Read(&m_iGreatGeneralRateModifier);
	stream->Read(&m_iDomesticGreatGeneralRateModifier);
	stream->Read(&m_iGlobalGreatPeopleRateModifier);
	stream->Read(&m_iAnarchyModifier);
	stream->Read(&m_iGoldenAgeModifier);
	stream->Read(&m_iGlobalHurryModifier);
	stream->Read(&m_iFreeExperience);
	stream->Read(&m_iGlobalFreeExperience);
	stream->Read(&m_iFoodKept);
	stream->Read(&m_iAirlift);
	stream->Read(&m_iAirModifier);
	stream->Read(&m_iAirUnitCapacity);
	stream->Read(&m_iNukeModifier);
	stream->Read(&m_iNukeExplosionRand);
	stream->Read(&m_iFreeSpecialist);
	stream->Read(&m_iAreaFreeSpecialist);
	stream->Read(&m_iGlobalFreeSpecialist);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iAreaHappiness);
	stream->Read(&m_iGlobalHappiness);
	stream->Read(&m_iStateReligionHappiness);
	stream->Read(&m_iWorkerSpeedModifier);
	stream->Read(&m_iMilitaryProductionModifier);
	stream->Read(&m_iSpaceProductionModifier);
	stream->Read(&m_iGlobalSpaceProductionModifier);
	stream->Read(&m_iTradeRoutes);
	stream->Read(&m_iCoastalTradeRoutes);
	stream->Read(&m_iGlobalTradeRoutes);
	stream->Read(&m_iTradeRouteModifier);
	stream->Read(&m_iForeignTradeRouteModifier);
	stream->Read(&m_iAssetValue);
	stream->Read(&m_iPowerValue);
	stream->Read(&m_iSpecialBuildingType);
	stream->Read(&m_iAdvisorType);
	stream->Read(&m_iHolyCity);
	stream->Read(&m_iReligionType);
	stream->Read(&m_iStateReligion);
	stream->Read(&m_iPrereqReligion);
	stream->Read(&m_iPrereqFlag);
	stream->Read(&m_iPrereqCorporation);
	stream->Read(&m_iPrereqCivic);
	stream->Read(&m_iFoundsCorporation);
	stream->Read(&m_iGlobalReligionCommerce);
	stream->Read(&m_iGlobalCorporationCommerce);
	stream->Read(&m_iPrereqAndBonus);
	stream->Read(&m_iGreatPeopleUnitClass);
	stream->Read(&m_iGreatPeopleRateChange);
	stream->Read(&m_iConquestProbability);
	stream->Read(&m_iMaintenanceModifier);
	stream->Read(&m_iWarWearinessModifier);
	stream->Read(&m_iGlobalWarWearinessModifier);
	stream->Read(&m_iEnemyWarWearinessModifier);
	stream->Read(&m_iHealRateChange);
	stream->Read(&m_iHealth);
	stream->Read(&m_iAreaHealth);
	stream->Read(&m_iGlobalHealth);
	stream->Read(&m_iGlobalPopulationChange);
	stream->Read(&m_iFreeTechs);
	stream->Read(&m_iDefenseModifier);
	stream->Read(&m_iBombardDefenseModifier);
	stream->Read(&m_iAllCityDefenseModifier);
	stream->Read(&m_iEspionageDefenseModifier);
	stream->Read(&m_iMissionType);
	stream->Read(&m_iVoteSourceType);

	stream->Read(&m_fVisibilityPriority);

	stream->Read(&m_bTeamShare);
	stream->Read(&m_bWater);
	stream->Read(&m_bRiver);
	stream->Read(&m_bPower);
	stream->Read(&m_bDirtyPower);
	stream->Read(&m_bAreaCleanPower);
	stream->Read(&m_bAreaBorderObstacle);
	stream->Read(&m_bForceTeamVoteEligible);
	stream->Read(&m_bCapital);
	stream->Read(&m_bGovernmentCenter);
	stream->Read(&m_bGoldenAge);
	stream->Read(&m_bMapCentering);
	stream->Read(&m_bNoUnhappiness);
	stream->ReadString(m_szPyHelp);

/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Read(&m_bFixedBorders);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Read(&m_bNoForeignTradeRoutes);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/* MultiBonus							  06/08/10									Valkrionn    */
/*                                                                                               */
/*				Causes certain building tags to use each instance of a resource                  */
/*************************************************************************************************/
	stream->Read(&m_bUseMultiBonuses);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Read(&m_bNoUnhealthyPopulation);
	stream->Read(&m_bBuildingOnlyHealthy);
	stream->Read(&m_bNeverCapture);
	stream->Read(&m_bNukeImmune);
	stream->Read(&m_bPrereqReligion);
	stream->Read(&m_bCenterInCity);
	stream->Read(&m_bStateReligion);
	stream->Read(&m_bAllowsNukes);

	stream->ReadString(m_szConstructSound);
	stream->ReadString(m_szArtDefineTag);
	stream->ReadString(m_szMovieDefineTag);

/*************************************************************************************************/
/**	New Tag Defs	(BuildingInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iEquipmentPromotion);
	stream->Read(&m_iPrereqBroadAlignment);
/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
	stream->Read(&m_iNumPrereqAlignments);
	if (m_iNumPrereqAlignments > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqAlignments);
		m_piPrereqAlignments = new int[m_iNumPrereqAlignments];
		stream->Read(m_iNumPrereqAlignments, m_piPrereqAlignments);
	}
	stream->Read(&m_iNumPrereqEthicalAlignments);
	if (m_iNumPrereqEthicalAlignments > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
		m_piPrereqEthicalAlignments = new int[m_iNumPrereqEthicalAlignments];
		stream->Read(m_iNumPrereqEthicalAlignments, m_piPrereqEthicalAlignments);
	}
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iAlignmentModifier);
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	stream->Read(&m_iAlignmentShift);
	stream->Read(&m_iAlignmentShiftModifier);
	stream->Read(&m_iAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBroadEthicalAlignment);
	stream->Read(&m_iEthicalAlignmentModifier);
	stream->Read(&m_iEthicalAlignmentShift);
	stream->Read(&m_iEthicalAlignmentShiftModifier);
	stream->Read(&m_iEthicalAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	//Crime
	stream->Read(&m_iPrereqCrime);
	stream->Read(&m_iMinCrime);
	stream->Read(&m_bAutoBuild);
	stream->Read(&m_bMustMaintain);
	stream->Read(&m_bCrimeEffect);
	stream->Read(&m_iPerCrimeEffectHappyChange);
	stream->Read(&m_iPerCrimeEffectHealthChange);
	SAFE_DELETE_ARRAY(m_piPerCrimeEffectYieldChange);
	m_piPerCrimeEffectYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piPerCrimeEffectYieldChange);
	SAFE_DELETE_ARRAY(m_piPerCrimeEffectCommerceChange);
	m_piPerCrimeEffectCommerceChange = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piPerCrimeEffectCommerceChange);

	stream->Read(&m_iPotency);
	SAFE_DELETE_ARRAY(m_pafPotencyAffinity);
	m_pafPotencyAffinity = new float[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_pafPotencyAffinity);
	SAFE_DELETE_ARRAY(m_paiPotencyBonusPrereq);
	m_paiPotencyBonusPrereq = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_paiPotencyBonusPrereq);
	stream->Read(&m_iShielding);
	SAFE_DELETE_ARRAY(m_pafShieldingAffinity);
	m_pafShieldingAffinity = new float[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_pafShieldingAffinity);
	SAFE_DELETE_ARRAY(m_paiShieldingBonusPrereq);
	m_paiShieldingBonusPrereq = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_paiShieldingBonusPrereq);
	SAFE_DELETE_ARRAY(m_pafTrainXPCap);
	m_pafTrainXPCap = new float[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pafTrainXPCap);
	SAFE_DELETE_ARRAY(m_pafTrainXPRate);
	m_pafTrainXPRate = new float[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pafTrainXPRate);
	SAFE_DELETE_ARRAY(m_pafPerCrimeTrainXPCap);
	m_pafPerCrimeTrainXPCap = new float[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pafPerCrimeTrainXPCap);
	SAFE_DELETE_ARRAY(m_pafPerCrimeTrainXPRate);
	m_pafPerCrimeTrainXPRate = new float[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pafPerCrimeTrainXPRate);

	stream->Read(&m_iGlobalPotency);
	SAFE_DELETE_ARRAY(m_pafGlobalPotencyAffinity);
	m_pafGlobalPotencyAffinity = new float[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_pafGlobalPotencyAffinity);
	SAFE_DELETE_ARRAY(m_paiGlobalPotencyBonusPrereq);
	m_paiGlobalPotencyBonusPrereq = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_paiGlobalPotencyBonusPrereq);
	stream->Read(&m_iGlobalShielding);
	SAFE_DELETE_ARRAY(m_pafGlobalShieldingAffinity);
	m_pafGlobalShieldingAffinity = new float[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_pafGlobalShieldingAffinity);
	SAFE_DELETE_ARRAY(m_paiGlobalShieldingBonusPrereq);
	m_paiGlobalShieldingBonusPrereq = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_paiGlobalShieldingBonusPrereq);
	SAFE_DELETE_ARRAY(m_pafGlobalTrainXPCap);
	m_pafGlobalTrainXPCap = new float[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pafGlobalTrainXPCap);
	SAFE_DELETE_ARRAY(m_pafGlobalTrainXPRate);
	m_pafGlobalTrainXPRate = new float[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pafGlobalTrainXPRate);

	stream->Read(&m_iNumPrereqTeamBuildingClassANDs);
	SAFE_DELETE_ARRAY(m_piPrereqTeamBuildingClassANDs);
	m_piPrereqTeamBuildingClassANDs = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqTeamBuildingClassANDs);
	stream->Read(&m_iNumPrereqTeamBuildingClassNOTs);
	SAFE_DELETE_ARRAY(m_piPrereqTeamBuildingClassNOTs);
	m_piPrereqTeamBuildingClassNOTs = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqTeamBuildingClassNOTs);
	stream->Read(&m_iNumPrereqTeamBuildingClassORs);
	SAFE_DELETE_ARRAY(m_piPrereqTeamBuildingClassORs);
	m_piPrereqTeamBuildingClassORs = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqTeamBuildingClassORs);

	stream->Read(&m_iNumPrereqGlobalBuildingClassANDs);
	SAFE_DELETE_ARRAY(m_piPrereqGlobalBuildingClassANDs);
	m_piPrereqGlobalBuildingClassANDs = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqGlobalBuildingClassANDs);
	stream->Read(&m_iNumPrereqGlobalBuildingClassNOTs);
	SAFE_DELETE_ARRAY(m_piPrereqGlobalBuildingClassNOTs);
	m_piPrereqGlobalBuildingClassNOTs = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqGlobalBuildingClassNOTs);
	stream->Read(&m_iNumPrereqGlobalBuildingClassORs);
	SAFE_DELETE_ARRAY(m_piPrereqGlobalBuildingClassORs);
	m_piPrereqGlobalBuildingClassORs = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqGlobalBuildingClassORs);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Buildings: Added by Kael 08/04/2007
	stream->Read(&m_bApplyFreePromotionOnMove);
	stream->Read(&m_bEquipment);
	stream->Read(&m_bHideUnits);
	stream->Read(&m_bNoCivicAnger);
	stream->Read(&m_bRequiresCaster);
/*************************************************************************************************/
/**	Aqueduct 	Orbis new tags 	 	Ahwaric		09/09/09	Ahwaric		**/
/*************************************************************************************************/
	stream->Read(&m_bCarriesFreshWater);
	stream->Read(&m_bPrereqNoFreshWater);
	/*************************************************************************************************/
/**	Aqueduct END 									**/
/*************************************************************************************************/
	stream->Read(&m_bSeeInvisible);
	stream->Read(&m_bUnhappyProduction);
	stream->Read(&m_iCrime);
	stream->Read(&m_iFreePromotionPick);
	stream->Read(&m_iFreeBonus2);
	stream->Read(&m_iFreeBonus3);
	stream->Read(&m_iGlobalResistEnemyModify);
	stream->Read(&m_iGlobalResistModify);
	stream->Read(&m_iModifyGlobalCounter);
	stream->Read(&m_iPlotRadius);
	stream->Read(&m_iPrereqTrait);
	stream->Read(&m_iPrereqTrait2);
	stream->Read(&m_iRemovePromotion);
	stream->Read(&m_iResistMagic);
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	stream->Read(&m_iCityCapModifier);
	stream->Read(&m_iGlobalCityCapModifier);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
	stream->Read(&m_bNoCultureCap);
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	m_piPrereqAndTechs = new int[GC.getNUM_BUILDING_AND_TECH_PREREQS()];
	stream->Read(GC.getNUM_BUILDING_AND_TECH_PREREQS(), m_piPrereqAndTechs);

	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	m_piPrereqOrBonuses = new int[GC.getNUM_BUILDING_PREREQ_OR_BONUSES()];
	stream->Read(GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);

	SAFE_DELETE_ARRAY(m_piProductionTraits);
	m_piProductionTraits = new int[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_piProductionTraits);

	SAFE_DELETE_ARRAY(m_piHappinessTraits);
	m_piHappinessTraits = new int[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_piHappinessTraits);

	SAFE_DELETE_ARRAY(m_piSeaPlotYieldChange);
	m_piSeaPlotYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piSeaPlotYieldChange);

	SAFE_DELETE_ARRAY(m_piRiverPlotYieldChange);
	m_piRiverPlotYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piRiverPlotYieldChange);

	SAFE_DELETE_ARRAY(m_piGlobalSeaPlotYieldChange);
	m_piGlobalSeaPlotYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piGlobalSeaPlotYieldChange);

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);

	SAFE_DELETE_ARRAY(m_piYieldModifier);
	m_piYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldModifier);

	SAFE_DELETE_ARRAY(m_piPowerYieldModifier);
	m_piPowerYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piPowerYieldModifier);

	SAFE_DELETE_ARRAY(m_piAreaYieldModifier);
	m_piAreaYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piAreaYieldModifier);

	SAFE_DELETE_ARRAY(m_piGlobalYieldModifier);
	m_piGlobalYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piGlobalYieldModifier);

	SAFE_DELETE_ARRAY(m_piCommerceChange);
	m_piCommerceChange = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceChange);

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piTradeYieldModifier);
	m_piTradeYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piTradeYieldModifier);

	SAFE_DELETE_ARRAY(m_piTradeCommerceModifier);
	m_piTradeCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piTradeCommerceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piObsoleteSafeCommerceChange);
	m_piObsoleteSafeCommerceChange = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piObsoleteSafeCommerceChange);

	SAFE_DELETE_ARRAY(m_piCommerceChangeDoubleTime);
	m_piCommerceChangeDoubleTime = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceChangeDoubleTime);

	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	m_piCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceModifier);

	SAFE_DELETE_ARRAY(m_piGlobalCommerceModifier);
	m_piGlobalCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piGlobalCommerceModifier);

	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	m_piSpecialistExtraCommerce = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);

	SAFE_DELETE_ARRAY(m_piStateReligionCommerce);
	m_piStateReligionCommerce = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piStateReligionCommerce);

	SAFE_DELETE_ARRAY(m_piCommerceHappiness);
	m_piCommerceHappiness = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceHappiness);

	SAFE_DELETE_ARRAY(m_piReligionChange);
	m_piReligionChange = new int[GC.getNumReligionInfos()];
	stream->Read(GC.getNumReligionInfos(), m_piReligionChange);

	SAFE_DELETE_ARRAY(m_piSpecialistCount);
	m_piSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piSpecialistCount);

	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	m_piFreeSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);

	SAFE_DELETE_ARRAY(m_piBonusHealthChanges);
	m_piBonusHealthChanges = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusHealthChanges);

	SAFE_DELETE_ARRAY(m_piBonusHappinessChanges);
	m_piBonusHappinessChanges = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusHappinessChanges);

	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	m_piBonusProductionModifier = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusProductionModifier);

	SAFE_DELETE_ARRAY(m_piUnitCombatFreeExperience);
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_piUnitCombatFreeExperience = new int[GC.getNumUnitCombatInfos()];
/**								----  End Original Code  ----									**/
	m_piUnitCombatFreeExperience = new float[GC.getNumUnitCombatInfos()];
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatFreeExperience);

	SAFE_DELETE_ARRAY(m_piDomainFreeExperience);
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_piDomainFreeExperience = new int[NUM_DOMAIN_TYPES];
/**								----  End Original Code  ----									**/
	m_piDomainFreeExperience = new float[NUM_DOMAIN_TYPES];
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainFreeExperience);

	SAFE_DELETE_ARRAY(m_piDomainProductionModifier);
	m_piDomainProductionModifier = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainProductionModifier);

	SAFE_DELETE_ARRAY(m_piBuildingHappinessChanges);
	m_piBuildingHappinessChanges = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piBuildingHappinessChanges);

	SAFE_DELETE_ARRAY(m_piPrereqNumOfBuildingClass);
	m_piPrereqNumOfBuildingClass = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqNumOfBuildingClass);
	
	SAFE_DELETE_ARRAY(m_piPrereqBuildingClassAtRange);
	m_piPrereqBuildingClassAtRange = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqBuildingClassAtRange);

	SAFE_DELETE_ARRAY(m_piBuildingExclude);
	m_piBuildingExclude = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piBuildingExclude);

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piImprovementFreeSpecialist);
	m_piImprovementFreeSpecialist = new int[GC.getNumImprovementInfos()];
	stream->Read(GC.getNumImprovementInfos(), m_piImprovementFreeSpecialist);

	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);
	m_pbCommerceFlexible = new bool[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);

	SAFE_DELETE_ARRAY(m_pbCommerceChangeOriginalOwner);
	m_pbCommerceChangeOriginalOwner = new bool[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_pbCommerceChangeOriginalOwner);

	SAFE_DELETE_ARRAY(m_pbBuildingClassNeededInCity);
	m_pbBuildingClassNeededInCity = new bool[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_pbBuildingClassNeededInCity);

	int i;
	if (m_ppaiSpecialistYieldChange != NULL)
	{
		for(i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange);
	}

	m_ppaiSpecialistYieldChange = new int*[GC.getNumSpecialistInfos()];
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		m_ppaiSpecialistYieldChange[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppaiSpecialistYieldChange[i]);
	}

//FfH: Added by Kael 11/06/2007
	if (m_ppaiSpecialistCommerceChange != NULL)
	{
		for(i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange);
	}
	m_ppaiSpecialistCommerceChange = new int*[GC.getNumSpecialistInfos()];
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		m_ppaiSpecialistCommerceChange[i]  = new int[NUM_COMMERCE_TYPES];
		stream->Read(NUM_COMMERCE_TYPES, m_ppaiSpecialistCommerceChange[i]);
	}
//FfH: End Add

/*************************************************************************************************/
/**	GWSLocalSpecialist																	Milaga	**/
/** Buildings can change give bonuses to specialists in only one city							**/
/*************************************************************************************************/
	if (m_paaiLocalSpecialistCommerceChange != NULL)
	{
		for(i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_paaiLocalSpecialistCommerceChange[i]);
		}
		SAFE_DELETE_ARRAY(m_paaiLocalSpecialistCommerceChange);
	}
	m_paaiLocalSpecialistCommerceChange = new int*[GC.getNumSpecialistInfos()];
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		m_paaiLocalSpecialistCommerceChange[i]  = new int[NUM_COMMERCE_TYPES];
		stream->Read(NUM_COMMERCE_TYPES, m_paaiLocalSpecialistCommerceChange[i]);
	}

	if (m_paaiLocalSpecialistYieldChange != NULL)
	{
		for(i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_paaiLocalSpecialistYieldChange[i]);
		}
		SAFE_DELETE_ARRAY(m_paaiLocalSpecialistYieldChange);
	}
	m_paaiLocalSpecialistYieldChange = new int*[GC.getNumSpecialistInfos()];
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		m_paaiLocalSpecialistYieldChange[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_paaiLocalSpecialistYieldChange[i]);
	}

	SAFE_DELETE_ARRAY(m_paiLocalSpecialistHappinessChange);
	m_paiLocalSpecialistHappinessChange = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_paiLocalSpecialistHappinessChange);

	SAFE_DELETE_ARRAY(m_paiLocalSpecialistHealthChange);
	m_paiLocalSpecialistHealthChange = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_paiLocalSpecialistHealthChange);

	SAFE_DELETE_ARRAY(m_paiLocalSpecialistCrimeChange);
	m_paiLocalSpecialistCrimeChange = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_paiLocalSpecialistCrimeChange);

	SAFE_DELETE_ARRAY(m_paiLocalSpecialistGPPChange);
	m_paiLocalSpecialistGPPChange = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_paiLocalSpecialistGPPChange);
/*************************************************************************************************/
/**	GWSLocalSpecialist																		END	**/
/*************************************************************************************************/

	if (m_ppaiBonusYieldModifier != NULL)
	{
		for(i=0;i<GC.getNumBonusInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier);
	}

	m_ppaiBonusYieldModifier = new int*[GC.getNumBonusInfos()];
	for(i=0;i<GC.getNumBonusInfos();i++)
	{
		m_ppaiBonusYieldModifier[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppaiBonusYieldModifier[i]);
	}
	
	if (m_ppaiBonusCommerceModifier != NULL)
	{
		for (i = 0; i < GC.getNumBonusInfos(); i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiBonusCommerceModifier[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiBonusCommerceModifier);
	}

	m_ppaiBonusCommerceModifier = new int* [GC.getNumBonusInfos()];
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		m_ppaiBonusCommerceModifier[i] = new int[NUM_COMMERCE_TYPES];
		stream->Read(NUM_COMMERCE_TYPES, m_ppaiBonusCommerceModifier[i]);
	}
	//PerPopEffect
	stream->Read(&m_iNumPerPopBonuses);
	m_cbPerPopBonuses.clear();
	if (m_iNumPerPopBonuses != 0)
	{
		CityBonuses cbTemp;
		for (int iI = 0; iI < m_iNumPerPopBonuses; iI++)
		{
			cbTemp.read(stream);
			m_cbPerPopBonuses.push_back(cbTemp);
		}
	}
}

//
// serialization
//
void CvBuildingInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iBuildingClassType);
	stream->Write(m_iVictoryPrereq);
	stream->Write(m_iFreeStartEra);
	stream->Write(m_iMaxStartEra);
	stream->Write(m_iObsoleteTech);
	stream->Write(m_iPrereqAndTech);
	stream->Write(m_iNoBonus);
	stream->Write(m_iPowerBonus);
	stream->Write(m_iFreeBonus);
	stream->Write(m_iNumFreeBonuses);
	stream->Write(m_iMinLevelAccess);
	stream->Write(m_iFreeBuildingClass);
	stream->Write(m_iParentBuildingClass);
	stream->Write(m_iFreePromotion);
	stream->Write(m_iCivicOption);
	stream->Write(m_iAIWeight);
	stream->Write(m_iProductionCost);
	stream->Write(m_iHurryCostModifier);
	stream->Write(m_iHurryAngerModifier);
	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);
	stream->Write(m_iMinAreaSize);
	stream->Write(m_iNumCitiesPrereq);
	stream->Write(m_iNumTeamsPrereq);
	stream->Write(m_iUnitLevelPrereq);
	stream->Write(m_iMinLatitude);
	stream->Write(m_iMaxLatitude);
	stream->Write(m_iGreatPeopleRateModifier);
	stream->Write(m_iGreatGeneralRateModifier);
	stream->Write(m_iDomesticGreatGeneralRateModifier);
	stream->Write(m_iGlobalGreatPeopleRateModifier);
	stream->Write(m_iAnarchyModifier);
	stream->Write(m_iGoldenAgeModifier);
	stream->Write(m_iGlobalHurryModifier);
	stream->Write(m_iFreeExperience);
	stream->Write(m_iGlobalFreeExperience);
	stream->Write(m_iFoodKept);
	stream->Write(m_iAirlift);
	stream->Write(m_iAirModifier);
	stream->Write(m_iAirUnitCapacity);
	stream->Write(m_iNukeModifier);
	stream->Write(m_iNukeExplosionRand);
	stream->Write(m_iFreeSpecialist);
	stream->Write(m_iAreaFreeSpecialist);
	stream->Write(m_iGlobalFreeSpecialist);
	stream->Write(m_iHappiness);
	stream->Write(m_iAreaHappiness);
	stream->Write(m_iGlobalHappiness);
	stream->Write(m_iStateReligionHappiness);
	stream->Write(m_iWorkerSpeedModifier);
	stream->Write(m_iMilitaryProductionModifier);
	stream->Write(m_iSpaceProductionModifier);
	stream->Write(m_iGlobalSpaceProductionModifier);
	stream->Write(m_iTradeRoutes);
	stream->Write(m_iCoastalTradeRoutes);
	stream->Write(m_iGlobalTradeRoutes);
	stream->Write(m_iTradeRouteModifier);
	stream->Write(m_iForeignTradeRouteModifier);
	stream->Write(m_iAssetValue);
	stream->Write(m_iPowerValue);
	stream->Write(m_iSpecialBuildingType);
	stream->Write(m_iAdvisorType);
	stream->Write(m_iHolyCity);
	stream->Write(m_iReligionType);
	stream->Write(m_iStateReligion);
	stream->Write(m_iPrereqReligion);
	stream->Write(m_iPrereqFlag);
	stream->Write(m_iPrereqCorporation);
	stream->Write(m_iPrereqCivic);
	stream->Write(m_iFoundsCorporation);
	stream->Write(m_iGlobalReligionCommerce);
	stream->Write(m_iGlobalCorporationCommerce);
	stream->Write(m_iPrereqAndBonus);
	stream->Write(m_iGreatPeopleUnitClass);
	stream->Write(m_iGreatPeopleRateChange);
	stream->Write(m_iConquestProbability);
	stream->Write(m_iMaintenanceModifier);
	stream->Write(m_iWarWearinessModifier);
	stream->Write(m_iGlobalWarWearinessModifier);
	stream->Write(m_iEnemyWarWearinessModifier);
	stream->Write(m_iHealRateChange);
	stream->Write(m_iHealth);
	stream->Write(m_iAreaHealth);
	stream->Write(m_iGlobalHealth);
	stream->Write(m_iGlobalPopulationChange);
	stream->Write(m_iFreeTechs);
	stream->Write(m_iDefenseModifier);
	stream->Write(m_iBombardDefenseModifier);
	stream->Write(m_iAllCityDefenseModifier);
	stream->Write(m_iEspionageDefenseModifier);
	stream->Write(m_iMissionType);
	stream->Write(m_iVoteSourceType);

	stream->Write(m_fVisibilityPriority);

	stream->Write(m_bTeamShare);
	stream->Write(m_bWater);
	stream->Write(m_bRiver);
	stream->Write(m_bPower);
	stream->Write(m_bDirtyPower);
	stream->Write(m_bAreaCleanPower);
	stream->Write(m_bAreaBorderObstacle);
	stream->Write(m_bForceTeamVoteEligible);
	stream->Write(m_bCapital);
	stream->Write(m_bGovernmentCenter);
	stream->Write(m_bGoldenAge);
	stream->Write(m_bMapCentering);
	stream->Write(m_bNoUnhappiness);
	stream->WriteString(m_szPyHelp);

/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	stream->Write(m_bFixedBorders);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	stream->Write(m_bNoForeignTradeRoutes);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/* MultiBonus							  06/08/10									Valkrionn    */
/*                                                                                               */
/*				Causes certain building tags to use each instance of a resource                  */
/*************************************************************************************************/
	stream->Write(m_bUseMultiBonuses);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Write(m_bNoUnhealthyPopulation);
	stream->Write(m_bBuildingOnlyHealthy);
	stream->Write(m_bNeverCapture);
	stream->Write(m_bNukeImmune);
	stream->Write(m_bPrereqReligion);
	stream->Write(m_bCenterInCity);
	stream->Write(m_bStateReligion);
	stream->Write(m_bAllowsNukes);

	stream->WriteString(m_szConstructSound);
	stream->WriteString(m_szArtDefineTag);
	stream->WriteString(m_szMovieDefineTag);

/*************************************************************************************************/
/**	New Tag Defs	(BuildingInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iEquipmentPromotion);
	stream->Write(m_iPrereqBroadAlignment);
/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
	stream->Write(m_iNumPrereqAlignments);
	if (m_iNumPrereqAlignments > 0)
		stream->Write(m_iNumPrereqAlignments, m_piPrereqAlignments);
	stream->Write(m_iNumPrereqEthicalAlignments);
	if (m_iNumPrereqEthicalAlignments > 0)
		stream->Write(m_iNumPrereqEthicalAlignments, m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iAlignmentModifier);
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	stream->Write(m_iAlignmentShift);
	stream->Write(m_iAlignmentShiftModifier);
	stream->Write(m_iAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBroadEthicalAlignment);
	stream->Write(m_iEthicalAlignmentModifier);
	stream->Write(m_iEthicalAlignmentShift);
	stream->Write(m_iEthicalAlignmentShiftModifier);
	stream->Write(m_iEthicalAlignmentShiftTowardsNeutral);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	//Crime
	stream->Write(m_iPrereqCrime);
	stream->Write(m_iMinCrime);
	stream->Write(m_bAutoBuild);
	stream->Write(m_bMustMaintain);
	stream->Write(m_bCrimeEffect);
	stream->Write(m_iPerCrimeEffectHappyChange);
	stream->Write(m_iPerCrimeEffectHealthChange);
	stream->Write(NUM_YIELD_TYPES, m_piPerCrimeEffectYieldChange);
	stream->Write(NUM_COMMERCE_TYPES, m_piPerCrimeEffectCommerceChange);

	stream->Write(m_iPotency);
	stream->Write(GC.getNumBonusInfos(), m_pafPotencyAffinity);
	stream->Write(GC.getNumBonusInfos(), m_paiPotencyBonusPrereq);
	stream->Write(m_iShielding);
	stream->Write(GC.getNumBonusInfos(), m_pafShieldingAffinity);
	stream->Write(GC.getNumBonusInfos(), m_paiShieldingBonusPrereq);
	stream->Write(GC.getNumUnitCombatInfos(), m_pafTrainXPCap);
	stream->Write(GC.getNumUnitCombatInfos(), m_pafTrainXPRate);
	stream->Write(GC.getNumUnitCombatInfos(), m_pafPerCrimeTrainXPCap);
	stream->Write(GC.getNumUnitCombatInfos(), m_pafPerCrimeTrainXPRate);

	stream->Write(m_iGlobalPotency);
	stream->Write(GC.getNumBonusInfos(), m_pafGlobalPotencyAffinity);
	stream->Write(GC.getNumBonusInfos(), m_paiGlobalPotencyBonusPrereq);
	stream->Write(m_iGlobalShielding);
	stream->Write(GC.getNumBonusInfos(), m_pafGlobalShieldingAffinity);
	stream->Write(GC.getNumBonusInfos(), m_paiGlobalShieldingBonusPrereq);
	stream->Write(GC.getNumUnitCombatInfos(), m_pafGlobalTrainXPCap);
	stream->Write(GC.getNumUnitCombatInfos(), m_pafGlobalTrainXPRate);

	stream->Write(m_iNumPrereqTeamBuildingClassANDs);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqTeamBuildingClassANDs);
	stream->Write(m_iNumPrereqTeamBuildingClassNOTs);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqTeamBuildingClassNOTs);
	stream->Write(m_iNumPrereqTeamBuildingClassORs);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqTeamBuildingClassORs);
	stream->Write(m_iNumPrereqGlobalBuildingClassANDs);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqGlobalBuildingClassANDs);
	stream->Write(m_iNumPrereqGlobalBuildingClassNOTs);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqGlobalBuildingClassNOTs);
	stream->Write(m_iNumPrereqGlobalBuildingClassORs);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqGlobalBuildingClassORs);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Buildings: Added by Kael 08/04/2007
	stream->Write(m_bApplyFreePromotionOnMove);
	stream->Write(m_bEquipment);
	stream->Write(m_bHideUnits);
	stream->Write(m_bNoCivicAnger);
	stream->Write(m_bRequiresCaster);
/*************************************************************************************************/
/**	Aqueduct 	Orbis new tags 	 	Ahwaric		09/09/09	Ahwaric		**/
/*************************************************************************************************/
	stream->Write(m_bCarriesFreshWater);
	stream->Write(m_bPrereqNoFreshWater);
	/*************************************************************************************************/
/**	Aqueduct END 									**/
/*************************************************************************************************/
	stream->Write(m_bSeeInvisible);
	stream->Write(m_bUnhappyProduction);
	stream->Write(m_iCrime);
	stream->Write(m_iFreePromotionPick);
	stream->Write(m_iFreeBonus2);
	stream->Write(m_iFreeBonus3);
	stream->Write(m_iGlobalResistEnemyModify);
	stream->Write(m_iGlobalResistModify);
	stream->Write(m_iModifyGlobalCounter);
	stream->Write(m_iPlotRadius);
	stream->Write(m_iPrereqTrait);
	stream->Write(m_iPrereqTrait2);
	stream->Write(m_iRemovePromotion);
	stream->Write(m_iResistMagic);
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	stream->Write(m_iCityCapModifier);
	stream->Write(m_iGlobalCityCapModifier);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
	stream->Write(m_bNoCultureCap);
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/

	stream->Write(GC.getNUM_BUILDING_AND_TECH_PREREQS(), m_piPrereqAndTechs);
	stream->Write(GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);
	stream->Write(GC.getNumTraitInfos(), m_piProductionTraits);
	stream->Write(GC.getNumTraitInfos(), m_piHappinessTraits);
	stream->Write(NUM_YIELD_TYPES, m_piSeaPlotYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piRiverPlotYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piGlobalSeaPlotYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piPowerYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piAreaYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piGlobalYieldModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceChange);
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
	stream->Write(NUM_YIELD_TYPES, m_piTradeYieldModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piTradeCommerceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	stream->Write(NUM_COMMERCE_TYPES, m_piObsoleteSafeCommerceChange);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceChangeDoubleTime);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piGlobalCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);
	stream->Write(NUM_COMMERCE_TYPES, m_piStateReligionCommerce);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceHappiness);
	stream->Write(GC.getNumReligionInfos(), m_piReligionChange);
	stream->Write(GC.getNumSpecialistInfos(), m_piSpecialistCount);
	stream->Write(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);
	stream->Write(GC.getNumBonusInfos(), m_piBonusHealthChanges);
	stream->Write(GC.getNumBonusInfos(), m_piBonusHappinessChanges);
	stream->Write(GC.getNumBonusInfos(), m_piBonusProductionModifier);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatFreeExperience);
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainFreeExperience);
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainProductionModifier);
	stream->Write(GC.getNumBuildingClassInfos(), m_piBuildingHappinessChanges);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqNumOfBuildingClass);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqBuildingClassAtRange);
	stream->Write(GC.getNumBuildingClassInfos(), m_piBuildingExclude);
	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(GC.getNumImprovementInfos(), m_piImprovementFreeSpecialist);
	stream->Write(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);
	stream->Write(NUM_COMMERCE_TYPES, m_pbCommerceChangeOriginalOwner);
	stream->Write(GC.getNumBuildingClassInfos(), m_pbBuildingClassNeededInCity);

	int i;
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppaiSpecialistYieldChange[i]);
	}

//FfH: Added by Kael 11/06/2007
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		stream->Write(NUM_COMMERCE_TYPES, m_ppaiSpecialistCommerceChange[i]);
	}
//FfH: End Add

/*************************************************************************************************/
/**	GWSLocalSpecialist																	Milaga	**/
/** Buildings can change give bonuses to specialists in only one city							**/
/*************************************************************************************************/
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_paaiLocalSpecialistYieldChange[i]);
	}

	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		stream->Write(NUM_COMMERCE_TYPES, m_paaiLocalSpecialistCommerceChange[i]);
	}

	stream->Write(GC.getNumSpecialistInfos(), m_paiLocalSpecialistHappinessChange);
	stream->Write(GC.getNumSpecialistInfos(), m_paiLocalSpecialistHealthChange);
	stream->Write(GC.getNumSpecialistInfos(), m_paiLocalSpecialistCrimeChange);
	stream->Write(GC.getNumSpecialistInfos(), m_paiLocalSpecialistGPPChange);
/*************************************************************************************************/
/**	GWSLocalSpecialist																		END	**/
/*************************************************************************************************/

	for(i=0;i<GC.getNumBonusInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppaiBonusYieldModifier[i]);
	}
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		stream->Write(NUM_COMMERCE_TYPES, m_ppaiBonusCommerceModifier[i]);
	}
	//PerPopEffect
	stream->Write(m_iNumPerPopBonuses);
	if (m_iNumPerPopBonuses != 0)
	{
		std::list<CityBonuses> cbDupe = m_cbPerPopBonuses;
		while (!cbDupe.empty())
		{
			CityBonuses cbTemp = cbDupe.front();
			cbDupe.pop_front();
			cbTemp.write(stream);
		}
	}
}

//
// read from XML
//
bool CvBuildingInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	int j=0;						//loop counter
	int k=0;						//loop counter
	int iNumSibs=0;				// the number of siblings the current xml node has
	int iNumChildren;				// the number of children the current node has

	pXML->GetChildXmlValByName(szTextVal, "BuildingClass");
	m_iBuildingClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SpecialBuildingType");
	m_iSpecialBuildingType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Advisor");
	m_iAdvisorType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**			Default value needed for proper comparison later on in CopyNonDefaults				**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "MovieDefineTag");
	setMovieDefineTag(szTextVal);
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(szTextVal, "MovieDefineTag", "NONE");
	setMovieDefineTag(szTextVal);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "HolyCity");
	m_iHolyCity = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ReligionType");
	m_iReligionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StateReligion");
	m_iStateReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqFlag");
	m_iPrereqFlag = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqCorporation");
	m_iPrereqCorporation = pXML->FindInInfoClass(szTextVal);
	
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivic");
	m_iPrereqCivic = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FoundsCorporation");
	m_iFoundsCorporation = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GlobalReligionCommerce");
	m_iGlobalReligionCommerce = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GlobalCorporationCommerce");
	m_iGlobalCorporationCommerce = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "VictoryPrereq");
	m_iVictoryPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeStartEra");
	m_iFreeStartEra = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MaxStartEra");
	m_iMaxStartEra = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ObsoleteTech");
	m_iObsoleteTech = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iPrereqAndTech = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechTypes"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_BUILDING_AND_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_BUILDING_AND_TECH_PREREQS()),"For loop iterator is greater than array size");
					for (j=0;j<iNumSibs;j++)
					{
						m_piPrereqAndTechs[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_BUILDING_AND_TECH_PREREQS(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "Bonus");
	m_iPrereqAndBonus = pXML->FindInInfoClass(szTextVal);

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonuses"))
	{
		// the next xml val in the buildinginfo tag set is the bonuses tag set
		// Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// get the total number of children the current xml node has
			iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), -1);

			if (0 < iNumChildren)
			{
				// if the call to the function that sets the current xml node to it's first non-comment
				// child and sets the parameter with the new node's value succeeds
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumChildren <= GC.getNUM_BUILDING_PREREQ_OR_BONUSES()),"For loop iterator is greater than array size");
					// loop through all the siblings
					for (j=0;j<iNumChildren;j++)
					{
						// call the find in list function to return either -1 if no value is found
						// or the index in the list the match is found at
						m_piPrereqOrBonuses[j] = pXML->FindInInfoClass(szTextVal);

						// if the call to the function that sets the current xml node to it's first non-comment
						// sibling and sets the parameter with the new node's value does not succeed
						// we will break out of this for loop
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					// set the current xml node to it's parent node
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	pXML->SetVariableListTagPair(&m_piHappinessTraits, "HappinessTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	pXML->GetChildXmlValByName(szTextVal, "NoBonus");
	m_iNoBonus = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PowerBonus");
	m_iPowerBonus = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeBonus");
	m_iFreeBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iNumFreeBonuses, "iNumFreeBonuses");

	pXML->GetChildXmlValByName(&m_iMinLevelAccess, "iMinLevelAccess");

	pXML->GetChildXmlValByName(szTextVal, "FreeBuilding");
	m_iFreeBuildingClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Parent");
	m_iParentBuildingClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreePromotion");
	m_iFreePromotion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "CivicOption");
	m_iCivicOption = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GreatPeopleUnitClass");
	m_iGreatPeopleUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DiploVoteType");
	m_iVoteSourceType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iGreatPeopleRateChange, "iGreatPeopleRateChange");
	pXML->GetChildXmlValByName(&m_bTeamShare, "bTeamShare");
	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(&m_bRiver, "bRiver");
	pXML->GetChildXmlValByName(&m_bPower, "bPower");
	pXML->GetChildXmlValByName(&m_bDirtyPower, "bDirtyPower");
	pXML->GetChildXmlValByName(&m_bAreaCleanPower, "bAreaCleanPower");
	pXML->GetChildXmlValByName(&m_bAreaBorderObstacle, "bBorderObstacle");
	pXML->GetChildXmlValByName(&m_bForceTeamVoteEligible, "bForceTeamVoteEligible");
	pXML->GetChildXmlValByName(&m_bCapital, "bCapital");
	pXML->GetChildXmlValByName(&m_bGovernmentCenter, "bGovernmentCenter");
	pXML->GetChildXmlValByName(&m_bGoldenAge, "bGoldenAge");
	pXML->GetChildXmlValByName(&m_bAllowsNukes, "bAllowsNukes");
	pXML->GetChildXmlValByName(&m_bMapCentering, "bMapCentering");
	pXML->GetChildXmlValByName(&m_bNoUnhappiness, "bNoUnhappiness");
	pXML->GetChildXmlValByName(m_szPyHelp, "PyHelp");

/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bFixedBorders, "bFixedBorders");
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bNoForeignTradeRoutes, "bNoForeignTradeRoutes");
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/* MultiBonus							  06/08/10									Valkrionn    */
/*                                                                                               */
/*				Causes certain building tags to use each instance of a resource                  */
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bUseMultiBonuses, "bUseMultiBonuses");
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bNoUnhealthyPopulation, "bNoUnhealthyPopulation");
	pXML->GetChildXmlValByName(&m_bBuildingOnlyHealthy, "bBuildingOnlyHealthy");
	pXML->GetChildXmlValByName(&m_bNeverCapture, "bNeverCapture");
	pXML->GetChildXmlValByName(&m_bNukeImmune, "bNukeImmune");
	pXML->GetChildXmlValByName(&m_bPrereqReligion, "bPrereqReligion");
	pXML->GetChildXmlValByName(&m_bCenterInCity, "bCenterInCity");
	pXML->GetChildXmlValByName(&m_bStateReligion, "bStateReligion");
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iProductionCost, "iCost", -1);
	pXML->GetChildXmlValByName(&m_iHurryCostModifier, "iHurryCostModifier");
	pXML->GetChildXmlValByName(&m_iHurryAngerModifier, "iHurryAngerModifier");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost", -1);
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");
	pXML->GetChildXmlValByName(&m_iMinAreaSize, "iMinAreaSize", -1);
	pXML->GetChildXmlValByName(&m_iConquestProbability, "iConquestProb", 100);
	pXML->GetChildXmlValByName(&m_iNumCitiesPrereq, "iCitiesPrereq");
	pXML->GetChildXmlValByName(&m_iNumTeamsPrereq, "iTeamsPrereq");
	pXML->GetChildXmlValByName(&m_iUnitLevelPrereq, "iLevelPrereq");
	pXML->GetChildXmlValByName(&m_iMinLatitude, "iMinLatitude");
	pXML->GetChildXmlValByName(&m_iMaxLatitude, "iMaxLatitude", 90);
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iGreatGeneralRateModifier, "iGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iDomesticGreatGeneralRateModifier, "iDomesticGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iGlobalGreatPeopleRateModifier, "iGlobalGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iAnarchyModifier, "iAnarchyModifier");
	pXML->GetChildXmlValByName(&m_iGoldenAgeModifier, "iGoldenAgeModifier");
	pXML->GetChildXmlValByName(&m_iGlobalHurryModifier, "iGlobalHurryModifier");
	pXML->GetChildXmlValByName(&m_iFreeExperience, "iExperience");
	pXML->GetChildXmlValByName(&m_iGlobalFreeExperience, "iGlobalExperience");
	pXML->GetChildXmlValByName(&m_iFoodKept, "iFoodKept");
	pXML->GetChildXmlValByName(&m_iAirlift, "iAirlift");
	pXML->GetChildXmlValByName(&m_iAirModifier, "iAirModifier");
	pXML->GetChildXmlValByName(&m_iAirUnitCapacity, "iAirUnitCapacity");
	pXML->GetChildXmlValByName(&m_iNukeModifier, "iNukeModifier");
	pXML->GetChildXmlValByName(&m_iNukeExplosionRand, "iNukeExplosionRand");
	pXML->GetChildXmlValByName(&m_iFreeSpecialist, "iFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iAreaFreeSpecialist, "iAreaFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iGlobalFreeSpecialist, "iGlobalFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iMaintenanceModifier, "iMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iWarWearinessModifier, "iWarWearinessModifier");
	pXML->GetChildXmlValByName(&m_iGlobalWarWearinessModifier, "iGlobalWarWearinessModifier");
	pXML->GetChildXmlValByName(&m_iEnemyWarWearinessModifier, "iEnemyWarWearinessModifier");
	pXML->GetChildXmlValByName(&m_iHealRateChange, "iHealRateChange");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iAreaHealth, "iAreaHealth");
	pXML->GetChildXmlValByName(&m_iGlobalHealth, "iGlobalHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iAreaHappiness, "iAreaHappiness");
	pXML->GetChildXmlValByName(&m_iGlobalHappiness, "iGlobalHappiness");
	pXML->GetChildXmlValByName(&m_iStateReligionHappiness, "iStateReligionHappiness");
	pXML->GetChildXmlValByName(&m_iWorkerSpeedModifier, "iWorkerSpeedModifier");
	pXML->GetChildXmlValByName(&m_iMilitaryProductionModifier, "iMilitaryProductionModifier");
	pXML->GetChildXmlValByName(&m_iSpaceProductionModifier, "iRitualProductionModifier");
	pXML->GetChildXmlValByName(&m_iGlobalSpaceProductionModifier, "iGlobalRitualProductionModifier");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_iCoastalTradeRoutes, "iCoastalTradeRoutes");
	pXML->GetChildXmlValByName(&m_iGlobalTradeRoutes, "iGlobalTradeRoutes");
	pXML->GetChildXmlValByName(&m_iTradeRouteModifier, "iTradeRouteModifier");
	pXML->GetChildXmlValByName(&m_iForeignTradeRouteModifier, "iForeignTradeRouteModifier");
	pXML->GetChildXmlValByName(&m_iGlobalPopulationChange, "iGlobalPopulationChange");
	pXML->GetChildXmlValByName(&m_iFreeTechs, "iFreeTechs");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefense");
	pXML->GetChildXmlValByName(&m_iBombardDefenseModifier, "iBombardDefense");
	pXML->GetChildXmlValByName(&m_iAllCityDefenseModifier, "iAllCityDefense");
	pXML->GetChildXmlValByName(&m_iEspionageDefenseModifier, "iEspionageDefense");
	pXML->GetChildXmlValByName(&m_iAssetValue, "iAsset");
	pXML->GetChildXmlValByName(&m_iPowerValue, "iPower");
	pXML->GetChildXmlValByName(&m_fVisibilityPriority, "fVisibilityPriority");

/*************************************************************************************************/
/**	New Tag Defs	(BuildingInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "EquipmentPromotion");
	m_iEquipmentPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iPrereqBroadAlignment, "iPrereqBroadAlignment");
/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqAlignments"))	pXML->SetIntWithChildList(&m_iNumPrereqAlignments, &m_piPrereqAlignments);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqEthicalAlignments"))	pXML->SetIntWithChildList(&m_iNumPrereqEthicalAlignments, &m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentShift, "iAlignmentShift");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftModifier, "iAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftTowardsNeutral, "iAlignmentShiftTowardsNeutral");
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqBroadEthicalAlignment, "iPrereqBroadEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShift, "iEthicalAlignmentShift");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftModifier, "iEthicalAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftTowardsNeutral, "iEthicalAlignmentShiftTowardsNeutral");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//Crime
	pXML->GetChildXmlValByName(&m_iPrereqCrime, "iPrereqCrime");
	pXML->GetChildXmlValByName(&m_iMinCrime, "iMinCrime");
	pXML->GetChildXmlValByName(&m_bAutoBuild, "bAutoBuild");
	pXML->GetChildXmlValByName(&m_bMustMaintain, "bMustMaintain");
	pXML->GetChildXmlValByName(&m_bCrimeEffect, "bCrimeEffect");
	pXML->GetChildXmlValByName(&m_iPerCrimeEffectHappyChange, "iPerCrimeEffectHappy");
	pXML->GetChildXmlValByName(&m_iPerCrimeEffectHealthChange, "iPerCrimeEffectHealth");

	pXML->GetChildXmlValByName(&m_iPotency, "iPotency");
	pXML->GetChildXmlValByName(&m_iGlobalPotency, "iGlobalPotency");
	pXML->GetChildXmlValByName(&m_iShielding, "iShielding");
	pXML->GetChildXmlValByName(&m_iGlobalShielding, "iGlobalShielding");
	pXML->SetVariableListTagPair(&m_pafPotencyAffinity, "PotencyAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_pafGlobalPotencyAffinity, "GlobalPotencyAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_paiPotencyBonusPrereq, "PotencyBonusPrereqs", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_paiGlobalPotencyBonusPrereq, "GlobalPotencyBonusPrereqs", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_pafShieldingAffinity, "ShieldingAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_pafGlobalShieldingAffinity, "GlobalShieldingAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_paiShieldingBonusPrereq, "ShieldingBonusPrereqs", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_paiGlobalShieldingBonusPrereq, "GlobalShieldingBonusPrereqs", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());

	pXML->SetVariableListTagPair(&m_pafTrainXPCap, "TrainXPCaps", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pafTrainXPRate, "TrainXPRates", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pafGlobalTrainXPCap, "GlobalTrainXPCaps", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pafGlobalTrainXPRate, "GlobalTrainXPRates", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pafPerCrimeTrainXPCap, "PerCrimeTrainXPCaps", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pafPerCrimeTrainXPRate, "PerCrimeTrainXPRates", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());

	pXML->SetVariableListTagPair(&m_piPrereqTeamBuildingClassANDs, "PrereqTeamBuildingClassANDs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_piPrereqTeamBuildingClassNOTs, "PrereqTeamBuildingClassNOTs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_piPrereqTeamBuildingClassORs, "PrereqTeamBuildingClassORs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_piPrereqGlobalBuildingClassANDs, "PrereqGlobalBuildingClassANDs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_piPrereqGlobalBuildingClassNOTs, "PrereqGlobalBuildingClassNOTs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_piPrereqGlobalBuildingClassORs, "PrereqGlobalBuildingClassORs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

	for (j=0;j<GC.getNumBuildingClassInfos();j++)
	{
		if (getPrereqTeamBuildingClassAND(j) 	> 0)	m_iNumPrereqTeamBuildingClassANDs++;
		if (getPrereqTeamBuildingClassNOT(j) 	> 0)	m_iNumPrereqTeamBuildingClassNOTs++;
		if (getPrereqTeamBuildingClassOR(j) 	> 0)	m_iNumPrereqTeamBuildingClassORs++;
		if (getPrereqGlobalBuildingClassAND(j) 	> 0)	m_iNumPrereqGlobalBuildingClassANDs++;
		if (getPrereqGlobalBuildingClassNOT(j) 	> 0)	m_iNumPrereqGlobalBuildingClassNOTs++;
		if (getPrereqGlobalBuildingClassOR(j) 	> 0)	m_iNumPrereqGlobalBuildingClassORs++;
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Buildings: Added by Kael 08/04/2007
	pXML->GetChildXmlValByName(&m_bApplyFreePromotionOnMove, "bApplyFreePromotionOnMove");
	pXML->GetChildXmlValByName(&m_bEquipment, "bEquipment");
	pXML->GetChildXmlValByName(&m_bHideUnits, "bHideUnits");
	pXML->GetChildXmlValByName(&m_bNoCivicAnger, "bNoCivicAnger");
	pXML->GetChildXmlValByName(&m_bRequiresCaster, "bRequiresCaster");
/*************************************************************************************************/
/**	Aqueduct 	Orbis new tags 	 	Ahwaric		09/09/09	Ahwaric		**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bCarriesFreshWater, "bCarriesFreshWater");
	pXML->GetChildXmlValByName(&m_bPrereqNoFreshWater, "bPrereqNoFreshWater");
	/*************************************************************************************************/
/**	Aqueduct END 									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bSeeInvisible, "bSeeInvisible");
	pXML->GetChildXmlValByName(&m_bUnhappyProduction, "bUnhappyProduction");
	pXML->GetChildXmlValByName(&m_iCrime, "iCrime");
	pXML->GetChildXmlValByName(&m_iFreePromotionPick, "iFreePromotionPick");
	pXML->GetChildXmlValByName(szTextVal, "FreeBonus2");
	m_iFreeBonus2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FreeBonus3");
	m_iFreeBonus3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iGlobalResistEnemyModify, "iGlobalResistEnemyModify");
	pXML->GetChildXmlValByName(&m_iGlobalResistModify, "iGlobalResistModify");
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter, "iModifyGlobalCounter");
	pXML->GetChildXmlValByName(&m_iPlotRadius, "iPlotRadius");
	pXML->GetChildXmlValByName(szTextVal, "PrereqTrait");
	m_iPrereqTrait = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqTrait2");
	m_iPrereqTrait2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotion");
	m_iRemovePromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iResistMagic, "iResistMagic");
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iCityCapModifier, "iCityCapModifier", 0);
	pXML->GetChildXmlValByName(&m_iGlobalCityCapModifier, "iGlobalCityCapModifier", 0);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/** MaxCulture					Opera															**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bNoCultureCap, "bNoCultureCap");
/*************************************************************************************************/
/** MaxCulture					END																**/
/*************************************************************************************************/

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SeaPlotYieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piSeaPlotYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piSeaPlotYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverPlotYieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piRiverPlotYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverPlotYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalSeaPlotYieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piGlobalSeaPlotYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piGlobalSeaPlotYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}
	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PerCrimeEffectYieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piPerCrimeEffectYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piPerCrimeEffectYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldModifier, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PowerYieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piPowerYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piPowerYieldModifier, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AreaYieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piAreaYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piAreaYieldModifier, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalYieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piGlobalYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piGlobalYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChanges"))
	{
		pXML->SetCommerce(&m_piCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceChange, NUM_COMMERCE_TYPES);
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PerCrimeEffectCommerceChanges"))
	{
		pXML->SetCommerce(&m_piPerCrimeEffectCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piPerCrimeEffectCommerceChange, NUM_COMMERCE_TYPES);
	}

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TradeYieldModifiers"))
	{
		pXML->SetYields(&m_piTradeYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piTradeYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TradeCommerceModifiers"))
	{
		pXML->SetCommerce(&m_piTradeCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piTradeCommerceModifier, NUM_COMMERCE_TYPES);
	}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ObsoleteSafeCommerceChanges"))
	{
		pXML->SetCommerce(&m_piObsoleteSafeCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piObsoleteSafeCommerceChange, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChangeDoubleTimes"))
	{
		pXML->SetCommerce(&m_piCommerceChangeDoubleTime);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceChangeDoubleTime, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalCommerceModifiers"))
	{
		pXML->SetCommerce(&m_piGlobalCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piGlobalCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistExtraCommerces"))
	{
		pXML->SetCommerce(&m_piSpecialistExtraCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piSpecialistExtraCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"StateReligionCommerces"))
	{
		pXML->SetCommerce(&m_piStateReligionCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piStateReligionCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceHappinesses"))
	{
		pXML->SetCommerce(&m_piCommerceHappiness);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceHappiness, NUM_COMMERCE_TYPES);
	}

	pXML->SetVariableListTagPair(&m_piReligionChange, "ReligionChanges", sizeof(GC.getReligionInfo((ReligionTypes)0)), GC.getNumReligionInfos());

	pXML->SetVariableListTagPair(&m_piSpecialistCount, "SpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_piFreeSpecialistCount, "FreeSpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceFlexibles"))
	{
		pXML->SetCommerce(&m_pbCommerceFlexible);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_pbCommerceFlexible, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChangeOriginalOwners"))
	{
		pXML->SetCommerce(&m_pbCommerceChangeOriginalOwner);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_pbCommerceChangeOriginalOwner, NUM_COMMERCE_TYPES);
	}

	pXML->GetChildXmlValByName(szTextVal, "ConstructSound");
	setConstructSound(szTextVal);

	pXML->SetVariableListTagPair(&m_piBonusHealthChanges, "BonusHealthChanges", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piBonusHappinessChanges, "BonusHappinessChanges", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piBonusProductionModifier, "BonusProductionModifiers", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());

	pXML->SetVariableListTagPair(&m_piUnitCombatFreeExperience, "UnitCombatFreeExperiences", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());

	pXML->SetVariableListTagPair(&m_piDomainFreeExperience, "DomainFreeExperiences", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);

	pXML->SetVariableListTagPair(&m_piDomainProductionModifier, "DomainProductionModifiers", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);

	pXML->SetVariableListTagPair(&m_piPrereqNumOfBuildingClass, "PrereqBuildingClasses", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_pbBuildingClassNeededInCity, "BuildingClassNeededs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_piPrereqBuildingClassAtRange, "PrereqBuildingAtRanges", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_piBuildingExclude, "BuildingExcludes", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

	pXML->Init2DIntList(&m_ppaiSpecialistYieldChange, GC.getNumSpecialistInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistYieldChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistYieldChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
					{
						// call the function that sets the yield change variable
						pXML->SetYields(&m_ppaiSpecialistYieldChange[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_ppaiSpecialistYieldChange[k], NUM_YIELD_TYPES);
					}
				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->Init2DIntList(&m_ppaiBonusYieldModifier, GC.getNumBonusInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusYieldModifiers"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusYieldModifier"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "BonusType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
					{
						// call the function that sets the yield change variable
						pXML->SetYields(&m_ppaiBonusYieldModifier[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_ppaiBonusYieldModifier[k], NUM_YIELD_TYPES);
					}

				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->Init2DIntList(&m_ppaiBonusCommerceModifier, GC.getNumBonusInfos(), NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BonusCommerceModifiers"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BonusCommerceModifier"))
		{
			for (j = 0; j < iNumChildren; j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "BonusType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_ppaiBonusCommerceModifier[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceModifiers"))
					{
						// call the function that sets the yield change variable
						pXML->SetCommerce(&m_ppaiBonusCommerceModifier[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_ppaiBonusCommerceModifier[k], NUM_COMMERCE_TYPES);
					}

				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());
	pXML->SetVariableListTagPair(&m_piImprovementFreeSpecialist, "ImprovementFreeSpecialists", sizeof(GC.getImprovementInfo((ImprovementTypes)0)), GC.getNumImprovementInfos());
	pXML->SetVariableListTagPair(&m_piBuildingHappinessChanges, "BuildingHappinessChanges", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

//FfH: Added by Kael 11/06/2007
	pXML->Init2DIntList(&m_ppaiSpecialistCommerceChange, GC.getNumSpecialistInfos(), NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistCommerceChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistCommerceChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[k]);
				if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChanges") && (k > -1))
				{
					pXML->SetCommerce(&m_ppaiSpecialistCommerceChange[k]);
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
				else
				{
					pXML->InitList(&m_ppaiSpecialistCommerceChange[k], NUM_COMMERCE_TYPES);
				}
				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
//FfH: End Add

/*************************************************************************************************/
/**	GWSLocalSpecialist																	Milaga	**/
/** Buildings can change give bonuses to specialists in only one city							**/
/*************************************************************************************************/
	pXML->Init2DIntList(&m_paaiLocalSpecialistCommerceChange, GC.getNumSpecialistInfos(), NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"LocalSpecialistCommerceChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"LocalSpecialistCommerceChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					SAFE_DELETE_ARRAY(m_paaiLocalSpecialistCommerceChange[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChanges"))
					{
						pXML->SetCommerce(&m_paaiLocalSpecialistCommerceChange[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_paaiLocalSpecialistCommerceChange[k], NUM_COMMERCE_TYPES);
					}
				}
				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	pXML->Init2DIntList(&m_paaiLocalSpecialistYieldChange, GC.getNumSpecialistInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"LocalSpecialistYieldChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"LocalSpecialistYieldChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_paaiLocalSpecialistYieldChange[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
					{
						// call the function that sets the yield change variable
						pXML->SetYields(&m_paaiLocalSpecialistYieldChange[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_paaiLocalSpecialistYieldChange[k], NUM_YIELD_TYPES);
					}
				}
				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->SetVariableListTagPair(&m_paiLocalSpecialistHappinessChange, "LocalSpecialistHappinessChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_paiLocalSpecialistHealthChange, "LocalSpecialistHealthChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_paiLocalSpecialistCrimeChange, "LocalSpecialistCrimeChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_paiLocalSpecialistGPPChange, "LocalSpecialistGPPChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
/*************************************************************************************************/
/**	GWSLocalSpecialist																		END	**/
/*************************************************************************************************/
	//PerPopEffect
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PerPopBonuses"))
	{
		int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (iNumSibs > 0)
		{
			m_iNumPerPopBonuses = iNumSibs;
			if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PerPopBonus"))
			{
				for (int iI = 0; iI < iNumSibs; iI++)
				{
					CityBonuses cbTemp;
					//	pXML->GetChildXmlValByName(&(cbTemp.bFullMap), "bFullMap", false);
					//	pXML->GetChildXmlValByName(&(cbTemp.bApplyEnemy), "bApplyEnemy", false);
					//	pXML->GetChildXmlValByName(&(cbTemp.bApplyRival), "bApplyRival", false);
					//	pXML->GetChildXmlValByName(&(cbTemp.bApplySelf), "bApplySelf", false);
					//	pXML->GetChildXmlValByName(&(cbTemp.bApplyTeam), "bApplyTeam", false);
					pXML->GetChildXmlValByName(&(cbTemp.fCulture), "fCulture", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fCrime), "fCrime", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fDefense), "fDefense", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fDiplo), "fDiplo", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fFood), "fFood", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fFreeXP), "fFreeXP", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fGold), "fGold", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fGPP), "fGPP", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fHappy), "fHappy", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fHealth), "fHealth", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fProduction), "fProduction", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fTradeRoutes), "fTradeRoutes", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fRitualAssist), "fRitualAssist", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fInfectCulture), "fInfectCulture", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fPotency), "fPotency", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fShielding), "fShielding", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fTrainXPCap), "fTrainXPCap", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.fTrainXPRate), "fTrainXPRate", 0.0f);
					pXML->GetChildXmlValByName(&(cbTemp.iBonusRange), "iBonusRange", 0);
					pXML->GetChildXmlValByName(&(cbTemp.fDecayRate), "fDecayRate", 0.0f);
					m_cbPerPopBonuses.push_back(cbTemp);
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))						break;
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(BuildingInfos)			05/15/08											**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBuildingInfo::copyNonDefaults(CvBuildingInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()						== cDefault)			setArtDefineTag(					pClassInfo->getArtDefineTag());
	if (getMovieDefineTag()						== cDefault)			setMovieDefineTag(					pClassInfo->getMovieDefineTag());
	//Art Define Tags must be done before InfoBase/Hotkey info to get the right buttons
	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);
	
	if (getPythonHelp() == cDefault)			m_szPyHelp = pClassInfo->getPythonHelp();

	if (isTeamShare()							== false)				m_bTeamShare						= pClassInfo->isTeamShare();
	if (isWater()								== false)				m_bWater							= pClassInfo->isWater();
	if (isRiver()								== false)				m_bRiver							= pClassInfo->isRiver();
	if (isPower()								== false)				m_bPower							= pClassInfo->isPower();
	if (isDirtyPower()							== false)				m_bDirtyPower						= pClassInfo->isDirtyPower();
	if (isAreaCleanPower()						== false)				m_bAreaCleanPower					= pClassInfo->isAreaCleanPower();
	if (isAreaBorderObstacle()					== false)				m_bAreaBorderObstacle				= pClassInfo->isAreaBorderObstacle();
	if (isForceTeamVoteEligible()				== false)				m_bForceTeamVoteEligible			= pClassInfo->isForceTeamVoteEligible();
	if (isCapital()								== false)				m_bCapital							= pClassInfo->isCapital();
	if (isGovernmentCenter()					== false)				m_bGovernmentCenter					= pClassInfo->isGovernmentCenter();
	if (isGoldenAge ()							== false)				m_bGoldenAge						= pClassInfo->isGoldenAge ();
	if (isAllowsNukes()							== false)				m_bAllowsNukes						= pClassInfo->isAllowsNukes();
	if (isMapCentering()						== false)				m_bMapCentering						= pClassInfo->isMapCentering();
	if (isNoUnhappiness()						== false)				m_bNoUnhappiness					= pClassInfo->isNoUnhappiness();
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	if (isFixedBorders()						== false)				m_bFixedBorders						= pClassInfo->isFixedBorders();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	if (isNoForeignTradeRoutes()				== false)				m_bNoForeignTradeRoutes				= pClassInfo->isNoForeignTradeRoutes();
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/* MultiBonus							  06/08/10									Valkrionn    */
/*                                                                                               */
/*				Causes certain building tags to use each instance of a resource                  */
/*************************************************************************************************/
	if (isUseMultiBonuses()						== false)				m_bUseMultiBonuses					= pClassInfo->isUseMultiBonuses();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	if (isNoUnhealthyPopulation()				== false)				m_bNoUnhealthyPopulation			= pClassInfo->isNoUnhealthyPopulation();
	if (isBuildingOnlyHealthy()					== false)				m_bBuildingOnlyHealthy				= pClassInfo->isBuildingOnlyHealthy();
	if (isNeverCapture()						== false)				m_bNeverCapture						= pClassInfo->isNeverCapture();
	if (isNukeImmune()							== false)				m_bNukeImmune						= pClassInfo->isNukeImmune();
	if (isPrereqReligion()						== false)				m_bPrereqReligion					= pClassInfo->isPrereqReligion();
	if (isCenterInCity()						== false)				m_bCenterInCity						= pClassInfo->isCenterInCity();
	if (isStateReligion()						== false)				m_bStateReligion					= pClassInfo->isStateReligion();
	if (isApplyFreePromotionOnMove()			== false)				m_bApplyFreePromotionOnMove			= pClassInfo->isApplyFreePromotionOnMove();
	if (isEquipment()							== false)				m_bEquipment						= pClassInfo->isEquipment();
	if (isHideUnits()							== false)				m_bHideUnits						= pClassInfo->isHideUnits();
	if (isNoCivicAnger()						== false)				m_bNoCivicAnger						= pClassInfo->isNoCivicAnger();
	if (isRequiresCaster()						== false)				m_bRequiresCaster					= pClassInfo->isRequiresCaster();
	if (isSeeInvisible()						== false)				m_bSeeInvisible						= pClassInfo->isSeeInvisible();
	if (isUnhappyProduction()					== false)				m_bUnhappyProduction				= pClassInfo->isUnhappyProduction();
	if (isCarriesFreshWater()					== false)				m_bCarriesFreshWater				= pClassInfo->isCarriesFreshWater();
	if (isPrereqNoFreshWater() == false)				m_bPrereqNoFreshWater = pClassInfo->isPrereqNoFreshWater();
	if (getNumFreeBonuses()						== 0)					m_iNumFreeBonuses					= pClassInfo->getNumFreeBonuses();
	if (getMinLevelAccess() == 0)					m_iMinLevelAccess = pClassInfo->getMinLevelAccess();
	if (getPrereqBroadAlignment()				== 0)					m_iPrereqBroadAlignment				= pClassInfo->getPrereqBroadAlignment();
/*************************************************************************************************/
/**	Building prereq Alignments				07/04/10								Snarko		**/
/**																								**/
/**							Allows buildings to require alignments								**/
/*************************************************************************************************/
	if(pClassInfo->getNumPrereqAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqAlignments() + pClassInfo->getNumPrereqAlignments()];
		for(int i = 0; i< getNumPrereqAlignments(); ++i)
		{
			tempArray[i] = getPrereqAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqAlignments();++j)
			{
				if(pClassInfo->getPrereqAlignment(i) == getPrereqAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqAlignments()] = pClassInfo->getPrereqAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqAlignments);
		int iGoalSize = getNumPrereqAlignments() + iNewItems;
		m_piPrereqAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqAlignments[i] < NUM_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqEthicalAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqEthicalAlignments() + pClassInfo->getNumPrereqEthicalAlignments()];
		for(int i = 0; i< getNumPrereqEthicalAlignments(); ++i)
		{
			tempArray[i] = getPrereqEthicalAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqEthicalAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqEthicalAlignments();++j)
			{
				if(pClassInfo->getPrereqEthicalAlignment(i) == getPrereqEthicalAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqEthicalAlignments()] = pClassInfo->getPrereqEthicalAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
		int iGoalSize = getNumPrereqEthicalAlignments() + iNewItems;
		m_piPrereqEthicalAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqEthicalAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqEthicalAlignments[i] < NUM_ETHICAL_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqEthicalAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqEthicalAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Building prereq Alignments					END												**/
/*************************************************************************************************/
	if (getAlignmentModifier()					== 0)					m_iAlignmentModifier				= pClassInfo->getAlignmentModifier();
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	if (getAlignmentShift()                     == 0)                   m_iAlignmentShift                   = pClassInfo->getAlignmentShift();
	if (getAlignmentShiftModifier()             == 0)                   m_iAlignmentShiftModifier           = pClassInfo->getAlignmentShiftModifier();
	if (getAlignmentShiftTowardsNeutral()       == -1)                  m_iAlignmentShiftTowardsNeutral     = pClassInfo->getAlignmentShiftTowardsNeutral();
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getPrereqBroadEthicalAlignment()		== 0)					m_iPrereqBroadEthicalAlignment			   = pClassInfo->getPrereqBroadEthicalAlignment();
	if (getEthicalAlignmentModifier()			== 0)					m_iEthicalAlignmentModifier				   = pClassInfo->getEthicalAlignmentModifier();
	if (getEthicalAlignmentShift()              == 0)                   m_iEthicalAlignmentShift                   = pClassInfo->getEthicalAlignmentShift();
	if (getEthicalAlignmentShiftModifier()      == 0)                   m_iEthicalAlignmentShiftModifier           = pClassInfo->getEthicalAlignmentShiftModifier();
	if (getEthicalAlignmentShiftTowardsNeutral() == -1)                 m_iEthicalAlignmentShiftTowardsNeutral     = pClassInfo->getEthicalAlignmentShiftTowardsNeutral();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	//Crime

	if (getPrereqCrime() == 0)					m_iPrereqCrime = pClassInfo->getPrereqCrime();
	if (getMinCrime() == 0)					m_iMinCrime = pClassInfo->getMinCrime();
	if (isAutoBuild() == false)					m_bAutoBuild = pClassInfo->isAutoBuild();
	if (isMustMaintain() == false)					m_bMustMaintain = pClassInfo->isMustMaintain();
	if (isCrimeEffect() == false)					m_bCrimeEffect = pClassInfo->isCrimeEffect();
	if (getPerCrimeEffectHappyChange() == 0)					m_iPerCrimeEffectHappyChange = pClassInfo->getPerCrimeEffectHappyChange();
	if (getPerCrimeEffectHealthChange() == 0)					m_iPerCrimeEffectHealthChange = pClassInfo->getPerCrimeEffectHealthChange();

	if (getPotency()							== 0)					m_iPotency							= pClassInfo->getPotency();
	if (getGlobalPotency()						== 0)					m_iGlobalPotency					= pClassInfo->getGlobalPotency();
	if (getShielding()							== 0)					m_iShielding						= pClassInfo->getShielding();
	if (getGlobalShielding()					== 0)					m_iGlobalShielding					= pClassInfo->getGlobalShielding();
	if (getCrime()								== 0)					m_iCrime							= pClassInfo->getCrime();
	if (getFreePromotionPick()					== 0)					m_iFreePromotionPick				= pClassInfo->getFreePromotionPick();
	if (getGlobalResistEnemyModify()			== 0)					m_iGlobalResistEnemyModify			= pClassInfo->getGlobalResistEnemyModify();
	if (getGlobalResistModify()					== 0)					m_iGlobalResistModify				= pClassInfo->getGlobalResistModify();
	if (getModifyGlobalCounter()				== 0)					m_iModifyGlobalCounter				= pClassInfo->getModifyGlobalCounter();
	if (getPlotRadius()							== 0)					m_iPlotRadius						= pClassInfo->getPlotRadius();
	if (getResistMagic()						== 0)					m_iResistMagic						= pClassInfo->getResistMagic();
	if (getGreatPeopleRateChange()				== 0)					m_iGreatPeopleRateChange			= pClassInfo->getGreatPeopleRateChange();
	if (getAIWeight()							== 0)					m_iAIWeight							= pClassInfo->getAIWeight();
	if (getProductionCost()						== -1)					m_iProductionCost					= pClassInfo->getProductionCost();
	if (getHurryCostModifier()					== 0)					m_iHurryCostModifier				= pClassInfo->getHurryCostModifier();
	if (getHurryAngerModifier()					== 0)					m_iHurryAngerModifier				= pClassInfo->getHurryAngerModifier();
	if (getAdvancedStartCost()					== -1)					m_iAdvancedStartCost				= pClassInfo->getAdvancedStartCost();
	if (getAdvancedStartCostIncrease()			== 0)					m_iAdvancedStartCostIncrease		= pClassInfo->getAdvancedStartCostIncrease();
	if (getMinAreaSize()						== -1)					m_iMinAreaSize						= pClassInfo->getMinAreaSize();
	if (getConquestProbability()				== 100)					m_iConquestProbability				= pClassInfo->getConquestProbability();
	if (getNumCitiesPrereq()					== 0)					m_iNumCitiesPrereq					= pClassInfo->getNumCitiesPrereq();
	if (getNumTeamsPrereq()						== 0)					m_iNumTeamsPrereq					= pClassInfo->getNumTeamsPrereq();
	if (getUnitLevelPrereq()					== 0)					m_iUnitLevelPrereq					= pClassInfo->getUnitLevelPrereq();
	if (getMinLatitude()						== 0)					m_iMinLatitude						= pClassInfo->getMinLatitude();
	if (getGreatPeopleRateModifier()			== 0)					m_iGreatPeopleRateModifier			= pClassInfo->getGreatPeopleRateModifier();
	if (getGreatGeneralRateModifier()			== 0)					m_iGreatGeneralRateModifier			= pClassInfo->getGreatGeneralRateModifier();
	if (getDomesticGreatGeneralRateModifier()	== 0)					m_iDomesticGreatGeneralRateModifier	= pClassInfo->getDomesticGreatGeneralRateModifier();
	if (getGlobalGreatPeopleRateModifier()		== 0)					m_iGlobalGreatPeopleRateModifier	= pClassInfo->getGlobalGreatPeopleRateModifier();
	if (getAnarchyModifier()					== 0)					m_iAnarchyModifier					= pClassInfo->getAnarchyModifier();
	if (getGoldenAgeModifier()					== 0)					m_iGoldenAgeModifier				= pClassInfo->getGoldenAgeModifier();
	if (getGlobalHurryModifier()				== 0)					m_iGlobalHurryModifier				= pClassInfo->getGlobalHurryModifier();
	if (getFreeExperience()						== 0)					m_iFreeExperience					= (float)(pClassInfo->getFreeExperience()/100.0);
	if (getGlobalFreeExperience()				== 0)					m_iGlobalFreeExperience				= (float)(pClassInfo->getGlobalFreeExperience()/100.0);
	if (getFoodKept()							== 0)					m_iFoodKept							= pClassInfo->getFoodKept();
	if (getAirlift()							== 0)					m_iAirlift							= pClassInfo->getAirlift();
	if (getAirModifier()						== 0)					m_iAirModifier						= pClassInfo->getAirModifier();
	if (getAirUnitCapacity()					== 0)					m_iAirUnitCapacity					= pClassInfo->getAirUnitCapacity();
	if (getNukeModifier()						== 0)					m_iNukeModifier						= pClassInfo->getNukeModifier();
	if (getNukeExplosionRand()					== 0)					m_iNukeExplosionRand				= pClassInfo->getNukeExplosionRand();
	if (getFreeSpecialist()						== 0)					m_iFreeSpecialist					= pClassInfo->getFreeSpecialist();
	if (getAreaFreeSpecialist()					== 0)					m_iAreaFreeSpecialist				= pClassInfo->getAreaFreeSpecialist();
	if (getGlobalFreeSpecialist()				== 0)					m_iGlobalFreeSpecialist				= pClassInfo->getGlobalFreeSpecialist();
	if (getMaintenanceModifier()				== 0)					m_iMaintenanceModifier				= pClassInfo->getMaintenanceModifier();
	if (getWarWearinessModifier()				== 0)					m_iWarWearinessModifier				= pClassInfo->getWarWearinessModifier();
	if (getGlobalWarWearinessModifier()			== 0)					m_iGlobalWarWearinessModifier		= pClassInfo->getGlobalWarWearinessModifier();
	if (getEnemyWarWearinessModifier()			== 0)					m_iEnemyWarWearinessModifier		= pClassInfo->getEnemyWarWearinessModifier();
	if (getHealRateChange()						== 0)					m_iHealRateChange					= pClassInfo->getHealRateChange();
	if (getHealth()								== 0)					m_iHealth							= pClassInfo->getHealth();
	if (getAreaHealth()							== 0)					m_iAreaHealth						= pClassInfo->getAreaHealth();
	if (getGlobalHealth()						== 0)					m_iGlobalHealth						= pClassInfo->getGlobalHealth();
	if (getHappiness()							== 0)					m_iHappiness						= pClassInfo->getHappiness();
	if (getAreaHappiness()						== 0)					m_iAreaHappiness					= pClassInfo->getAreaHappiness();
	if (getGlobalHappiness()					== 0)					m_iGlobalHappiness					= pClassInfo->getGlobalHappiness();
	if (getStateReligionHappiness()				== 0)					m_iStateReligionHappiness			= pClassInfo->getStateReligionHappiness();
	if (getWorkerSpeedModifier()				== 0)					m_iWorkerSpeedModifier				= pClassInfo->getWorkerSpeedModifier();
	if (getMilitaryProductionModifier()			== 0)					m_iMilitaryProductionModifier		= pClassInfo->getMilitaryProductionModifier();
	if (getRitualProductionModifier()			== 0)					m_iSpaceProductionModifier			= pClassInfo->getRitualProductionModifier();
	if (getGlobalRitualProductionModifier()		== 0)					m_iGlobalSpaceProductionModifier	= pClassInfo->getGlobalRitualProductionModifier();
	if (getTradeRoutes()						== 0)					m_iTradeRoutes						= pClassInfo->getTradeRoutes();
	if (getCoastalTradeRoutes()					== 0)					m_iCoastalTradeRoutes				= pClassInfo->getCoastalTradeRoutes();
	if (getGlobalTradeRoutes()					== 0)					m_iGlobalTradeRoutes				= pClassInfo->getGlobalTradeRoutes();
	if (getTradeRouteModifier()					== 0)					m_iTradeRouteModifier				= pClassInfo->getTradeRouteModifier();
	if (getForeignTradeRouteModifier()			== 0)					m_iForeignTradeRouteModifier		= pClassInfo->getForeignTradeRouteModifier();
	if (getGlobalPopulationChange()				== 0)					m_iGlobalPopulationChange			= pClassInfo->getGlobalPopulationChange();
	if (getFreeTechs()							== 0)					m_iFreeTechs						= pClassInfo->getFreeTechs();
	if (getDefenseModifier()					== 0)					m_iDefenseModifier					= pClassInfo->getDefenseModifier();
	if (getBombardDefenseModifier()				== 0)					m_iBombardDefenseModifier			= pClassInfo->getBombardDefenseModifier();
	if (getAllCityDefenseModifier()				== 0)					m_iAllCityDefenseModifier			= pClassInfo->getAllCityDefenseModifier();
	if (getEspionageDefenseModifier()			== 0)					m_iEspionageDefenseModifier			= pClassInfo->getEspionageDefenseModifier();
	if (getAssetValue()							== 0)					m_iAssetValue						= pClassInfo->getAssetValue();
	if (getPowerValue()							== 0)					m_iPowerValue						= pClassInfo->getPowerValue();
	if (getMaxLatitude()						== 90)					m_iMaxLatitude						= pClassInfo->getMaxLatitude();
	if (getVisibilityPriority()					== 0.0f)				m_fVisibilityPriority				= pClassInfo->getVisibilityPriority();
	if (getConstructSound()						== cDefault)			setConstructSound(					pClassInfo->getConstructSound() );
	if (getFreeStartEra()						== NO_ERA)				m_iFreeStartEra						= pClassInfo->getFreeStartEra();
	if (getMaxStartEra()						== NO_ERA)				m_iMaxStartEra						= pClassInfo->getMaxStartEra();
	if (getObsoleteTech()						== NO_TECH)				m_iObsoleteTech						= pClassInfo->getObsoleteTech();
	if (getPrereqAndTech()						== NO_TECH)				m_iPrereqAndTech					= pClassInfo->getPrereqAndTech();
	if (getPrereqTrait()						== NO_TRAIT)			m_iPrereqTrait						= pClassInfo->getPrereqTrait();
	if (getPrereqTrait2() == NO_TRAIT)			m_iPrereqTrait2 = pClassInfo->getPrereqTrait2();
	if (getPrereqAndBonus()						== NO_BONUS)			m_iPrereqAndBonus					= pClassInfo->getPrereqAndBonus();
	if (getNoBonus()							== NO_BONUS)			m_iNoBonus							= pClassInfo->getNoBonus();
	if (getPowerBonus()							== NO_BONUS)			m_iPowerBonus						= pClassInfo->getPowerBonus();
	if (getFreeBonus()							== NO_BONUS)			m_iFreeBonus						= pClassInfo->getFreeBonus();
	if (getFreeBonus2()							== NO_BONUS)			m_iFreeBonus2						= pClassInfo->getFreeBonus2();
	if (getFreeBonus3()							== NO_BONUS)			m_iFreeBonus3						= pClassInfo->getFreeBonus3();
	if (getAdvisorType()						== NO_ADVISOR)			m_iAdvisorType						= pClassInfo->getAdvisorType();
	if (getVictoryPrereq()						== NO_VICTORY)			m_iVictoryPrereq					= pClassInfo->getVictoryPrereq();
	if (getHolyCity()							== NO_RELIGION)			m_iHolyCity							= pClassInfo->getHolyCity();
	if (getReligionType()						== NO_RELIGION)			m_iReligionType						= pClassInfo->getReligionType();
	if (getStateReligion()						== NO_RELIGION)			m_iStateReligion					= pClassInfo->getStateReligion();
	if (getPrereqReligion()						== NO_RELIGION)			m_iPrereqReligion					= pClassInfo->getPrereqReligion();
	if (getPrereqFlag() == NO_FLAG)			m_iPrereqFlag = pClassInfo->getPrereqFlag();
	if (getGlobalReligionCommerce()				== NO_RELIGION)			m_iGlobalReligionCommerce			= pClassInfo->getGlobalReligionCommerce();
	if (getEquipmentPromotion()					== NO_PROMOTION)		m_iEquipmentPromotion				= pClassInfo->getEquipmentPromotion();
	if (getFreePromotion()						== NO_PROMOTION)		m_iFreePromotion					= pClassInfo->getFreePromotion();
	if (getRemovePromotion()					== NO_PROMOTION)		m_iRemovePromotion					= pClassInfo->getRemovePromotion();
	if (getGreatPeopleUnitClass()				== NO_UNITCLASS)		m_iGreatPeopleUnitClass				= pClassInfo->getGreatPeopleUnitClass();
	if (getVoteSourceType()						== NO_VOTESOURCE)		m_iVoteSourceType					= pClassInfo->getVoteSourceType();
	if (getPrereqCorporation()					== NO_CORPORATION)		m_iPrereqCorporation				= pClassInfo->getPrereqCorporation();
	if (getPrereqCivic() == NO_CIVIC)		m_iPrereqCivic = pClassInfo->getPrereqCivic();
	if (getFoundsCorporation()					== NO_CORPORATION)		m_iFoundsCorporation				= pClassInfo->getFoundsCorporation();
	if (getGlobalCorporationCommerce()			== NO_CORPORATION)		m_iGlobalCorporationCommerce		= pClassInfo->getGlobalCorporationCommerce();
	if (getCivicOption()						== NO_CIVICOPTION)		m_iCivicOption						= pClassInfo->getCivicOption();
	if (getBuildingClassType()					== NO_BUILDINGCLASS)	m_iBuildingClassType				= pClassInfo->getBuildingClassType();
	if (getFreeBuildingClass()					== NO_BUILDINGCLASS)	m_iFreeBuildingClass				= pClassInfo->getFreeBuildingClass();
	if (getParentBuildingClass()				== NO_BUILDINGCLASS)	m_iParentBuildingClass				= pClassInfo->getParentBuildingClass();
	if (getSpecialBuildingType()				== NO_SPECIALBUILDING)	m_iSpecialBuildingType				= pClassInfo->getSpecialBuildingType();
	for ( int j = 0; j < GC.getNUM_BUILDING_AND_TECH_PREREQS(); j++)
	{
		if (getPrereqAndTechs(j)				== NO_TECH)				m_piPrereqAndTechs[j]				= pClassInfo->getPrereqAndTechs(j);
	}
	for ( int j = 0; j < GC.getNUM_BUILDING_PREREQ_OR_BONUSES(); j++)
	{
		if (getPrereqOrBonuses(j)				== NO_BONUS)			m_piPrereqOrBonuses[j]				= pClassInfo->getPrereqOrBonuses(j);
	}
	for ( int j = 0; j < GC.getNumTraitInfos(); j++)
	{
		if (getProductionTraits(j)				== 0)					m_piProductionTraits[j]				= pClassInfo->getProductionTraits(j);
		if (getHappinessTraits(j)				== 0)					m_piHappinessTraits[j]				= pClassInfo->getHappinessTraits(j);
	}
	for ( int j = 0; j < NUM_YIELD_TYPES; j++)
	{
		if (getSeaPlotYieldChange(j)			== 0)					m_piSeaPlotYieldChange[j]			= pClassInfo->getSeaPlotYieldChange(j);
		if (getRiverPlotYieldChange(j)			== 0)					m_piRiverPlotYieldChange[j]			= pClassInfo->getRiverPlotYieldChange(j);
		if (getGlobalSeaPlotYieldChange(j)		== 0)					m_piGlobalSeaPlotYieldChange[j]		= pClassInfo->getGlobalSeaPlotYieldChange(j);
		if (getYieldChange(j)					== 0)					m_piYieldChange[j]					= pClassInfo->getYieldChange(j);
		if (getYieldModifier(j)					== 0)					m_piYieldModifier[j]				= pClassInfo->getYieldModifier(j);
		if (getPowerYieldModifier(j)			== 0)					m_piPowerYieldModifier[j]			= pClassInfo->getPowerYieldModifier(j);
		if (getAreaYieldModifier(j)				== 0)					m_piAreaYieldModifier[j]			= pClassInfo->getAreaYieldModifier(j);
		if (getGlobalYieldModifier(j)			== 0)					m_piGlobalYieldModifier[j]			= pClassInfo->getGlobalYieldModifier(j);
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
		if (getTradeYieldModifier(j)			== 0)					m_piTradeYieldModifier[j]			= pClassInfo->getTradeYieldModifier(j);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	}
	for ( int j = 0; j < NUM_COMMERCE_TYPES; j++)
	{
		if (getCommerceChange(j)				== 0)					m_piCommerceChange[j]				= pClassInfo->getCommerceChange(j);
		if (getObsoleteSafeCommerceChange(j)	== 0)					m_piObsoleteSafeCommerceChange[j]	= pClassInfo->getObsoleteSafeCommerceChange(j);
		if (getCommerceChangeDoubleTime(j)		== 0)					m_piCommerceChangeDoubleTime[j]		= pClassInfo->getCommerceChangeDoubleTime(j);
		if (getCommerceModifier(j)				== 0)					m_piCommerceModifier[j]				= pClassInfo->getCommerceModifier(j);
		if (getGlobalCommerceModifier(j)		== 0)					m_piGlobalCommerceModifier[j]		= pClassInfo->getGlobalCommerceModifier(j);
		if (getSpecialistExtraCommerce(j)		== 0)					m_piSpecialistExtraCommerce[j]		= pClassInfo->getSpecialistExtraCommerce(j);
		if (getStateReligionCommerce(j)			== 0)					m_piStateReligionCommerce[j]		= pClassInfo->getStateReligionCommerce(j);
		if (getCommerceHappiness(j)				== 0)					m_piCommerceHappiness[j]			= pClassInfo->getCommerceHappiness(j);
		if (isCommerceFlexible(j)				== false)				m_pbCommerceFlexible[j]				= pClassInfo->isCommerceFlexible(j);
		if (isCommerceChangeOriginalOwner(j)	== false)				m_pbCommerceChangeOriginalOwner[j]	= pClassInfo->isCommerceChangeOriginalOwner(j);
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**						Allows buildings to modify trade Yield and Commerces					**/
/*************************************************************************************************/
		if (getTradeCommerceModifier(j)			== 0)					m_piTradeCommerceModifier[j]		= pClassInfo->getTradeCommerceModifier(j);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	}
	for ( int j = 0; j < GC.getNumReligionInfos(); j++)
	{
		if (getReligionChange(j)				== 0)					m_piReligionChange[j]				= pClassInfo->getReligionChange(j);
	}
	for ( int j = 0; j < GC.getNumSpecialistInfos(); j++)
	{
		if (getSpecialistCount(j)				== 0)					m_piSpecialistCount[j]				= pClassInfo->getSpecialistCount(j);
		if (getFreeSpecialistCount(j)			== 0)					m_piFreeSpecialistCount[j]			= pClassInfo->getFreeSpecialistCount(j);
		for ( int i = 0; i < NUM_YIELD_TYPES; i++)
		{
			if (getSpecialistYieldChange(j, i)	== 0)					m_ppaiSpecialistYieldChange[j][i]	= pClassInfo->getSpecialistYieldChange(j, i);
		}
		for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
		{
			if (getSpecialistCommerceChange(j, i)== 0)					m_ppaiSpecialistCommerceChange[j][i]= pClassInfo->getSpecialistCommerceChange(j, i);
		}
	}

/*************************************************************************************************/
/**	GWSLocalSpecialist																	Milaga	**/
/** Buildings can change give bonuses to specialists in only one city							**/
/*************************************************************************************************/
	for (int i = 0; i < GC.getNumSpecialistInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (getLocalSpecialistYieldChange(i, j)	== 0)	m_paaiLocalSpecialistYieldChange[i][j]		= pClassInfo->getLocalSpecialistYieldChange(i, j);
		}
		for (int j = 0; j < NUM_COMMERCE_TYPES; j++)
		{
			if (getLocalSpecialistCommerceChange(i, j)== 0)	m_paaiLocalSpecialistCommerceChange[i][j]	= pClassInfo->getLocalSpecialistCommerceChange(i, j);
		}
		if (getLocalSpecialistHappinessChange(i)== 0)		m_paiLocalSpecialistHappinessChange[i]		= pClassInfo->getLocalSpecialistHappinessChange(i);
		if (getLocalSpecialistHealthChange(i)== 0)			m_paiLocalSpecialistHealthChange[i]			= pClassInfo->getLocalSpecialistHealthChange(i);
		if (getLocalSpecialistCrimeChange(i) == 0)			m_paiLocalSpecialistCrimeChange[i] = pClassInfo->getLocalSpecialistCrimeChange(i);
		if (getLocalSpecialistGPPChange(i)== 0)				m_paiLocalSpecialistGPPChange[i]			= pClassInfo->getLocalSpecialistGPPChange(i);
	}
/*************************************************************************************************/
/**	GWSLocalSpecialist																		END	**/
/*************************************************************************************************/

	for ( int j = 0; j < GC.getNumBonusInfos(); j++)
	{
		if (getBonusHealthChanges(j)			== 0)					m_piBonusHealthChanges[j]			= pClassInfo->getBonusHealthChanges(j);
		if (getBonusHappinessChanges(j)			== 0)					m_piBonusHappinessChanges[j]		= pClassInfo->getBonusHappinessChanges(j);
		if (getBonusProductionModifier(j)		== 0)					m_piBonusProductionModifier[j]		= pClassInfo->getBonusProductionModifier(j);
		for ( int i = 0; i < NUM_YIELD_TYPES; i++)
		{
/*************************************************************************************************/
/**	Tweak							14/07/10								Snarko				**/
/**																								**/
/**					It's the other way around, (bonus, yield)									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			if (getBonusYieldModifier(i, j)		== 0)					m_ppaiBonusYieldModifier[i][j]		= pClassInfo->getBonusYieldModifier(i, j);
/**								----  End Original Code  ----									**/
			if (getBonusYieldModifier(j, i)		== 0)					m_ppaiBonusYieldModifier[j][i]		= pClassInfo->getBonusYieldModifier(j, i);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		}
		for (int i = 0; i < NUM_COMMERCE_TYPES; i++)
		{
			if (getBonusCommerceModifier(j, i) == 0)					m_ppaiBonusCommerceModifier[j][i] = pClassInfo->getBonusCommerceModifier(j, i);
		}
		if (getPotencyAffinity(j) == 0.0f)				m_pafPotencyAffinity[j] = pClassInfo->getPotencyAffinity(j);
		if (getGlobalPotencyAffinity(j)			== 0.0f)				m_pafGlobalPotencyAffinity[j]		= pClassInfo->getGlobalPotencyAffinity(j);
		if (getShieldingAffinity(j)				== 0.0f)				m_pafShieldingAffinity[j]			= pClassInfo->getShieldingAffinity(j);
		if (getGlobalShieldingAffinity(j)		== 0.0f)				m_pafGlobalShieldingAffinity[j]		= pClassInfo->getGlobalShieldingAffinity(j);
		if (getPotencyBonusPrereq(j)			== 0)					m_paiPotencyBonusPrereq[j]			= pClassInfo->getPotencyBonusPrereq(j);
		if (getGlobalPotencyBonusPrereq(j)		== 0)					m_paiGlobalPotencyBonusPrereq[j]	= pClassInfo->getGlobalPotencyBonusPrereq(j);
		if (getShieldingBonusPrereq(j)			== 0)					m_paiShieldingBonusPrereq[j]		= pClassInfo->getShieldingBonusPrereq(j);
		if (getGlobalShieldingBonusPrereq(j)	== 0)					m_paiGlobalShieldingBonusPrereq[j]	= pClassInfo->getGlobalShieldingBonusPrereq(j);
	}
	for ( int j = 0; j < GC.getNumUnitCombatInfos(); j++)
	{
		if (getUnitCombatFreeExperience(j)		== 0)					m_piUnitCombatFreeExperience[j]		= (float)pClassInfo->getUnitCombatFreeExperience(j)/100.0f;
		if (getTrainXPCap(j)					== 0)					m_pafTrainXPCap[j]					= (float)pClassInfo->getTrainXPCap(j)/100.0f;
		if (getGlobalTrainXPCap(j)				== 0)					m_pafGlobalTrainXPCap[j]			= (float)pClassInfo->getGlobalTrainXPCap(j)/100.0f;
		if (getTrainXPRate(j)					== 0.0f)				m_pafTrainXPRate[j]					= pClassInfo->getTrainXPRate(j);
		if (getGlobalTrainXPRate(j)				== 0.0f)				m_pafGlobalTrainXPRate[j]			= pClassInfo->getGlobalTrainXPRate(j);
		if (getPerCrimeTrainXPCap(j) == 0)					m_pafPerCrimeTrainXPCap[j] = (float)pClassInfo->getPerCrimeTrainXPCap(j) / 100.0f;
		if (getPerCrimeTrainXPRate(j) == 0.0f)				m_pafPerCrimeTrainXPRate[j] = pClassInfo->getPerCrimeTrainXPRate(j);
	}
	for ( int j = 0; j < NUM_DOMAIN_TYPES; j++)
	{
		if (m_piDomainFreeExperience[j]			== 0)					m_piDomainFreeExperience[j]			= (float)(pClassInfo->getDomainFreeExperience(j)/100.0);
		if (m_piDomainProductionModifier[j]		== 0)					m_piDomainProductionModifier[j]		= pClassInfo->getDomainProductionModifier(j);
	}
	for ( int j = 0; j < GC.getNumBuildingClassInfos(); j++)
	{
		if (isBuildingClassNeededInCity(j)		== false)				m_pbBuildingClassNeededInCity[j]	= pClassInfo->isBuildingClassNeededInCity(j);
		if (getPrereqNumOfBuildingClass(j)		== 0)					m_piPrereqNumOfBuildingClass[j]		= pClassInfo->getPrereqNumOfBuildingClass(j);
		if (getPrereqBuildingClassAtRange(j) == 0)					m_piPrereqBuildingClassAtRange[j] = pClassInfo->getPrereqBuildingClassAtRange(j);
		if (getBuildingExclude(j) == 0)					m_piBuildingExclude[j] = pClassInfo->getBuildingExclude(j);
		if (getPrereqTeamBuildingClassAND(j)	== 0)					m_piPrereqTeamBuildingClassANDs[j]	= pClassInfo->getPrereqTeamBuildingClassAND(j);
		if (getPrereqTeamBuildingClassNOT(j)	== 0)					m_piPrereqTeamBuildingClassNOTs[j]	= pClassInfo->getPrereqTeamBuildingClassNOT(j);
		if (getPrereqTeamBuildingClassOR(j)		== 0)					m_piPrereqTeamBuildingClassORs[j]	= pClassInfo->getPrereqTeamBuildingClassOR(j);
		if (getPrereqGlobalBuildingClassAND(j)	== 0)					m_piPrereqGlobalBuildingClassANDs[j]= pClassInfo->getPrereqGlobalBuildingClassAND(j);
		if (getPrereqGlobalBuildingClassNOT(j)	== 0)					m_piPrereqGlobalBuildingClassNOTs[j]= pClassInfo->getPrereqGlobalBuildingClassNOT(j);
		if (getPrereqGlobalBuildingClassOR(j)	== 0)					m_piPrereqGlobalBuildingClassORs[j]	= pClassInfo->getPrereqGlobalBuildingClassOR(j);
	}
	//Storing these values allows us to skip the loop over all buildingclasses if there aren't any prereqs needing checked.
	m_iNumPrereqTeamBuildingClassANDs=0;
	m_iNumPrereqTeamBuildingClassNOTs=0;
	m_iNumPrereqTeamBuildingClassORs=0;
	m_iNumPrereqGlobalBuildingClassANDs=0;
	m_iNumPrereqGlobalBuildingClassNOTs=0;
	m_iNumPrereqGlobalBuildingClassORs=0;
	for (j=0;j<GC.getNumBuildingClassInfos();j++)
	{
		if (getPrereqTeamBuildingClassAND(j) 	> 0)	m_iNumPrereqTeamBuildingClassANDs++;
		if (getPrereqTeamBuildingClassNOT(j) 	> 0)	m_iNumPrereqTeamBuildingClassNOTs++;
		if (getPrereqTeamBuildingClassOR(j) 	> 0)	m_iNumPrereqTeamBuildingClassORs++;
		if (getPrereqGlobalBuildingClassAND(j) 	> 0)	m_iNumPrereqGlobalBuildingClassANDs++;
		if (getPrereqGlobalBuildingClassNOT(j) 	> 0)	m_iNumPrereqGlobalBuildingClassNOTs++;
		if (getPrereqGlobalBuildingClassOR(j) 	> 0)	m_iNumPrereqGlobalBuildingClassORs++;
	}
	for ( int j = 0; j < GC.getNumFlavorTypes(); j++)
	{
		if (getFlavorValue(j)					== 0)					m_piFlavorValue[j]					= pClassInfo->getFlavorValue(j);
	}
	for ( int j = 0; j < GC.getNumImprovementInfos(); j++)
	{
		if (getImprovementFreeSpecialist(j)		== 0)					m_piImprovementFreeSpecialist[j]	= pClassInfo->getImprovementFreeSpecialist(j);
	}
	for ( int j = 0; j < GC.getNumBuildingClassInfos(); j++)
	{
		if (getBuildingHappinessChanges(j)		== 0)					m_piBuildingHappinessChanges[j]		= pClassInfo->getBuildingHappinessChanges(j);
	}
	for (int i = 0; i < pClassInfo->getNumPerPopBonuses(); ++i)
	{
		CityBonuses cbTemp;
		cbTemp = pClassInfo->getPerPopBonus(i);
		m_cbPerPopBonuses.push_back(cbTemp);
		m_iNumPerPopBonuses++;
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvSpecialBuildingInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpecialBuildingInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialBuildingInfo::CvSpecialBuildingInfo() :
m_iObsoleteTech(NO_TECH),
m_iTechPrereq(NO_TECH),
m_iTechPrereqAnyone(NO_TECH),
m_bValid(false),
m_piProductionTraits(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpecialBuildingInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialBuildingInfo::~CvSpecialBuildingInfo()
{
	SAFE_DELETE_ARRAY(m_piProductionTraits);
}

int CvSpecialBuildingInfo::getObsoleteTech( void ) const
{
	return m_iObsoleteTech;
}

int CvSpecialBuildingInfo::getTechPrereq( void ) const
{
	return m_iTechPrereq;
}

int CvSpecialBuildingInfo::getTechPrereqAnyone( void ) const
{
	return m_iTechPrereqAnyone;
}

bool CvSpecialBuildingInfo::isValid( void ) const
{
	return m_bValid;
}

// Arrays

int CvSpecialBuildingInfo::getProductionTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
}

bool CvSpecialBuildingInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ObsoleteTech");
	m_iObsoleteTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TechPrereqAnyone");
	m_iTechPrereqAnyone = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bValid, "bValid");

	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpecialBuildingInfo::copyNonDefaults(CvSpecialBuildingInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getObsoleteTech()				== 0)			m_iObsoleteTech				= pClassInfo->getObsoleteTech();
	if (getTechPrereq()					== 0)			m_iTechPrereq				= pClassInfo->getTechPrereq();
	if (getTechPrereqAnyone()			== 0)			m_iTechPrereqAnyone			= pClassInfo->getTechPrereqAnyone();
	if (isValid()						== false)		m_bValid					= pClassInfo->isValid();
	for (int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if (m_piProductionTraits[i]		== 0)			m_piProductionTraits[i]		= pClassInfo->getProductionTraits(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvBuildingClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBuildingClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingClassInfo::CvBuildingClassInfo() :
m_iMaxGlobalInstances(0),
m_iMaxTeamInstances(0),
m_iMaxPlayerInstances(0),
m_iExtraPlayerInstances(0),
m_iDefaultBuildingIndex(NO_BUILDING),
m_bNoLimit(false),
m_bMonument(false),
/*************************************************************************************************/
/**	New Tag Defs	(BuildingClassInfos)	10/18/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_bUnique(false),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_piVictoryThreshold(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBuildingClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingClassInfo::~CvBuildingClassInfo()
{
	SAFE_DELETE_ARRAY(m_piVictoryThreshold);
}

int CvBuildingClassInfo::getMaxGlobalInstances() const
{
	return m_iMaxGlobalInstances;
}

int CvBuildingClassInfo::getMaxTeamInstances() const
{
	return m_iMaxTeamInstances;
}

int CvBuildingClassInfo::getMaxPlayerInstances() const
{
	return m_iMaxPlayerInstances;
}

int CvBuildingClassInfo::getExtraPlayerInstances() const
{
	return m_iExtraPlayerInstances;
}

int CvBuildingClassInfo::getDefaultBuildingIndex() const
{
	return m_iDefaultBuildingIndex;
}

void CvBuildingClassInfo::setDefaultBuildingIndex(int i)
{
	m_iDefaultBuildingIndex = i;
}

bool CvBuildingClassInfo::isNoLimit() const
{
	return m_bNoLimit;
}

bool CvBuildingClassInfo::isMonument() const
{
	return m_bMonument;
}
/*************************************************************************************************/
/**	New Tag Defs	(BuildingClassInfos)	10/18/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
bool CvBuildingClassInfo::isUnique() const
{
	return m_bUnique;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

// Arrays

int CvBuildingClassInfo::getVictoryThreshold(int i) const
{
	FAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piVictoryThreshold ? m_piVictoryThreshold[i] : -1;
}

bool CvBuildingClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iMaxGlobalInstances, "iMaxGlobalInstances");
	pXML->GetChildXmlValByName(&m_iMaxTeamInstances, "iMaxTeamInstances");
	pXML->GetChildXmlValByName(&m_iMaxPlayerInstances, "iMaxPlayerInstances");
	pXML->GetChildXmlValByName(&m_iExtraPlayerInstances, "iExtraPlayerInstances");

	pXML->GetChildXmlValByName(&m_bNoLimit, "bNoLimit");
	pXML->GetChildXmlValByName(&m_bMonument, "bMonument");
/*************************************************************************************************/
/**	New Tag Defs	(BuildingClassInfos)	10/18/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bUnique, "bUnique");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piVictoryThreshold, "VictoryThresholds", sizeof(GC.getVictoryInfo((VictoryTypes)0)), GC.getNumVictoryInfos());

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "DefaultBuilding");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	return true;
}

bool CvBuildingClassInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iDefaultBuildingIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iTextDefault = -1;
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]) != iTextDefault)
		{
			m_iDefaultBuildingIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(BuildingClassInfos)	10/18/08								Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBuildingClassInfo::copyNonDefaults(CvBuildingClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getMaxGlobalInstances()			== 0)				m_iMaxGlobalInstances		= pClassInfo->getMaxGlobalInstances();
	if (getMaxTeamInstances()			== 0)				m_iMaxTeamInstances			= pClassInfo->getMaxTeamInstances();
	if (getMaxPlayerInstances()			== 0)				m_iMaxPlayerInstances		= pClassInfo->getMaxPlayerInstances();
	if (getExtraPlayerInstances()		== 0)				m_iExtraPlayerInstances		= pClassInfo->getExtraPlayerInstances();
	if (isNoLimit()						== false)			m_bNoLimit					= pClassInfo->isNoLimit();
	if (isMonument()					== false)			m_bMonument					= pClassInfo->isMonument();
	if (isUnique()						== false)			m_bUnique					= pClassInfo->isUnique();
	for ( int i = 0; i < GC.getNumVictoryInfos(); i++ )
	{
		if (m_piVictoryThreshold[i]		== 0)				m_piVictoryThreshold[i]		= pClassInfo->getVictoryThreshold(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvRiverInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRiverInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRiverInfo::CvRiverInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRiverInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRiverInfo::~CvRiverInfo()
{
}

//======================================================================================================
//					CvRiverModelInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRiverModelInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRiverModelInfo::CvRiverModelInfo() :
m_iTextureIndex(0)
{
	m_szDeltaString[0] = '\0';
	m_szConnectString[0] = '\0';
	m_szRotateString[0] = '\0';
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRiverModelInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRiverModelInfo::~CvRiverModelInfo()
{
}

const TCHAR* CvRiverModelInfo::getModelFile() const
{
	return m_szModelFile;
}

void CvRiverModelInfo::setModelFile(const TCHAR* szVal)					// The model filename
{
	m_szModelFile=szVal;
}

const TCHAR* CvRiverModelInfo::getBorderFile() const
{
	return m_szBorderFile;
}

void CvRiverModelInfo::setBorderFile(const TCHAR* szVal)					// The model filename
{
	m_szBorderFile=szVal;
}

int CvRiverModelInfo::getTextureIndex() const
{
	return m_iTextureIndex;
}

const TCHAR* CvRiverModelInfo::getDeltaString() const
{
	return m_szDeltaString;
}

const TCHAR* CvRiverModelInfo::getConnectString() const
{
	return m_szConnectString;
}

const TCHAR* CvRiverModelInfo::getRotateString() const
{
	return m_szRotateString;
}

bool CvRiverModelInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	if(pXML->GetChildXmlValByName(szTextVal, "ModelFile"))
	{
		setModelFile(szTextVal);
	}
	if(pXML->GetChildXmlValByName(szTextVal, "BorderFile"))
	{
		setBorderFile(szTextVal);
	}

	pXML->GetChildXmlValByName(&m_iTextureIndex, "TextureIndex");
	pXML->GetChildXmlValByName(m_szDeltaString, "DeltaType");
	pXML->GetChildXmlValByName(m_szConnectString, "Connections");
	pXML->GetChildXmlValByName(m_szRotateString, "Rotations");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvRiverModelInfo::copyNonDefaults(CvRiverModelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTextureIndex()	== 0)			m_iTextureIndex													= pClassInfo->getTextureIndex();
	if (getModelFile()		== cDefault)	setModelFile(													pClassInfo->getModelFile());
	if (getBorderFile()		== cDefault)	setBorderFile(													pClassInfo->getBorderFile());
	if (getDeltaString()	== cDefault)	strcpy (m_szDeltaString, (LPCTSTR) CvString::format("%s",		pClassInfo->getDeltaString()));
	if (getConnectString()	== cDefault)	strcpy (m_szConnectString, (LPCTSTR) CvString::format("%s",		pClassInfo->getConnectString()));
	if (getRotateString()	== cDefault)	strcpy (m_szRotateString, (LPCTSTR) CvString::format("%s",		pClassInfo->getRotateString()));
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvRouteModelInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRouteModelInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRouteModelInfo::CvRouteModelInfo() :
m_eRouteType(NO_ROUTE),
m_bAnimated(false)
{
	m_szConnectString[0] = '\0';
	m_szModelConnectString[0] = '\0';
	m_szRotateString[0] = '\0';
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRouteModelInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRouteModelInfo::~CvRouteModelInfo()
{
}

RouteTypes CvRouteModelInfo::getRouteType() const		// The route type
{
	return m_eRouteType;
}

const TCHAR* CvRouteModelInfo::getModelFile() const
{
	return m_szModelFile;
}

void CvRouteModelInfo::setModelFile(const TCHAR* szVal)				// The model filename
{
	m_szModelFile=szVal;
}

const TCHAR* CvRouteModelInfo::getLateModelFile() const
{
	return m_szLateModelFile;
}

void CvRouteModelInfo::setLateModelFile(const TCHAR* szVal)				// The model filename
{
	m_szLateModelFile=szVal;
}

const TCHAR* CvRouteModelInfo::getModelFileKey() const
{
	return m_szModelFileKey;
}

void CvRouteModelInfo::setModelFileKey(const TCHAR* szVal)				// The model filename Key
{
	m_szModelFileKey=szVal;
}

bool CvRouteModelInfo::isAnimated() const
{
	return m_bAnimated;
}

const TCHAR* CvRouteModelInfo::getConnectString() const
{
	return m_szConnectString;
}

const TCHAR* CvRouteModelInfo::getModelConnectString() const
{
	return m_szModelConnectString;
}

const TCHAR* CvRouteModelInfo::getRotateString() const
{
	return m_szRotateString;
}

bool CvRouteModelInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ModelFile");
	setModelFile(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "LateModelFile");
	setLateModelFile(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ModelFileKey");
	setModelFileKey(szTextVal);

	pXML->GetChildXmlValByName(&m_bAnimated, "Animated");

	pXML->GetChildXmlValByName(szTextVal, "RouteType");
	m_eRouteType = (RouteTypes)(pXML->FindInInfoClass(szTextVal));
	pXML->GetChildXmlValByName(m_szConnectString, "Connections");
	pXML->GetChildXmlValByName(m_szModelConnectString, "ModelConnections");
	pXML->GetChildXmlValByName(m_szRotateString, "Rotations");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvRouteModelInfo::copyNonDefaults(CvRouteModelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isAnimated()				== false)			m_bAnimated															= pClassInfo->isAnimated();
	if (getRouteType()				== NO_ROUTE)		m_eRouteType														= pClassInfo->getRouteType();
	if (getModelFile()				== cDefault)		setModelFile(														pClassInfo->getModelFile());
	if (getLateModelFile()			== cDefault)		setLateModelFile(													pClassInfo->getLateModelFile());
	if (getModelFileKey()			== cDefault)		setModelFileKey(													pClassInfo->getModelFileKey());
	if (getConnectString()			== cDefault)		strcpy (m_szConnectString, (LPCTSTR) CvString::format("%s",			pClassInfo->getConnectString()));
	if (getModelConnectString()		== cDefault)		strcpy (m_szModelConnectString, (LPCTSTR) CvString::format("%s",	pClassInfo->getModelConnectString()));
	if (getRotateString()			== cDefault)		strcpy (m_szRotateString, (LPCTSTR) CvString::format("%s",			pClassInfo->getRotateString()));
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCivilizationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCivilizationInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCivilizationInfo::CvCivilizationInfo():
m_iDefaultPlayerColor(NO_PLAYERCOLOR),
m_iArtStyleType(NO_ARTSTYLE),
m_iUnitArtStyleType(NO_UNIT_ARTSTYLE),
m_iNumCityNames(0),
m_iNumLeaders(0),
m_iSelectionSoundScriptId(0),
m_iActionSoundScriptId(0),
m_iDerivativeCiv(NO_CIVILIZATION),
m_bPlayable(false),
m_bAIPlayable(false),
m_bNoCrimeCiv(false),
m_piCivilizationBuildingArtDefines(NULL),
m_piCivilizationBuildings(NULL),
m_piCivilizationUnits(NULL),
m_piCivilizationFreeUnitsClass(NULL),
m_piCivilizationInitialCivics(NULL),
m_pbLeaders(NULL),
m_pbSecondaryLeaders(NULL),
m_pbCivilizationFreeBuildingClass(NULL),
m_pbCivilizationFreeTechs(NULL),
m_pbCivilizationDisableTechs(NULL),
m_paszCityNames(NULL),
m_piFlavorValue(NULL),
//InterfaceUpgrade: Better Pedia - Added by Grey Fox 04/18/2008
m_szCivilizationImage(NULL),
//Interface Upgrade: Better Pedia - End Add

//FfH: Added by Kael 08/07/2007
m_iCivTrait(NO_TRAIT),
m_iDefaultRace(NO_PROMOTION),
m_iHero(NO_UNIT),
m_pbMaintainFeatures(NULL)
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(CivilizationInfos)		01/12/09								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
,m_bLimitedSelection(false),
m_piFeatureHealthPercentChanges(NULL),
m_ppiFeatureYieldChanges(NULL),
m_ppiImprovementYieldChanges(NULL),
m_ppiTerrainYieldChanges(NULL)

//ClimateSystem:
,m_iFormClimateZoneType(NO_CLIMATEZONE)
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Civilization Flavors				07/07/10										Snarko	**/
/**																								**/
/**							Making civilization flavors,										**/
/**			for helping AI with things we can't really add in a non-hardcoded way				**/
/*************************************************************************************************/
,m_piCivFlavorValue(NULL)
/*************************************************************************************************/
/**	Civilization Flavors					END													**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCivilizationInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCivilizationInfo::~CvCivilizationInfo()
{
	SAFE_DELETE_ARRAY(m_piCivilizationBuildingArtDefines);
	SAFE_DELETE_ARRAY(m_piCivilizationBuildings);
	SAFE_DELETE_ARRAY(m_piCivilizationUnits);
	SAFE_DELETE_ARRAY(m_piCivilizationFreeUnitsClass);
	SAFE_DELETE_ARRAY(m_piCivilizationInitialCivics);
	SAFE_DELETE_ARRAY(m_pbLeaders);
	SAFE_DELETE_ARRAY(m_pbSecondaryLeaders);
	SAFE_DELETE_ARRAY(m_pbCivilizationFreeBuildingClass);
	SAFE_DELETE_ARRAY(m_pbCivilizationFreeTechs);
	SAFE_DELETE_ARRAY(m_pbCivilizationDisableTechs);
	SAFE_DELETE_ARRAY(m_paszCityNames);
	SAFE_DELETE_ARRAY(m_piFlavorValue);

/*************************************************************************************************/
/**	New Tag Defs	(CivilizationInfos)		03/23/09								Jean Elcard	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piFeatureHealthPercentChanges);

	if (m_ppiFeatureYieldChanges != NULL)
	{
		for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiFeatureYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiFeatureYieldChanges);
	}

	if (m_ppiImprovementYieldChanges != NULL)
	{
		for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges);
	}

	if (m_ppiTerrainYieldChanges != NULL)
	{
		for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiTerrainYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiTerrainYieldChanges);
	}
	SAFE_DELETE_ARRAY(m_paiPeakYieldChange);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

//FfH: Added by Kael 05/27/2008
	SAFE_DELETE_ARRAY(m_pbMaintainFeatures);
//FfH: End Add
/*************************************************************************************************/
/**	Civilization Flavors				07/07/10										Snarko	**/
/**																								**/
/**							Making civilization flavors,										**/
/**			for helping AI with things we can't really add in a non-hardcoded way				**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piCivFlavorValue);
/*************************************************************************************************/
/**	Civilization Flavors					END													**/
/*************************************************************************************************/

}

void CvCivilizationInfo::reset()
{
	CvInfoBase::reset();
	m_aszAdjective.clear();
	m_aszShortDescription.clear();
}


int CvCivilizationInfo::getDefaultPlayerColor() const
{
	return m_iDefaultPlayerColor;
}

int CvCivilizationInfo::getArtStyleType() const
{
	return m_iArtStyleType;
}

int CvCivilizationInfo::getUnitArtStyleType() const
{
	return m_iUnitArtStyleType;
}

int CvCivilizationInfo::getNumCityNames() const
{
	return m_iNumCityNames;
}

int CvCivilizationInfo::getNumLeaders() const// the number of leaders the Civ has, this is needed so that random leaders can be generated easily
{
	return m_iNumLeaders;
}

int CvCivilizationInfo::getSelectionSoundScriptId() const
{
	return m_iSelectionSoundScriptId;
}

int CvCivilizationInfo::getActionSoundScriptId() const
{
	return m_iActionSoundScriptId;
}

bool CvCivilizationInfo::isAIPlayable() const
{

//FfH: Added by Kael 07/01/2008
	if (CvPlayerAI::areStaticsInitialized())
	{
		if (GC.getGameINLINE().isFinalInitialized())
		{
			if (isGraphicalOnly())
			{
				return false;
			}
		}
	}
//FfH: End Add

	return m_bAIPlayable;
}

bool CvCivilizationInfo::isPlayable() const
{

//FfH: Added by Kael 07/01/2008
	if (CvPlayerAI::areStaticsInitialized())
	{
		if (GC.getGameINLINE().isFinalInitialized())
		{
			if (isGraphicalOnly())
			{
				return false;
			}
		}
	}
//FfH: End Add

	return m_bPlayable;
}
bool CvCivilizationInfo::isNoCrimeCiv() const
{


	return m_bNoCrimeCiv;
}

const wchar* CvCivilizationInfo::getShortDescription(uint uiForm)
{
	while(m_aszShortDescription.size() <= uiForm)
	{
		m_aszShortDescription.push_back(gDLL->getObjectText(m_szShortDescriptionKey, m_aszShortDescription.size()));
	}

	return m_aszShortDescription[uiForm];
}

const wchar* CvCivilizationInfo::getShortDescriptionKey() const
{
	return m_szShortDescriptionKey;
}

const wchar* CvCivilizationInfo::getAdjective(uint uiForm)
{
	while(m_aszAdjective.size() <= uiForm)
	{
		m_aszAdjective.push_back(gDLL->getObjectText(m_szAdjectiveKey, m_aszAdjective.size()));
	}

	return m_aszAdjective[uiForm];
}

const wchar* CvCivilizationInfo::getAdjectiveKey() const
{
	return m_szAdjectiveKey;
}

const TCHAR* CvCivilizationInfo::getFlagTexture() const
{
	return ARTFILEMGR.getCivilizationArtInfo( getArtDefineTag() )->getPath();
}

const TCHAR* CvCivilizationInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvCivilizationInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

//InterfaceUpgrade: Better Pedia - Added by Grey Fox 04/18/2008
const TCHAR* CvCivilizationInfo::getImage() const
{
	return m_szCivilizationImage;
}
void CvCivilizationInfo::setImage(const TCHAR* szVal)
{
	m_szCivilizationImage = szVal;
}
//Interface Upgrade: Better Pedia - End Add

//FfH: Added by Kael 08/07/2007
int CvCivilizationInfo::getCivTrait() const
{
	return m_iCivTrait;
}

int CvCivilizationInfo::getDefaultRace() const
{
	return m_iDefaultRace;
}

int CvCivilizationInfo::getHero() const
{
	return m_iHero;
}

bool CvCivilizationInfo::isMaintainFeatures(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbMaintainFeatures ? m_pbMaintainFeatures[i] : false;
}
//FfH: End Add

// Arrays

CvString CvCivilizationInfo::getCivilizationBuildingArtDefines(int i) const
{
	CvString cDefault = CvString::format("").GetCString();

	FAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationBuildingArtDefines ? m_piCivilizationBuildingArtDefines[i] : cDefault;
}


int CvCivilizationInfo::getCivilizationBuildings(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationBuildings ? m_piCivilizationBuildings[i] : -1;
}

int CvCivilizationInfo::getCivilizationUnits(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationUnits ? m_piCivilizationUnits[i] : -1;
}

int CvCivilizationInfo::getCivilizationFreeUnitsClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationFreeUnitsClass ? m_piCivilizationFreeUnitsClass[i] : -1;
}

int CvCivilizationInfo::getCivilizationInitialCivics(int i) const
{
	FAssertMsg(i < GC.getNumCivicOptionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationInitialCivics ? m_piCivilizationInitialCivics[i] : -1;
}

bool CvCivilizationInfo::isLeaders(int i) const
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbLeaders ? m_pbLeaders[i] : false;
}
bool CvCivilizationInfo::isSecondaryLeaders(int i) const
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbSecondaryLeaders ? m_pbSecondaryLeaders[i] : false;
}

bool CvCivilizationInfo::isPediaLeaders(int i) const
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return isLeaders(i) || isSecondaryLeaders(i);
}

bool CvCivilizationInfo::isCivilizationFreeBuildingClass(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationFreeBuildingClass ? m_pbCivilizationFreeBuildingClass[i] : false;
}

bool CvCivilizationInfo::isCivilizationFreeTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationFreeTechs ? m_pbCivilizationFreeTechs[i] : false;
}

bool CvCivilizationInfo::isCivilizationDisableTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationDisableTechs ? m_pbCivilizationDisableTechs[i] : false;
}

const CvArtInfoCivilization* CvCivilizationInfo::getArtInfo() const
{
	return ARTFILEMGR.getCivilizationArtInfo( getArtDefineTag() );
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**Not entirely certain about the last few lines here, but it is safety measures to preven NULLs**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
const TCHAR* CvCivilizationInfo::getButton() const
{
	return getArtInfo()->getButton();
}
/**								----  End Original Code  ----									**/
const TCHAR* CvCivilizationInfo::getButton() const
{
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
	const CvArtInfoCivilization * pArtInfoCivilization;
	pArtInfoCivilization = getArtInfo();
	if (pArtInfoCivilization != NULL)
	{
		return getArtInfo()->getButton();
	}
	return NULL;
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

std::string CvCivilizationInfo::getCityNames(int i) const
{
	FAssertMsg(i < getNumCityNames(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paszCityNames[i];
}

int CvCivilizationInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvCivilizationInfo::getDerivativeCiv() const
{
	return m_iDerivativeCiv;
}

void CvCivilizationInfo::setDerivativeCiv(int iCiv)
{
	m_iDerivativeCiv = iCiv;
}

/*************************************************************************************************/
/**	New Tag Defs	(CivilizationInfos)		03/23/09								Jean Elcard	**/
/**																								**/
/**							Methods for accessing member variables.								**/
/*************************************************************************************************/
void CvCivilizationInfo::setAIPlayable(bool bPlayable)
{
	m_bAIPlayable = bPlayable;
}

void CvCivilizationInfo::setPlayable(bool bPlayable)
{
	m_bPlayable = bPlayable;
}

bool CvCivilizationInfo::isLimitedSelection() const
{
	return m_bLimitedSelection;
}

int CvCivilizationInfo::getFeatureHealthPercentChange(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureHealthPercentChanges ? m_piFeatureHealthPercentChanges[i] : -1;
}

int CvCivilizationInfo::getFeatureYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiFeatureYieldChanges[i][j];
}

int CvCivilizationInfo::getImprovementYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiImprovementYieldChanges[i][j];
}

int CvCivilizationInfo::getTerrainYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiTerrainYieldChanges[i][j];
}
int CvCivilizationInfo::getPeakYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiPeakYieldChange ? m_paiPeakYieldChange[i] : -1;
}

//ClimateSystem:

int CvCivilizationInfo::getFormClimateZoneType() const
{
	return m_iFormClimateZoneType;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Civilization Flavors				07/07/10										Snarko	**/
/**																								**/
/**							Making civilization flavors,										**/
/**			for helping AI with things we can't really add in a non-hardcoded way				**/
/*************************************************************************************************/
int CvCivilizationInfo::getCivFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumCivFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivFlavorValue ? m_piCivFlavorValue[i] : 0;
}
/*************************************************************************************************/
/**	Civilization Flavors					END													**/
/*************************************************************************************************/

void CvCivilizationInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iDefaultPlayerColor);
	stream->Read(&m_iArtStyleType);
	stream->Read(&m_iUnitArtStyleType);   // FlavorUnits by Impaler[WrG]
	stream->Read(&m_iNumCityNames);
	stream->Read(&m_iNumLeaders);
	stream->Read(&m_iSelectionSoundScriptId);
	stream->Read(&m_iActionSoundScriptId);
	stream->Read(&m_iDerivativeCiv);
	stream->Read(&m_bAIPlayable);
	stream->Read(&m_bPlayable);
	stream->Read(&m_bNoCrimeCiv);

	stream->ReadString(m_szArtDefineTag);
	stream->ReadString(m_szShortDescriptionKey);
	stream->ReadString(m_szAdjectiveKey);

//InterfaceUpgrade: Better Pedia - Added by Grey Fox 04/18/2008
	stream->ReadString(m_szCivilizationImage);
//Interface Upgrade: Better Pedia - End Add

//FfH: Added by Kael 08/07/2007
	stream->Read(&m_iCivTrait);
	stream->Read(&m_iDefaultRace);
	stream->Read(&m_iHero);

	SAFE_DELETE_ARRAY(m_pbMaintainFeatures);
	m_pbMaintainFeatures = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbMaintainFeatures);
//FfH: End Add

	// Arrays

	SAFE_DELETE_ARRAY(m_piCivilizationBuildingArtDefines);
	m_piCivilizationBuildingArtDefines = new CvString[GC.getNumBuildingInfos()];
	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		stream->ReadString(m_piCivilizationBuildingArtDefines[i]);
	}

	SAFE_DELETE_ARRAY(m_piCivilizationBuildings);
	m_piCivilizationBuildings = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piCivilizationBuildings);

	SAFE_DELETE_ARRAY(m_piCivilizationUnits);
	m_piCivilizationUnits = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piCivilizationUnits);

	SAFE_DELETE_ARRAY(m_piCivilizationFreeUnitsClass);
	m_piCivilizationFreeUnitsClass = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piCivilizationFreeUnitsClass);

	SAFE_DELETE_ARRAY(m_piCivilizationInitialCivics);
	m_piCivilizationInitialCivics = new int[GC.getNumCivicOptionInfos()];
	stream->Read(GC.getNumCivicOptionInfos(), m_piCivilizationInitialCivics);

	SAFE_DELETE_ARRAY(m_pbLeaders);
	m_pbLeaders = new bool[GC.getNumLeaderHeadInfos()];
	stream->Read(GC.getNumLeaderHeadInfos(), m_pbLeaders);
	
	SAFE_DELETE_ARRAY(m_pbSecondaryLeaders);
	m_pbSecondaryLeaders = new bool[GC.getNumLeaderHeadInfos()];
	stream->Read(GC.getNumLeaderHeadInfos(), m_pbSecondaryLeaders);

	SAFE_DELETE_ARRAY(m_pbCivilizationFreeBuildingClass);
	m_pbCivilizationFreeBuildingClass = new bool[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_pbCivilizationFreeBuildingClass);

	SAFE_DELETE_ARRAY(m_pbCivilizationFreeTechs);
	m_pbCivilizationFreeTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbCivilizationFreeTechs);

	SAFE_DELETE_ARRAY(m_pbCivilizationDisableTechs);
	m_pbCivilizationDisableTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbCivilizationDisableTechs);

	SAFE_DELETE_ARRAY(m_paszCityNames);
	m_paszCityNames = new CvString[m_iNumCityNames];
	stream->ReadString(m_iNumCityNames, m_paszCityNames);
/*************************************************************************************************/
/**	Civilization Flavors				07/07/10										Snarko	**/
/**																								**/
/**							Making civilization flavors,										**/
/**			for helping AI with things we can't really add in a non-hardcoded way				**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piCivFlavorValue);
	m_piCivFlavorValue = new int[GC.getNumCivFlavorTypes()];
	stream->Read(GC.getNumCivFlavorTypes(), m_piCivFlavorValue);
/*************************************************************************************************/
/**	Civilization Flavors					END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);
/*************************************************************************************************/
/**	New Tag Defs	(CivilizationInfos)		01/12/09								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_bLimitedSelection);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
}

void CvCivilizationInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iDefaultPlayerColor);
	stream->Write(m_iArtStyleType);
	stream->Write(m_iUnitArtStyleType);
	stream->Write(m_iNumCityNames);
	stream->Write(m_iNumLeaders);
	stream->Write(m_iSelectionSoundScriptId);
	stream->Write(m_iActionSoundScriptId);
	stream->Write(m_iDerivativeCiv);
	stream->Write(m_bAIPlayable);
	stream->Write(m_bPlayable);
	stream->Write(m_bNoCrimeCiv);

	stream->WriteString(m_szArtDefineTag);
	stream->WriteString(m_szShortDescriptionKey);
	stream->WriteString(m_szAdjectiveKey);

//InterfaceUpgrade: Better Pedia - Added by Grey Fox 04/18/2008
	stream->WriteString(m_szCivilizationImage);
//Interface Upgrade: Better Pedia - End Add

//FfH: Added by Kael 08/07/2007
	stream->Write(m_iCivTrait);
	stream->Write(m_iDefaultRace);
	stream->Write(m_iHero);
	stream->Write(GC.getNumFeatureInfos(), m_pbMaintainFeatures);
//FfH: End Add

	// Arrays
	for (int i = 0;  i < GC.getNumBuildingInfos(); i++)
	{
		stream->WriteString( m_piCivilizationBuildingArtDefines[i]);
	}
	stream->Write(GC.getNumBuildingClassInfos(), m_piCivilizationBuildings);
	stream->Write(GC.getNumUnitClassInfos(), m_piCivilizationUnits);
	stream->Write(GC.getNumUnitClassInfos(), m_piCivilizationFreeUnitsClass);
	stream->Write(GC.getNumCivicOptionInfos(), m_piCivilizationInitialCivics);
	stream->Write(GC.getNumLeaderHeadInfos(), m_pbLeaders);
	stream->Write(GC.getNumLeaderHeadInfos(), m_pbSecondaryLeaders);
	stream->Write(GC.getNumBuildingClassInfos(), m_pbCivilizationFreeBuildingClass);
	stream->Write(GC.getNumTechInfos(), m_pbCivilizationFreeTechs);
	stream->Write(GC.getNumTechInfos(), m_pbCivilizationDisableTechs);
	stream->WriteString(m_iNumCityNames, m_paszCityNames);
/*************************************************************************************************/
/**	Civilization Flavors				07/07/10										Snarko	**/
/**																								**/
/**							Making civilization flavors,										**/
/**			for helping AI with things we can't really add in a non-hardcoded way				**/
/*************************************************************************************************/
	stream->Write(GC.getNumCivFlavorTypes(), m_piCivFlavorValue);
/*************************************************************************************************/
/**	Civilization Flavors					END													**/
/*************************************************************************************************/
	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
/*************************************************************************************************/
/**	New Tag Defs	(CivilizationInfos)		01/12/09								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_bLimitedSelection);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
}

bool CvCivilizationInfo::read(CvXMLLoadUtility* pXML)
{
	char szClassVal[256];					// holds the text value of the relevant classinfo

	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j, iNumSibs;

	pXML->GetChildXmlValByName(m_szShortDescriptionKey, "ShortDescription");
	// Get the Text from Text/Civ4GameTextXML.xml

	pXML->GetChildXmlValByName(m_szAdjectiveKey, "Adjective");
	// Get the Text from Text/Civ4GameTextXML.xml
/*************************************************************************************************/
/**	New Tag Defs	(CivilizationInfos)		01/12/09								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bLimitedSelection, "bLimitedSelection");

	pXML->SetVariableListTagPair(&m_piFeatureHealthPercentChanges, "FeatureHealthPercentChanges", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos(), 0);

	// Civilization Feature Yield Changes:
	FAssertMsg((GC.getNumFeatureInfos() > 0) && (NUM_YIELD_TYPES) > 0, "either the number of feature infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiFeatureYieldChanges, GC.getNumFeatureInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "FeatureYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					int iIndex;

					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "FeatureType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiFeatureYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiFeatureYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiFeatureYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// Civilization Improvement Yield Changes:
	FAssertMsg((GC.getNumImprovementInfos() > 0) && (NUM_YIELD_TYPES) > 0, "either the number of improvement infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiImprovementYieldChanges, GC.getNumImprovementInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ImprovementYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					int iIndex;

					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiImprovementYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiImprovementYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// Civilization Terrain Yield Changes:
	FAssertMsg((GC.getNumTerrainInfos() > 0) && (NUM_YIELD_TYPES) > 0, "either the number of terrain infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiTerrainYieldChanges, GC.getNumTerrainInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TerrainYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					int iIndex;

					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "TerrainType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiTerrainYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TerrainYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiTerrainYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiTerrainYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PeakYieldChange"))
	{
		pXML->SetYields(&m_paiPeakYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiPeakYieldChange, NUM_YIELD_TYPES);
	}
//ClimateSystem:

	pXML->GetChildXmlValByName(szTextVal, "FormClimateZoneType");
	if (szTextVal != "") m_iFormClimateZoneType = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "DefaultPlayerColor");
	m_iDefaultPlayerColor = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ArtStyleType");
	m_iArtStyleType = GC.getTypesEnum(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "UnitArtStyleType");
	m_iUnitArtStyleType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "CivilizationSelectionSound");
	m_iSelectionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;
	pXML->GetChildXmlValByName(szTextVal, "CivilizationActionSound");
	m_iActionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;

	// set the current xml node to it's next sibling and then
	pXML->GetChildXmlValByName(&m_bPlayable, "bPlayable");
	pXML->GetChildXmlValByName(&m_bAIPlayable, "bAIPlayable");
	pXML->GetChildXmlValByName(&m_bNoCrimeCiv, "bNoCrimeCiv");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Cities"))
	{
		pXML->SetStringList(&m_paszCityNames, &m_iNumCityNames);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BuildingArtDefines"))
	{
		CvString cDefault = CvString::format("").GetCString();

		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default civilization buildings
			pXML->InitBuildingArtDefineDefaults(&m_piCivilizationBuildingArtDefines);
			/*************************************************************************************************/
			/**	TrimmingFat								01/12/09								Xienwolf	**/
			/**																								**/
			/**						Blocks all Units not specifically authorized for Civ					**/
			/*************************************************************************************************/
			if (m_bLimitedSelection)
			{
				for (int i = 0; i < GC.getNumBuildingInfos(); i++)
				{
					m_piCivilizationBuildingArtDefines[i] = cDefault;
				}
			}
			/*************************************************************************************************/
			/**	TrimmingFat								END													**/
			/*************************************************************************************************/
						// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ((0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())))
			{
				int iBuildingIndex;

				FAssertMsg((iNumSibs <= GC.getNumBuildingInfos()), "In SetGlobalCivilizationInfo iNumSibs is greater than GC.getNumBuildingInfos()");

				// loop through all the siblings
				for (j = 0; j < iNumSibs; j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// get the index into the array based on the building class type
						iBuildingIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iBuildingIndex)
						{
							// get the next value which should be the building type to set this civilization's version of this building class too
							pXML->GetNextXmlVal(szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_piCivilizationBuildingArtDefines[iBuildingIndex] = szTextVal;
						}
						else
						{
							FAssertMsg(0, "Building index is -1 in SetGlobalCivilizationInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	/*************************************************************************************************/
	/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
	/**		Quickly adjusted to account for bUnique tag, should work as now written, but untested	**/
	/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
	/*************************************************************************************************/
	else
	{
		CvString cDefault = CvString::format("").GetCString();
		pXML->InitBuildingArtDefineDefaults(&m_piCivilizationBuildingArtDefines);
		if (isLimitedSelection())
		{
			for (j = 0; j < GC.getNumBuildingInfos(); j++)
			{
				m_piCivilizationBuildingArtDefines[j] = cDefault;
			}
		}
	}
	/*************************************************************************************************/
	/**	TrueModular								END													**/
	/*************************************************************************************************/


	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Buildings"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default civilization buildings
			pXML->InitBuildingDefaults(&m_piCivilizationBuildings);
/*************************************************************************************************/
/**	TrimmingFat								01/12/09								Xienwolf	**/
/**																								**/
/**						Blocks all Units not specifically authorized for Civ					**/
/*************************************************************************************************/
			if (m_bLimitedSelection)
			{
				for (int i=0;i<GC.getNumBuildingClassInfos();i++)
				{
					m_piCivilizationBuildings[i] = -1;
				}
			}
/*************************************************************************************************/
/**	TrimmingFat								END													**/
/*************************************************************************************************/
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ( (0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())) )
			{
				int iBuildingClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumBuildingClassInfos()) ,"In SetGlobalCivilizationInfo iNumSibs is greater than GC.getNumBuildingClassInfos()");

				// loop through all the siblings
				for (j=0;j<iNumSibs;j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// get the index into the array based on the building class type
						iBuildingClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iBuildingClassIndex)
						{
							// get the next value which should be the building type to set this civilization's version of this building class too
							pXML->GetNextXmlVal( szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_piCivilizationBuildings[iBuildingClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0,"BuildingClass index is -1 in SetGlobalCivilizationInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		Quickly adjusted to account for bUnique tag, should work as now written, but untested	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitBuildingDefaults(&m_piCivilizationBuildings);
		if(isLimitedSelection())
		{
			for ( j = 0; j < GC.getNumBuildingClassInfos(); j++)
			{
				m_piCivilizationBuildings[j] = NO_BUILDING;
			}
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Units"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default civilization buildings
			pXML->InitUnitDefaults(&m_piCivilizationUnits);
/*************************************************************************************************/
/**	TrimmingFat								01/12/09								Xienwolf	**/
/**																								**/
/**						Blocks all Units not specifically authorized for Civ					**/
/*************************************************************************************************/
			if (m_bLimitedSelection)
			{
				for (int i=0;i<GC.getNumUnitClassInfos();i++)
				{
					m_piCivilizationUnits[i] = -1;
				}
			}
/*************************************************************************************************/
/**	TrimmingFat								END													**/
/*************************************************************************************************/
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ( (0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())) )
			{
				int iUnitClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumUnitClassInfos()),"In SetGlobalCivilizationInfo iNumSibs is greater than GC.getNumUnitClassInfos()");

				// loop through all the siblings
				for (j=0;j<iNumSibs;j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// set the unit class index
						iUnitClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iUnitClassIndex)
						{
							// get the next value which should be the building type to set this civilization's version of this building class too
							pXML->GetNextXmlVal( szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_piCivilizationUnits[iUnitClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0, "UnitClass index is -1 in SetGlobalCivilizationInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		Quickly adjusted to account for bUnique tag, should work as now written, but untested	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitUnitDefaults(&m_piCivilizationUnits);
		if(isLimitedSelection())
		{
			for ( j = 0; j < GC.getNumUnitClassInfos(); j++)
			{
				m_piCivilizationUnits[j] = NO_UNIT;
			}
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piCivilizationFreeUnitsClass, "FreeUnitClasses", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());

	pXML->SetVariableListTagPair(&m_pbCivilizationFreeBuildingClass, "FreeBuildingClasses", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

	pXML->SetVariableListTagPair(&m_pbCivilizationFreeTechs, "FreeTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
	pXML->SetVariableListTagPair(&m_pbCivilizationDisableTechs, "DisableTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"InitialCivics"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			pXML->InitList(&m_piCivilizationInitialCivics, GC.getNumCivicOptionInfos());

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNumCivicOptionInfos()),"For loop iterator is greater than array size");
					for (j=0;j<iNumSibs;j++)
					{
						m_piCivilizationInitialCivics[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piCivilizationInitialCivics, GC.getNumCivicOptionInfos());
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_pbLeaders, "Leaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());
	pXML->SetVariableListTagPair(&m_pbSecondaryLeaders, "SecondaryLeaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());

	pXML->GetChildXmlValByName(szTextVal, "CivilizationSelectionSound");


//InterfaceUpgrade: Better Pedia - Added by Grey Fox 04/18/2008
	pXML->GetChildXmlValByName(m_szCivilizationImage, "Image");
//Interface Upgrade: Better Pedia - End Add

//FfH: Added by Kael 08/06/2007
	pXML->GetChildXmlValByName(szTextVal, "CivTrait");
	m_iCivTrait = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DefaultRace");
	m_iDefaultRace = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "Hero");
	m_iHero = GC.getInfoTypeForString(szTextVal);
	pXML->SetVariableListTagPair(&m_pbMaintainFeatures, "MaintainFeatures", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
//FfH: End Add
/*************************************************************************************************/
/**	Civilization Flavors				07/07/10										Snarko	**/
/**																								**/
/**							Making civilization flavors,										**/
/**			for helping AI with things we can't really add in a non-hardcoded way				**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piCivFlavorValue, "CivFlavors", GC.getCivFlavorTypes(), GC.getNumCivFlavorTypes());
/*************************************************************************************************/
/**	Civilization Flavors					END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());

	return true;
}

bool CvCivilizationInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "DerivativeCiv");
	m_iDerivativeCiv = GC.getInfoTypeForString(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(CivilizationInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCivilizationInfo::copyNonDefaults(CvCivilizationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag() == cDefault)			setArtDefineTag(pClassInfo->getArtDefineTag());
	if (getImage() == cDefault)			setImage(pClassInfo->getImage());
	//Must set the Art Define before doing the Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isPlayable() == false)				m_bPlayable = (pClassInfo->isPlayable());
	if (isAIPlayable() == false)				m_bAIPlayable = (pClassInfo->isAIPlayable());
	if (isNoCrimeCiv() == false)				m_bNoCrimeCiv = (pClassInfo->isNoCrimeCiv());
	if (isLimitedSelection() == false)				m_bLimitedSelection = (pClassInfo->isLimitedSelection());
	if (getShortDescriptionKey() == wDefault)			m_szShortDescriptionKey = pClassInfo->getShortDescriptionKey();
	if (getAdjectiveKey() == wDefault)			m_szAdjectiveKey = pClassInfo->getAdjectiveKey();
	if (getHero() == NO_UNIT)				m_iHero = (pClassInfo->getHero());
	if (getCivTrait() == NO_TRAIT)			m_iCivTrait = (pClassInfo->getCivTrait());
	if (getArtStyleType() == NO_ARTSTYLE)			m_iArtStyleType = (pClassInfo->getArtStyleType());
	if (getDefaultRace() == NO_PROMOTION)		m_iDefaultRace = (pClassInfo->getDefaultRace());
	if (getSelectionSoundScriptId() == AUDIOTAG_NONE)		m_iSelectionSoundScriptId = (pClassInfo->getSelectionSoundScriptId());
	if (getActionSoundScriptId() == AUDIOTAG_NONE)		m_iActionSoundScriptId = (pClassInfo->getActionSoundScriptId());
	if (getDefaultPlayerColor() == NO_PLAYERCOLOR)		m_iDefaultPlayerColor = (pClassInfo->getDefaultPlayerColor());
	if (getUnitArtStyleType() == NO_UNIT_ARTSTYLE)	m_iUnitArtStyleType = (pClassInfo->getUnitArtStyleType());
	if (getFormClimateZoneType() == NO_CLIMATEZONE)		m_iFormClimateZoneType = (pClassInfo->getFormClimateZoneType());

	//NEED A MASSIVE RE-WRITE IN HERE FOR FINDING DEFAULT BUILDINGS
	for (int i = 0; i < GC.getNumBuildingClassInfos(); i++)
	{
		int iDefaultBuilding = (GC.getBuildingClassInfo((BuildingClassTypes)i).isUnique() || isLimitedSelection()) ? -1 : GC.getBuildingClassInfo((BuildingClassTypes)i).getDefaultBuildingIndex();
		if (getCivilizationBuildings(i) == iDefaultBuilding)	m_piCivilizationBuildings[i] = pClassInfo->getCivilizationBuildings(i);
		if (isCivilizationFreeBuildingClass(i) == false)				m_pbCivilizationFreeBuildingClass[i] = pClassInfo->isCivilizationFreeBuildingClass(i);
	}
	cDefault = CvString::format("").GetCString();

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		if (getCivilizationBuildingArtDefines(i) == cDefault)	m_piCivilizationBuildingArtDefines[i] = pClassInfo->getCivilizationBuildingArtDefines(i);
	}


	for ( int i = 0; i < GC.getNumUnitClassInfos(); i++)
	{
		int iDefaultUnit = (GC.getUnitClassInfo((UnitClassTypes) i).isUnique() || isLimitedSelection()) ? -1 : GC.getUnitClassInfo((UnitClassTypes) i).getDefaultUnitIndex();
		if (getCivilizationUnits(i)					== iDefaultUnit)		m_piCivilizationUnits[i]				= pClassInfo->getCivilizationUnits(i);
		if (getCivilizationFreeUnitsClass(i)		== 0)					m_piCivilizationFreeUnitsClass[i]		= pClassInfo->getCivilizationFreeUnitsClass(i);
	}
	for ( int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if (isCivilizationFreeTechs(i)				== false)				m_pbCivilizationFreeTechs[i]			= pClassInfo->isCivilizationFreeTechs(i);
		if (isCivilizationDisableTechs(i)			== false)				m_pbCivilizationDisableTechs[i]			= pClassInfo->isCivilizationDisableTechs(i);
	}
	for ( int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		if (getCivilizationInitialCivics(i)			== 0)					m_piCivilizationInitialCivics[i]		= pClassInfo->getCivilizationInitialCivics(i);
	}
	for ( int i = 0; i < GC.getNumLeaderHeadInfos(); i++)
	{
		if (isLeaders(i)							== false)				m_pbLeaders[i]							= pClassInfo->isLeaders(i);
		if (isSecondaryLeaders(i) == false)				m_pbSecondaryLeaders[i] = pClassInfo->isSecondaryLeaders(i);
	}
	for (int i = 0; i < GC.getNumFeatureInfos(); ++i)
	{
		if (isMaintainFeatures(i)					== false)				m_pbMaintainFeatures[i]					= pClassInfo->isMaintainFeatures(i);
		if (getFeatureHealthPercentChange(i)		== 0)					m_piFeatureHealthPercentChanges[i]		= pClassInfo->getFeatureHealthPercentChange(i);
	}
	// First we check if there are different Unique Names in the Modules(we want to keep all of them)
	// So we have to set the Arraysize properly, knowing the amount of Unique Names
	if ( pClassInfo->getNumCityNames() != 0 )
	{
		CvString* m_paszOldNames = new CvString[pClassInfo->getNumCityNames()];
		for ( int i = 0; i < pClassInfo->getNumCityNames(); i++)
		{
																			m_paszOldNames[i]						= pClassInfo->getCityNames(i);
		}
		CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
		pCurrentUnitClass->StringArrayExtend(&m_paszCityNames, &m_iNumCityNames, &m_paszOldNames, pClassInfo->getNumCityNames());
		SAFE_DELETE_ARRAY(m_paszOldNames)
	}
	for (int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiFeatureYieldChanges[i][j]					== 0)				m_ppiFeatureYieldChanges[i][j]					= pClassInfo->getFeatureYieldChanges(i, j);
		}
	}
	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiImprovementYieldChanges[i][j]				== 0)				m_ppiImprovementYieldChanges[i][j]				= pClassInfo->getImprovementYieldChanges(i, j);
		}
	}
	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiTerrainYieldChanges[i][j]					== 0)				m_ppiTerrainYieldChanges[i][j]					= pClassInfo->getTerrainYieldChanges(i, j);
		}
	}
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_paiPeakYieldChange[i]								== 0)				m_paiPeakYieldChange[i]							= pClassInfo->getPeakYieldChange(i);
	}
/*************************************************************************************************/
/**	Civilization Flavors				07/07/10										Snarko	**/
/**																								**/
/**							Making civilization flavors,										**/
/**			for helping AI with things we can't really add in a non-hardcoded way				**/
/*************************************************************************************************/
	for (int j = 0; j < GC.getNumCivFlavorTypes(); j++)
	{
		if (getCivFlavorValue(j)							== 0)				m_piCivFlavorValue[j]								= pClassInfo->getCivFlavorValue(j);
	}
/*************************************************************************************************/
/**	Civilization Flavors					END													**/
/*************************************************************************************************/
	for ( int i = 0; i < GC.getNumFlavorTypes(); i++ )
	{
		if(getFlavorValue(i)		== 0)					m_piFlavorValue[i]			= pClassInfo->getFlavorValue(i);
	}

	// Readpass2 stuff
	if (getDerivativeCiv()							== NO_CIVILIZATION)		m_iDerivativeCiv						= pClassInfo->getDerivativeCiv();
}

void CvCivilizationInfo::copyNonDefaultsReadPass2(CvCivilizationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getDerivativeCiv()		!= -1)					m_iDerivativeCiv						= pClassInfo->getDerivativeCiv();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvVictoryInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvVictoryInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvVictoryInfo::CvVictoryInfo() :
m_iPopulationPercentLead(0),
m_iLandPercent(0),
m_iMinLandPercent(0),
m_iReligionPercent(0),
m_iCityCulture(0),
m_iNumCultureCities(0),
m_iTotalCultureRatio(0),
m_iVictoryDelayTurns(0),
m_bTargetScore(false),
m_bEndScore(false),
m_bConquest(false),
m_bDiploVote(false),
m_bPermanent(false)
/*************************************************************************************************/
/**	New Tag Defs	(VictoryInfos)			01/16/09								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
,m_iNumLinkedVictories(0)
,m_piLinkedVictories(NULL)
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
,m_piAIVictoryTypes(NULL)
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvVictoryInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvVictoryInfo::~CvVictoryInfo()
{
/*************************************************************************************************/
/**	New Tag Defs	(VictoryInfos)			01/16/09								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piLinkedVictories);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAIVictoryTypes);
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
}

int CvVictoryInfo::getPopulationPercentLead() const
{
	return m_iPopulationPercentLead;
}

int CvVictoryInfo::getLandPercent() const
{
	return m_iLandPercent;
}

int CvVictoryInfo::getMinLandPercent() const
{
	return m_iMinLandPercent;
}

int CvVictoryInfo::getReligionPercent() const
{
	return m_iReligionPercent;
}

int CvVictoryInfo::getCityCulture() const
{
	return m_iCityCulture;
}

int CvVictoryInfo::getNumCultureCities() const
{
	return m_iNumCultureCities;
}

int CvVictoryInfo::getTotalCultureRatio() const
{
	return m_iTotalCultureRatio;
}

int CvVictoryInfo::getVictoryDelayTurns() const
{
	return m_iVictoryDelayTurns;
}

bool CvVictoryInfo::isTargetScore() const
{
	return m_bTargetScore;
}

bool CvVictoryInfo::isEndScore() const
{
	return m_bEndScore;
}

bool CvVictoryInfo::isConquest() const
{
	return m_bConquest;
}

bool CvVictoryInfo::isDiploVote() const
{
	return m_bDiploVote;
}

bool CvVictoryInfo::isPermanent() const
{
	return m_bPermanent;
}

const char* CvVictoryInfo::getMovie() const
{
	return m_szMovie;
}
/*************************************************************************************************/
/**	New Tag Defs	(VictoryInfos)			01/16/09								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvVictoryInfo::getLinkedVictory(int iI) const						{return (getNumLinkedVictories() > iI) ? m_piLinkedVictories[iI] : -1;}
int CvVictoryInfo::getNumLinkedVictories() const						{return m_iNumLinkedVictories;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
int CvVictoryInfo::getAIVictoryWeight(int i) const
{
	FAssertMsg(i < NUM_AI_VICTORY_WEIGHT, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAIVictoryTypes ? m_piAIVictoryTypes[i] : 0;
}
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/


//
// read from xml
//
bool CvVictoryInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bTargetScore, "bTargetScore");
	pXML->GetChildXmlValByName(&m_bEndScore, "bEndScore");
	pXML->GetChildXmlValByName(&m_bConquest, "bConquest");
	pXML->GetChildXmlValByName(&m_bDiploVote, "bDiploVote");
	pXML->GetChildXmlValByName(&m_bPermanent, "bPermanent");
	pXML->GetChildXmlValByName(&m_iPopulationPercentLead, "iPopulationPercentLead");
	pXML->GetChildXmlValByName(&m_iLandPercent, "iLandPercent");
	pXML->GetChildXmlValByName(&m_iMinLandPercent, "iMinLandPercent");
	pXML->GetChildXmlValByName(&m_iReligionPercent, "iReligionPercent");

	pXML->GetChildXmlValByName(szTextVal, "CityCulture");
	m_iCityCulture = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iNumCultureCities, "iNumCultureCities");
	pXML->GetChildXmlValByName(&m_iTotalCultureRatio, "iTotalCultureRatio");
	pXML->GetChildXmlValByName(&m_iVictoryDelayTurns, "iVictoryDelayTurns");
	pXML->GetChildXmlValByName(m_szMovie, "VictoryMovie");

/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piAIVictoryTypes, "VictoryAIs", GC.getAIVictoryTypes(), GC.getNumAIVictoryTypes());
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	New Tag Defs	(VictoryInfos)			01/16/09								Xienwolf	**/
/**																								**/
/**					Second Pass to reference information within the same file					**/
/*************************************************************************************************/
bool CvVictoryInfo::readPass2(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"LinkedVictories"))
	{
		pXML->SetIntWithChildList(&m_iNumLinkedVictories, &m_piLinkedVictories);
	}
	return true;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(VictoryInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvVictoryInfo::copyNonDefaults(CvVictoryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isTargetScore()				== false)				m_bTargetScore				= pClassInfo->isTargetScore();
	if (isEndScore()				== false)				m_bEndScore					= pClassInfo->isEndScore();
	if (isConquest()				== false)				m_bConquest					= pClassInfo->isConquest();
	if (isDiploVote()				== false)				m_bDiploVote				= pClassInfo->isDiploVote();
	if (isPermanent()				== false)				m_bPermanent				= pClassInfo->isPermanent();
	if (getPopulationPercentLead()	== 0)					m_iPopulationPercentLead	= pClassInfo->getPopulationPercentLead();
	if (getLandPercent()			== 0)					m_iLandPercent				= pClassInfo->getLandPercent();
	if (getMinLandPercent()			== 0)					m_iMinLandPercent			= pClassInfo->getMinLandPercent();
	if (getReligionPercent()		== 0)					m_iReligionPercent			= pClassInfo->getReligionPercent();
	if (getCityCulture()			== NO_CULTURELEVEL)		m_iCityCulture				= pClassInfo->getCityCulture();
	if (getNumCultureCities()		== 0)					m_iNumCultureCities			= pClassInfo->getNumCultureCities();
	if (getTotalCultureRatio()		== 0)					m_iTotalCultureRatio		= pClassInfo->getTotalCultureRatio();
	if (getVictoryDelayTurns()		== 0)					m_iVictoryDelayTurns		= pClassInfo->getVictoryDelayTurns();
	if (getMovie()					== cDefault)			m_szMovie					= pClassInfo->getMovie();
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	for ( int i = 0; i < NUM_AI_VICTORY_WEIGHT; i++ )
	{
		if(getAIVictoryWeight(i)		== 0)					m_piAIVictoryTypes[i]			= pClassInfo->getAIVictoryWeight(i);
	}
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/

	//Readpass2 stuff
	if(pClassInfo->getNumLinkedVictories() > 0)
	{
		int iGoalSize = getNumLinkedVictories() + pClassInfo->getNumLinkedVictories();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i< getNumLinkedVictories(); ++i)
		{
			tempArray[i] = getLinkedVictory(i);
		}
		for(int i = 0; i < pClassInfo->getNumLinkedVictories(); ++i)
		{
			tempArray[i+getNumLinkedVictories()] = pClassInfo->getLinkedVictory(i);
		}
		SAFE_DELETE_ARRAY(m_piLinkedVictories);
		m_piLinkedVictories = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
															m_piLinkedVictories[i]		= tempArray[i];
			FAssertMsg(m_piLinkedVictories[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piLinkedVictories[i] >= 0 ,"Out of Bounds Array Melding");
		}
															m_iNumLinkedVictories		= iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}
void CvVictoryInfo::copyNonDefaultsReadPass2(CvVictoryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if(pClassInfo->getNumLinkedVictories() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumLinkedVictories() : getNumLinkedVictories() + pClassInfo->getNumLinkedVictories();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumLinkedVictories(); ++i)
		{
			tempArray[i] = pClassInfo->getLinkedVictory(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumLinkedVictories();
			for(int i = 0; i< getNumLinkedVictories(); ++i)
			{
				tempArray[i+iOffset] = getLinkedVictory(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piLinkedVictories);
		m_piLinkedVictories = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
															m_piLinkedVictories[i]		= tempArray[i];
			FAssertMsg(m_piLinkedVictories[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piLinkedVictories[i] >= 0 ,"Out of Bounds Array Melding");
		}
															m_iNumLinkedVictories		= iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvHurryInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvHurryInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvHurryInfo::CvHurryInfo() :
m_iGoldPerProduction(0),
m_iProductionPerPopulation(0),
m_bAnger(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvHurryInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvHurryInfo::~CvHurryInfo()
{
}

int CvHurryInfo::getGoldPerProduction() const
{
	return m_iGoldPerProduction;
}

int CvHurryInfo::getProductionPerPopulation() const
{
	return m_iProductionPerPopulation;
}

bool CvHurryInfo::isAnger() const
{
	return m_bAnger;
}

bool CvHurryInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iGoldPerProduction, "iGoldPerProduction");
	pXML->GetChildXmlValByName(&m_iProductionPerPopulation, "iProductionPerPopulation");

	pXML->GetChildXmlValByName(&m_bAnger, "bAnger");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvHurryInfo::copyNonDefaults(CvHurryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getGoldPerProduction()			== 0)		m_iGoldPerProduction		= pClassInfo->getGoldPerProduction();
	if (getProductionPerPopulation()	== 0)		m_iProductionPerPopulation	= pClassInfo->getProductionPerPopulation();
	if (isAnger()						== false)	m_bAnger					= pClassInfo->isAnger();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
//======================================================================================================
//					CvHandicapInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvHandicapInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvHandicapInfo::CvHandicapInfo() :
m_iFreeWinsVsBarbs(0),
m_iAnimalAttackProb(0),
m_iStartingLocationPercent(0),
m_iAdvancedStartPointsMod(0),
m_iStartingGold(0),
m_iFreeUnits(0),
m_iUnitCostPercent(0),
m_iResearchPercent(0),
m_iDistanceMaintenancePercent(0),
m_iNumCitiesMaintenancePercent(0),
m_iMaxNumCitiesMaintenance(0),
m_iColonyMaintenancePercent(0),
m_iMaxColonyMaintenance(0),
m_iCorporationMaintenancePercent(0),
m_iCivicUpkeepPercent(0),
m_iInflationPercent(0),
m_iHealthBonus(0),
m_iHappyBonus(0),
m_iAttitudeChange(0),
m_iNoTechTradeModifier(0),
m_iTechTradeKnownModifier(0),
m_iUnownedTilesPerGameAnimal(0),
m_iUnownedTilesPerBarbarianUnit(0),
m_iUnownedWaterTilesPerBarbarianUnit(0),
m_iUnownedTilesPerBarbarianCity(0),
m_iBarbarianCreationTurnsElapsed(0),
m_iBarbarianCityCreationTurnsElapsed(0),
m_iBarbarianCityCreationProb(0),
m_iAnimalCombatModifier(0),
m_iBarbarianCombatModifier(0),
m_iAIAnimalCombatModifier(0),
m_iAIBarbarianCombatModifier(0),
m_iStartingDefenseUnits(0),
m_iStartingWorkerUnits(0),
m_iStartingExploreUnits(0),
m_iAIStartingUnitMultiplier(0),
m_iAIStartingDefenseUnits(0),
m_iAIStartingWorkerUnits(0),
m_iAIStartingExploreUnits(0),
m_iBarbarianInitialDefenders(0),
m_iAIDeclareWarProb(0),
m_iAIWorkRateModifier(0),
m_iAIGrowthPercent(0),
m_iAITrainPercent(0),
m_iAIWorldTrainPercent(0),
m_iAIConstructPercent(0),
m_iAIWorldConstructPercent(0),
m_iAICreatePercent(0),
m_iAIWorldCreatePercent(0),
m_iAICivicUpkeepPercent(0),
m_iAIUnitCostPercent(0),
m_iAIUnitSupplyPercent(0),
m_iAIUnitUpgradePercent(0),
m_iAIInflationPercent(0),
m_iAIWarWearinessPercent(0),
m_iAIPerEraModifier(0),
m_iAIAdvancedStartPercent(0),
m_iNumGoodies(0),
m_piGoodies(NULL),
m_pbFreeTechs(NULL),
m_pbAIFreeTechs(NULL),

//FfH Improvements: Added by Kael 08/07/2007
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iAIFreeXP(0),
/**								----  End Original Code  ----									**/
m_iAIFreeXP(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(HandicapInfos)			12/27/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iUnownedWaterTilesPerGameAnimal(0),
m_iAnimalEscalationTurnsElapsed(0),
m_iLairSpawnChance(0),
m_iLairsPerCycle(0),
m_iPercentDemonsPerUnownedEvilPlot(0),
m_iDemonGlobalCountSpawnBoostInterval(0),
m_iDemonGlobalCountSpawnBoostRate(0),
m_iDemonPerTurnKnownTechsPercent(0),
m_iDemonGlobalCounterFreeXPPercent(0),
m_iDemonSpawnRateGlobalCounterEnhancementPercent(0),
m_iDemonBonus(0),
m_iAIDemonBonus(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_iLairSpawnRate(0)
//FfH: End Add

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvHandicapInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvHandicapInfo::~CvHandicapInfo()
{
	SAFE_DELETE_ARRAY(m_piGoodies);
	SAFE_DELETE_ARRAY(m_pbFreeTechs);
	SAFE_DELETE_ARRAY(m_pbAIFreeTechs);
}

int CvHandicapInfo::getFreeWinsVsBarbs() const
{
	return m_iFreeWinsVsBarbs;
}

int CvHandicapInfo::getAnimalAttackProb() const
{
	return m_iAnimalAttackProb;
}

int CvHandicapInfo::getStartingLocationPercent() const
{
	return m_iStartingLocationPercent;
}

int CvHandicapInfo::getAdvancedStartPointsMod() const
{
	return m_iAdvancedStartPointsMod;
}

int CvHandicapInfo::getStartingGold() const
{
	return m_iStartingGold;
}

int CvHandicapInfo::getFreeUnits() const
{
	return m_iFreeUnits;
}

int CvHandicapInfo::getUnitCostPercent() const
{
	return m_iUnitCostPercent;
}

int CvHandicapInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvHandicapInfo::getDistanceMaintenancePercent() const
{
	return m_iDistanceMaintenancePercent;
}

int CvHandicapInfo::getNumCitiesMaintenancePercent() const
{
	return m_iNumCitiesMaintenancePercent;
}

int CvHandicapInfo::getMaxNumCitiesMaintenance() const
{
	return m_iMaxNumCitiesMaintenance;
}

int CvHandicapInfo::getColonyMaintenancePercent() const
{
	return m_iColonyMaintenancePercent;
}

int CvHandicapInfo::getMaxColonyMaintenance() const
{
	return m_iMaxColonyMaintenance;
}

int CvHandicapInfo::getCorporationMaintenancePercent() const
{
	return m_iCorporationMaintenancePercent;
}

int CvHandicapInfo::getCivicUpkeepPercent() const
{
	return m_iCivicUpkeepPercent;
}

int CvHandicapInfo::getInflationPercent() const
{
	return m_iInflationPercent;
}

int CvHandicapInfo::getHealthBonus() const
{
	return m_iHealthBonus;
}

int CvHandicapInfo::getHappyBonus() const
{
	return m_iHappyBonus;
}

int CvHandicapInfo::getAttitudeChange() const
{
	return m_iAttitudeChange;
}

int CvHandicapInfo::getNoTechTradeModifier() const
{
	return m_iNoTechTradeModifier;
}

int CvHandicapInfo::getTechTradeKnownModifier() const
{
	return m_iTechTradeKnownModifier;
}

int CvHandicapInfo::getUnownedTilesPerGameAnimal() const
{
	return m_iUnownedTilesPerGameAnimal;
}

int CvHandicapInfo::getUnownedTilesPerBarbarianUnit() const
{
	return m_iUnownedTilesPerBarbarianUnit;
}

int CvHandicapInfo::getUnownedWaterTilesPerBarbarianUnit() const
{
	return m_iUnownedWaterTilesPerBarbarianUnit;
}

int CvHandicapInfo::getUnownedTilesPerBarbarianCity() const
{
	return m_iUnownedTilesPerBarbarianCity;
}

int CvHandicapInfo::getBarbarianCreationTurnsElapsed() const
{
	return m_iBarbarianCreationTurnsElapsed;
}

int CvHandicapInfo::getBarbarianCityCreationTurnsElapsed() const
{
	return m_iBarbarianCityCreationTurnsElapsed;
}

int CvHandicapInfo::getBarbarianCityCreationProb() const
{
	return m_iBarbarianCityCreationProb;
}

int CvHandicapInfo::getAnimalCombatModifier() const
{
	return m_iAnimalCombatModifier;
}

int CvHandicapInfo::getBarbarianCombatModifier() const
{
	return m_iBarbarianCombatModifier;
}

int CvHandicapInfo::getAIAnimalCombatModifier() const
{
	return m_iAIAnimalCombatModifier;
}

int CvHandicapInfo::getAIBarbarianCombatModifier() const
{
	return m_iAIBarbarianCombatModifier;
}

int CvHandicapInfo::getStartingDefenseUnits() const
{
	return m_iStartingDefenseUnits;
}

int CvHandicapInfo::getStartingWorkerUnits() const
{
	return m_iStartingWorkerUnits;
}

int CvHandicapInfo::getStartingExploreUnits() const
{
	return m_iStartingExploreUnits;
}

int CvHandicapInfo::getAIStartingUnitMultiplier() const
{
	return m_iAIStartingUnitMultiplier;
}

int CvHandicapInfo::getAIStartingDefenseUnits() const
{
	return m_iAIStartingDefenseUnits;
}

int CvHandicapInfo::getAIStartingWorkerUnits() const
{
	return m_iAIStartingWorkerUnits;
}

int CvHandicapInfo::getAIStartingExploreUnits() const
{
	return m_iAIStartingExploreUnits;
}

int CvHandicapInfo::getBarbarianInitialDefenders() const
{
	return m_iBarbarianInitialDefenders;
}

int CvHandicapInfo::getAIDeclareWarProb() const
{
	return m_iAIDeclareWarProb;
}

int CvHandicapInfo::getAIWorkRateModifier() const
{
	return m_iAIWorkRateModifier;
}

int CvHandicapInfo::getAIGrowthPercent() const
{
	return m_iAIGrowthPercent;
}

int CvHandicapInfo::getAITrainPercent() const
{
	return m_iAITrainPercent;
}

int CvHandicapInfo::getAIWorldTrainPercent() const
{
	return m_iAIWorldTrainPercent;
}

int CvHandicapInfo::getAIConstructPercent() const
{
	return m_iAIConstructPercent;
}

int CvHandicapInfo::getAIWorldConstructPercent() const
{
	return m_iAIWorldConstructPercent;
}

int CvHandicapInfo::getAICreatePercent() const
{
	return m_iAICreatePercent;
}

int CvHandicapInfo::getAIWorldCreatePercent() const
{
	return m_iAIWorldCreatePercent;
}

int CvHandicapInfo::getAICivicUpkeepPercent() const
{
	return m_iAICivicUpkeepPercent;
}

int CvHandicapInfo::getAIUnitCostPercent() const
{
	return m_iAIUnitCostPercent;
}

int CvHandicapInfo::getAIUnitSupplyPercent() const
{
	return m_iAIUnitSupplyPercent;
}

int CvHandicapInfo::getAIUnitUpgradePercent() const
{
	return m_iAIUnitUpgradePercent;
}

int CvHandicapInfo::getAIInflationPercent() const
{
	return m_iAIInflationPercent;
}

int CvHandicapInfo::getAIWarWearinessPercent() const
{
	return m_iAIWarWearinessPercent;
}

int CvHandicapInfo::getAIPerEraModifier() const
{
	return m_iAIPerEraModifier;
}

int CvHandicapInfo::getAIAdvancedStartPercent() const
{
	return m_iAIAdvancedStartPercent;
}

int CvHandicapInfo::getNumGoodies() const
{
	return m_iNumGoodies;
}

//FfH Improvements: Added by Kael 08/07/2007
int CvHandicapInfo::getAIFreeXP() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iAIFreeXP;
/**								----  End Original Code  ----									**/
	return (int)(m_iAIFreeXP*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvHandicapInfo::getLairSpawnRate() const
{
	return m_iLairSpawnRate;
}
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(HandicapInfos)			12/27/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvHandicapInfo::getUnownedWaterTilesPerGameAnimal() const					{return m_iUnownedWaterTilesPerGameAnimal;}
int CvHandicapInfo::getAnimalEscalationTurnsElapsed() const						{return m_iAnimalEscalationTurnsElapsed;}
int CvHandicapInfo::getLairSpawnChance() const									{return m_iLairSpawnChance;}
int CvHandicapInfo::getLairsPerCycle() const									{return m_iLairsPerCycle;}
int CvHandicapInfo::getPercentDemonsPerUnownedEvilPlot() const					{return m_iPercentDemonsPerUnownedEvilPlot;}
int CvHandicapInfo::getDemonGlobalCountSpawnBoostInterval() const				{return m_iDemonGlobalCountSpawnBoostInterval;}
int CvHandicapInfo::getDemonGlobalCountSpawnBoostRate() const					{return m_iDemonGlobalCountSpawnBoostRate;}
int CvHandicapInfo::getDemonPerTurnKnownTechsPercent() const					{return m_iDemonPerTurnKnownTechsPercent;}
int CvHandicapInfo::getDemonGlobalCounterFreeXPPercent() const					{return m_iDemonGlobalCounterFreeXPPercent;}
int CvHandicapInfo::getDemonSpawnRateGlobalCounterEnhancementPercent() const    {return m_iDemonSpawnRateGlobalCounterEnhancementPercent;}
int CvHandicapInfo::getDemonBonus() const										{return m_iDemonBonus;}
int CvHandicapInfo::getAIDemonBonus() const										{return m_iAIDemonBonus;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

// Arrays

int CvHandicapInfo::getGoodies(int i) const
{
	FAssertMsg(i < getNumGoodies(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGoodies[i];
}

int CvHandicapInfo::isFreeTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFreeTechs[i];
}

int CvHandicapInfo::isAIFreeTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbAIFreeTechs[i];
}

void CvHandicapInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// Flag for Expansion

	stream->Read(&m_iFreeWinsVsBarbs);
	stream->Read(&m_iAnimalAttackProb);
	stream->Read(&m_iStartingLocationPercent);
	stream->Read(&m_iAdvancedStartPointsMod);
	stream->Read(&m_iStartingGold);
	stream->Read(&m_iFreeUnits);
	stream->Read(&m_iUnitCostPercent);
	stream->Read(&m_iResearchPercent);
	stream->Read(&m_iDistanceMaintenancePercent);
	stream->Read(&m_iNumCitiesMaintenancePercent);
	stream->Read(&m_iMaxNumCitiesMaintenance);
	stream->Read(&m_iColonyMaintenancePercent);
	stream->Read(&m_iMaxColonyMaintenance);
	stream->Read(&m_iCorporationMaintenancePercent);
	stream->Read(&m_iCivicUpkeepPercent);
	stream->Read(&m_iInflationPercent);
	stream->Read(&m_iHealthBonus);
	stream->Read(&m_iHappyBonus);
	stream->Read(&m_iAttitudeChange);
	stream->Read(&m_iNoTechTradeModifier);
	stream->Read(&m_iTechTradeKnownModifier);
	stream->Read(&m_iUnownedTilesPerGameAnimal);
	stream->Read(&m_iUnownedTilesPerBarbarianUnit);
	stream->Read(&m_iUnownedWaterTilesPerBarbarianUnit);
	stream->Read(&m_iUnownedTilesPerBarbarianCity);
	stream->Read(&m_iBarbarianCreationTurnsElapsed);
	stream->Read(&m_iBarbarianCityCreationTurnsElapsed);
	stream->Read(&m_iBarbarianCityCreationProb);
	stream->Read(&m_iAnimalCombatModifier);
	stream->Read(&m_iBarbarianCombatModifier);
	stream->Read(&m_iAIAnimalCombatModifier);
	stream->Read(&m_iAIBarbarianCombatModifier);

	stream->Read(&m_iStartingDefenseUnits);
	stream->Read(&m_iStartingWorkerUnits);
	stream->Read(&m_iStartingExploreUnits);
	stream->Read(&m_iAIStartingUnitMultiplier);
	stream->Read(&m_iAIStartingDefenseUnits);
	stream->Read(&m_iAIStartingWorkerUnits);
	stream->Read(&m_iAIStartingExploreUnits);
	stream->Read(&m_iBarbarianInitialDefenders);
	stream->Read(&m_iAIDeclareWarProb);
	stream->Read(&m_iAIWorkRateModifier);
	stream->Read(&m_iAIGrowthPercent);
	stream->Read(&m_iAITrainPercent);
	stream->Read(&m_iAIWorldTrainPercent);
	stream->Read(&m_iAIConstructPercent);
	stream->Read(&m_iAIWorldConstructPercent);
	stream->Read(&m_iAICreatePercent);
	stream->Read(&m_iAIWorldCreatePercent);
	stream->Read(&m_iAICivicUpkeepPercent);
	stream->Read(&m_iAIUnitCostPercent);
	stream->Read(&m_iAIUnitSupplyPercent);
	stream->Read(&m_iAIUnitUpgradePercent);
	stream->Read(&m_iAIInflationPercent);
	stream->Read(&m_iAIWarWearinessPercent);
	stream->Read(&m_iAIPerEraModifier);
	stream->Read(&m_iAIAdvancedStartPercent);
	stream->Read(&m_iNumGoodies);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Read(&m_iAIFreeXP);
	stream->Read(&m_iLairSpawnRate);
//FfH: End Add

	stream->ReadString(m_szHandicapName);
/*************************************************************************************************/
/**	New Tag Defs	(HandicapInfos)			12/27/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iUnownedWaterTilesPerGameAnimal);
	stream->Read(&m_iAnimalEscalationTurnsElapsed);
	stream->Read(&m_iLairSpawnChance);
	stream->Read(&m_iLairsPerCycle);
	stream->Read(&m_iPercentDemonsPerUnownedEvilPlot);
	stream->Read(&m_iDemonGlobalCountSpawnBoostInterval);
	stream->Read(&m_iDemonGlobalCountSpawnBoostRate);
	stream->Read(&m_iDemonPerTurnKnownTechsPercent);
	stream->Read(&m_iDemonGlobalCounterFreeXPPercent);
	stream->Read(&m_iDemonSpawnRateGlobalCounterEnhancementPercent);
	stream->Read(&m_iDemonBonus);
	stream->Read(&m_iAIDemonBonus);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	// Arrays

	SAFE_DELETE_ARRAY(m_piGoodies);
	m_piGoodies = new int[getNumGoodies()];
	stream->Read(getNumGoodies(), m_piGoodies);

	SAFE_DELETE_ARRAY(m_pbFreeTechs);
	m_pbFreeTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbFreeTechs);

	SAFE_DELETE_ARRAY(m_pbAIFreeTechs);
	m_pbAIFreeTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbAIFreeTechs);
}

void CvHandicapInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// Flag for Expansion

	stream->Write(m_iFreeWinsVsBarbs);
	stream->Write(m_iAnimalAttackProb);
	stream->Write(m_iStartingLocationPercent);
	stream->Write(m_iAdvancedStartPointsMod);
	stream->Write(m_iStartingGold);
	stream->Write(m_iFreeUnits);
	stream->Write(m_iUnitCostPercent);
	stream->Write(m_iResearchPercent);
	stream->Write(m_iDistanceMaintenancePercent);
	stream->Write(m_iNumCitiesMaintenancePercent);
	stream->Write(m_iMaxNumCitiesMaintenance);
	stream->Write(m_iColonyMaintenancePercent);
	stream->Write(m_iMaxColonyMaintenance);
	stream->Write(m_iCorporationMaintenancePercent);
	stream->Write(m_iCivicUpkeepPercent);
	stream->Write(m_iInflationPercent);
	stream->Write(m_iHealthBonus);
	stream->Write(m_iHappyBonus);
	stream->Write(m_iAttitudeChange);
	stream->Write(m_iNoTechTradeModifier);
	stream->Write(m_iTechTradeKnownModifier);
	stream->Write(m_iUnownedTilesPerGameAnimal);
	stream->Write(m_iUnownedTilesPerBarbarianUnit);
	stream->Write(m_iUnownedWaterTilesPerBarbarianUnit);
	stream->Write(m_iUnownedTilesPerBarbarianCity);
	stream->Write(m_iBarbarianCreationTurnsElapsed);
	stream->Write(m_iBarbarianCityCreationTurnsElapsed);
	stream->Write(m_iBarbarianCityCreationProb);
	stream->Write(m_iAnimalCombatModifier);
	stream->Write(m_iBarbarianCombatModifier);
	stream->Write(m_iAIAnimalCombatModifier);
	stream->Write(m_iAIBarbarianCombatModifier);

	stream->Write(m_iStartingDefenseUnits);
	stream->Write(m_iStartingWorkerUnits);
	stream->Write(m_iStartingExploreUnits);
	stream->Write(m_iAIStartingUnitMultiplier);
	stream->Write(m_iAIStartingDefenseUnits);
	stream->Write(m_iAIStartingWorkerUnits);
	stream->Write(m_iAIStartingExploreUnits);
	stream->Write(m_iBarbarianInitialDefenders);
	stream->Write(m_iAIDeclareWarProb);
	stream->Write(m_iAIWorkRateModifier);
	stream->Write(m_iAIGrowthPercent);
	stream->Write(m_iAITrainPercent);
	stream->Write(m_iAIWorldTrainPercent);
	stream->Write(m_iAIConstructPercent);
	stream->Write(m_iAIWorldConstructPercent);
	stream->Write(m_iAICreatePercent);
	stream->Write(m_iAIWorldCreatePercent);
	stream->Write(m_iAICivicUpkeepPercent);
	stream->Write(m_iAIUnitCostPercent);
	stream->Write(m_iAIUnitSupplyPercent);
	stream->Write(m_iAIUnitUpgradePercent);
	stream->Write(m_iAIInflationPercent);
	stream->Write(m_iAIWarWearinessPercent);
	stream->Write(m_iAIPerEraModifier);
	stream->Write(m_iAIAdvancedStartPercent);
	stream->Write(m_iNumGoodies);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Write(m_iAIFreeXP);
	stream->Write(m_iLairSpawnRate);
//FfH: End Add

	stream->WriteString(m_szHandicapName);
/*************************************************************************************************/
/**	New Tag Defs	(HandicapInfos)			12/27/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iUnownedWaterTilesPerGameAnimal);
	stream->Write(m_iAnimalEscalationTurnsElapsed);
	stream->Write(m_iLairSpawnChance);
	stream->Write(m_iLairsPerCycle);
	stream->Write(m_iPercentDemonsPerUnownedEvilPlot);
	stream->Write(m_iDemonGlobalCountSpawnBoostInterval);
	stream->Write(m_iDemonGlobalCountSpawnBoostRate);
	stream->Write(m_iDemonPerTurnKnownTechsPercent);
	stream->Write(m_iDemonGlobalCounterFreeXPPercent);
	stream->Write(m_iDemonSpawnRateGlobalCounterEnhancementPercent);
	stream->Write(m_iDemonBonus);
	stream->Write(m_iAIDemonBonus);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	// Arrays

	stream->Write(getNumGoodies(), m_piGoodies);
	stream->Write(GC.getNumTechInfos(), m_pbFreeTechs);
	stream->Write(GC.getNumTechInfos(), m_pbAIFreeTechs);
}

bool CvHandicapInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j;

	pXML->GetChildXmlValByName(&m_iFreeWinsVsBarbs, "iFreeWinsVsBarbs");
	pXML->GetChildXmlValByName(&m_iAnimalAttackProb, "iAnimalAttackProb");
	pXML->GetChildXmlValByName(&m_iStartingLocationPercent, "iStartingLocPercent");
	pXML->GetChildXmlValByName(&m_iAdvancedStartPointsMod, "iAdvancedStartPointsMod");
	pXML->GetChildXmlValByName(&m_iStartingGold, "iGold");
	pXML->GetChildXmlValByName(&m_iFreeUnits, "iFreeUnits");
	pXML->GetChildXmlValByName(&m_iUnitCostPercent, "iUnitCostPercent");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iDistanceMaintenancePercent, "iDistanceMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iNumCitiesMaintenancePercent, "iNumCitiesMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iMaxNumCitiesMaintenance, "iMaxNumCitiesMaintenance");
	pXML->GetChildXmlValByName(&m_iColonyMaintenancePercent, "iColonyMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iMaxColonyMaintenance, "iMaxColonyMaintenance");
	pXML->GetChildXmlValByName(&m_iCorporationMaintenancePercent, "iCorporationMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iCivicUpkeepPercent, "iCivicUpkeepPercent");
	pXML->GetChildXmlValByName(&m_iInflationPercent, "iInflationPercent");
	pXML->GetChildXmlValByName(&m_iHealthBonus, "iHealthBonus");
	pXML->GetChildXmlValByName(&m_iHappyBonus, "iHappyBonus");
	pXML->GetChildXmlValByName(&m_iAttitudeChange, "iAttitudeChange");
	pXML->GetChildXmlValByName(&m_iNoTechTradeModifier, "iNoTechTradeModifier");
	pXML->GetChildXmlValByName(&m_iTechTradeKnownModifier, "iTechTradeKnownModifier");
	pXML->GetChildXmlValByName(&m_iUnownedTilesPerGameAnimal, "iUnownedTilesPerGameAnimal");
	pXML->GetChildXmlValByName(&m_iUnownedTilesPerBarbarianUnit, "iUnownedTilesPerBarbarianUnit");
	pXML->GetChildXmlValByName(&m_iUnownedWaterTilesPerBarbarianUnit, "iUnownedWaterTilesPerBarbarianUnit");
	pXML->GetChildXmlValByName(&m_iUnownedTilesPerBarbarianCity, "iUnownedTilesPerBarbarianCity");
	pXML->GetChildXmlValByName(&m_iBarbarianCreationTurnsElapsed, "iBarbarianCreationTurnsElapsed");
	pXML->GetChildXmlValByName(&m_iBarbarianCityCreationTurnsElapsed, "iBarbarianCityCreationTurnsElapsed");
	pXML->GetChildXmlValByName(&m_iBarbarianCityCreationProb, "iBarbarianCityCreationProb");
	pXML->GetChildXmlValByName(&m_iAnimalCombatModifier, "iAnimalBonus");
	pXML->GetChildXmlValByName(&m_iBarbarianCombatModifier, "iBarbarianBonus");
	pXML->GetChildXmlValByName(&m_iAIAnimalCombatModifier, "iAIAnimalBonus");
	pXML->GetChildXmlValByName(&m_iAIBarbarianCombatModifier, "iAIBarbarianBonus");
	pXML->GetChildXmlValByName(&m_iStartingDefenseUnits, "iStartingDefenseUnits");
	pXML->GetChildXmlValByName(&m_iStartingWorkerUnits, "iStartingWorkerUnits");
	pXML->GetChildXmlValByName(&m_iStartingExploreUnits, "iStartingExploreUnits");
	pXML->GetChildXmlValByName(&m_iAIStartingUnitMultiplier, "iAIStartingUnitMultiplier");
	pXML->GetChildXmlValByName(&m_iAIStartingDefenseUnits, "iAIStartingDefenseUnits");
	pXML->GetChildXmlValByName(&m_iAIStartingWorkerUnits, "iAIStartingWorkerUnits");
	pXML->GetChildXmlValByName(&m_iAIStartingExploreUnits, "iAIStartingExploreUnits");
	pXML->GetChildXmlValByName(&m_iBarbarianInitialDefenders, "iBarbarianDefenders");
	pXML->GetChildXmlValByName(&m_iAIDeclareWarProb, "iAIDeclareWarProb");
	pXML->GetChildXmlValByName(&m_iAIWorkRateModifier, "iAIWorkRateModifier");
	pXML->GetChildXmlValByName(&m_iAIGrowthPercent, "iAIGrowthPercent");
	pXML->GetChildXmlValByName(&m_iAITrainPercent, "iAITrainPercent");
	pXML->GetChildXmlValByName(&m_iAIWorldTrainPercent, "iAIWorldTrainPercent");
	pXML->GetChildXmlValByName(&m_iAIConstructPercent, "iAIConstructPercent");
	pXML->GetChildXmlValByName(&m_iAIWorldConstructPercent, "iAIWorldConstructPercent");
	pXML->GetChildXmlValByName(&m_iAICreatePercent, "iAICreatePercent");
	pXML->GetChildXmlValByName(&m_iAIWorldCreatePercent, "iAIWorldCreatePercent");
	pXML->GetChildXmlValByName(&m_iAICivicUpkeepPercent, "iAICivicUpkeepPercent");
	pXML->GetChildXmlValByName(&m_iAIUnitCostPercent, "iAIUnitCostPercent");
	pXML->GetChildXmlValByName(&m_iAIUnitSupplyPercent, "iAIUnitSupplyPercent");
	pXML->GetChildXmlValByName(&m_iAIUnitUpgradePercent, "iAIUnitUpgradePercent");
	pXML->GetChildXmlValByName(&m_iAIInflationPercent, "iAIInflationPercent");
	pXML->GetChildXmlValByName(&m_iAIWarWearinessPercent, "iAIWarWearinessPercent");
	pXML->GetChildXmlValByName(&m_iAIPerEraModifier, "iAIPerEraModifier");
	pXML->GetChildXmlValByName(&m_iAIAdvancedStartPercent, "iAIAdvancedStartPercent");
/*************************************************************************************************/
/**	New Tag Defs	(HandicapInfos)			12/27/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iUnownedWaterTilesPerGameAnimal, "iUnownedWaterTilesPerGameAnimal");
	pXML->GetChildXmlValByName(&m_iAnimalEscalationTurnsElapsed, "iAnimalEscalationTurnsElapsed");
	pXML->GetChildXmlValByName(&m_iLairSpawnChance, "iLairSpawnChance");
	pXML->GetChildXmlValByName(&m_iLairsPerCycle, "iLairsPerCycle");
	pXML->GetChildXmlValByName(&m_iPercentDemonsPerUnownedEvilPlot, "iPercentDemonsPerUnownedEvilPlot");
	pXML->GetChildXmlValByName(&m_iDemonGlobalCountSpawnBoostInterval, "iDemonGlobalCountSpawnBoostInterval");
	pXML->GetChildXmlValByName(&m_iDemonGlobalCountSpawnBoostRate, "iDemonGlobalCountSpawnBoostRate");
	pXML->GetChildXmlValByName(&m_iDemonPerTurnKnownTechsPercent, "iDemonPerTurnKnownTechsPercent");
	pXML->GetChildXmlValByName(&m_iDemonGlobalCounterFreeXPPercent, "iDemonGlobalCounterFreeXPPercent");
	pXML->GetChildXmlValByName(&m_iDemonSpawnRateGlobalCounterEnhancementPercent, "iDemonSpawnRateGlobalCounterEnhancementPercent");
	pXML->GetChildXmlValByName(&m_iDemonBonus, "iDemonBonus");
	pXML->GetChildXmlValByName(&m_iAIDemonBonus, "iAIDemonBonus");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Goodies"))
	{
		CvString* pszGoodyNames = NULL;
		pXML->SetStringList(&pszGoodyNames, &m_iNumGoodies);

		if (m_iNumGoodies > 0)
		{
			m_piGoodies = new int[m_iNumGoodies];

			for (j=0;j<m_iNumGoodies;j++)
			{
				m_piGoodies[j] = pXML->FindInInfoClass(pszGoodyNames[j]);
			}
		}
		else
		{
			m_piGoodies = NULL;
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

		SAFE_DELETE_ARRAY(pszGoodyNames);
	}

	pXML->SetVariableListTagPair(&m_pbFreeTechs, "FreeTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
	pXML->SetVariableListTagPair(&m_pbAIFreeTechs, "AIFreeTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());

//FfH Improvements: Added by Kael 08/07/2007
	pXML->GetChildXmlValByName(&m_iAIFreeXP, "iAIFreeXP");
	pXML->GetChildXmlValByName(&m_iLairSpawnRate, "iLairSpawnRate");
//FfH: End Add

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(HandicapInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvHandicapInfo::copyNonDefaults(CvHandicapInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getFreeWinsVsBarbs()					== 0)		m_iFreeWinsVsBarbs						= pClassInfo->getFreeWinsVsBarbs();
	if (getAnimalAttackProb()					== 0)		m_iAnimalAttackProb						= pClassInfo->getAnimalAttackProb();
	if (getStartingLocationPercent()			== 0)		m_iStartingLocationPercent				= pClassInfo->getStartingLocationPercent();
	if (getAdvancedStartPointsMod()				== 0)		m_iAdvancedStartPointsMod				= pClassInfo->getAdvancedStartPointsMod();
	if (getStartingGold()						== 0)		m_iStartingGold							= pClassInfo->getStartingGold();
	if (getFreeUnits()							== 0)		m_iFreeUnits							= pClassInfo->getFreeUnits();
	if (getUnitCostPercent()					== 0)		m_iUnitCostPercent						= pClassInfo->getUnitCostPercent();
	if (getResearchPercent()					== 0)		m_iResearchPercent						= pClassInfo->getResearchPercent();
	if (getDistanceMaintenancePercent()			== 0)		m_iDistanceMaintenancePercent			= pClassInfo->getDistanceMaintenancePercent();
	if (getNumCitiesMaintenancePercent()		== 0)		m_iNumCitiesMaintenancePercent			= pClassInfo->getNumCitiesMaintenancePercent();
	if (getMaxNumCitiesMaintenance()			== 0)		m_iMaxNumCitiesMaintenance				= pClassInfo->getMaxNumCitiesMaintenance();
	if (getColonyMaintenancePercent()			== 0)		m_iColonyMaintenancePercent				= pClassInfo->getColonyMaintenancePercent();
	if (getMaxColonyMaintenance()				== 0)		m_iMaxColonyMaintenance					= pClassInfo->getMaxColonyMaintenance();
	if (getCorporationMaintenancePercent()		== 0)		m_iCorporationMaintenancePercent		= pClassInfo->getCorporationMaintenancePercent();
	if (getCivicUpkeepPercent()					== 0)		m_iCivicUpkeepPercent					= pClassInfo->getCivicUpkeepPercent();
	if (getInflationPercent()					== 0)		m_iInflationPercent						= pClassInfo->getInflationPercent();
	if (getHealthBonus()						== 0)		m_iHealthBonus							= pClassInfo->getHealthBonus();
	if (getHappyBonus()							== 0)		m_iHappyBonus							= pClassInfo->getHappyBonus();
	if (getAttitudeChange()						== 0)		m_iAttitudeChange						= pClassInfo->getAttitudeChange();
	if (getNoTechTradeModifier()				== 0)		m_iNoTechTradeModifier					= pClassInfo->getNoTechTradeModifier();
	if (getTechTradeKnownModifier()				== 0)		m_iTechTradeKnownModifier				= pClassInfo->getTechTradeKnownModifier();
	if (getUnownedTilesPerGameAnimal()			== 0)		m_iUnownedTilesPerGameAnimal			= pClassInfo->getUnownedTilesPerGameAnimal();
	if (getUnownedTilesPerBarbarianUnit()		== 0)		m_iUnownedTilesPerBarbarianUnit			= pClassInfo->getUnownedTilesPerBarbarianUnit();
	if (getUnownedWaterTilesPerBarbarianUnit()	== 0)		m_iUnownedWaterTilesPerBarbarianUnit	= pClassInfo->getUnownedWaterTilesPerBarbarianUnit();
	if (getUnownedTilesPerBarbarianCity()		== 0)		m_iUnownedTilesPerBarbarianCity			= pClassInfo->getUnownedTilesPerBarbarianCity();
	if (getBarbarianCreationTurnsElapsed()		== 0)		m_iBarbarianCreationTurnsElapsed		= pClassInfo->getBarbarianCreationTurnsElapsed();
	if (getBarbarianCityCreationTurnsElapsed()	== 0)		m_iBarbarianCityCreationTurnsElapsed	= pClassInfo->getBarbarianCityCreationTurnsElapsed();
	if (getBarbarianCityCreationProb()			== 0)		m_iBarbarianCityCreationProb			= pClassInfo->getBarbarianCityCreationProb();
	if (getAnimalCombatModifier()				== 0)		m_iAnimalCombatModifier					= pClassInfo->getAnimalCombatModifier();
	if (getBarbarianCombatModifier()			== 0)		m_iBarbarianCombatModifier				= pClassInfo->getBarbarianCombatModifier();
	if (getAIAnimalCombatModifier()				== 0)		m_iAIAnimalCombatModifier				= pClassInfo->getAIAnimalCombatModifier();
	if (getAIBarbarianCombatModifier()			== 0)		m_iAIBarbarianCombatModifier			= pClassInfo->getAIBarbarianCombatModifier();
	if (getStartingDefenseUnits()				== 0)		m_iStartingDefenseUnits					= pClassInfo->getStartingDefenseUnits();
	if (getStartingWorkerUnits()				== 0)		m_iStartingWorkerUnits					= pClassInfo->getStartingWorkerUnits();
	if (getStartingExploreUnits()				== 0)		m_iStartingExploreUnits					= pClassInfo->getStartingExploreUnits();
	if (getAIStartingUnitMultiplier()			== 0)		m_iAIStartingUnitMultiplier				= pClassInfo->getAIStartingUnitMultiplier();
	if (getAIStartingDefenseUnits()				== 0)		m_iAIStartingDefenseUnits				= pClassInfo->getAIStartingDefenseUnits();
	if (getAIStartingWorkerUnits()				== 0)		m_iAIStartingWorkerUnits				= pClassInfo->getAIStartingWorkerUnits();
	if (getAIStartingExploreUnits()				== 0)		m_iAIStartingExploreUnits				= pClassInfo->getAIStartingExploreUnits();
	if (getBarbarianInitialDefenders()			== 0)		m_iBarbarianInitialDefenders			= pClassInfo->getBarbarianInitialDefenders();
	if (getAIDeclareWarProb()					== 0)		m_iAIDeclareWarProb						= pClassInfo->getAIDeclareWarProb();
	if (getAIWorkRateModifier()					== 0)		m_iAIWorkRateModifier					= pClassInfo->getAIWorkRateModifier();
	if (getAIGrowthPercent()					== 0)		m_iAIGrowthPercent						= pClassInfo->getAIGrowthPercent();
	if (getAITrainPercent()						== 0)		m_iAITrainPercent						= pClassInfo->getAITrainPercent();
	if (getAIWorldTrainPercent()				== 0)		m_iAIWorldTrainPercent					= pClassInfo->getAIWorldTrainPercent();
	if (getAIConstructPercent()					== 0)		m_iAIConstructPercent					= pClassInfo->getAIConstructPercent();
	if (getAIWorldConstructPercent()			== 0)		m_iAIWorldConstructPercent				= pClassInfo->getAIWorldConstructPercent();
	if (getAICreatePercent()					== 0)		m_iAICreatePercent						= pClassInfo->getAICreatePercent();
	if (getAIWorldCreatePercent()				== 0)		m_iAIWorldCreatePercent					= pClassInfo->getAIWorldCreatePercent();
	if (getAICivicUpkeepPercent()				== 0)		m_iAICivicUpkeepPercent					= pClassInfo->getAICivicUpkeepPercent();
	if (getAIUnitCostPercent()					== 0)		m_iAIUnitCostPercent					= pClassInfo->getAIUnitCostPercent();
	if (getAIUnitSupplyPercent()				== 0)		m_iAIUnitSupplyPercent					= pClassInfo->getAIUnitSupplyPercent();
	if (getAIUnitUpgradePercent()				== 0)		m_iAIUnitUpgradePercent					= pClassInfo->getAIUnitUpgradePercent();
	if (getAIInflationPercent()					== 0)		m_iAIInflationPercent					= pClassInfo->getAIInflationPercent();
	if (getAIWarWearinessPercent()				== 0)		m_iAIWarWearinessPercent				= pClassInfo->getAIWarWearinessPercent();
	if (getAIPerEraModifier()					== 0)		m_iAIPerEraModifier						= pClassInfo->getAIPerEraModifier();
	if (getAIAdvancedStartPercent()				== 0)		m_iAIAdvancedStartPercent				= pClassInfo->getAIAdvancedStartPercent();
	if (getUnownedWaterTilesPerGameAnimal()		== 0)		m_iUnownedWaterTilesPerGameAnimal		= pClassInfo->getUnownedWaterTilesPerGameAnimal();
	if (getAnimalEscalationTurnsElapsed()		== 0)		m_iAnimalEscalationTurnsElapsed			= pClassInfo->getAnimalEscalationTurnsElapsed();
	if (getLairSpawnChance()					== 0)		m_iLairSpawnChance						= pClassInfo->getLairSpawnChance();
	if (getLairsPerCycle()						== 0)		m_iLairsPerCycle						= pClassInfo->getLairsPerCycle();
	if (getPercentDemonsPerUnownedEvilPlot()	== 0)		m_iPercentDemonsPerUnownedEvilPlot		= pClassInfo->getPercentDemonsPerUnownedEvilPlot();
	if (getDemonGlobalCountSpawnBoostInterval()	== 0)		m_iDemonGlobalCountSpawnBoostInterval	= pClassInfo->getDemonGlobalCountSpawnBoostInterval();
	if (getDemonGlobalCountSpawnBoostRate()		== 0)		m_iDemonGlobalCountSpawnBoostRate		= pClassInfo->getDemonGlobalCountSpawnBoostRate();
	if (getDemonPerTurnKnownTechsPercent()		== 0)		m_iDemonPerTurnKnownTechsPercent		= pClassInfo->getDemonPerTurnKnownTechsPercent();
	if (getDemonGlobalCounterFreeXPPercent()	== 0)		m_iDemonGlobalCounterFreeXPPercent		= pClassInfo->getDemonGlobalCounterFreeXPPercent();
	if (getDemonSpawnRateGlobalCounterEnhancementPercent()	== 0)	m_iDemonSpawnRateGlobalCounterEnhancementPercent	= pClassInfo->getDemonSpawnRateGlobalCounterEnhancementPercent();
	if (getDemonBonus()							== 0)		m_iDemonBonus							= pClassInfo->getDemonBonus();
	if (getAIDemonBonus()						== 0)		m_iAIDemonBonus							= pClassInfo->getAIDemonBonus();
	if (getAIFreeXP()							== 0)		m_iAIFreeXP								= (float)pClassInfo->getAIFreeXP()/100.0f;
	if (getLairSpawnRate()						== 0)		m_iLairSpawnRate						= pClassInfo->getLairSpawnRate();
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if (m_pbFreeTechs[i]					== false)	m_pbFreeTechs[i]						= pClassInfo->isFreeTechs(i);
		if (m_pbAIFreeTechs[i]					== false)	m_pbAIFreeTechs[i]						= pClassInfo->isAIFreeTechs(i);
	}
	if ( pClassInfo->getNumGoodies() >= 0 )
	{
		int iNumGoodiesOld = m_iNumGoodies;
		CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
		for ( int i = 0; i < pClassInfo->getNumGoodies(); i++ )
		{
			if (!(pCurrentUnitClass->isDuplicate(getNumGoodies(), &m_piGoodies[0], pClassInfo->getGoodies(i))))
			{
				if (pClassInfo->getGoodies(i) != NO_GOODY)	m_iNumGoodies++;
			}
		}
		int* m_piGoodiesTemp = new int[m_iNumGoodies];
		for ( int i = 0; i < m_iNumGoodies; i++ )
		{
			if (i < iNumGoodiesOld)		m_piGoodiesTemp[i] = m_piGoodies[i];
			else if (!(pCurrentUnitClass->isDuplicate(getNumGoodies(), &m_piGoodiesTemp[0], pClassInfo->getGoodies(i))))		m_piGoodiesTemp[i] = pClassInfo->getGoodies(i);
		}
		SAFE_DELETE_ARRAY(m_piGoodies);
		m_piGoodies = new int[m_iNumGoodies];
		for ( int i = 0; i < m_iNumGoodies; i++ )
		{
															m_piGoodies[i]							= m_piGoodiesTemp[i];
		}
		SAFE_DELETE_ARRAY(m_piGoodiesTemp);
		SAFE_DELETE(pCurrentUnitClass);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvGameSpeedInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvGameSpeedInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvGameSpeedInfo::CvGameSpeedInfo() :
m_iGrowthPercent(0),
m_iTrainPercent(0),
m_iConstructPercent(0),
m_iCreatePercent(0),
m_iResearchPercent(0),
m_iBuildPercent(0),
m_iImprovementPercent(0),
m_iGreatPeoplePercent(0),
m_iAnarchyPercent(0),
m_iBarbPercent(0),
m_iFeatureProductionPercent(0),
m_iUnitDiscoverPercent(0),
m_iUnitHurryPercent(0),
m_iUnitTradePercent(0),
m_iUnitGreatWorkPercent(0),
m_iGoldenAgePercent(0),
m_iHurryPercent(0),
m_iHurryConscriptAngerPercent(0),
m_iInflationOffset(0),
m_iInflationPercent(0),
m_iVictoryDelayPercent(0),
m_iNumTurnIncrements(0),
/*************************************************************************************************/
/**	New Tag Defs	(GameSpeedInfos)		12/27/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iTurnsPerLairCycle(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_pGameTurnInfo(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvGameSpeedInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvGameSpeedInfo::~CvGameSpeedInfo()
{
	SAFE_DELETE_ARRAY(m_pGameTurnInfo);
}

int CvGameSpeedInfo::getGrowthPercent() const
{
	return m_iGrowthPercent;
}

int CvGameSpeedInfo::getTrainPercent() const
{
	return m_iTrainPercent;
}

int CvGameSpeedInfo::getConstructPercent() const
{
	return m_iConstructPercent;
}

int CvGameSpeedInfo::getCreatePercent() const
{
	return m_iCreatePercent;
}

int CvGameSpeedInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvGameSpeedInfo::getBuildPercent() const
{
	return m_iBuildPercent;
}

int CvGameSpeedInfo::getImprovementPercent() const
{
	return m_iImprovementPercent;
}

int CvGameSpeedInfo::getGreatPeoplePercent() const
{
	return m_iGreatPeoplePercent;
}

int CvGameSpeedInfo::getAnarchyPercent() const
{
	return m_iAnarchyPercent;
}

int CvGameSpeedInfo::getBarbPercent() const
{
	return m_iBarbPercent;
}

int CvGameSpeedInfo::getFeatureProductionPercent() const
{
	return m_iFeatureProductionPercent;
}

int CvGameSpeedInfo::getUnitDiscoverPercent() const
{
	return m_iUnitDiscoverPercent;
}

int CvGameSpeedInfo::getUnitHurryPercent() const
{
	return m_iUnitHurryPercent;
}

int CvGameSpeedInfo::getUnitTradePercent() const
{
	return m_iUnitTradePercent;
}

int CvGameSpeedInfo::getUnitGreatWorkPercent() const
{
	return m_iUnitGreatWorkPercent;
}

int CvGameSpeedInfo::getGoldenAgePercent() const
{
	return m_iGoldenAgePercent;
}

int CvGameSpeedInfo::getHurryPercent() const
{
	return m_iHurryPercent;
}

int CvGameSpeedInfo::getHurryConscriptAngerPercent() const
{
	return m_iHurryConscriptAngerPercent;
}

int CvGameSpeedInfo::getInflationOffset() const
{
	return m_iInflationOffset;
}

int CvGameSpeedInfo::getInflationPercent() const
{
	return m_iInflationPercent;
}

int CvGameSpeedInfo::getVictoryDelayPercent() const
{
	return m_iVictoryDelayPercent;
}

int CvGameSpeedInfo::getNumTurnIncrements() const
{
	return m_iNumTurnIncrements;
}
/*************************************************************************************************/
/**	New Tag Defs	(GameSpeedInfos)		12/27/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvGameSpeedInfo::getTurnsPerLairCycle() const    {return m_iTurnsPerLairCycle;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

GameTurnInfo& CvGameSpeedInfo::getGameTurnInfo(int iIndex) const
{
	return m_pGameTurnInfo[iIndex];
}

void CvGameSpeedInfo::allocateGameTurnInfos(const int iSize)
{
	m_pGameTurnInfo = new GameTurnInfo[iSize];
}

bool CvGameSpeedInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j, iTempVal;

	pXML->GetChildXmlValByName(&m_iGrowthPercent, "iGrowthPercent");
	pXML->GetChildXmlValByName(&m_iTrainPercent, "iTrainPercent");
	pXML->GetChildXmlValByName(&m_iConstructPercent, "iConstructPercent");
	pXML->GetChildXmlValByName(&m_iCreatePercent, "iCreatePercent");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iBuildPercent, "iBuildPercent");
	pXML->GetChildXmlValByName(&m_iImprovementPercent, "iImprovementPercent");
	pXML->GetChildXmlValByName(&m_iGreatPeoplePercent, "iGreatPeoplePercent");
	pXML->GetChildXmlValByName(&m_iAnarchyPercent, "iAnarchyPercent");
	pXML->GetChildXmlValByName(&m_iBarbPercent, "iBarbPercent");
	pXML->GetChildXmlValByName(&m_iFeatureProductionPercent, "iFeatureProductionPercent");
	pXML->GetChildXmlValByName(&m_iUnitDiscoverPercent, "iUnitDiscoverPercent");
	pXML->GetChildXmlValByName(&m_iUnitHurryPercent, "iUnitHurryPercent");
	pXML->GetChildXmlValByName(&m_iUnitTradePercent, "iUnitTradePercent");
	pXML->GetChildXmlValByName(&m_iUnitGreatWorkPercent, "iUnitGreatWorkPercent");
	pXML->GetChildXmlValByName(&m_iGoldenAgePercent, "iGoldenAgePercent");
	pXML->GetChildXmlValByName(&m_iHurryPercent, "iHurryPercent");
	pXML->GetChildXmlValByName(&m_iHurryConscriptAngerPercent, "iHurryConscriptAngerPercent");
	pXML->GetChildXmlValByName(&m_iInflationOffset, "iInflationOffset");
	pXML->GetChildXmlValByName(&m_iInflationPercent, "iInflationPercent");
	pXML->GetChildXmlValByName(&m_iVictoryDelayPercent, "iVictoryDelayPercent");
/*************************************************************************************************/
/**	New Tag Defs	(GameSpeedInfos)		12/27/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iTurnsPerLairCycle, "iTurnsPerLairCycle");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GameTurnInfos"))
	{
		m_iNumTurnIncrements = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
		{
			allocateGameTurnInfos(getNumTurnIncrements());

			// loop through each tag
			for (j=0;j<getNumTurnIncrements();j++)
			{
				pXML->GetChildXmlValByName(&iTempVal, "iMonthIncrement");
				getGameTurnInfo(j).iMonthIncrement = iTempVal;
				pXML->GetChildXmlValByName(&iTempVal, "iTurnsPerIncrement");
				getGameTurnInfo(j).iNumGameTurnsPerIncrement = iTempVal;

				// if we cannot set the current xml node to it's next sibling then we will break out of the for loop
				// otherwise we will continue looping
				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(GameSpeedInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGameSpeedInfo::copyNonDefaults(CvGameSpeedInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getGrowthPercent()				== 0)		m_iGrowthPercent				= pClassInfo->getGrowthPercent();
	if (getTrainPercent()				== 0)		m_iTrainPercent					= pClassInfo->getTrainPercent();
	if (getConstructPercent()			== 0)		m_iConstructPercent				= pClassInfo->getConstructPercent();
	if (getCreatePercent()				== 0)		m_iCreatePercent				= pClassInfo->getCreatePercent();
	if (getResearchPercent()			== 0)		m_iResearchPercent				= pClassInfo->getResearchPercent();
	if (getBuildPercent()				== 0)		m_iBuildPercent					= pClassInfo->getBuildPercent();
	if (getImprovementPercent()			== 0)		m_iImprovementPercent			= pClassInfo->getImprovementPercent();
	if (getGreatPeoplePercent()			== 0)		m_iGreatPeoplePercent			= pClassInfo->getGreatPeoplePercent();
	if (getAnarchyPercent()				== 0)		m_iAnarchyPercent				= pClassInfo->getAnarchyPercent();
	if (getBarbPercent()				== 0)		m_iBarbPercent					= pClassInfo->getBarbPercent();
	if (getFeatureProductionPercent()	== 0)		m_iFeatureProductionPercent		= pClassInfo->getFeatureProductionPercent();
	if (getUnitDiscoverPercent()		== 0)		m_iUnitDiscoverPercent			= pClassInfo->getUnitDiscoverPercent();
	if (getUnitHurryPercent()			== 0)		m_iUnitHurryPercent				= pClassInfo->getUnitHurryPercent();
	if (getUnitTradePercent()			== 0)		m_iUnitTradePercent				= pClassInfo->getUnitTradePercent();
	if (getUnitGreatWorkPercent()		== 0)		m_iUnitGreatWorkPercent			= pClassInfo->getUnitGreatWorkPercent();
	if (getGoldenAgePercent()			== 0)		m_iGoldenAgePercent				= pClassInfo->getGoldenAgePercent();
	if (getHurryPercent()				== 0)		m_iHurryPercent					= pClassInfo->getHurryPercent();
	if (getHurryConscriptAngerPercent()	== 0)		m_iHurryConscriptAngerPercent	= pClassInfo->getHurryConscriptAngerPercent();
	if (getInflationOffset()			== 0)		m_iInflationOffset				= pClassInfo->getInflationOffset();
	if (getInflationPercent()			== 0)		m_iInflationPercent				= pClassInfo->getInflationPercent();
	if (getVictoryDelayPercent()		== 0)		m_iVictoryDelayPercent			= pClassInfo->getVictoryDelayPercent();
	if (getTurnsPerLairCycle()			== 0)		m_iTurnsPerLairCycle			= pClassInfo->getTurnsPerLairCycle();
	if (getNumTurnIncrements()			== 0)
	{
													m_iNumTurnIncrements			= pClassInfo->getNumTurnIncrements();
		allocateGameTurnInfos(getNumTurnIncrements());
		for (int j = 0; j < getNumTurnIncrements(); j++)
		{
													m_pGameTurnInfo[j]				= pClassInfo->getGameTurnInfo(j);
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvTurnTimerInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTurnTimerInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTurnTimerInfo::CvTurnTimerInfo() :
m_iBaseTime(0),
m_iCityBonus(0),
m_iUnitBonus(0),
m_iFirstTurnMultiplier(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTurnTimerInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTurnTimerInfo::~CvTurnTimerInfo()
{
}

int CvTurnTimerInfo::getBaseTime() const
{
	return m_iBaseTime;
}

int CvTurnTimerInfo::getCityBonus() const
{
	return m_iCityBonus;
}

int CvTurnTimerInfo::getUnitBonus() const
{
	return m_iUnitBonus;
}

int CvTurnTimerInfo::getFirstTurnMultiplier() const
{
	return m_iFirstTurnMultiplier;
}

bool CvTurnTimerInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iBaseTime, "iBaseTime");
	pXML->GetChildXmlValByName(&m_iCityBonus, "iCityBonus");
	pXML->GetChildXmlValByName(&m_iUnitBonus, "iUnitBonus");
	pXML->GetChildXmlValByName(&m_iFirstTurnMultiplier, "iFirstTurnMultiplier");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTurnTimerInfo::copyNonDefaults(CvTurnTimerInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getBaseTime()				== 0)		m_iBaseTime				= pClassInfo->getBaseTime();
	if (getCityBonus()				== 0)		m_iCityBonus			= pClassInfo->getCityBonus();
	if (getUnitBonus()				== 0)		m_iUnitBonus			= pClassInfo->getUnitBonus();
	if (getFirstTurnMultiplier()	== 0)		m_iFirstTurnMultiplier	= pClassInfo->getFirstTurnMultiplier();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvBuildInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBuildInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBuildInfo::CvBuildInfo() :
m_iTime(0),
m_iCost(0),
/*************************************************************************************************/
/**	BuildXP									7/17/10									Valkrionn	**/
/**																								**/
/**									Allows Builds to grant XP									**/
/*************************************************************************************************/
m_iXPValue(0.0f),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LinkedBuilds							7/18/10									Valkrionn	**/
/**																								**/
/**		Creates a list of Builds, which are executed before the main build if reqs are met		**/
/*************************************************************************************************/
m_iNumLinkedBuilds(0),
m_piLinkedBuilds(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_iTechPrereq(NO_TECH),
m_iImprovement(NO_IMPROVEMENT),
m_iRoute(NO_ROUTE),
m_iEntityEvent(ENTITY_EVENT_NONE),
m_iMissionType(NO_MISSION),
m_bKill(false),
m_paiFeatureTech(NULL),
m_paiFeatureTime(NULL),
m_paiFeatureProduction(NULL),
/*************************************************************************************************/
/**	New Tag Defs	(BuildInfos)			12/07/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_paiTechDiscount(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_pabFeatureRemove(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBuildInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBuildInfo::~CvBuildInfo()
{
	SAFE_DELETE_ARRAY(m_paiFeatureTech);
	SAFE_DELETE_ARRAY(m_paiFeatureTime);
	SAFE_DELETE_ARRAY(m_paiFeatureProduction);
	SAFE_DELETE_ARRAY(m_pabFeatureRemove);
/*************************************************************************************************/
/**	New Tag Defs	(BuildInfos)			12/07/08								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiTechDiscount);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LinkedBuilds							7/18/10									Valkrionn	**/
/**																								**/
/**		Creates a list of Builds, which are executed before the main build if reqs are met		**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piLinkedBuilds);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
}

int CvBuildInfo::getTime() const
{
	return m_iTime;
}

int CvBuildInfo::getCost() const
{
	return m_iCost;
}

/*************************************************************************************************/
/**	BuildXP									7/17/10									Valkrionn	**/
/**																								**/
/**									Allows Builds to grant XP									**/
/*************************************************************************************************/
int CvBuildInfo::getXPValue() const
{
	return (int)(m_iXPValue*100);
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LinkedBuilds							7/18/10									Valkrionn	**/
/**																								**/
/**		Creates a list of Builds, which are executed before the main build if reqs are met		**/
/*************************************************************************************************/
BuildTypes CvBuildInfo::getLinkedBuilds(int iI) const			{return (getNumLinkedBuilds() > iI)				? (BuildTypes)m_piLinkedBuilds[iI]	: NO_BUILD;}
int CvBuildInfo::getNumLinkedBuilds() const						{return m_iNumLinkedBuilds;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

int CvBuildInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvBuildInfo::getImprovement() const
{
	return m_iImprovement;
}

int CvBuildInfo::getRoute() const
{
	return m_iRoute;
}

int CvBuildInfo::getEntityEvent() const
{
	return m_iEntityEvent;
}

int CvBuildInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvBuildInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

bool CvBuildInfo::isKill() const
{
	return m_bKill;
}

// Arrays

int CvBuildInfo::getFeatureTech(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureTech ? m_paiFeatureTech[i] : -1;
}

int CvBuildInfo::getFeatureTime(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureTime ? m_paiFeatureTime[i] : -1;
}

int CvBuildInfo::getFeatureProduction(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureProduction ? m_paiFeatureProduction[i] : -1;
}

bool CvBuildInfo::isFeatureRemove(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabFeatureRemove ? m_pabFeatureRemove[i] : false;
}
/*************************************************************************************************/
/**	New Tag Defs	(BuildInfos)			12/07/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvBuildInfo::getTechDiscount(int iI) const			{return m_paiTechDiscount ? m_paiTechDiscount[iI] : 0;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

bool CvBuildInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iTime, "iTime");
	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_bKill, "bKill");
/*************************************************************************************************/
/**	BuildXP									7/17/10									Valkrionn	**/
/**																								**/
/**									Allows Builds to grant XP									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iXPValue, "iXPValue");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
	m_iImprovement = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RouteType");
	m_iRoute = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EntityEvent");
	m_iEntityEvent = pXML->FindInInfoClass(szTextVal);

	pXML->SetFeatureStruct(&m_paiFeatureTech, &m_paiFeatureTime, &m_paiFeatureProduction, &m_pabFeatureRemove);
/*************************************************************************************************/
/**	New Tag Defs	(BuildInfos)			12/07/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_paiTechDiscount, "TechBuildDiscounts", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	return true;
}

/*************************************************************************************************/
/**	LinkedBuilds							7/18/10									Valkrionn	**/
/**																								**/
/**		Creates a list of Builds, which are executed before the main build if reqs are met		**/
/*************************************************************************************************/
bool CvBuildInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	HotkeyInfo will call InfoBase for us, so if we need hotkeys, then we don't need Infobase	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"LinkedBuilds"))
		pXML->SetIntWithChildList(&m_iNumLinkedBuilds, &m_piLinkedBuilds);

	return true;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(BuildInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBuildInfo::copyNonDefaults(CvBuildInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getTechPrereq()				== NO_TECH)				m_iTechPrereq				= pClassInfo->getTechPrereq();
	if (getTime()					== 0)					m_iTime						= pClassInfo->getTime();
	if (getCost()					== 0)					m_iCost						= pClassInfo->getCost();
	if (isKill()					== false)				m_bKill						= pClassInfo->isKill();
/*************************************************************************************************/
/**	BuildXP									7/17/10									Valkrionn	**/
/**																								**/
/**									Allows Builds to grant XP									**/
/*************************************************************************************************/
	if(getXPValue()					== 0.0f)				m_iXPValue					= (float)(pClassInfo->getXPValue()/100.0);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	if (getImprovement()			== NO_IMPROVEMENT)		m_iImprovement				= pClassInfo->getImprovement();
	if (getRoute()					== NO_ROUTE)			m_iRoute					= pClassInfo->getRoute();
	if (getEntityEvent()			== ENTITY_EVENT_NONE)	m_iEntityEvent				= pClassInfo->getEntityEvent();
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if (m_paiFeatureTech[i]		== NO_TECH)
		{
															m_paiFeatureTech[i]			= pClassInfo->getFeatureTech(i);
															m_paiFeatureTime[i]			= pClassInfo->getFeatureTime(i);
															m_paiFeatureProduction[i]	= pClassInfo->getFeatureProduction(i);
															m_pabFeatureRemove[i]		= pClassInfo->isFeatureRemove(i);
		}
	}
	for ( int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if (m_paiTechDiscount[i]		== 0)
		{
															m_paiTechDiscount[i]			= pClassInfo->getTechDiscount(i);
		}
	}

	// Readpass2 stuff
/*************************************************************************************************/
/**	LinkedBuilds							7/18/10									Valkrionn	**/
/**																								**/
/**		Creates a list of Builds, which are executed before the main build if reqs are met		**/
/*************************************************************************************************/
	if(pClassInfo->getNumLinkedBuilds() > 0)
	{
		int* tempArray = new int[getNumLinkedBuilds() + pClassInfo->getNumLinkedBuilds()];
		for(int i = 0; i< getNumLinkedBuilds(); ++i)
		{
			tempArray[i] = getLinkedBuilds(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumLinkedBuilds(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumLinkedBuilds();++j)
			{
				if(pClassInfo->getLinkedBuilds(i) == getLinkedBuilds(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumLinkedBuilds()] = pClassInfo->getLinkedBuilds(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piLinkedBuilds);
		int iGoalSize = getNumLinkedBuilds() + iNewItems;
		m_piLinkedBuilds = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piLinkedBuilds[i] = tempArray[i];
			FAssertMsg(m_piLinkedBuilds[i] < GC.getNumBuildInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piLinkedBuilds[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumLinkedBuilds = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}

void CvBuildInfo::copyNonDefaultsReadPass2(CvBuildInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if(pClassInfo->getNumLinkedBuilds() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumLinkedBuilds() : getNumLinkedBuilds() + pClassInfo->getNumLinkedBuilds();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumLinkedBuilds(); ++i)
		{
			tempArray[i] = pClassInfo->getLinkedBuilds(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumLinkedBuilds();
			for(int i = 0; i< getNumLinkedBuilds(); ++i)
			{
				tempArray[i+iOffset] = getLinkedBuilds(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piLinkedBuilds);
		m_piLinkedBuilds = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piLinkedBuilds[i] = tempArray[i];
			FAssertMsg(m_piLinkedBuilds[i] < GC.getNumBuildInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piLinkedBuilds[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumLinkedBuilds = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvGoodyInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvGoodyInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvGoodyInfo::CvGoodyInfo() :
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
m_pbGoodyClassTypes(NULL),
m_bUnique(false),
m_iWeight(0),
m_iDamageType(NO_DAMAGE),
m_iDamageLimit(100),
m_iBonusType(NO_BONUS),
m_iPrereqAlignment(NO_ALIGNMENT),
m_iDestroyLairChance(0),
m_bAnyPromotion(0),
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
m_iGold(0),
m_iGoldRand1(0),
m_iGoldRand2(0),
m_iMapOffset(0),
m_iMapRange(0),
m_iMapProb(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iExperience(0),
/**								----  End Original Code  ----									**/
m_iExperience(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iHealing(0),
m_iDamagePrereq(0),
m_iBarbarianUnitProb(0),
m_iMinBarbarians(0),
m_iUnitClassType(NO_UNITCLASS),
m_iBarbarianUnitClass(NO_UNITCLASS),
/*************************************************************************************************/
/**	Spawn Groups						08/05/10									Valkrionn	**/
/**																								**/
/**					New spawn mechanic, allowing us to customize stacks							**/
/*************************************************************************************************/
m_iBarbarianSpawnGroup(NO_SPAWNGROUP),
/*************************************************************************************************/
/**	Spawn Groups							END													**/
/*************************************************************************************************/
m_bTech(false),
/*************************************************************************************************/
/**	New Tag Defs	(GoodyInfos)			07/29/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iScience(0),
m_iScienceRand1(0),
m_iScienceRand2(0),
m_iBarbarianCivilization(NO_CIVILIZATION),
m_iNumPromotionAdds(0),
m_piPromotionAdds(NULL),
m_iNumPromotionRemoves(0),
m_piPromotionRemoves(NULL),
m_iMinTurnsElapsed(0),
m_iMaxTurnsElapsed(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Balancing							05/10/12										Snarko	**/
/**																								**/
/**					Making the more OP results require certain techs							**/
/*************************************************************************************************/
m_iTechPrereq(NO_TECH),
m_iEraPrereq(NO_ERA),
/*************************************************************************************************/
/**	Balancing								END													**/
/*************************************************************************************************/
m_bBad(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvGoodyInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvGoodyInfo::~CvGoodyInfo()
{
/*************************************************************************************************/
/**	New Tag Defs	(GoodyInfos)			07/29/08								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPromotionAdds);
	SAFE_DELETE_ARRAY(m_piPromotionRemoves);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbGoodyClassTypes);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
}
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
bool CvGoodyInfo::isGoodyClassType(int i) const
{
	FAssertMsg(i < GC.getNumGoodyClassTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbGoodyClassTypes ? m_pbGoodyClassTypes[i] : 0;
}

int CvGoodyInfo::getWeight() const
{
	return m_iWeight;
}

int CvGoodyInfo::getDamageType() const
{
	return m_iDamageType;
}

int CvGoodyInfo::getDamageLimit() const
{
	return m_iDamageLimit;
}

int CvGoodyInfo::getBonusType() const
{
	return m_iBonusType;
}

int CvGoodyInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

int CvGoodyInfo::getDestroyLairChance() const
{
	return m_iDestroyLairChance;
}

const char* CvGoodyInfo::getPythonCallback() const
{
	return m_szPythonCallback;
}

const char* CvGoodyInfo::getPythonPrereq() const
{
	return m_szPythonPrereq;
}
bool CvGoodyInfo::isAnyPromotion() const
{
	return m_bAnyPromotion;
}
bool CvGoodyInfo::isUnique() const
{
	return m_bUnique;
}

/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/


int CvGoodyInfo::getGold() const
{
	return m_iGold;
}

int CvGoodyInfo::getGoldRand1() const
{
	return m_iGoldRand1;
}

int CvGoodyInfo::getGoldRand2() const
{
	return m_iGoldRand2;
}

int CvGoodyInfo::getMapOffset() const
{
	return m_iMapOffset;
}

int CvGoodyInfo::getMapRange() const
{
	return m_iMapRange;
}

int CvGoodyInfo::getMapProb() const
{
	return m_iMapProb;
}

int CvGoodyInfo::getExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvGoodyInfo::getHealing() const
{
	return m_iHealing;
}

int CvGoodyInfo::getDamagePrereq() const
{
	return m_iDamagePrereq;
}

int CvGoodyInfo::getBarbarianUnitProb() const
{
	return m_iBarbarianUnitProb;
}

int CvGoodyInfo::getMinBarbarians() const
{
	return m_iMinBarbarians;
}

int CvGoodyInfo::getUnitClassType() const
{
	return m_iUnitClassType;
}

int CvGoodyInfo::getBarbarianUnitClass() const
{
	return m_iBarbarianUnitClass;
}

/*************************************************************************************************/
/**	Spawn Groups						08/05/10									Valkrionn	**/
/**																								**/
/**					New spawn mechanic, allowing us to customize stacks							**/
/*************************************************************************************************/
int CvGoodyInfo::getBarbarianSpawnGroup() const
{
	return m_iBarbarianSpawnGroup;
}
/*************************************************************************************************/
/**	Spawn Groups							END													**/
/*************************************************************************************************/

bool CvGoodyInfo::isTech() const
{
	return m_bTech;
}

/*************************************************************************************************/
/**	New Tag Defs	(GoodyInfos)			07/29/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvGoodyInfo::getScience() const										{return m_iScience;}
int CvGoodyInfo::getScienceRand1() const								{return m_iScienceRand1;}
int CvGoodyInfo::getScienceRand2() const								{return m_iScienceRand2;}
int CvGoodyInfo::getBarbarianCivilization() const						{return m_iBarbarianCivilization;}
int CvGoodyInfo::getPromotionAdd(int iI) const							{return (getNumPromotionAdds() > iI)	? m_piPromotionAdds[iI]		: -1;}
int CvGoodyInfo::getNumPromotionAdds() const							{return m_iNumPromotionAdds;}
int CvGoodyInfo::getPromotionRemove(int iI) const						{return (getNumPromotionRemoves() > iI)	? m_piPromotionRemoves[iI]	: -1;}
int CvGoodyInfo::getNumPromotionRemoves() const							{return m_iNumPromotionRemoves;}
int CvGoodyInfo::getMinTurnsElapsed() const								{return m_iMinTurnsElapsed;}
int CvGoodyInfo::getMaxTurnsElapsed() const								{return m_iMaxTurnsElapsed;}
int CvGoodyInfo::getBarbarianCivilizationVectorSize()					{return m_aszExtraXMLforPass3.size();}
CvString CvGoodyInfo::getBarbarianCivilizationVectorElement(int i)		{return m_aszExtraXMLforPass3[i];}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
bool CvGoodyInfo::isBad() const
{
	return m_bBad;
}

/*************************************************************************************************/
/**	Balancing							05/10/12										Snarko	**/
/**																								**/
/**					Making the more OP results require certain techs							**/
/*************************************************************************************************/
int CvGoodyInfo::getPrereqTech() const
{
	return m_iTechPrereq;
}
int CvGoodyInfo::getPrereqEra() const
{
	return m_iEraPrereq;
}
/*************************************************************************************************/
/**	Balancing								END													**/
/*************************************************************************************************/

const TCHAR* CvGoodyInfo::getSound() const
{
	return m_szSound;
}

void CvGoodyInfo::setSound(const TCHAR* szVal)
{
	m_szSound=szVal;
}

bool CvGoodyInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_pbGoodyClassTypes, "GoodyClasses", GC.getGoodyClassTypes(), GC.getNumGoodyClassTypes());
	pXML->GetChildXmlValByName(&m_iWeight, "iWeight");
	pXML->GetChildXmlValByName(szTextVal, "DamageType");
	if (szTextVal != "") m_iDamageType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iDamageLimit, "iDamageLimit", 100);
	pXML->GetChildXmlValByName(szTextVal, "BonusType");
	if (szTextVal != "") m_iBonusType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(m_szPythonCallback, "PythonCallback");
	pXML->GetChildXmlValByName(m_szPythonPrereq, "PythonPrereq");
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	if (szTextVal != "") m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iDestroyLairChance, "iDestroyLairChance");
	pXML->GetChildXmlValByName(&m_bAnyPromotion, "bAnyPromotion");
	pXML->GetChildXmlValByName(&m_bUnique, "bUnique");
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(&m_iGold, "iGold");
	pXML->GetChildXmlValByName(&m_iGoldRand1, "iGoldRand1");
	pXML->GetChildXmlValByName(&m_iGoldRand2, "iGoldRand2");
	pXML->GetChildXmlValByName(&m_iMapOffset, "iMapOffset");
	pXML->GetChildXmlValByName(&m_iMapRange, "iMapRange");
	pXML->GetChildXmlValByName(&m_iMapProb, "iMapProb");
	pXML->GetChildXmlValByName(&m_iExperience, "iExperience");
	pXML->GetChildXmlValByName(&m_iHealing, "iHealing");
	pXML->GetChildXmlValByName(&m_iDamagePrereq, "iDamagePrereq");
	pXML->GetChildXmlValByName(&m_bTech, "bTech");
/*************************************************************************************************/
/**	New Tag Defs	(GoodyInfos)			07/29/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iScience, "iScience");
	pXML->GetChildXmlValByName(&m_iScienceRand1, "iScienceRand1");
	pXML->GetChildXmlValByName(&m_iScienceRand2, "iScienceRand2");
	pXML->GetChildXmlValByName(szTextVal, "BarbarianCivilization");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionAdds"))
		pXML->SetIntWithChildList(&m_iNumPromotionAdds, &m_piPromotionAdds);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionRemoves"))
		pXML->SetIntWithChildList(&m_iNumPromotionRemoves, &m_piPromotionRemoves);
	pXML->GetChildXmlValByName(&m_iMinTurnsElapsed, "iMinTurnsElapsed");
	pXML->GetChildXmlValByName(&m_iMaxTurnsElapsed, "iMaxTurnsElapsed");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bBad, "bBad");

	pXML->GetChildXmlValByName(szTextVal, "UnitClass");
	m_iUnitClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "BarbarianClass");
	m_iBarbarianUnitClass = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	Spawn Groups						08/05/10									Valkrionn	**/
/**																								**/
/**					New spawn mechanic, allowing us to customize stacks							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "BarbarianSpawnGroup");
	m_iBarbarianSpawnGroup = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Spawn Groups							END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(&m_iBarbarianUnitProb, "iBarbarianUnitProb");
	pXML->GetChildXmlValByName(&m_iMinBarbarians, "iMinBarbarians");

/*************************************************************************************************/
/**	Balancing							05/10/12										Snarko	**/
/**																								**/
/**					Making the more OP results require certain techs							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqEra");
	m_iEraPrereq = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Balancing								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	New Tag Defs	(GoodyInfos)			12/31/08								Xienwolf	**/
/**																								**/
/**					Third Pass to reference information which didn't exist before				**/
/*************************************************************************************************/
bool CvGoodyInfo::readPass3()
{
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iBarbarianCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
	m_aszExtraXMLforPass3.clear();
	return true;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(GoodyInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGoodyInfo::copyNonDefaults(CvGoodyInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	for ( int i = 0; i < GC.getNumGoodyClassTypes(); i++ )
	{
		if(isGoodyClassType(i)		== 0)					m_pbGoodyClassTypes[i]			= pClassInfo->isGoodyClassType(i);
	}
	if (getWeight()					== 0)				m_iWeight					= pClassInfo->getWeight();
	if (getDamageType()					== (int)NO_DAMAGE)			m_iDamageType					= pClassInfo->getDamageType();
	if (getDamageLimit()					== -1)			m_iDamageLimit					= pClassInfo->getDamageLimit();
	if (getBonusType()					== (int)NO_BONUS)			m_iBonusType					= pClassInfo->getBonusType();
	if (getPythonCallback()							== cDefault)		m_szPythonCallback						= pClassInfo->getPythonCallback();
	if (getPythonPrereq() == cDefault)		m_szPythonPrereq = pClassInfo->getPythonPrereq();
	if (getPrereqAlignment()					== (int)NO_ALIGNMENT)			m_iPrereqAlignment					= pClassInfo->getPrereqAlignment();
	if (getDestroyLairChance()					== 0)				m_iDestroyLairChance					= pClassInfo->getDestroyLairChance();
	if (isAnyPromotion()					== false)				m_bAnyPromotion					= pClassInfo->isAnyPromotion();
	if (isUnique() == false)				m_bUnique = pClassInfo->isUnique();
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/

	if (isTech()					== false)			m_bTech					= pClassInfo->isTech();
	if (isBad()						== false)			m_bBad					= pClassInfo->isBad();
	if (getGold()					== 0)				m_iGold					= pClassInfo->getGold();
	if (getGoldRand1()				== 0)				m_iGoldRand1			= pClassInfo->getGoldRand1();
	if (getGoldRand2()				== 0)				m_iGoldRand2			= pClassInfo->getGoldRand2();
	if (getMapOffset()				== 0)				m_iMapOffset			= pClassInfo->getMapOffset();
	if (getMapRange()				== 0)				m_iMapRange				= pClassInfo->getMapRange();
	if (getMapProb()				== 0)				m_iMapProb				= pClassInfo->getMapProb();
	if (getExperience()				== 0)				m_iExperience			= (float)(pClassInfo->getExperience()/100.0);
	if (getHealing()				== 0)				m_iHealing				= pClassInfo->getHealing();
	if (getDamagePrereq()			== 0)				m_iDamagePrereq			= pClassInfo->getDamagePrereq();
	if (getBarbarianUnitProb()		== 0)				m_iBarbarianUnitProb	= pClassInfo->getBarbarianUnitProb();
	if (getMinBarbarians()			== 0)				m_iMinBarbarians		= pClassInfo->getMinBarbarians();
	if (getScience()				== 0)				m_iScience				= pClassInfo->getScience();
	if (getScienceRand1()			== 0)				m_iScienceRand1			= pClassInfo->getScienceRand1();
	if (getScienceRand2()			== 0)				m_iScienceRand2			= pClassInfo->getScienceRand2();
	if (getMinTurnsElapsed()		== 0)				m_iMinTurnsElapsed		= pClassInfo->getMinTurnsElapsed();
	if (getMaxTurnsElapsed()		== 0)				m_iMaxTurnsElapsed		= pClassInfo->getMaxTurnsElapsed();
	if (getSound()					== cDefault)		setSound(				pClassInfo->getSound());
	if (getUnitClassType()			== NO_UNITCLASS)	m_iUnitClassType		= pClassInfo->getUnitClassType();
	if (getBarbarianUnitClass()		== NO_UNITCLASS)	m_iBarbarianUnitClass	= pClassInfo->getBarbarianUnitClass();
	if (getBarbarianSpawnGroup()	== NO_SPAWNGROUP)	m_iBarbarianSpawnGroup	= pClassInfo->getBarbarianSpawnGroup();
/*************************************************************************************************/
/**	Balancing							05/10/12										Snarko	**/
/**																								**/
/**					Making the more OP results require certain techs							**/
/*************************************************************************************************/
	if (getPrereqTech()				== NO_TECH)	m_iTechPrereq			= pClassInfo->getPrereqTech();
	if (getPrereqEra()				== NO_ERA)	m_iEraPrereq			= pClassInfo->getPrereqEra();
/*************************************************************************************************/
/**	Balancing								END													**/
/*************************************************************************************************/
	if(pClassInfo->getNumPromotionRemoves() > 0)
	{
		int* tempArray = new int[getNumPromotionRemoves() + pClassInfo->getNumPromotionRemoves()];
		for(int i = 0; i< getNumPromotionRemoves(); ++i)
		{
			tempArray[i] = getPromotionRemove(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionRemoves(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionRemoves();++j)
			{
				if(pClassInfo->getPromotionRemove(i) == getPromotionRemove(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionRemoves()] = pClassInfo->getPromotionRemove(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionRemoves);
		int iGoalSize = getNumPromotionRemoves() + iNewItems;
		m_piPromotionRemoves = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionRemoves[i] = tempArray[i];
			FAssertMsg(m_piPromotionRemoves[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionRemoves[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionRemoves = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionAdds() > 0)
	{
		int* tempArray = new int[getNumPromotionAdds() + pClassInfo->getNumPromotionAdds()];
		for(int i = 0; i< getNumPromotionAdds(); ++i)
		{
			tempArray[i] = getPromotionAdd(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionAdds(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionAdds();++j)
			{
				if(pClassInfo->getPromotionAdd(i) == getPromotionAdd(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionAdds()] = pClassInfo->getPromotionAdd(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionAdds);
		int iGoalSize = getNumPromotionAdds() + iNewItems;
		m_piPromotionAdds = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionAdds[i] = tempArray[i];
			FAssertMsg(m_piPromotionAdds[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionAdds[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionAdds = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}

	//Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getBarbarianCivilizationVectorSize(); i++ )
	{
														m_aszExtraXMLforPass3.push_back(		pClassInfo->getBarbarianCivilizationVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvRouteInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRouteInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRouteInfo::CvRouteInfo() :
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iValue(0),
m_iMovementCost(0),
m_iFlatMovementCost(0),
m_iPrereqBonus(NO_BONUS),
m_piYieldChange(NULL),
m_piTechMovementChange(NULL),
m_piPrereqOrBonuses(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRouteInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRouteInfo::~CvRouteInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piTechMovementChange);
	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
}

int CvRouteInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvRouteInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvRouteInfo::getValue() const
{
	return m_iValue;
}

int CvRouteInfo::getMovementCost() const
{
	return m_iMovementCost;
}

int CvRouteInfo::getFlatMovementCost() const
{
	return m_iFlatMovementCost;
}

int CvRouteInfo::getPrereqBonus() const
{
	return m_iPrereqBonus;
}

// Arrays

int CvRouteInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int CvRouteInfo::getTechMovementChange(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTechMovementChange ? m_piTechMovementChange[i] : -1;
}

int CvRouteInfo::getPrereqOrBonus(int i) const
{
	return m_piPrereqOrBonuses ? m_piPrereqOrBonuses[i] : -1;
}

bool CvRouteInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");

	pXML->GetChildXmlValByName(&m_iValue, "iValue");
	pXML->GetChildXmlValByName(&m_iMovementCost, "iMovement");
	pXML->GetChildXmlValByName(&m_iFlatMovementCost, "iFlatMovement");

	pXML->GetChildXmlValByName(szTextVal, "BonusType");
	m_iPrereqBonus = pXML->FindInInfoClass(szTextVal);

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Yields"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldChange);
		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	pXML->SetVariableListTagPair(&m_piTechMovementChange, "TechMovementChanges", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqOrBonuses"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_ROUTE_PREREQ_OR_BONUSES()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_ROUTE_PREREQ_OR_BONUSES(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_ROUTE_PREREQ_OR_BONUSES()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (int j=0;j<iNumSibs;j++)
					{
						m_piPrereqOrBonuses[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_ROUTE_PREREQ_OR_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvRouteInfo::copyNonDefaults(CvRouteInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getAdvancedStartCost()			== 0)			m_iAdvancedStartCost			= pClassInfo->getAdvancedStartCost();
	if (getAdvancedStartCostIncrease()	== 0)			m_iAdvancedStartCostIncrease	= pClassInfo->getAdvancedStartCostIncrease();
	if (getValue()						== 0)			m_iValue						= pClassInfo->getValue();
	if (getMovementCost()				== 0)			m_iMovementCost					= pClassInfo->getMovementCost();
	if (getFlatMovementCost()			== 0)			m_iFlatMovementCost				= pClassInfo->getFlatMovementCost();
	if (getPrereqBonus()				== NO_BONUS)	m_iPrereqBonus					= pClassInfo->getPrereqBonus();
	for (int i = 0;  i < NUM_YIELD_TYPES; i++)
	{
		if (getYieldChange(i)			== 0)			m_piYieldChange[i]				= pClassInfo->getYieldChange(i);
	}
	for (int i = 0;  i < GC.getNumTechInfos(); i++)
	{
		if (getTechMovementChange(i)	== 0)			m_piTechMovementChange[i]		= pClassInfo->getTechMovementChange(i);
	}
	for (int i = 0;  i < GC.getNUM_ROUTE_PREREQ_OR_BONUSES(); i++)
	{
		if (getPrereqOrBonus(i)			== 0)			m_piPrereqOrBonuses[i]			= pClassInfo->getPrereqOrBonus(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvImprovementBonusInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvImprovementBonusInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementBonusInfo::CvImprovementBonusInfo() :
m_iDiscoverRand(0),
m_bBonusMakesValid(false),
m_bBonusTrade(false),
m_piYieldChange(NULL)
/*************************************************************************************************/
/** SpreadBonus     Opera   28/08/09        imported by Valkrionn	09.26.09                    **/
/**                                                                                             **/
/** Create a new tag, iSpreadChance, to allow improvement to discover new resources that you
/** already own only.                                                                           **/
/*************************************************************************************************/
,m_iSpreadRand(0)
/*************************************************************************************************/
/** SpreadBonus                 END                                                             **/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvImprovementBonusInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementBonusInfo::~CvImprovementBonusInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
}

int CvImprovementBonusInfo::getDiscoverRand() const
{
	return m_iDiscoverRand;
}

bool CvImprovementBonusInfo::isBonusMakesValid() const
{
	return m_bBonusMakesValid;
}

bool CvImprovementBonusInfo::isBonusTrade() const
{
	return m_bBonusTrade;
}

int CvImprovementBonusInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

/*************************************************************************************************/
/** SpreadBonus     Opera   28/08/09         imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
int CvImprovementBonusInfo::getSpreadRand() const
{
	return m_iSpreadRand;
}
/*************************************************************************************************/
/** SpreadBonus                 END                                                             **/
/*************************************************************************************************/

void CvImprovementBonusInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iDiscoverRand);

	stream->Read(&m_bBonusMakesValid);
	stream->Read(&m_bBonusTrade);

/*************************************************************************************************/
/** SpreadBonus     Opera       28/08/09        imported by Valkrionn	09.26.09                **/
/*************************************************************************************************/
	stream->Read(&m_iSpreadRand);
/*************************************************************************************************/
/** SpreadBonus                 END                                                             **/
/*************************************************************************************************/

	// Arrays

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);
}

void CvImprovementBonusInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iDiscoverRand);

	stream->Write(m_bBonusMakesValid);
	stream->Write(m_bBonusTrade);

/*************************************************************************************************/
/** SpreadBonus     Opera       28/08/09         imported by Valkrionn	09.26.09                **/
/*************************************************************************************************/
	stream->Write(m_iSpreadRand);
/*************************************************************************************************/
/** SpreadBonus                 END                                                             **/
/*************************************************************************************************/

	// Arrays

	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
}

//======================================================================================================
//					CvImprovementInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvImprovementInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementInfo::CvImprovementInfo() :
	m_iAdvancedStartCost(0),
	m_iAdvancedStartCostIncrease(0),
	m_iTilesPerGoody(0),
	m_iGoodyUniqueRange(0),
	m_iFeatureGrowthProbability(0),
	m_iUpgradeTime(0),
	m_iExploreDelay(0),
	m_iAirBombDefense(0),
	m_iDefenseModifier(0),
	m_iHappiness(0),
	m_iPillageGold(0),
	m_iImprovementPillage(NO_IMPROVEMENT),
	m_iImprovementUpgrade(NO_IMPROVEMENT),
	m_bActsAsCity(true),
	m_bHillsMakesValid(false),
	/*************************************************************************************************/
	/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
	/*************************************************************************************************/
	m_bPeakMakesValid(false),
	/*************************************************************************************************/
	/**	Mountain Mod	END									**/
	/*************************************************************************************************/
	m_bFreshWaterMakesValid(false),
	m_bRiverSideMakesValid(false),
	m_bNoFreshWater(false),
	m_bRequiresFlatlands(false),
	m_bRequiresRiverSide(false),
	m_bRequiresIrrigation(false),
	m_bCarriesIrrigation(false),
	m_bRequiresFeature(false),
	m_bWater(false),
	m_bGoody(false),
	m_bPermanent(false),
	m_bOutsideBorders(false),
	m_iLairTier(0),
	m_iMaxAirlift(0),
	m_iMaxOutgoingAirlift(0),
	/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
m_iMinimumDistance(0),
m_iCultureRange(-1),
m_iCultureControlStrength(0),
m_iCultureCenterBonus(0),
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/
m_iWorldSoundscapeScriptId(0),
m_piPrereqNatureYield(NULL),
m_piYieldChange(NULL),
m_piRiverSideYieldChange(NULL),
m_piHillsYieldChange(NULL),
m_piIrrigatedChange(NULL),
m_pbTerrainMakesValid(NULL),
m_pbFeatureMakesValid(NULL),
/*************************************************************************************************/
/**	Feature spread		 				Ahwaric	23.09.09		**/
/*************************************************************************************************/
m_pbAllowsFeature(NULL),
/*************************************************************************************************/
/**	Feature spread	END									**/
/*************************************************************************************************/
m_ppiTechYieldChanges(NULL),
m_ppiRouteYieldChanges(NULL),
m_paImprovementBonus(NULL),
/*************************************************************************************************/
/**	New Tag Defs	(ImprovementInfos)		12/27/08								Xienwolf	**/
/**								Added to by Valkrionn, 1/15/10									**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iSpawnUnitCiv(0),
m_iSpawnPerGameLimit(-1),
m_iSpawnAtOnceLimit(-1),
m_iLairCreationWeight(0),
/*************************************************************************************************/
/** Hinterlands				  				07/11/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
m_piLairCreationWeightTechs(NULL),
m_piLairUpgradeTechs(NULL),
/*************************************************************************************************/
/**											END													**/
/*************************************************************************************************/
m_bExplorable(false),
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
m_pbGoodyClassTypes(NULL),
m_iNoBadExplore(0),
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
m_bFort(false),
m_bFreshWater(false),
m_bSpawnOnlyForOwner(false),
m_iBasePlotCounterModify(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

//FfH Improvements: Added by Kael 08/07/2007
m_bRequiresPeak(false),
m_bUnique(false),
m_iAppearanceProbability(0),
m_iHealRateChange(0),
m_iRange(0),
m_iRangeDefenseModifier(0),
m_iBonusConvert(NO_BONUS),
/*************************************************************************************************/
/**	Statesmen								02/05/10											**/
/**																								**/
/**						Allows improvements to grant specific specialists						**/
/*************************************************************************************************/
m_iFreeSpecialist(NO_SPECIALIST),
/*************************************************************************************************/
/**	Statesmen								END													**/
/*************************************************************************************************/
m_iFeatureUpgrade(NO_FEATURE),
m_iPrereqCivilization(NO_CIVILIZATION),
m_iSpawnUnitType(NO_UNIT),
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
m_iImmediateSpawnUnitType(NO_UNIT),
m_iSpawnGroupType(NO_SPAWNGROUP),
m_iImmediateSpawnGroupType(NO_SPAWNGROUP),
m_iNumSpawnPromotions(0),
m_iNumGuardianPromotions(0),
m_piSpawnPromotions(NULL),
m_piGuardianPromotions(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_iVisibilityChange(0)
//FfH: End Add

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvImprovementInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementInfo::~CvImprovementInfo()
{
	int iI;

/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbGoodyClassTypes);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqNatureYield);
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piRiverSideYieldChange);
	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	SAFE_DELETE_ARRAY(m_piIrrigatedChange);
	SAFE_DELETE_ARRAY(m_pbTerrainMakesValid);
	SAFE_DELETE_ARRAY(m_pbFeatureMakesValid);
/*************************************************************************************************/
/** Hinterlands				  				07/11/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piLairCreationWeightTechs);
	SAFE_DELETE_ARRAY(m_piLairUpgradeTechs);
/*************************************************************************************************/
/**											END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piSpawnPromotions);
	SAFE_DELETE_ARRAY(m_piGuardianPromotions);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Feature spread						Ahwaric	23.09.09		**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbAllowsFeature);
/*************************************************************************************************/
/**	Feature spread		END								**/
/*************************************************************************************************/

	if (m_paImprovementBonus != NULL)
	{
		SAFE_DELETE_ARRAY(m_paImprovementBonus); // XXX make sure this isn't leaking memory...
	}

	if (m_ppiTechYieldChanges != NULL)
	{
		for (iI=0;iI<GC.getNumTechInfos();iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiTechYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiTechYieldChanges);
	}

	if (m_ppiRouteYieldChanges != NULL)
	{
		for (iI=0;iI<GC.getNumRouteInfos();iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges);
	}
}

int CvImprovementInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvImprovementInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvImprovementInfo::getTilesPerGoody() const
{
	return m_iTilesPerGoody;
}

int CvImprovementInfo::getGoodyUniqueRange() const
{
	return m_iGoodyUniqueRange;
}

int CvImprovementInfo::getFeatureGrowthProbability() const
{
	return m_iFeatureGrowthProbability;
}

int CvImprovementInfo::getUpgradeTime() const
{
	return m_iUpgradeTime;
}
int CvImprovementInfo::getExploreDelay() const
{
	return m_iExploreDelay;
}

int CvImprovementInfo::getAirBombDefense() const
{
	return m_iAirBombDefense;
}

int CvImprovementInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

int CvImprovementInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvImprovementInfo::getPillageGold() const
{
	return m_iPillageGold;
}

bool CvImprovementInfo::isOutsideBorders() const
{
	return m_bOutsideBorders;
}
int CvImprovementInfo::getLairTier() const
{
	return m_iLairTier;
}

int CvImprovementInfo::getMaxAirlift() const
{
	return m_iMaxAirlift;
}
int CvImprovementInfo::getMaxOutgoingAirlift() const
{
	return m_iMaxOutgoingAirlift;
}
/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
int CvImprovementInfo::getMinimumDistance() const
{
	return m_iMinimumDistance;
}

int CvImprovementInfo::getCultureRange() const
{
	return m_iCultureRange;
}

void CvImprovementInfo::setCultureRange(int i)
{
	m_iCultureRange = i;
}

int CvImprovementInfo::getCultureControlStrength() const
{
	return m_iCultureControlStrength;
}

void CvImprovementInfo::setCultureControlStrength(int i)
{
	m_iCultureControlStrength = i;
}

int CvImprovementInfo::getCultureCenterBonus() const
{
	return m_iCultureCenterBonus;
}

void CvImprovementInfo::setCultureCenterBonus(int i)
{
	m_iCultureCenterBonus = i;
}
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/

int CvImprovementInfo::getImprovementPillage() const
{
	return m_iImprovementPillage;
}

void CvImprovementInfo::setImprovementPillage(int i)
{
	m_iImprovementPillage = i;
}

int CvImprovementInfo::getImprovementUpgrade() const
{
	return m_iImprovementUpgrade;
}

void CvImprovementInfo::setImprovementUpgrade(int i)
{
	m_iImprovementUpgrade = i;
}

bool CvImprovementInfo::isActsAsCity() const
{
	return m_bActsAsCity;
}

bool CvImprovementInfo::isHillsMakesValid() const
{
	return m_bHillsMakesValid;
}

/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
bool CvImprovementInfo::isPeakMakesValid() const
{
	return m_bPeakMakesValid;
}
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/

bool CvImprovementInfo::isFreshWaterMakesValid() const
{
	return m_bFreshWaterMakesValid;
}

bool CvImprovementInfo::isRiverSideMakesValid() const
{
	return m_bRiverSideMakesValid;
}

bool CvImprovementInfo::isNoFreshWater() const
{
	return m_bNoFreshWater;
}

bool CvImprovementInfo::isRequiresFlatlands() const
{
	return m_bRequiresFlatlands;
}

bool CvImprovementInfo::isRequiresRiverSide() const
{
	return m_bRequiresRiverSide;
}

bool CvImprovementInfo::isRequiresIrrigation() const
{
	return m_bRequiresIrrigation;
}

bool CvImprovementInfo::isCarriesIrrigation() const
{
	return m_bCarriesIrrigation;
}

bool CvImprovementInfo::isRequiresFeature() const
{
	return m_bRequiresFeature;
}

bool CvImprovementInfo::isWater() const
{
	return m_bWater;
}

bool CvImprovementInfo::isGoody() const
{
	return m_bGoody;
}

bool CvImprovementInfo::isPermanent() const
{
	return m_bPermanent;
}

const TCHAR* CvImprovementInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvImprovementInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

int CvImprovementInfo::getWorldSoundscapeScriptId() const
{
	return m_iWorldSoundscapeScriptId;
}

//FfH Improvements: Added by Kael 08/07/2007
int CvImprovementInfo::getAppearanceProbability() const
{
	return m_iAppearanceProbability;
}

int CvImprovementInfo::getHealRateChange() const
{
	return m_iHealRateChange;
}

int CvImprovementInfo::getRange() const
{
	return m_iRange;
}

int CvImprovementInfo::getRangeDefenseModifier() const
{
	return m_iRangeDefenseModifier;
}

int CvImprovementInfo::getBonusConvert() const
{
	return m_iBonusConvert;
}


/*************************************************************************************************/
/**	Statesmen								02/05/10											**/
/**																								**/
/**						Allows improvements to grant specific specialists						**/
/*************************************************************************************************/
int CvImprovementInfo::getFreeSpecialist() const
{
	return m_iFreeSpecialist;
}
/*************************************************************************************************/
/**	Statesmen								END													**/
/*************************************************************************************************/

int CvImprovementInfo::getFeatureUpgrade() const
{
	return m_iFeatureUpgrade;
}

int CvImprovementInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

const TCHAR *CvImprovementInfo::getPythonAtRange() const
{
	return m_szPythonAtRange;
}

const TCHAR *CvImprovementInfo::getPythonOnMove() const
{
	return m_szPythonOnMove;
}

int CvImprovementInfo::getSpawnUnitType() const
{
	return m_iSpawnUnitType;
}

/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
int CvImprovementInfo::getImmediateSpawnUnitType() const
{
	return m_iImmediateSpawnUnitType;
}
int CvImprovementInfo::getSpawnGroupType() const
{
	return m_iSpawnGroupType;
}
int CvImprovementInfo::getImmediateSpawnGroupType() const
{
	return m_iImmediateSpawnGroupType;
}

int CvImprovementInfo::getSpawnPromotions(int iI) const
{
	return (getNumSpawnPromotions() > iI) ? m_piSpawnPromotions[iI] : -1;
}

int CvImprovementInfo::getNumSpawnPromotions() const
{
	return m_iNumSpawnPromotions;
}

int CvImprovementInfo::getGuardianPromotions(int iI) const
{
	return (getNumGuardianPromotions() > iI) ? m_piGuardianPromotions[iI] : -1;
}

int CvImprovementInfo::getNumGuardianPromotions() const
{
	return m_iNumGuardianPromotions;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

int CvImprovementInfo::getVisibilityChange() const
{
	return m_iVisibilityChange;
}

bool CvImprovementInfo::isRequiresPeak() const
{
	return m_bRequiresPeak;
}

bool CvImprovementInfo::isUnique() const
{
	return m_bUnique;
}
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(ImprovementInfos)		12/27/08								Xienwolf	**/
/**								Added to by Valkrionn, 1/15/10									**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvImprovementInfo::getSpawnUnitCiv() const							{return m_iSpawnUnitCiv;}
int CvImprovementInfo::getSpawnPerGameLimit() const						{return m_iSpawnPerGameLimit < 0 ? MAX_INT : m_iSpawnPerGameLimit;}
int CvImprovementInfo::getSpawnAtOnceLimit() const						{return m_iSpawnAtOnceLimit < 0 ? MAX_INT : m_iSpawnAtOnceLimit;}
int CvImprovementInfo::getLairCreationWeight() const					{return m_iLairCreationWeight;}
/*************************************************************************************************/
/** Hinterlands				  				07/11/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
int CvImprovementInfo::getLairCreationWeightTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piLairCreationWeightTechs ? m_piLairCreationWeightTechs[i] : -1;
}
int CvImprovementInfo::getLairUpgradeTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piLairUpgradeTechs ? m_piLairUpgradeTechs[i] : -1;
}
/*************************************************************************************************/
/**											END													**/
/*************************************************************************************************/
bool CvImprovementInfo::isExplorable() const							{return m_bExplorable;}
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
bool CvImprovementInfo::isGoodyClassType(int i) const
{
	FAssertMsg(i < GC.getNumGoodyClassTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbGoodyClassTypes ? m_pbGoodyClassTypes[i] : 0;
}

int CvImprovementInfo::getNoBadExplore() const
{
	return m_iNoBadExplore;
}
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
bool CvImprovementInfo::isFort() const									{return m_bFort;}
bool CvImprovementInfo::isFreshWater() const { return m_bFreshWater; }
bool CvImprovementInfo::isSpawnOnlyForOwner() const						{return m_bSpawnOnlyForOwner;}
int CvImprovementInfo::getBasePlotCounterModify() const					{return m_iBasePlotCounterModify;}
int CvImprovementInfo::getSpawnUnitTypeVectorSize()						{return m_aszExtraXMLforPass3.size();}
CvString CvImprovementInfo::getSpawnUnitTypeVectorElement(int i)		{return m_aszExtraXMLforPass3[i];}
int CvImprovementInfo::getPrereqCivilizationVectorSize()				{return m_aszExtraXML2forPass3.size();}
CvString CvImprovementInfo::getPrereqCivilizationVectorElement(int i)	{return m_aszExtraXML2forPass3[i];}
int CvImprovementInfo::getSpawnUnitCivVectorSize()						{return m_aszExtraXML3forPass3.size();}
CvString CvImprovementInfo::getSpawnUnitCivVectorElement(int i)			{return m_aszExtraXML3forPass3[i];}
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
int CvImprovementInfo::getImmediateSpawnUnitTypeVectorSize()			{return m_aszExtraXML4forPass3.size();}
CvString CvImprovementInfo::getImmediateSpawnUnitTypeVectorElement(int i) {return m_aszExtraXML4forPass3[i];}
int CvImprovementInfo::getSpawnGroupTypeVectorSize()			{return m_aszExtraXML5forPass3.size();}
CvString CvImprovementInfo::getSpawnGroupTypeVectorElement(int i) {return m_aszExtraXML5forPass3[i];}
int CvImprovementInfo::getImmediateSpawnGroupTypeVectorSize()			{return m_aszExtraXML6forPass3.size();}
CvString CvImprovementInfo::getImmediateSpawnGroupTypeVectorElement(int i) {return m_aszExtraXML6forPass3[i];}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

// Arrays

int CvImprovementInfo::getPrereqNatureYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqNatureYield ? m_piPrereqNatureYield[i] : -1;
}

int* CvImprovementInfo::getPrereqNatureYieldArray()
{
	return m_piPrereqNatureYield;
}

int CvImprovementInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int* CvImprovementInfo::getYieldChangeArray()
{
	return m_piYieldChange;
}

int CvImprovementInfo::getRiverSideYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverSideYieldChange ? m_piRiverSideYieldChange[i] : -1;
}

int* CvImprovementInfo::getRiverSideYieldChangeArray()
{
	return m_piRiverSideYieldChange;
}

int CvImprovementInfo::getHillsYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;
}

int* CvImprovementInfo::getHillsYieldChangeArray()
{
	return m_piHillsYieldChange;
}

int CvImprovementInfo::getIrrigatedYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piIrrigatedChange ? m_piIrrigatedChange[i] : -1;
}

int* CvImprovementInfo::getIrrigatedYieldChangeArray()
{
	return m_piIrrigatedChange;
}

bool CvImprovementInfo::getTerrainMakesValid(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainMakesValid ? m_pbTerrainMakesValid[i] : false;
}

bool CvImprovementInfo::getFeatureMakesValid(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureMakesValid ? m_pbFeatureMakesValid[i] : false;
}

/*************************************************************************************************/
/**	Feature spread						Ahwaric	23.09.09		**/
/*************************************************************************************************/
bool CvImprovementInfo::getAllowsFeature(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbAllowsFeature ? m_pbAllowsFeature[i] : false;
}
/*************************************************************************************************/
/**	Feature spread		END								**/
/*************************************************************************************************/

int CvImprovementInfo::getTechYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiTechYieldChanges[i][j];
}

int* CvImprovementInfo::getTechYieldChangesArray(int i)
{
	return m_ppiTechYieldChanges[i];
}

int CvImprovementInfo::getRouteYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumRouteInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiRouteYieldChanges[i][j];
}

int* CvImprovementInfo::getRouteYieldChangesArray(int i)
{
	return m_ppiRouteYieldChanges[i];
}

int CvImprovementInfo::getImprovementBonusYield(int i, int j) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_piYieldChange ? m_paImprovementBonus[i].getYieldChange(j) : -1;
}

bool CvImprovementInfo::isImprovementBonusMakesValid(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_bBonusMakesValid;
}

bool CvImprovementInfo::isImprovementBonusTrade(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_bBonusTrade;
}

int CvImprovementInfo::getImprovementBonusDiscoverRand(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_iDiscoverRand;
}

/*************************************************************************************************/
/** SpreadBonus     Opera   28/08/09        imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
int CvImprovementInfo::getImprovementBonusSpreadRand(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_iSpreadRand;
}
/*************************************************************************************************/
/** SpreadBonus                 END                                                             **/
/*************************************************************************************************/

const TCHAR* CvImprovementInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoImprovement * pImprovementArtInfo;
	pImprovementArtInfo = getArtInfo();
	if (pImprovementArtInfo != NULL)
	{
		return pImprovementArtInfo->getButton();
	}
	return NULL;
}

const CvArtInfoImprovement* CvImprovementInfo::getArtInfo() const
{
	return ARTFILEMGR.getImprovementArtInfo(getArtDefineTag());
}

const TCHAR* CvArtInfoImprovement::getShaderNIF() const
{
	return m_szShaderNIF;
}
void CvArtInfoImprovement::setShaderNIF(const TCHAR* szDesc)
{
	m_szShaderNIF = szDesc;
}

void CvImprovementInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);

	stream->Read(&m_iTilesPerGoody);
	stream->Read(&m_iGoodyUniqueRange);
	stream->Read(&m_iFeatureGrowthProbability);
	stream->Read(&m_iUpgradeTime);
	stream->Read(&m_iExploreDelay);
	stream->Read(&m_iAirBombDefense);
	stream->Read(&m_iDefenseModifier);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iPillageGold);
	stream->Read(&m_iImprovementPillage);
	stream->Read(&m_iImprovementUpgrade);
	stream->Read(&m_bActsAsCity);
	stream->Read(&m_bHillsMakesValid);
/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
	stream->Read(&m_bPeakMakesValid);
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/
	stream->Read(&m_bFreshWaterMakesValid);
	stream->Read(&m_bRiverSideMakesValid);
	stream->Read(&m_bNoFreshWater);
	stream->Read(&m_bRequiresFlatlands);
	stream->Read(&m_bRequiresRiverSide);
	stream->Read(&m_bRequiresIrrigation);
	stream->Read(&m_bCarriesIrrigation);
	stream->Read(&m_bRequiresFeature);
	stream->Read(&m_bWater);
	stream->Read(&m_bGoody);
	stream->Read(&m_bPermanent);
	stream->Read(&m_bOutsideBorders);
	stream->Read(&m_iLairTier);
	stream->Read(&m_iMaxAirlift);
	stream->Read(&m_iMaxOutgoingAirlift);

/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
	stream->Read(&m_iMinimumDistance);
	stream->Read(&m_iCultureRange);
	stream->Read(&m_iCultureControlStrength);
	stream->Read(&m_iCultureCenterBonus);
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/

	stream->ReadString(m_szArtDefineTag);

	stream->Read(&m_iWorldSoundscapeScriptId);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Read(&m_bRequiresPeak);
	stream->Read(&m_bUnique);
	stream->Read(&m_iAppearanceProbability);
	stream->Read(&m_iHealRateChange);
	stream->Read(&m_iRange);
	stream->Read(&m_iRangeDefenseModifier);
	stream->Read(&m_iBonusConvert);
/*************************************************************************************************/
/**	Statesmen								02/05/10											**/
/**																								**/
/**						Allows improvements to grant specific specialists						**/
/*************************************************************************************************/
	stream->Read(&m_iFreeSpecialist);
/*************************************************************************************************/
/**	Statesmen								END													**/
/*************************************************************************************************/
	stream->Read(&m_iFeatureUpgrade);
	stream->Read(&m_iPrereqCivilization);
	stream->ReadString(m_szPythonAtRange);
	stream->ReadString(m_szPythonOnMove);
	stream->Read(&m_iSpawnUnitType);
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
	stream->Read(&m_iImmediateSpawnUnitType);
	stream->Read(&m_iSpawnGroupType);
	stream->Read(&m_iImmediateSpawnGroupType);
	stream->Read(&m_iNumSpawnPromotions);
	if (m_iNumSpawnPromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piSpawnPromotions);
		m_piSpawnPromotions = new int[m_iNumSpawnPromotions];
		stream->Read(m_iNumSpawnPromotions, m_piSpawnPromotions);
	}
	stream->Read(&m_iNumGuardianPromotions);
	if (m_iNumGuardianPromotions > 0)
	{
		SAFE_DELETE_ARRAY(m_piGuardianPromotions);
		m_piGuardianPromotions = new int[m_iNumGuardianPromotions];
		stream->Read(m_iNumGuardianPromotions, m_piGuardianPromotions);
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	stream->Read(&m_iVisibilityChange);
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(ImprovementInfos)		12/27/08								Xienwolf	**/
/**								Added to by Valkrionn, 1/15/10									**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iSpawnUnitCiv);
	stream->Read(&m_iSpawnPerGameLimit);
	stream->Read(&m_iSpawnAtOnceLimit);
	stream->Read(&m_iLairCreationWeight);
	stream->Read(&m_bExplorable);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	stream->Read(&m_iNoBadExplore);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
	stream->Read(&m_bFort);
	stream->Read(&m_bFreshWater);
	stream->Read(&m_bSpawnOnlyForOwner);
	stream->Read(&m_iBasePlotCounterModify);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	// Arrays

/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbGoodyClassTypes);
	m_pbGoodyClassTypes = new bool[GC.getNumGoodyClassTypes()];
	stream->Read(GC.getNumGoodyClassTypes(), m_pbGoodyClassTypes);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/** Hinterlands				  				07/11/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piLairCreationWeightTechs);
	m_piLairCreationWeightTechs = new int[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_piLairCreationWeightTechs);

	SAFE_DELETE_ARRAY(m_piLairUpgradeTechs);
	m_piLairUpgradeTechs = new int[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_piLairUpgradeTechs);
/*************************************************************************************************/
/**											END													**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piPrereqNatureYield);
	m_piPrereqNatureYield = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piPrereqNatureYield);

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);

	SAFE_DELETE_ARRAY(m_piRiverSideYieldChange);
	m_piRiverSideYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piRiverSideYieldChange);

	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	m_piHillsYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piHillsYieldChange);

	SAFE_DELETE_ARRAY(m_piIrrigatedChange);
	m_piIrrigatedChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piIrrigatedChange);

	SAFE_DELETE_ARRAY(m_pbTerrainMakesValid);
	m_pbTerrainMakesValid = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainMakesValid);

	SAFE_DELETE_ARRAY(m_pbFeatureMakesValid);
	m_pbFeatureMakesValid = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureMakesValid);

/*************************************************************************************************/
/**	Feature spread		 				Ahwaric	23.09.09		**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbAllowsFeature);
	m_pbAllowsFeature = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbAllowsFeature);
/*************************************************************************************************/
/**	Feature spread	END									**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_paImprovementBonus);
	m_paImprovementBonus = new CvImprovementBonusInfo[GC.getNumBonusInfos()];
	int i;
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		m_paImprovementBonus[i].read(stream);
	}

	if (m_ppiTechYieldChanges != NULL)
	{
		for(i=0;i<GC.getNumTechInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppiTechYieldChanges[i]);
		}
		SAFE_DELETE_ARRAY(m_ppiTechYieldChanges);
	}

	m_ppiTechYieldChanges = new int*[GC.getNumTechInfos()];
	for(i=0;i<GC.getNumTechInfos();i++)
	{
		m_ppiTechYieldChanges[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppiTechYieldChanges[i]);
	}

	if (m_ppiRouteYieldChanges != NULL)
	{
		for(i=0;i<GC.getNumRouteInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges[i]);
		}
		SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges);
	}

	m_ppiRouteYieldChanges = new int*[GC.getNumRouteInfos()];
	for(i=0;i<GC.getNumRouteInfos();i++)
	{
		m_ppiRouteYieldChanges[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppiRouteYieldChanges[i]);
	}
}

void CvImprovementInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);

	stream->Write(m_iTilesPerGoody);
	stream->Write(m_iGoodyUniqueRange);
	stream->Write(m_iFeatureGrowthProbability);
	stream->Write(m_iUpgradeTime); 
	stream->Write(m_iExploreDelay);
	stream->Write(m_iAirBombDefense);
	stream->Write(m_iDefenseModifier);
	stream->Write(m_iHappiness);
	stream->Write(m_iPillageGold);
	stream->Write(m_iImprovementPillage);
	stream->Write(m_iImprovementUpgrade);
	stream->Write(m_bActsAsCity);
	stream->Write(m_bHillsMakesValid);
/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
	stream->Write(m_bPeakMakesValid);
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/
	stream->Write(m_bFreshWaterMakesValid);
	stream->Write(m_bRiverSideMakesValid);
	stream->Write(m_bNoFreshWater);
	stream->Write(m_bRequiresFlatlands);
	stream->Write(m_bRequiresRiverSide);
	stream->Write(m_bRequiresIrrigation);
	stream->Write(m_bCarriesIrrigation);
	stream->Write(m_bRequiresFeature);
	stream->Write(m_bWater);
	stream->Write(m_bGoody);
	stream->Write(m_bPermanent);
	stream->Write(m_bOutsideBorders);
	stream->Write(m_iLairTier);
	stream->Write(m_iMaxAirlift);
	stream->Write(m_iMaxOutgoingAirlift);

/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
	stream->Write(m_iMinimumDistance);
	stream->Write(m_iCultureRange);
	stream->Write(m_iCultureControlStrength);
	stream->Write(m_iCultureCenterBonus);
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/

	stream->WriteString(m_szArtDefineTag);

	stream->Write(m_iWorldSoundscapeScriptId);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Write(m_bRequiresPeak);
	stream->Write(m_bUnique);
	stream->Write(m_iAppearanceProbability);
	stream->Write(m_iHealRateChange);
	stream->Write(m_iRange);
	stream->Write(m_iRangeDefenseModifier);
	stream->Write(m_iBonusConvert);
/*************************************************************************************************/
/**	Statesmen								02/05/10											**/
/**																								**/
/**						Allows improvements to grant specific specialists						**/
/*************************************************************************************************/
	stream->Write(m_iFreeSpecialist);
/*************************************************************************************************/
/**	Statesmen								END													**/
/*************************************************************************************************/
	stream->Write(m_iFeatureUpgrade);
	stream->Write(m_iPrereqCivilization);
	stream->WriteString(m_szPythonAtRange);
	stream->WriteString(m_szPythonOnMove);
	stream->Write(m_iSpawnUnitType);
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
	stream->Write(m_iImmediateSpawnUnitType);
	stream->Write(m_iSpawnGroupType);
	stream->Write(m_iImmediateSpawnGroupType);
	stream->Write(m_iNumSpawnPromotions);
	if (m_iNumSpawnPromotions > 0)
		stream->Write(m_iNumSpawnPromotions, m_piSpawnPromotions);
	stream->Write(m_iNumGuardianPromotions);
	if (m_iNumGuardianPromotions > 0)
		stream->Write(m_iNumGuardianPromotions, m_piGuardianPromotions);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	stream->Write(m_iVisibilityChange);
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(ImprovementInfos)		12/27/08								Xienwolf	**/
/**								Added to by Valkrionn, 1/15/10									**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iSpawnUnitCiv);
	stream->Write(m_iSpawnPerGameLimit);
	stream->Write(m_iSpawnAtOnceLimit);
	stream->Write(m_iLairCreationWeight);
/*************************************************************************************************/
/** Hinterlands				  				07/11/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	stream->Write(GC.getNumTechInfos(), m_piLairCreationWeightTechs);
	stream->Write(GC.getNumTechInfos(), m_piLairUpgradeTechs);
/*************************************************************************************************/
/**											END													**/
/*************************************************************************************************/
	stream->Write(m_bExplorable);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	stream->Write(m_iNoBadExplore);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
	stream->Write(m_bFort);
	stream->Write(m_bFreshWater);
	stream->Write(m_bSpawnOnlyForOwner);
	stream->Write(m_iBasePlotCounterModify);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	// Arrays

/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	stream->Write(GC.getNumGoodyClassTypes(), m_pbGoodyClassTypes);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/

	stream->Write(NUM_YIELD_TYPES, m_piPrereqNatureYield);
	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piRiverSideYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piHillsYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piIrrigatedChange);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainMakesValid);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureMakesValid);
/*************************************************************************************************/
/**	Feature spread		 				Ahwaric	23.09.09		**/
/*************************************************************************************************/
	stream->Write(GC.getNumFeatureInfos(), m_pbAllowsFeature);
/*************************************************************************************************/
/**	Feature spread	END									**/
/*************************************************************************************************/

	int i;
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		m_paImprovementBonus[i].write(stream);
	}

	for(i=0;i<GC.getNumTechInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppiTechYieldChanges[i]);
	}

	for(i=0;i<GC.getNumRouteInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppiRouteYieldChanges[i]);
	}
}
bool CvImprovementInfo::read(CvXMLLoadUtility* pXML)
{
	int iI;
	CvString szTextVal;
	std::vector<CvString> aszSpawnPromotions;
	std::vector<CvString> aszGuardianPromotions;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int iIndex, j, iNumSibs;

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqNatureYields"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piPrereqNatureYield);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piPrereqNatureYield, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverSideYieldChange"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piRiverSideYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverSideYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HillsYieldChange"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piHillsYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piHillsYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"IrrigatedYieldChange"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piIrrigatedChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piIrrigatedChange, NUM_YIELD_TYPES);
	}

	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost", -1);
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");
	pXML->GetChildXmlValByName(&m_bActsAsCity, "bActsAsCity");
	pXML->GetChildXmlValByName(&m_bHillsMakesValid, "bHillsMakesValid");
/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bPeakMakesValid, "bPeakMakesValid");
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bFreshWaterMakesValid, "bFreshWaterMakesValid");
	pXML->GetChildXmlValByName(&m_bRiverSideMakesValid, "bRiverSideMakesValid");
	pXML->GetChildXmlValByName(&m_bNoFreshWater, "bNoFreshWater");
	pXML->GetChildXmlValByName(&m_bRequiresFlatlands, "bRequiresFlatlands");
	pXML->GetChildXmlValByName(&m_bRequiresRiverSide, "bRequiresRiverSide");
	pXML->GetChildXmlValByName(&m_bRequiresIrrigation, "bRequiresIrrigation");
	pXML->GetChildXmlValByName(&m_bCarriesIrrigation, "bCarriesIrrigation");
	pXML->GetChildXmlValByName(&m_bRequiresFeature, "bRequiresFeature");
	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(&m_bGoody, "bGoody");
	pXML->GetChildXmlValByName(&m_bPermanent, "bPermanent");
	pXML->GetChildXmlValByName(&m_iTilesPerGoody, "iTilesPerGoody");
	pXML->GetChildXmlValByName(&m_iGoodyUniqueRange, "iGoodyRange");
	pXML->GetChildXmlValByName(&m_iFeatureGrowthProbability, "iFeatureGrowth");
	pXML->GetChildXmlValByName(&m_iUpgradeTime, "iUpgradeTime");
	pXML->GetChildXmlValByName(&m_iExploreDelay, "iExploreDelay");
	pXML->GetChildXmlValByName(&m_iAirBombDefense, "iAirBombDefense");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefenseModifier");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iPillageGold, "iPillageGold");
	pXML->GetChildXmlValByName(&m_bOutsideBorders, "bOutsideBorders");
	pXML->GetChildXmlValByName(&m_iLairTier, "iLairTier");
	pXML->GetChildXmlValByName(&m_iMaxAirlift, "iMaxAirlift");
	pXML->GetChildXmlValByName(&m_iMaxOutgoingAirlift, "iMaxOutgoingAirlift");

/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iMinimumDistance, "iMinimumDistance");
	pXML->GetChildXmlValByName(&m_iCultureRange, "iCultureRange");
	pXML->GetChildXmlValByName(&m_iCultureControlStrength, "iCultureControlStrength");
	pXML->GetChildXmlValByName(&m_iCultureCenterBonus, "iCultureCenterBonus");
/*************************************************************************************************/
/**	Improvements Mods 	END								**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_pbTerrainMakesValid, "TerrainMakesValids", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureMakesValid, "FeatureMakesValids", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	Feature spread		 				Ahwaric	23.09.09		**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_pbAllowsFeature, "AllowsFeatures", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
/*************************************************************************************************/
/**	Feature spread	END									**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusTypeStructs"))
	{
		// call the function that sets the bonus booleans
		pXML->SetImprovementBonuses(&m_paImprovementBonus);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		// initialize the boolean list to the correct size and all the booleans to false
		pXML->InitImprovementBonusList(&m_paImprovementBonus, GC.getNumBonusInfos());
	}

	// initialize the boolean list to the correct size and all the booleans to false
	FAssertMsg((GC.getNumTechInfos() > 0) && (NUM_YIELD_TYPES) > 0,"either the number of tech infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiTechYieldChanges, GC.getNumTechInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiTechYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiTechYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiTechYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// initialize the boolean list to the correct size and all the booleans to false
	FAssertMsg((GC.getNumRouteInfos() > 0) && (NUM_YIELD_TYPES) > 0,"either the number of route infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiRouteYieldChanges, GC.getNumRouteInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RouteYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{

				if (0 < iNumSibs)
				{
					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "RouteType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RouteYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiRouteYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiRouteYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "WorldSoundscapeAudioScript");
	if ( szTextVal.GetLength() > 0 )
		m_iWorldSoundscapeScriptId = gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_SOUNDSCAPE );
	else
		m_iWorldSoundscapeScriptId = -1;

//FfH Improvements: Added by Kael 08/07/2007
	pXML->GetChildXmlValByName(&m_bRequiresPeak, "bRequiresPeak");
	pXML->GetChildXmlValByName(&m_bUnique, "bUnique");
	pXML->GetChildXmlValByName(&m_iAppearanceProbability, "iAppearanceProbability");
	pXML->GetChildXmlValByName(&m_iHealRateChange, "iHealRateChange");
	pXML->GetChildXmlValByName(&m_iRange, "iRange");
	pXML->GetChildXmlValByName(&m_iRangeDefenseModifier, "iRangeDefenseModifier");
	pXML->GetChildXmlValByName(&m_iVisibilityChange, "iVisibilityChange");
	pXML->GetChildXmlValByName(szTextVal, "BonusConvert");
	m_iBonusConvert = GC.getInfoTypeForString(szTextVal);
/*************************************************************************************************/
/**	Statesmen								02/05/10											**/
/**																								**/
/**						Allows improvements to grant specific specialists						**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "FreeSpecialist");
	m_iFreeSpecialist = GC.getInfoTypeForString(szTextVal);
/*************************************************************************************************/
/**	Statesmen								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "FeatureUpgrade");
	m_iFeatureUpgrade = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization");
	m_aszExtraXML2forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(m_szPythonAtRange, "PythonAtRange");
	pXML->GetChildXmlValByName(m_szPythonOnMove, "PythonOnMove");
	pXML->GetChildXmlValByName(szTextVal, "SpawnUnitType");
	m_aszExtraXMLforPass3.push_back(szTextVal);
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "ImmediateSpawnUnitType");
	m_aszExtraXML4forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "SpawnGroupType");
	m_aszExtraXML5forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ImmediateSpawnGroupType");
	m_aszExtraXML6forPass3.push_back(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "SpawnPromotions"))
	{
		pXML->SetStringWithChildList(&m_iNumSpawnPromotions, &aszSpawnPromotions);
	}

	m_piSpawnPromotions = new int[m_iNumSpawnPromotions];

	for (iI = 0; iI < m_iNumSpawnPromotions; iI++)
	{
		m_piSpawnPromotions[iI] = GC.getInfoTypeForString(aszSpawnPromotions[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "GuardianPromotions"))
	{
		pXML->SetStringWithChildList(&m_iNumGuardianPromotions, &aszGuardianPromotions);
	}

	m_piGuardianPromotions = new int[m_iNumGuardianPromotions];

	for (iI = 0; iI < m_iNumGuardianPromotions; iI++)
	{
		m_piGuardianPromotions[iI] = GC.getInfoTypeForString(aszGuardianPromotions[iI]);
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(ImprovementInfos)		12/27/08								Xienwolf	**/
/**								Added to by Valkrionn, 1/15/10									**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "SpawnUnitCiv");
	m_aszExtraXML3forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iSpawnPerGameLimit, "iSpawnPerGameLimit", -1);
	pXML->GetChildXmlValByName(&m_iSpawnAtOnceLimit, "iSpawnAtOnceLimit", -1);
	pXML->GetChildXmlValByName(&m_iLairCreationWeight, "iLairCreationWeight");
/*************************************************************************************************/
/** Hinterlands				  				07/11/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piLairCreationWeightTechs, "LairCreationWeightTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
	pXML->SetVariableListTagPair(&m_piLairUpgradeTechs, "LairUpgradeTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
/*************************************************************************************************/
/**											END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bExplorable, "bExplorable");
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_pbGoodyClassTypes, "GoodyClasses", GC.getGoodyClassTypes(), GC.getNumGoodyClassTypes());
	pXML->GetChildXmlValByName(&m_iNoBadExplore, "iNoBadExplore");
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bFort, "bFort");
	pXML->GetChildXmlValByName(&m_bFreshWater, "bFreshWater");
	pXML->GetChildXmlValByName(&m_bSpawnOnlyForOwner, "bSpawnOnlyForOwner");
	pXML->GetChildXmlValByName(&m_iBasePlotCounterModify, "iBasePlotCounterModify");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	return true;
}

bool CvImprovementInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "ImprovementPillage");
	m_iImprovementPillage = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ImprovementUpgrade");
	m_iImprovementUpgrade = GC.getInfoTypeForString(szTextVal);

	return true;
}

//FfH Improvements: Added by Kael 05/12/2007
bool CvImprovementInfo::readPass3()
{
/*************************************************************************************************/
/**	New Tag Defs	(ImprovementInfos)		12/31/08								Xienwolf	**/
/**																								**/
/**					Third Pass to reference information which didn't exist before				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

	m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXML2forPass3[0]);
	m_aszExtraXML2forPass3.clear();
	m_iSpawnUnitType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_aszExtraXMLforPass3.clear();
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iSpawnUnitType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
	m_aszExtraXMLforPass3.clear();

	iSize = m_aszExtraXML2forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML2forPass3[i], true) != -1)
		{
			m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXML2forPass3[i]);
			break;
		}
	}
	m_aszExtraXML2forPass3.clear();

	iSize = m_aszExtraXML3forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML3forPass3[i], true) != -1)
		{
			m_iSpawnUnitCiv = GC.getInfoTypeForString(m_aszExtraXML3forPass3[i]);
			break;
		}
	}
	m_aszExtraXML3forPass3.clear();
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
	iSize = m_aszExtraXML4forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML4forPass3[i], true) != -1)
		{
			m_iImmediateSpawnUnitType = GC.getInfoTypeForString(m_aszExtraXML4forPass3[i]);
			break;
		}
	}
	m_aszExtraXML4forPass3.clear();
	iSize = m_aszExtraXML5forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML5forPass3[i], true) != -1)
		{
			m_iSpawnGroupType = GC.getInfoTypeForString(m_aszExtraXML5forPass3[i]);
			break;
		}
	}
	m_aszExtraXML5forPass3.clear();
	iSize = m_aszExtraXML6forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML6forPass3[i], true) != -1)
		{
			m_iImmediateSpawnGroupType = GC.getInfoTypeForString(m_aszExtraXML6forPass3[i]);
			break;
		}
	}
	m_aszExtraXML6forPass3.clear();
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(ImprovementInfos)															**/
/**								Added to by Valkrionn, 1/15/10									**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvImprovementInfo::copyNonDefaults(CvImprovementInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()									== cDefault)		setArtDefineTag(							pClassInfo->getArtDefineTag());
	//Must do Art Define before InfoBase to get the right button on time
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isActsAsCity()										== false)			m_bActsAsCity								= pClassInfo->isActsAsCity();
	if (isHillsMakesValid()									== false)			m_bHillsMakesValid							= pClassInfo->isHillsMakesValid();
	if (isFreshWaterMakesValid()							== false)			m_bFreshWaterMakesValid						= pClassInfo->isFreshWaterMakesValid();
	if (isRiverSideMakesValid()								== false)			m_bRiverSideMakesValid						= pClassInfo->isRiverSideMakesValid();
	if (isNoFreshWater()									== false)			m_bNoFreshWater								= pClassInfo->isNoFreshWater();
	if (isRequiresFlatlands()								== false)			m_bRequiresFlatlands						= pClassInfo->isRequiresFlatlands();
	if (isRequiresRiverSide()								== false)			m_bRequiresRiverSide						= pClassInfo->isRequiresRiverSide();
	if (isRequiresIrrigation()								== false)			m_bRequiresIrrigation						= pClassInfo->isRequiresIrrigation();
	if (isCarriesIrrigation()								== false)			m_bCarriesIrrigation						= pClassInfo->isCarriesIrrigation();
	if (isRequiresFeature()									== false)			m_bRequiresFeature							= pClassInfo->isRequiresFeature();
	if (isWater()											== false)			m_bWater									= pClassInfo->isWater();
	if (isGoody()											== false)			m_bGoody									= pClassInfo->isGoody();
	if (isPermanent()										== false)			m_bPermanent								= pClassInfo->isPermanent();
	if (isOutsideBorders()									== false)			m_bOutsideBorders							= pClassInfo->isOutsideBorders();
	if (isRequiresPeak()									== false)			m_bRequiresPeak								= pClassInfo->isRequiresPeak();
	if (isUnique()											== false)			m_bUnique									= pClassInfo->isUnique();
	if (isExplorable()										== false)			m_bExplorable								= pClassInfo->isExplorable();
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				20/06/10										Snarko	**/
/**																								**/
/**							Moving explore lair results into SDK								**/
/*************************************************************************************************/
	for ( int i = 0; i < GC.getNumGoodyClassTypes(); i++ )
	{
		if(isGoodyClassType(i)		== 0)					m_pbGoodyClassTypes[i]			= pClassInfo->isGoodyClassType(i);
	}
	if (getNoBadExplore()										== 0)			m_iNoBadExplore								= pClassInfo->getNoBadExplore();
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/

	if (isFort()											== false)			m_bFort										= pClassInfo->isFort();
	if (isFreshWater() == false)			m_bFreshWater = pClassInfo->isFreshWater();
	if (isSpawnOnlyForOwner()								== false)			m_bSpawnOnlyForOwner						= pClassInfo->isSpawnOnlyForOwner();
	if (isPeakMakesValid()									== false)			m_bPeakMakesValid							= pClassInfo->isPeakMakesValid();
	if (getAppearanceProbability()							== 0)				m_iAppearanceProbability					= pClassInfo->getAppearanceProbability();
	if (getHealRateChange()									== 0)				m_iHealRateChange							= pClassInfo->getHealRateChange();
	if (getRange()											== 0)				m_iRange									= pClassInfo->getRange();
	if (getRangeDefenseModifier()							== 0)				m_iRangeDefenseModifier						= pClassInfo->getRangeDefenseModifier();
	if (getVisibilityChange()								== 0)				m_iVisibilityChange							= pClassInfo->getVisibilityChange();
	if (getLairCreationWeight()								== 0)				m_iLairCreationWeight						= pClassInfo->getLairCreationWeight();
	if (getBasePlotCounterModify()							== 0)				m_iBasePlotCounterModify					= pClassInfo->getBasePlotCounterModify();
	if (getAdvancedStartCostIncrease()						== 0)				m_iAdvancedStartCostIncrease				= pClassInfo->getAdvancedStartCostIncrease();
	if (getTilesPerGoody()									== 0)				m_iTilesPerGoody							= pClassInfo->getTilesPerGoody();
	if (getGoodyUniqueRange()								== 0)				m_iGoodyUniqueRange							= pClassInfo->getGoodyUniqueRange();
	if (getFeatureGrowthProbability()						== 0)				m_iFeatureGrowthProbability					= pClassInfo->getFeatureGrowthProbability();
	if (getUpgradeTime()									== 0)				m_iUpgradeTime								= pClassInfo->getUpgradeTime();
	if (getExploreDelay() == 0)				m_iExploreDelay = pClassInfo->getExploreDelay();
	if (getAirBombDefense()									== 0)				m_iAirBombDefense							= pClassInfo->getAirBombDefense();
	if (getDefenseModifier()								== 0)				m_iDefenseModifier							= pClassInfo->getDefenseModifier();
	if (getHappiness()										== 0)				m_iHappiness								= pClassInfo->getHappiness();
	if (getPillageGold()									== 0)				m_iPillageGold								= pClassInfo->getPillageGold();
	if (getAdvancedStartCost()								== -1)				m_iAdvancedStartCost						= pClassInfo->getAdvancedStartCost();
	if (getSpawnPerGameLimit()								== -1)				m_iSpawnPerGameLimit						= pClassInfo->getSpawnPerGameLimit();
	if (getSpawnAtOnceLimit()								== -1)				m_iSpawnAtOnceLimit							= pClassInfo->getSpawnAtOnceLimit();
	if (m_iWorldSoundscapeScriptId							== -1)				m_iWorldSoundscapeScriptId					= pClassInfo->getWorldSoundscapeScriptId();
	if (getCultureControlStrength() == 0)	m_iCultureControlStrength = pClassInfo->getCultureControlStrength();
	if (getCultureRange() == -1)	m_iCultureRange = pClassInfo->getCultureRange();
	if (getPythonAtRange()									== cDefault)		m_szPythonAtRange							= pClassInfo->getPythonAtRange();
	if (getPythonOnMove()									== cDefault)		m_szPythonOnMove							= pClassInfo->getPythonOnMove();
	if (getBonusConvert()									== NO_BONUS)		m_iBonusConvert								= pClassInfo->getBonusConvert();
/*************************************************************************************************/
/**	Statesmen								02/05/10											**/
/**																								**/
/**						Allows improvements to grant specific specialists						**/
/*************************************************************************************************/
	if (getFreeSpecialist()									== NO_SPECIALIST)	m_iFreeSpecialist							= pClassInfo->getFreeSpecialist();
/*************************************************************************************************/
/**	Statesmen								END													**/
/*************************************************************************************************/
	if (getFeatureUpgrade()									== NO_FEATURE)		m_iFeatureUpgrade							= pClassInfo->getFeatureUpgrade();
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_piPrereqNatureYield[i]						== 0)				m_piPrereqNatureYield[i]					= pClassInfo->getPrereqNatureYield(i);
		if (m_piYieldChange[i]								== 0)				m_piYieldChange[i]							= pClassInfo->getYieldChange(i);
		if (m_piRiverSideYieldChange[i]						== 0)				m_piRiverSideYieldChange[i]					= pClassInfo->getRiverSideYieldChange(i);
		if (m_piHillsYieldChange[i]							== 0)				m_piHillsYieldChange[i]						= pClassInfo->getHillsYieldChange(i);
		if (m_piIrrigatedChange[i]							== 0)				m_piIrrigatedChange[i]						= pClassInfo->getIrrigatedYieldChange(i);
	}
	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (m_pbTerrainMakesValid[i]						== false)			m_pbTerrainMakesValid[i]					= pClassInfo->getTerrainMakesValid(i);
	}
	for (int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if (m_pbFeatureMakesValid[i]						== false)			m_pbFeatureMakesValid[i]					= pClassInfo->getFeatureMakesValid(i);
		if (m_pbAllowsFeature[i]							== false)			m_pbAllowsFeature[i]						= pClassInfo->getAllowsFeature(i);
	}
	for (int i = 0; i < GC.getNumBonusInfos(); i++)
	{
		if (m_paImprovementBonus[i].m_bBonusMakesValid		== false)			m_paImprovementBonus[i].m_bBonusMakesValid	= pClassInfo->isImprovementBonusMakesValid(i);
		if (m_paImprovementBonus[i].m_bBonusTrade			== false)			m_paImprovementBonus[i].m_bBonusTrade		= pClassInfo->isImprovementBonusTrade(i);
		if (m_paImprovementBonus[i].m_iDiscoverRand			== 0)				m_paImprovementBonus[i].m_iDiscoverRand		= pClassInfo->getImprovementBonusDiscoverRand(i);
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_paImprovementBonus[i].m_piYieldChange[j]	== 0)				m_paImprovementBonus[i].m_piYieldChange[j]	= pClassInfo->getImprovementBonusYield(i,j);
		}
	}
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiTechYieldChanges[i][j]					== 0)				m_ppiTechYieldChanges[i][j]					= pClassInfo->getTechYieldChanges(i, j);
		}
/*************************************************************************************************/
/** Hinterlands				  				07/11/09								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
		if(getLairCreationWeightTechs(i)			== false)			m_piLairCreationWeightTechs[i]				= pClassInfo->getLairCreationWeightTechs(i);
		if(getLairUpgradeTechs(i)					== false)			m_piLairUpgradeTechs[i]						= pClassInfo->getLairUpgradeTechs(i);
/*************************************************************************************************/
/**											END													**/
/*************************************************************************************************/
	}
	for (int i = 0; i < GC.getNumRouteInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiRouteYieldChanges[i][j]				== 0)				m_ppiRouteYieldChanges[i][j]				= pClassInfo->getRouteYieldChanges(i, j);
		}
	}
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
	if(pClassInfo->getNumSpawnPromotions() > 0)
	{
		int* tempArray = new int[getNumSpawnPromotions() + pClassInfo->getNumSpawnPromotions()];
		for(int i = 0; i< getNumSpawnPromotions(); ++i)
		{
			tempArray[i] = getSpawnPromotions(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumSpawnPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumSpawnPromotions();++j)
			{
				if(pClassInfo->getSpawnPromotions(i) == getSpawnPromotions(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumSpawnPromotions()] = pClassInfo->getSpawnPromotions(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piSpawnPromotions);
		int iGoalSize = getNumSpawnPromotions() + iNewItems;
		m_piSpawnPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piSpawnPromotions[i] = tempArray[i];
			FAssertMsg(m_piSpawnPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piSpawnPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumSpawnPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumGuardianPromotions() > 0)
	{
		int* tempArray = new int[getNumGuardianPromotions() + pClassInfo->getNumGuardianPromotions()];
		for(int i = 0; i< getNumGuardianPromotions(); ++i)
		{
			tempArray[i] = getGuardianPromotions(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumGuardianPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumGuardianPromotions();++j)
			{
				if(pClassInfo->getGuardianPromotions(i) == getGuardianPromotions(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumGuardianPromotions()] = pClassInfo->getGuardianPromotions(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piGuardianPromotions);
		int iGoalSize = getNumGuardianPromotions() + iNewItems;
		m_piGuardianPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piGuardianPromotions[i] = tempArray[i];
			FAssertMsg(m_piGuardianPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piGuardianPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumGuardianPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	//Readpass2 stuff
	if (m_iImprovementPillage								== -1)				m_iImprovementPillage						= pClassInfo->getImprovementPillage();
	if (m_iImprovementUpgrade								== -1)				m_iImprovementUpgrade						= pClassInfo->getImprovementUpgrade();

	//Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getSpawnUnitTypeVectorSize(); i++ )
	{
														m_aszExtraXMLforPass3.push_back(		pClassInfo->getSpawnUnitTypeVectorElement(i));
	}
/*************************************************************************************************/
/**	LairGuardians							7/17/10									Valkrionn	**/
/**																								**/
/**				Allows for lairs to spawn a unit on creation, but spawn others normally			**/
/*************************************************************************************************/
	for ( int i = 0; i < pClassInfo->getImmediateSpawnUnitTypeVectorSize(); i++ )
	{
														m_aszExtraXML4forPass3.push_back(		pClassInfo->getImmediateSpawnUnitTypeVectorElement(i));
	}
	for ( int i = 0; i < pClassInfo->getSpawnGroupTypeVectorSize(); i++ )
	{
														m_aszExtraXML5forPass3.push_back(		pClassInfo->getSpawnGroupTypeVectorElement(i));
	}
	for ( int i = 0; i < pClassInfo->getImmediateSpawnGroupTypeVectorSize(); i++ )
	{
														m_aszExtraXML6forPass3.push_back(		pClassInfo->getImmediateSpawnGroupTypeVectorElement(i));
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	for ( int i = 0; i < pClassInfo->getPrereqCivilizationVectorSize(); i++ )
	{
														m_aszExtraXML2forPass3.push_back(		pClassInfo->getPrereqCivilizationVectorElement(i));
	}
	for ( int i = 0; i < pClassInfo->getSpawnUnitCivVectorSize(); i++ )
	{
														m_aszExtraXML3forPass3.push_back(		pClassInfo->getSpawnUnitCivVectorElement(i));
	}

}

void CvImprovementInfo::copyNonDefaultsReadPass2(CvImprovementInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getImprovementPillage()		!= -1)				m_iImprovementPillage						= pClassInfo->getImprovementPillage();
	if (bOver || pClassInfo->getImprovementUpgrade()		!= -1)				m_iImprovementUpgrade						= pClassInfo->getImprovementUpgrade();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvBonusClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBonusClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBonusClassInfo::CvBonusClassInfo() :
m_iUniqueRange(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBonusClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBonusClassInfo::~CvBonusClassInfo()
{
}

int CvBonusClassInfo::getUniqueRange() const
{
	return m_iUniqueRange;
}

bool CvBonusClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iUniqueRange, "iUnique");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBonusClassInfo::copyNonDefaults(CvBonusClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getUniqueRange()	== 0)	m_iUniqueRange	= pClassInfo->getUniqueRange();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvBonusInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBonusInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBonusInfo::CvBonusInfo() :
m_iBonusClassType(NO_BONUSCLASS),
m_iChar(0),
m_iTechReveal(0),
m_iTechCityTrade(0),
m_iTechObsolete(0),
m_iAITradeModifier(0),
m_iAIObjective(0),
m_iHealth(0),
m_iHappiness(0),
m_iMinAreaSize(0),
m_iMinLatitude(0),
m_iMaxLatitude(90),
m_iPlacementOrder(0),
m_iConstAppearance(0),
m_iRandAppearance1(0),
m_iRandAppearance2(0),
m_iRandAppearance3(0),
m_iRandAppearance4(0),
m_iPercentPerPlayer(0),
m_iTilesPer(0),
m_iMinLandPercent(0),
m_iUniqueRange(0),
m_iGroupRange(0),
m_iGroupRand(0),
m_bOneArea(false),
m_bHills(false),
/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
m_bPeaks(false),
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/
m_bFlatlands(false),
m_bNoRiverSide(false),
m_bNormalize(false),
m_piYieldChange(NULL),
m_piYieldModifier(NULL),
m_piCommerceModifier(NULL),
m_piImprovementChange(NULL),
m_pbTerrain(NULL),
m_pbFeature(NULL),
m_pbFeatureTerrain(NULL),

//FfH: Added by Kael 08/16/2007
m_bModifierPerBonus(false),
m_iBadAttitude(0),
m_iDamageType(NO_DAMAGE),
m_iDiscoverRandModifier(0),
m_iFreePromotion(NO_PROMOTION),
m_iGreatPeopleRateModifier(0),
m_iHealChange(0),
m_iHealChangeEnemy(0),
m_iMaintenanceModifier(0),
m_iMutateChance(0),
m_iResearchModifier(0)
//FfH: End Add

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBonusInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBonusInfo::~CvBonusInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piYieldModifier);
	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	SAFE_DELETE_ARRAY(m_piImprovementChange);
	SAFE_DELETE_ARRAY(m_pbTerrain);
	SAFE_DELETE_ARRAY(m_pbFeature);
	SAFE_DELETE_ARRAY(m_pbFeatureTerrain);	// free memory - MT
}

int CvBonusInfo::getBonusClassType() const
{
	return m_iBonusClassType;
}

int CvBonusInfo::getChar() const
{
	return m_iChar;
}

void CvBonusInfo::setChar(int i)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iChar = i;
/**								----  End Original Code  ----									**/
	m_iChar = i + 125;
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvBonusInfo::getTechReveal() const
{
	return m_iTechReveal;
}

int CvBonusInfo::getTechCityTrade() const
{
	return m_iTechCityTrade;
}

int CvBonusInfo::getTechObsolete() const
{
	return m_iTechObsolete;
}

int CvBonusInfo::getAITradeModifier() const
{
	return m_iAITradeModifier;
}

int CvBonusInfo::getAIObjective() const
{
	return m_iAIObjective;
}

int CvBonusInfo::getHealth() const
{
	return m_iHealth;
}

int CvBonusInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvBonusInfo::getMinAreaSize() const
{
	return m_iMinAreaSize;
}

int CvBonusInfo::getMinLatitude() const
{
	return m_iMinLatitude;
}

int CvBonusInfo::getMaxLatitude() const
{
	return m_iMaxLatitude;
}

int CvBonusInfo::getPlacementOrder() const
{
	return m_iPlacementOrder;
}

int CvBonusInfo::getConstAppearance() const
{
	return m_iConstAppearance;
}

int CvBonusInfo::getRandAppearance1() const
{
	return m_iRandAppearance1;
}

int CvBonusInfo::getRandAppearance2() const
{
	return m_iRandAppearance2;
}

int CvBonusInfo::getRandAppearance3() const
{
	return m_iRandAppearance3;
}

int CvBonusInfo::getRandAppearance4() const
{
	return m_iRandAppearance4;
}

int CvBonusInfo::getPercentPerPlayer() const
{
	return m_iPercentPerPlayer;
}

int CvBonusInfo::getTilesPer() const
{
	return m_iTilesPer;
}

int CvBonusInfo::getMinLandPercent() const
{
	return m_iMinLandPercent;
}

int CvBonusInfo::getUniqueRange() const
{
	return m_iUniqueRange;
}

int CvBonusInfo::getGroupRange() const
{
	return m_iGroupRange;
}

int CvBonusInfo::getGroupRand() const
{
	return m_iGroupRand;
}

bool CvBonusInfo::isOneArea() const
{
	return m_bOneArea;
}

bool CvBonusInfo::isHills() const
{
	return m_bHills;
}

/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
bool CvBonusInfo::isPeaks() const
{
	return m_bPeaks;
}
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/

bool CvBonusInfo::isFlatlands() const
{
	return m_bFlatlands;
}

bool CvBonusInfo::isNoRiverSide() const
{
	return m_bNoRiverSide;
}

bool CvBonusInfo::isNormalize() const
{
	return m_bNormalize;
}

const TCHAR* CvBonusInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvBonusInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

//FfH: Added by Kael 08/16/2007
bool CvBonusInfo::isModifierPerBonus() const
{
	return m_bModifierPerBonus;
}

int CvBonusInfo::getBadAttitude() const
{
	return m_iBadAttitude;
}

int CvBonusInfo::getDamageType() const
{
	return m_iDamageType;
}

int CvBonusInfo::getDiscoverRandModifier() const
{
	return m_iDiscoverRandModifier;
}

int CvBonusInfo::getFreePromotion() const
{
	return m_iFreePromotion;
}

int CvBonusInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvBonusInfo::getHealChange() const
{
	return m_iHealChange;
}

int CvBonusInfo::getHealChangeEnemy() const
{
	return m_iHealChangeEnemy;
}

int CvBonusInfo::getMaintenanceModifier() const
{
	return m_iMaintenanceModifier;
}

int CvBonusInfo::getMutateChance() const
{
	return m_iMutateChance;
}

int CvBonusInfo::getResearchModifier() const
{
	return m_iResearchModifier;
}
//FfH: End Add
/*************************************************************************************************/
/**	New Tag Defs	(BonusInfos)			05/31/09								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvBonusInfo::getFreePromotionVectorSize()					{return m_aszExtraXMLforPass3.size();}
CvString CvBonusInfo::getFreePromotionVectorElement(int i)		{return m_aszExtraXMLforPass3[i];}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

// Arrays

int CvBonusInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int* CvBonusInfo::getYieldChangeArray()
{
	return m_piYieldChange;
}
int CvBonusInfo::getYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldModifier ? m_piYieldModifier[i] : -1;
}

int* CvBonusInfo::getYieldModifierArray()
{
	return m_piYieldModifier;
}
int CvBonusInfo::getCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceModifier ? m_piCommerceModifier[i] : -1;
}

int* CvBonusInfo::getCommerceModifierArray()
{
	return m_piCommerceModifier;
}

int CvBonusInfo::getImprovementChange(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piImprovementChange ? m_piImprovementChange[i] : -1;
}

bool CvBonusInfo::isTerrain(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrain ?	m_pbTerrain[i] : false;
}

bool CvBonusInfo::isFeature(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeature ? m_pbFeature[i] : false;
}

bool CvBonusInfo::isFeatureTerrain(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureTerrain ?	m_pbFeatureTerrain[i] : false;
}

const TCHAR* CvBonusInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoBonus * pBonusArtInfo;
	pBonusArtInfo = getArtInfo();
	if (pBonusArtInfo != NULL)
	{
		return pBonusArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

void CvBonusInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iBonusClassType);
	stream->Read(&m_iChar);
	stream->Read(&m_iTechReveal);
	stream->Read(&m_iTechCityTrade);
	stream->Read(&m_iTechObsolete);
	stream->Read(&m_iAITradeModifier);
	stream->Read(&m_iAIObjective);
	stream->Read(&m_iHealth);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iMinAreaSize);
	stream->Read(&m_iMinLatitude);
	stream->Read(&m_iMaxLatitude);
	stream->Read(&m_iPlacementOrder);
	stream->Read(&m_iConstAppearance);
	stream->Read(&m_iRandAppearance1);
	stream->Read(&m_iRandAppearance2);
	stream->Read(&m_iRandAppearance3);
	stream->Read(&m_iRandAppearance4);
	stream->Read(&m_iPercentPerPlayer);
	stream->Read(&m_iTilesPer);
	stream->Read(&m_iMinLandPercent);
	stream->Read(&m_iUniqueRange);
	stream->Read(&m_iGroupRange);
	stream->Read(&m_iGroupRand);

	stream->Read(&m_bOneArea);
	stream->Read(&m_bHills);
/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
	stream->Read(&m_bPeaks);
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/
	stream->Read(&m_bFlatlands);
	stream->Read(&m_bNoRiverSide);
	stream->Read(&m_bNormalize);

	stream->ReadString(m_szArtDefineTag);

//FfH: Added by Kael 08/16/2007
	stream->Read(&m_bModifierPerBonus);
	stream->Read(&m_iBadAttitude);
	stream->Read(&m_iDamageType);
	stream->Read(&m_iDiscoverRandModifier);
	stream->Read(&m_iFreePromotion);
	stream->Read(&m_iGreatPeopleRateModifier);
	stream->Read(&m_iHealChange);
	stream->Read(&m_iHealChangeEnemy);
	stream->Read(&m_iMaintenanceModifier);
	stream->Read(&m_iMutateChance);
	stream->Read(&m_iResearchModifier);
//FfH: End Add

	// Arrays

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);

	SAFE_DELETE_ARRAY(m_piYieldModifier);
	m_piYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldModifier);

	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	m_piCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceModifier);

	SAFE_DELETE_ARRAY(m_piImprovementChange);
	m_piImprovementChange = new int[GC.getNumImprovementInfos()];
	stream->Read(GC.getNumImprovementInfos(), m_piImprovementChange);

	SAFE_DELETE_ARRAY(m_pbTerrain);
	m_pbTerrain = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrain);

	SAFE_DELETE_ARRAY(m_pbFeature);
	m_pbFeature = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeature);

	SAFE_DELETE_ARRAY(m_pbFeatureTerrain);
	m_pbFeatureTerrain = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbFeatureTerrain);
}

void CvBonusInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iBonusClassType);
	stream->Write(m_iChar);
	stream->Write(m_iTechReveal);
	stream->Write(m_iTechCityTrade);
	stream->Write(m_iTechObsolete);
	stream->Write(m_iAITradeModifier);
	stream->Write(m_iAIObjective);
	stream->Write(m_iHealth);
	stream->Write(m_iHappiness);
	stream->Write(m_iMinAreaSize);
	stream->Write(m_iMinLatitude);
	stream->Write(m_iMaxLatitude);
	stream->Write(m_iPlacementOrder);
	stream->Write(m_iConstAppearance);
	stream->Write(m_iRandAppearance1);
	stream->Write(m_iRandAppearance2);
	stream->Write(m_iRandAppearance3);
	stream->Write(m_iRandAppearance4);
	stream->Write(m_iPercentPerPlayer);
	stream->Write(m_iTilesPer);
	stream->Write(m_iMinLandPercent);
	stream->Write(m_iUniqueRange);
	stream->Write(m_iGroupRange);
	stream->Write(m_iGroupRand);

	stream->Write(m_bOneArea);
	stream->Write(m_bHills);
/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
	stream->Write(m_bPeaks);
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/
	stream->Write(m_bFlatlands);
	stream->Write(m_bNoRiverSide);
	stream->Write(m_bNormalize);

	stream->WriteString(m_szArtDefineTag);

//FfH: Added by Kael 08/16/2007
	stream->Write(m_bModifierPerBonus);
	stream->Write(m_iBadAttitude);
	stream->Write(m_iDamageType);
	stream->Write(m_iDiscoverRandModifier);
	stream->Write(m_iFreePromotion);
	stream->Write(m_iGreatPeopleRateModifier);
	stream->Write(m_iHealChange);
	stream->Write(m_iHealChangeEnemy);
	stream->Write(m_iMaintenanceModifier);
	stream->Write(m_iMutateChance);
	stream->Write(m_iResearchModifier);
//FfH: End Add

	// Arrays

	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piYieldModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceModifier);
	stream->Write(GC.getNumImprovementInfos(), m_piImprovementChange);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrain);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeature);
	stream->Write(GC.getNumTerrainInfos(), m_pbFeatureTerrain);
}

bool CvBonusInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName( szTextVal, "BonusClassType");
	m_iBonusClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "TechReveal");
	m_iTechReveal = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "TechCityTrade");
	m_iTechCityTrade = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "TechObsolete");
	m_iTechObsolete = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "YieldModifiers"))
	{
		pXML->SetYields(&m_piYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceModifier, NUM_COMMERCE_TYPES);
	}

	pXML->GetChildXmlValByName(&m_iAITradeModifier, "iAITradeModifier");
	pXML->GetChildXmlValByName(&m_iAIObjective, "iAIObjective");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iMinAreaSize, "iMinAreaSize");
	pXML->GetChildXmlValByName(&m_iMinLatitude, "iMinLatitude");
	pXML->GetChildXmlValByName(&m_iMaxLatitude, "iMaxLatitude", 90);
	pXML->GetChildXmlValByName(&m_iPlacementOrder, "iPlacementOrder");
	pXML->GetChildXmlValByName(&m_iConstAppearance, "iConstAppearance");

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Rands"))
	{
		pXML->GetChildXmlValByName(&m_iRandAppearance1, "iRandApp1");
		pXML->GetChildXmlValByName(&m_iRandAppearance2, "iRandApp2");
		pXML->GetChildXmlValByName(&m_iRandAppearance3, "iRandApp3");
		pXML->GetChildXmlValByName(&m_iRandAppearance4, "iRandApp4");

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(&m_iPercentPerPlayer, "iPlayer");
	pXML->GetChildXmlValByName(&m_iTilesPer, "iTilesPer");
	pXML->GetChildXmlValByName(&m_iMinLandPercent, "iMinLandPercent");
	pXML->GetChildXmlValByName(&m_iUniqueRange, "iUnique");
	pXML->GetChildXmlValByName(&m_iGroupRange, "iGroupRange");
	pXML->GetChildXmlValByName(&m_iGroupRand, "iGroupRand");
	pXML->GetChildXmlValByName(&m_bOneArea, "bArea");
	pXML->GetChildXmlValByName(&m_bHills, "bHills");
/*************************************************************************************************/
/**	Mountain Mod by NeverMind 		imported by Ahwaric	19.09.09		**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bPeaks, "bPeaks");
/*************************************************************************************************/
/**	Mountain Mod	END									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bFlatlands, "bFlatlands");
	pXML->GetChildXmlValByName(&m_bNoRiverSide, "bNoRiverSide");
	pXML->GetChildXmlValByName(&m_bNormalize, "bNormalize");

	pXML->SetVariableListTagPair(&m_pbTerrain, "TerrainBooleans", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeature, "FeatureBooleans", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureTerrain, "FeatureTerrainBooleans", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());

//FfH: Added by Kael 08/16/2007
	pXML->GetChildXmlValByName(&m_bModifierPerBonus, "bModifierPerBonus");
	pXML->GetChildXmlValByName(&m_iBadAttitude, "iBadAttitude");
	pXML->GetChildXmlValByName(&m_iDiscoverRandModifier, "iDiscoverRandModifier");
	pXML->GetChildXmlValByName(szTextVal, "FreePromotion");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iHealChange, "iHealChange");
	pXML->GetChildXmlValByName(&m_iHealChangeEnemy, "iHealChangeEnemy");
	pXML->GetChildXmlValByName(&m_iMaintenanceModifier, "iMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iMutateChance, "iMutateChance");
	pXML->GetChildXmlValByName(&m_iResearchModifier, "iResearchModifier");
	pXML->GetChildXmlValByName( szTextVal, "DamageType");
	m_iDamageType = pXML->FindInInfoClass(szTextVal);
//FfH: End Add

	return true;
}

//FfH: Added by Kael 08/09/2007
bool CvBonusInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iFreePromotion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iFreePromotion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBonusInfo::copyNonDefaults(CvBonusInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()			== cDefault)		setArtDefineTag(		pClassInfo->getArtDefineTag());
	//Must do Art Define before Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isOneArea()					== false)			m_bOneArea					= pClassInfo->isOneArea();
	if (isHills()					== false)			m_bHills					= pClassInfo->isHills();
	if (isPeaks()					== false)			m_bPeaks					= pClassInfo->isPeaks();
	if (isFlatlands()				== false)			m_bFlatlands				= pClassInfo->isFlatlands();
	if (isNoRiverSide()				== false)			m_bNoRiverSide				= pClassInfo->isNoRiverSide();
	if (isNormalize()				== false)			m_bNormalize				= pClassInfo->isNormalize();
	if (isModifierPerBonus()		== false)			m_bModifierPerBonus			= pClassInfo->isModifierPerBonus();
	if (getBadAttitude()			== 0)				m_iBadAttitude				= pClassInfo->getBadAttitude();
	if (getDiscoverRandModifier()	== 0)				m_iDiscoverRandModifier		= pClassInfo->getDiscoverRandModifier();
	if (getGreatPeopleRateModifier()== 0)				m_iGreatPeopleRateModifier	= pClassInfo->getGreatPeopleRateModifier();
	if (getHealChange()				== 0)				m_iHealChange				= pClassInfo->getHealChange();
	if (getHealChangeEnemy()		== 0)				m_iHealChangeEnemy			= pClassInfo->getHealChangeEnemy();
	if (getMaintenanceModifier()	== 0)				m_iMaintenanceModifier		= pClassInfo->getMaintenanceModifier();
	if (getMutateChance()			== 0)				m_iMutateChance				= pClassInfo->getMutateChance();
	if (getResearchModifier()		== 0)				m_iResearchModifier			= pClassInfo->getResearchModifier();
	if (getAITradeModifier()		== 0)				m_iAITradeModifier			= pClassInfo->getAITradeModifier();
	if (getAIObjective()			== 0)				m_iAIObjective				= pClassInfo->getAIObjective();
	if (getHealth()					== 0)				m_iHealth					= pClassInfo->getHealth();
	if (getHappiness()				== 0)				m_iHappiness				= pClassInfo->getHappiness();
	if (getMinAreaSize()			== 0)				m_iMinAreaSize				= pClassInfo->getMinAreaSize();
	if (getMinLatitude()			== 0)				m_iMinLatitude				= pClassInfo->getMinLatitude();
	if (getPlacementOrder()			== 0)				m_iPlacementOrder			= pClassInfo->getPlacementOrder();
	if (getConstAppearance()		== 0)				m_iConstAppearance			= pClassInfo->getConstAppearance();
	if (getRandAppearance1()		== 0)				m_iRandAppearance1			= pClassInfo->getRandAppearance1();
	if (getRandAppearance2()		== 0)				m_iRandAppearance2			= pClassInfo->getRandAppearance2();
	if (getRandAppearance3()		== 0)				m_iRandAppearance3			= pClassInfo->getRandAppearance3();
	if (getRandAppearance4()		== 0)				m_iRandAppearance4			= pClassInfo->getRandAppearance4();
	if (getPercentPerPlayer()		== 0)				m_iPercentPerPlayer			= pClassInfo->getPercentPerPlayer();
	if (getTilesPer()				== 0)				m_iTilesPer					= pClassInfo->getTilesPer();
	if (getMinLandPercent()			== 0)				m_iMinLandPercent			= pClassInfo->getMinLandPercent();
	if (getUniqueRange()			== 0)				m_iUniqueRange				= pClassInfo->getUniqueRange();
	if (getGroupRange()				== 0)				m_iGroupRange				= pClassInfo->getGroupRange();
	if (getGroupRand()				== 0)				m_iGroupRand				= pClassInfo->getGroupRand();
	if (getMaxLatitude()			== 90)				m_iMaxLatitude				= pClassInfo->getMaxLatitude();
	if (getTechReveal()				== NO_TECH)			m_iTechReveal				= pClassInfo->getTechReveal();
	if (getTechCityTrade()			== NO_TECH)			m_iTechCityTrade			= pClassInfo->getTechCityTrade();
	if (getTechObsolete()			== NO_TECH)			m_iTechObsolete				= pClassInfo->getTechObsolete();
	if (getDamageType()				== NO_DAMAGE)		m_iDamageType				= pClassInfo->getDamageType();
	if (getBonusClassType()			== NO_BONUSCLASS)	m_iBonusClassType			= pClassInfo->getBonusClassType();
	for ( int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_piYieldChange[i]		== 0)				m_piYieldChange[i]			= pClassInfo->getYieldChange(i);
		if (m_piYieldModifier[i] == 0)				m_piYieldModifier[i] = pClassInfo->getYieldModifier(i);
	}
	for (int i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		if (m_piCommerceModifier[i] == 0)				m_piCommerceModifier[i] = pClassInfo->getCommerceModifier(i);
	}
	for ( int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (m_pbTerrain[i]			== false)			m_pbTerrain[i]				= pClassInfo->isTerrain(i);
		if (m_pbFeatureTerrain[i]	== false)			m_pbFeatureTerrain[i]		= pClassInfo->isFeatureTerrain(i);
	}
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if (m_pbFeature[i]			== false)			m_pbFeature[i]				= pClassInfo->isFeature(i);
	}

	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getFreePromotionVectorSize(); i++ )
	{
														m_aszExtraXMLforPass3.push_back(		pClassInfo->getFreePromotionVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvFeatureInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvFeatureInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvFeatureInfo::CvFeatureInfo() :
m_iMovementCost(0),
m_iSeeThroughChange(0),
m_iHealthPercent(0),
m_iAppearanceProbability(0),
m_iDisappearanceProbability(0),
m_iGrowthProbability(0),
m_iDefenseModifier(0),
m_iAdvancedStartRemoveCost(0),
m_iTurnDamage(0),
m_bNoCoast(false),
m_bNoRiver(false),
m_bNoAdjacent(false),
m_bRequiresFlatlands(false),
m_bRequiresRiver(false),
/*************************************************************************************************/
/**	Features expanded						Ahwaric	04/10/09	**/
/*************************************************************************************************/
m_bRequiresFreshwater(false),
m_iTerrainConvert(NO_TERRAIN),
/*************************************************************************************************/
/**										END		**/
/*************************************************************************************************/
m_bAddsFreshWater(false),
m_bImpassable(false),
m_bNoCity(false),
m_bNoImprovement(false),
m_bVisibleAlways(false),
m_bNukeImmune(false),
m_iWorldSoundscapeScriptId(0),
m_iEffectProbability(0),

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
m_bMist(false),
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

//FfH: Added by Kael 03/20/2008
m_bFlammable(false),
m_iFeatureUpgrade(NO_FEATURE),
m_iPrereqStateReligion(NO_RELIGION),
m_iRequireResist(NO_DAMAGE),
//FfH: End Add

m_piYieldChange(NULL),
m_piRiverYieldChange(NULL),
m_piHillsYieldChange(NULL),
m_pi3DAudioScriptFootstepIndex(NULL),
m_pbTerrain(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvFeatureInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvFeatureInfo::~CvFeatureInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piRiverYieldChange);
	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	SAFE_DELETE_ARRAY(m_pi3DAudioScriptFootstepIndex);
	SAFE_DELETE_ARRAY(m_pbTerrain);
}


/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
int CvFeatureInfo::isMist() const                                       {return m_bMist             ;}
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

int CvFeatureInfo::getMovementCost() const
{
	return m_iMovementCost;
}

int CvFeatureInfo::getSeeThroughChange() const
{
	return m_iSeeThroughChange;
}

int CvFeatureInfo::getHealthPercent() const
{
	return m_iHealthPercent;
}

int CvFeatureInfo::getAppearanceProbability() const
{
	return m_iAppearanceProbability;
}

int CvFeatureInfo::getDisappearanceProbability() const
{
	return m_iDisappearanceProbability;
}

int CvFeatureInfo::getGrowthProbability() const
{
	return m_iGrowthProbability;
}

int CvFeatureInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

int CvFeatureInfo::getAdvancedStartRemoveCost() const
{
	return m_iAdvancedStartRemoveCost;
}

int CvFeatureInfo::getTurnDamage() const
{
	return m_iTurnDamage;
}

bool CvFeatureInfo::isNoCoast() const
{
	return m_bNoCoast;
}

bool CvFeatureInfo::isNoRiver() const
{
	return m_bNoRiver;
}

bool CvFeatureInfo::isNoAdjacent() const
{
	return m_bNoAdjacent;
}

bool CvFeatureInfo::isRequiresFlatlands() const
{
	return m_bRequiresFlatlands;
}

bool CvFeatureInfo::isRequiresRiver() const
{
	return m_bRequiresRiver;
}
/*************************************************************************************************/
/**	Features expanded						Ahwaric	04/10/09	**/
/*************************************************************************************************/
bool CvFeatureInfo::isRequiresFreshwater() const
{
	return m_bRequiresFreshwater;
}

int CvFeatureInfo::getTerrainConvert() const
{
	return m_iTerrainConvert;
}
/*************************************************************************************************/
/**										END		**/
/*************************************************************************************************/

bool CvFeatureInfo::isAddsFreshWater() const
{
	return m_bAddsFreshWater;
}

bool CvFeatureInfo::isImpassable() const
{
	return m_bImpassable;
}

bool CvFeatureInfo::isNoCity() const
{
	return m_bNoCity;
}

bool CvFeatureInfo::isNoImprovement() const
{
	return m_bNoImprovement;
}

bool CvFeatureInfo::isVisibleAlways() const
{
	return m_bVisibleAlways;
}

bool CvFeatureInfo::isNukeImmune() const
{
	return m_bNukeImmune;
}

const TCHAR* CvFeatureInfo::getOnUnitChangeTo() const
{
	return m_szOnUnitChangeTo;
}

const TCHAR* CvFeatureInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvFeatureInfo::setArtDefineTag(const TCHAR* szTag)
{
	m_szArtDefineTag = szTag;
}

int CvFeatureInfo::getWorldSoundscapeScriptId() const
{
	return m_iWorldSoundscapeScriptId;
}

const TCHAR* CvFeatureInfo::getEffectType() const
{
	return m_szEffectType;
}

int CvFeatureInfo::getEffectProbability() const
{
	return m_iEffectProbability;
}

//FfH: Added by Kael 08/26/2007
bool CvFeatureInfo::isFlammable() const
{
	return m_bFlammable;
}

int CvFeatureInfo::getFeatureUpgrade() const
{
	return m_iFeatureUpgrade;
}

int CvFeatureInfo::getPrereqStateReligion() const
{
	return m_iPrereqStateReligion;
}

const TCHAR *CvFeatureInfo::getPythonOnMove() const
{
	return m_szPythonOnMove;
}

int CvFeatureInfo::getRequireResist() const
{
	return m_iRequireResist;
}
//FfH: End Add

// Arrays

int CvFeatureInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int CvFeatureInfo::getRiverYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;
}

int CvFeatureInfo::getHillsYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;
}

int CvFeatureInfo::get3DAudioScriptFootstepIndex(int i) const
{
	//	FAssertMsg(i < ?, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;
}

bool CvFeatureInfo::isTerrain(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrain ? m_pbTerrain[i] : false;
}

int CvFeatureInfo::getNumVarieties() const
{
	return getArtInfo()->getNumVarieties();
}

const TCHAR* CvFeatureInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoFeature * pFeatureArtInfo;
	pFeatureArtInfo = getArtInfo();
	if (pFeatureArtInfo != NULL)
	{
		return pFeatureArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

const CvArtInfoFeature* CvFeatureInfo::getArtInfo() const
{
	return ARTFILEMGR.getFeatureArtInfo( getArtDefineTag());
}

bool CvFeatureInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName( szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverYieldChange"))
	{
		pXML->SetYields(&m_piRiverYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HillsYieldChange"))
	{
		pXML->SetYields(&m_piHillsYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piHillsYieldChange, NUM_YIELD_TYPES);
	}

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bMist, "bMist", false);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(&m_iMovementCost, "iMovement");
	pXML->GetChildXmlValByName(&m_iSeeThroughChange, "iSeeThrough");
	pXML->GetChildXmlValByName(&m_iHealthPercent, "iHealthPercent");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefense");
	pXML->GetChildXmlValByName(&m_iAdvancedStartRemoveCost, "iAdvancedStartRemoveCost");
	pXML->GetChildXmlValByName(&m_iTurnDamage, "iTurnDamage");
	pXML->GetChildXmlValByName(&m_iAppearanceProbability, "iAppearance");
	pXML->GetChildXmlValByName(&m_iDisappearanceProbability, "iDisappearance");
	pXML->GetChildXmlValByName(&m_iGrowthProbability, "iGrowth");
	pXML->GetChildXmlValByName(&m_bNoCoast, "bNoCoast");
	pXML->GetChildXmlValByName(&m_bNoRiver, "bNoRiver");
	pXML->GetChildXmlValByName(&m_bNoAdjacent, "bNoAdjacent");
	pXML->GetChildXmlValByName(&m_bRequiresFlatlands, "bRequiresFlatlands");
	pXML->GetChildXmlValByName(&m_bRequiresRiver, "bRequiresRiver");
/*************************************************************************************************/
/**	Features expanded						Ahwaric	04/10/09	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bRequiresFreshwater, "bRequiresFreshwater");
	pXML->GetChildXmlValByName(szTextVal, "TerrainConvert");
	m_iTerrainConvert = GC.getInfoTypeForString(szTextVal);
/*************************************************************************************************/
/**										END		**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bAddsFreshWater, "bAddsFreshWater");
	pXML->GetChildXmlValByName(&m_bImpassable, "bImpassable");
	pXML->GetChildXmlValByName(&m_bNoCity, "bNoCity");
	pXML->GetChildXmlValByName(&m_bNoImprovement, "bNoImprovement");
	pXML->GetChildXmlValByName(&m_bVisibleAlways, "bVisibleAlways");
	pXML->GetChildXmlValByName(&m_bNukeImmune, "bNukeImmune");
	pXML->GetChildXmlValByName(m_szOnUnitChangeTo, "OnUnitChangeTo");

	pXML->SetVariableListTagPairForAudioScripts(&m_pi3DAudioScriptFootstepIndex, "FootstepSounds", GC.getFootstepAudioTypes(), GC.getNumFootstepAudioTypes());

	pXML->GetChildXmlValByName(szTextVal, "WorldSoundscapeAudioScript");
	if ( szTextVal.GetLength() > 0 )
	{
		m_iWorldSoundscapeScriptId = gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_SOUNDSCAPE );
	}
	else
	{
		m_iWorldSoundscapeScriptId = -1;
	}

	pXML->GetChildXmlValByName(m_szEffectType, "EffectType");
	pXML->GetChildXmlValByName(&m_iEffectProbability, "iEffectProbability");

	pXML->SetVariableListTagPair(&m_pbTerrain, "TerrainBooleans", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());

//FfH: Added by Kael 09/02/2007
	pXML->GetChildXmlValByName(&m_bFlammable, "bFlammable");
	pXML->GetChildXmlValByName(szTextVal, "PrereqStateReligion");
	m_iPrereqStateReligion = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(m_szPythonOnMove, "PythonOnMove");
	pXML->GetChildXmlValByName(szTextVal, "RequireResist");
	m_iRequireResist = GC.getInfoTypeForString(szTextVal);
//FfH: End Add

	return true;
}

//FfH: Added by Kael 08/26/2007
bool CvFeatureInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "FeatureUpgrade");
	m_iFeatureUpgrade = GC.getInfoTypeForString(szTextVal);

	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvFeatureInfo::copyNonDefaults(CvFeatureInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()							== cDefault)	setArtDefineTag(					pClassInfo->getArtDefineTag());
	//Must do Art Define before Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	if (isMist()									== 0)			m_bMist								= pClassInfo->isMist();
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

	if (isNoCoast()									== false)		m_bNoCoast							= pClassInfo->isNoCoast();
	if (isNoRiver()									== false)		m_bNoRiver							= pClassInfo->isNoRiver();
	if (isNoAdjacent()								== false)		m_bNoAdjacent						= pClassInfo->isNoAdjacent();
	if (isRequiresFlatlands()						== false)		m_bRequiresFlatlands				= pClassInfo->isRequiresFlatlands();
	if (isRequiresRiver()							== false)		m_bRequiresRiver					= pClassInfo->isRequiresRiver();
	if (isAddsFreshWater()							== false)		m_bAddsFreshWater					= pClassInfo->isAddsFreshWater();
	if (isImpassable()								== false)		m_bImpassable						= pClassInfo->isImpassable();
	if (isNoCity()									== false)		m_bNoCity							= pClassInfo->isNoCity();
	if (isNoImprovement()							== false)		m_bNoImprovement					= pClassInfo->isNoImprovement();
	if (isVisibleAlways()							== false)		m_bVisibleAlways					= pClassInfo->isVisibleAlways();
	if (isNukeImmune()								== false)		m_bNukeImmune						= pClassInfo->isNukeImmune();
	if (isFlammable()								== false)		m_bFlammable						= pClassInfo->isFlammable();
	if (isRequiresFreshwater()						== false)		m_bRequiresFreshwater				= pClassInfo->isRequiresFreshwater();
	if (getMovementCost()							== 0)			m_iMovementCost						= pClassInfo->getMovementCost();
	if (getSeeThroughChange()						== 0)			m_iSeeThroughChange					= pClassInfo->getSeeThroughChange();
	if (getHealthPercent()							== 0)			m_iHealthPercent					= pClassInfo->getHealthPercent();
	if (getDefenseModifier()						== 0)			m_iDefenseModifier					= pClassInfo->getDefenseModifier();
	if (getAdvancedStartRemoveCost()				== 0)			m_iAdvancedStartRemoveCost			= pClassInfo->getAdvancedStartRemoveCost();
	if (getTurnDamage()								== 0)			m_iTurnDamage						= pClassInfo->getTurnDamage();
	if (getAppearanceProbability()					== 0)			m_iAppearanceProbability			= pClassInfo->getAppearanceProbability();
	if (getDisappearanceProbability()				== 0)			m_iDisappearanceProbability			= pClassInfo->getDisappearanceProbability();
	if (getGrowthProbability()						== 0)			m_iGrowthProbability				= pClassInfo->getGrowthProbability();
	if (getEffectProbability()						== 0)			m_iEffectProbability				= pClassInfo->getEffectProbability();
	if (getWorldSoundscapeScriptId()				== -1)			m_iWorldSoundscapeScriptId			= pClassInfo->getWorldSoundscapeScriptId();
	if (getOnUnitChangeTo()							== cDefault)	m_szOnUnitChangeTo					= pClassInfo->getOnUnitChangeTo();
	if (getEffectType()								== cDefault)	m_szEffectType						= pClassInfo->getEffectType();
	if (getPythonOnMove()							== cDefault)	m_szPythonOnMove					= pClassInfo->getPythonOnMove();
	if (getRequireResist()							== NO_DAMAGE)	m_iRequireResist					= pClassInfo->getRequireResist();
	if (getPrereqStateReligion()					== NO_RELIGION)	m_iPrereqStateReligion				= pClassInfo->getPrereqStateReligion();
	if (getTerrainConvert()							== NO_TERRAIN)	m_iTerrainConvert					= pClassInfo->getTerrainConvert();
	for (int i = 0; i < GC.getNumFootstepAudioTypes(); i++)
	{
		if (m_pi3DAudioScriptFootstepIndex[i]		== 0)			m_pi3DAudioScriptFootstepIndex[i]	= pClassInfo->get3DAudioScriptFootstepIndex(i);
	}
	for ( int i = 0; i < GC.getNumTerrainInfos(); i++ )
	{
		if (m_pbTerrain[i]							== false)		m_pbTerrain[i]						= pClassInfo->isTerrain(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_piYieldChange[i]						== 0)			m_piYieldChange[i]					= pClassInfo->getYieldChange(i);
		if (m_piRiverYieldChange[i]					== 0)			m_piRiverYieldChange[i]				= pClassInfo->getRiverYieldChange(i);
		if (m_piHillsYieldChange[i]					== 0)			m_piHillsYieldChange[i]				= pClassInfo->getHillsYieldChange(i);
	}

	//Readpass2 stuff
	if (m_iFeatureUpgrade							== -1)			m_iFeatureUpgrade					= pClassInfo->getFeatureUpgrade();
}
void CvFeatureInfo::copyNonDefaultsReadPass2(CvFeatureInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getFeatureUpgrade()	!= -1)			m_iFeatureUpgrade					= pClassInfo->getFeatureUpgrade();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCommerceInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCommerceInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCommerceInfo::CvCommerceInfo() :
m_iChar(0),
m_iInitialPercent(0),
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
m_iTradeModifier(0),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
m_iInitialHappiness(0),
m_iAIWeightPercent(0),
m_bFlexiblePercent(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCommerceInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCommerceInfo::~CvCommerceInfo()
{
}

int CvCommerceInfo::getChar() const
{
	return m_iChar;
}

void CvCommerceInfo::setChar(int i)
{
	m_iChar = i;
}

int CvCommerceInfo::getInitialPercent() const
{
	return m_iInitialPercent;
}

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
int CvCommerceInfo::getTradeModifier() const
{
	return m_iTradeModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

int CvCommerceInfo::getInitialHappiness() const
{
	return m_iInitialHappiness;
}

int CvCommerceInfo::getAIWeightPercent() const
{
	return m_iAIWeightPercent;
}

bool CvCommerceInfo::isFlexiblePercent() const
{
	return m_bFlexiblePercent;
}

bool CvCommerceInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iInitialPercent, "iInitialPercent");
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iTradeModifier, "iTradeModifier");
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iInitialHappiness, "iInitialHappiness");
	pXML->GetChildXmlValByName(&m_iAIWeightPercent, "iAIWeightPercent");
	pXML->GetChildXmlValByName(&m_bFlexiblePercent, "bFlexiblePercent");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCommerceInfo::copyNonDefaults(CvCommerceInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getInitialPercent()		== 0)		m_iInitialPercent	= pClassInfo->getInitialPercent();
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	if (getTradeModifier()		== 0)		m_iTradeModifier	= pClassInfo->getTradeModifier();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
	if (getInitialHappiness()	== 0)		m_iInitialHappiness	= pClassInfo->getInitialHappiness();
	if (getAIWeightPercent()	== 0)		m_iAIWeightPercent	= pClassInfo->getAIWeightPercent();
	if (isFlexiblePercent()		== false)	m_bFlexiblePercent	= pClassInfo->isFlexiblePercent();

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvYieldInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvYieldInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvYieldInfo::CvYieldInfo() :
m_iChar(0),
m_iHillsChange(0),
m_iPeakChange(0),
m_iLakeChange(0),
m_iCityChange(0),
m_iPopulationChangeOffset(0),
m_iPopulationChangeDivisor(0),
m_iMinCity(0),
m_iTradeModifier(0),
m_iGoldenAgeYield(0),
m_iGoldenAgeYieldThreshold(0),
m_iAIWeightPercent(0),
m_iColorType(NO_COLOR),
m_paszSymbolPath(NULL)
{
}


//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvYieldInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvYieldInfo::~CvYieldInfo()
{
	SAFE_DELETE_ARRAY(m_paszSymbolPath);
}

int CvYieldInfo::getChar() const
{
	return m_iChar;
}

void CvYieldInfo::setChar(int i)
{
	m_iChar = i;
}

int CvYieldInfo::getHillsChange() const
{
	return m_iHillsChange;
}

int CvYieldInfo::getPeakChange() const
{
	return m_iPeakChange;
}

int CvYieldInfo::getLakeChange() const
{
	return m_iLakeChange;
}

int CvYieldInfo::getCityChange() const
{
	return m_iCityChange;
}

int CvYieldInfo::getPopulationChangeOffset() const
{
	return m_iPopulationChangeOffset;
}

int CvYieldInfo::getPopulationChangeDivisor() const
{
	return m_iPopulationChangeDivisor;
}

int CvYieldInfo::getMinCity() const
{
	return m_iMinCity;
}

int CvYieldInfo::getTradeModifier() const
{
	return m_iTradeModifier;
}

int CvYieldInfo::getGoldenAgeYield() const
{
	return m_iGoldenAgeYield;
}

int CvYieldInfo::getGoldenAgeYieldThreshold() const
{
	return m_iGoldenAgeYieldThreshold;
}

int CvYieldInfo::getAIWeightPercent() const
{
	return m_iAIWeightPercent;
}

int CvYieldInfo::getColorType() const
{
	return m_iColorType;
}

// Arrays

const TCHAR* CvYieldInfo::getSymbolPath(int i) const
{
	FAssertMsg(i < GC.getDefineINT("MAX_YIELD_STACK"), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paszSymbolPath ? m_paszSymbolPath[i] : -1;
}

bool CvYieldInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int iNumSibs, j;

	pXML->GetChildXmlValByName(&m_iHillsChange, "iHillsChange");
	pXML->GetChildXmlValByName(&m_iPeakChange, "iPeakChange");
	pXML->GetChildXmlValByName(&m_iLakeChange, "iLakeChange");
	pXML->GetChildXmlValByName(&m_iCityChange, "iCityChange");
	pXML->GetChildXmlValByName(&m_iPopulationChangeOffset, "iPopulationChangeOffset");
	pXML->GetChildXmlValByName(&m_iPopulationChangeDivisor, "iPopulationChangeDivisor");
	pXML->GetChildXmlValByName(&m_iMinCity, "iMinCity");
	pXML->GetChildXmlValByName(&m_iTradeModifier, "iTradeModifier");
	pXML->GetChildXmlValByName(&m_iGoldenAgeYield, "iGoldenAgeYield");
	pXML->GetChildXmlValByName(&m_iGoldenAgeYieldThreshold, "iGoldenAgeYieldThreshold");
	pXML->GetChildXmlValByName(&m_iAIWeightPercent, "iAIWeightPercent");

	pXML->GetChildXmlValByName(szTextVal, "ColorType");
	m_iColorType = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "SymbolPaths"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getDefineINT("MAX_YIELD_STACK")) ,"Allocating zero or less memory in SetGlobalYieldInfo");
			m_paszSymbolPath = new CvString[GC.getDefineINT("MAX_YIELD_STACK")];

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getDefineINT("MAX_YIELD_STACK")) ,"There are more siblings than memory allocated for them in SetGlobalYieldInfo");
					for (j=0;j<iNumSibs;j++)
					{
						m_paszSymbolPath[j] = szTextVal;
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		CvString cDefault = CvString::format("").GetCString();
		m_paszSymbolPath = new CvString[GC.getDefineINT("MAX_YIELD_STACK")];
		for ( int i = 0; i < GC.getDefineINT("MAX_YIELD_STACK"); i++)
		{
			m_paszSymbolPath[i] = cDefault;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvYieldInfo::copyNonDefaults(CvYieldInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getHillsChange()				== 0)			m_iHillsChange				= pClassInfo->getHillsChange();
	if (getPeakChange()					== 0)			m_iPeakChange				= pClassInfo->getPeakChange();
	if (getLakeChange()					== 0)			m_iLakeChange				= pClassInfo->getLakeChange();
	if (getCityChange()					== 0)			m_iCityChange				= pClassInfo->getCityChange();
	if (getPopulationChangeOffset()		== 0)			m_iPopulationChangeOffset	= pClassInfo->getPopulationChangeOffset();
	if (getPopulationChangeDivisor()	== 0)			m_iPopulationChangeDivisor	= pClassInfo->getPopulationChangeDivisor();
	if (getMinCity()					== 0)			m_iMinCity					= pClassInfo->getMinCity();
	if (getTradeModifier()				== 0)			m_iTradeModifier			= pClassInfo->getTradeModifier();
	if (getGoldenAgeYield()				== 0)			m_iGoldenAgeYield			= pClassInfo->getGoldenAgeYield();
	if (getGoldenAgeYieldThreshold()	== 0)			m_iGoldenAgeYieldThreshold	= pClassInfo->getGoldenAgeYieldThreshold();
	if (getAIWeightPercent()			== 0)			m_iAIWeightPercent			= pClassInfo->getAIWeightPercent();
	if (getColorType()					== NO_COLOR)	m_iColorType				= pClassInfo->getColorType();
	for ( int i = 0; i < GC.getDefineINT("MAX_YIELD_STACK"); i++)
	{
		if ( m_paszSymbolPath[i]		== cDefault)	m_paszSymbolPath[i]			= pClassInfo->getSymbolPath(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//FlavourMod: Addded by Jean Elcard (ClimateSystem)
CvTerrainClassInfo::CvTerrainClassInfo() :
m_iDefaultTemperature(-1),
m_iDefaultHumidity(-1),
m_iNaturalTerrain(NO_TERRAIN),
m_iHellTerrain(NO_TERRAIN)
{
}

CvTerrainClassInfo::~CvTerrainClassInfo()
{
}

int CvTerrainClassInfo::getDefaultTemperature() const
{
	return m_iDefaultTemperature;
}

int CvTerrainClassInfo::getDefaultHumidity() const
{
	return m_iDefaultHumidity;
}

int CvTerrainClassInfo::getNaturalTerrain() const
{
	return m_iNaturalTerrain;
}

int CvTerrainClassInfo::getHellTerrain() const
{
	return m_iHellTerrain;
}

bool CvTerrainClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvString szTextVal;

	pXML->GetChildXmlValByName(&m_iDefaultTemperature, "iDefaultTemperature");
	pXML->GetChildXmlValByName(&m_iDefaultHumidity, "iDefaultHumidity");

	pXML->GetChildXmlValByName(szTextVal, "NaturalTerrain");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "HellTerrain");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	return true;
}

bool CvTerrainClassInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 2)
	{
		FAssert(false);
		return false;
	}

	m_iNaturalTerrain = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_iHellTerrain = GC.getInfoTypeForString(m_aszExtraXMLforPass3[1]);
	m_aszExtraXMLforPass3.clear();

	return true;
}
// FlavourMod: End Add

//======================================================================================================
//					CvTerrainInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTerrainInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTerrainInfo::CvTerrainInfo() :
m_iMovementCost(0),
m_iSeeFromLevel(0),
m_iSeeThroughLevel(0),
m_iBuildModifier(0),
m_iDefenseModifier(0),
m_bWater(false),
m_bImpassable(false),
m_bFound(false),
m_bFoundCoast(false),
m_bFoundFreshWater(false),
m_bHell(false),
m_iWorldSoundscapeScriptId(0),
m_piYields(NULL),
m_piRiverYieldChange(NULL),
m_piHillsYieldChange(NULL),
m_pi3DAudioScriptFootstepIndex(NULL),

//FfH: Added By Kael 08/02/2007
m_bNormalize(false),
/*************************************************************************************************/
/**	CivPlotMods								03/23/09								Jean Elcard	**/
/**																								**/
/**			Obsolete FfH Code. Replaced with TerrainYieldChanges in CvCivilizationInfo.			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iCivilizationYieldType(NO_CIVILIZATION),
m_iPlotCounterDown(-1),
m_iTerrainDown(NO_TERRAIN),
m_iPlotCounterUp(-1),
m_iTerrainUp(NO_TERRAIN)
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	CivPlotMods								END													**/
/*************************************************************************************************/


//FlavourMod: Addded by Jean Elcard (ClimateSystem)
m_iTerrainClassType(NO_TERRAINCLASS)
//FlavourMod: End Add
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTerrainInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTerrainInfo::~CvTerrainInfo()
{
	SAFE_DELETE_ARRAY(m_piYields);
	SAFE_DELETE_ARRAY(m_piRiverYieldChange);
	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	SAFE_DELETE_ARRAY(m_pi3DAudioScriptFootstepIndex);

/*************************************************************************************************/
/**	CivPlotMods								03/23/09								Jean Elcard	**/
/**																								**/
/**			Obsolete FfH Code. Replaced with TerrainYieldChanges in CvCivilizationInfo.			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
//FfH: Added by Kael 09/18/2008
	SAFE_DELETE_ARRAY(m_piCivilizationYieldChange);
//FfH: End Add
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	CivPlotMods								END													**/
/*************************************************************************************************/

}

int CvTerrainInfo::getMovementCost() const
{
	return m_iMovementCost;
}

int CvTerrainInfo::getSeeFromLevel() const
{
	return m_iSeeFromLevel;
}

int CvTerrainInfo::getSeeThroughLevel() const
{
	return m_iSeeThroughLevel;
}

int CvTerrainInfo::getBuildModifier() const
{
	return m_iBuildModifier;
}

int CvTerrainInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

bool CvTerrainInfo::isWater() const
{
	return m_bWater;
}

bool CvTerrainInfo::isImpassable() const
{
	return m_bImpassable;
}

bool CvTerrainInfo::isFound() const
{
	return m_bFound;
}

bool CvTerrainInfo::isFoundCoast() const
{
	return m_bFoundCoast;
}

bool CvTerrainInfo::isFoundFreshWater() const
{
	return m_bFoundFreshWater;
}

bool CvTerrainInfo::isHell() const
{
	return m_bHell;
}

const TCHAR* CvTerrainInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvTerrainInfo::setArtDefineTag(const TCHAR* szTag)
{
	m_szArtDefineTag = szTag;
}

int CvTerrainInfo::getWorldSoundscapeScriptId() const
{
	return m_iWorldSoundscapeScriptId;
}

//FfH: Added by Kael 08/02/2007
bool CvTerrainInfo::isNormalize() const
{
	return m_bNormalize;
}

/*************************************************************************************************/
/**	CivPlotMods								03/23/09								Jean Elcard	**/
/**																								**/
/**			Obsolete FfH Code. Replaced with TerrainYieldChanges in CvCivilizationInfo.			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvTerrainInfo::getCivilizationYieldType() const
{
	return m_iCivilizationYieldType;
}

int CvTerrainInfo::getCivilizationYieldChange(int i) const
{
	return m_piCivilizationYieldChange ? m_piCivilizationYieldChange[i] : -1;
}

int CvTerrainInfo::getPlotCounterDown() const
{
	return m_iPlotCounterDown;
}

int CvTerrainInfo::getTerrainDown() const
{
	return m_iTerrainDown;
}

int CvTerrainInfo::getPlotCounterUp() const
{
	return m_iPlotCounterUp;
}

int CvTerrainInfo::getTerrainUp() const
{
	return m_iTerrainUp;
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	CivPlotMods								END													**/
/*************************************************************************************************/

//FfH: End Add

// Arrays

int CvTerrainInfo::getYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYields ? m_piYields[i] : -1;
}

int CvTerrainInfo::getRiverYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;
}

int CvTerrainInfo::getHillsYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;
}

int CvTerrainInfo::get3DAudioScriptFootstepIndex(int i) const
{
//	FAssertMsg(i < ?, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;
}

//FlavourMod: Added by Jean Elcard (ClimateSystem)
int CvTerrainInfo::getTerrainClassType() const
{
	return m_iTerrainClassType;
}
//FlavourMod: End Add

bool CvTerrainInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName( szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Yields"))
	{
		pXML->SetYields(&m_piYields);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYields, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverYieldChange"))
	{
		pXML->SetYields(&m_piRiverYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HillsYieldChange"))
	{
		pXML->SetYields(&m_piHillsYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piHillsYieldChange, NUM_YIELD_TYPES);
	}

	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(&m_bImpassable, "bImpassable");
	pXML->GetChildXmlValByName(&m_bFound, "bFound");
	pXML->GetChildXmlValByName(&m_bFoundCoast, "bFoundCoast");
	pXML->GetChildXmlValByName(&m_bFoundFreshWater, "bFoundFreshWater");
	pXML->GetChildXmlValByName(&m_bHell, "bHell");

	pXML->GetChildXmlValByName(&m_iMovementCost, "iMovement");
	pXML->GetChildXmlValByName(&m_iSeeFromLevel, "iSeeFrom");
	pXML->GetChildXmlValByName(&m_iSeeThroughLevel, "iSeeThrough");
	pXML->GetChildXmlValByName(&m_iBuildModifier, "iBuildModifier");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefense");

	pXML->SetVariableListTagPairForAudioScripts(&m_pi3DAudioScriptFootstepIndex, "FootstepSounds", GC.getFootstepAudioTypes(), GC.getNumFootstepAudioTypes());

	pXML->GetChildXmlValByName(szTextVal, "WorldSoundscapeAudioScript");
	if ( szTextVal.GetLength() > 0 )
		m_iWorldSoundscapeScriptId = gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_SOUNDSCAPE );
	else
		m_iWorldSoundscapeScriptId = -1;

//FfH: Added by Kael 08/02/2007
	pXML->GetChildXmlValByName(&m_bNormalize, "bNormalize");
/*************************************************************************************************/
/**	CivPlotMods								03/23/09								Jean Elcard	**/
/**																								**/
/**			Obsolete FfH Code. Replaced with TerrainYieldChanges in CvCivilizationInfo.			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(&m_iPlotCounterDown, "iPlotCounterDown");
	pXML->GetChildXmlValByName(&m_iPlotCounterUp, "iPlotCounterUp");
	pXML->GetChildXmlValByName(szTextVal, "CivilizationYieldType");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CivilizationYieldChange"))
	{
		pXML->SetYields(&m_piCivilizationYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCivilizationYieldChange, NUM_YIELD_TYPES);
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	CivPlotMods								END													**/
/*************************************************************************************************/
//FfH: End Add

//FlavourMod: Addded by Jean Elcard (ClimateSystem)
	pXML->GetChildXmlValByName(szTextVal, "TerrainClass");
	if (szTextVal != "") m_iTerrainClassType = pXML->FindInInfoClass(szTextVal);
//FlavourMod: End Add

	return true;
}

//FlavourMod: Disabled by Jean Elcard
/*
//FfH: Added by Kael 08/15/2007
bool CvTerrainInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	pXML->GetChildXmlValByName(szTextVal, "TerrainDown");
	m_iTerrainDown = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainUp");
	m_iTerrainUp = GC.getInfoTypeForString(szTextVal);

	return true;
}

/*************************************************************************************************/
/**	CivPlotMods								03/23/09								Jean Elcard	**/
/**																								**/
/**			Obsolete FfH Code. Replaced with TerrainYieldChanges in CvCivilizationInfo.			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvTerrainInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		return false;
	}
	m_iCivilizationYieldType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_aszExtraXMLforPass3.clear();
	return true;
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	CivPlotMods								END													**/
/*************************************************************************************************/
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTerrainInfo::copyNonDefaults(CvTerrainInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()						== cDefault)	setArtDefineTag(					pClassInfo->getArtDefineTag());
	//Must do Art Define before the Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isWater()								== false)			m_bWater							= pClassInfo->isWater();
	if (isImpassable()							== false)			m_bImpassable						= pClassInfo->isImpassable();
	if (isFound()								== false)			m_bFound							= pClassInfo->isFound();
	if (isFoundCoast()							== false)			m_bFoundCoast						= pClassInfo->isFoundCoast();
	if (isFoundFreshWater()						== false)			m_bFoundFreshWater					= pClassInfo->isFoundFreshWater();
	if (isNormalize()							== false)			m_bNormalize						= pClassInfo->isNormalize();
	if (isHell()								== false)			m_bHell								= pClassInfo->isHell();
	if (getMovementCost()						== 0)				m_iMovementCost						= pClassInfo->getMovementCost();
	if (getSeeFromLevel()						== 0)				m_iSeeFromLevel						= pClassInfo->getSeeFromLevel();
	if (getSeeThroughLevel()					== 0)				m_iSeeThroughLevel					= pClassInfo->getSeeThroughLevel();
	if (getBuildModifier()						== 0)				m_iBuildModifier					= pClassInfo->getBuildModifier();
	if (getDefenseModifier()					== 0) 				m_iDefenseModifier					= pClassInfo->getDefenseModifier();
	if (getWorldSoundscapeScriptId()			== -1) 				m_iWorldSoundscapeScriptId			= pClassInfo->getWorldSoundscapeScriptId();
	if (getTerrainClassType()					== NO_TERRAINCLASS) m_iTerrainClassType					= pClassInfo->getTerrainClassType();

	for (int i = 0; i < GC.getNumFootstepAudioTypes(); i++)
	{
		if (m_pi3DAudioScriptFootstepIndex[i]	== 0)			m_pi3DAudioScriptFootstepIndex[i]	= pClassInfo->get3DAudioScriptFootstepIndex(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_piYields[i]						== 0)			m_piYields[i]						= pClassInfo->getYield(i);
		if (m_piRiverYieldChange[i]				== 0)			m_piRiverYieldChange[i]				= pClassInfo->getRiverYieldChange(i);
		if (m_piHillsYieldChange[i]				== 0)			m_piHillsYieldChange[i]				= pClassInfo->getHillsYieldChange(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

const TCHAR* CvTerrainInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoTerrain * pTerrainArtInfo;
	pTerrainArtInfo = getArtInfo();
	if (pTerrainArtInfo != NULL)
	{
		return pTerrainArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

const CvArtInfoTerrain* CvTerrainInfo::getArtInfo() const
{
	return ARTFILEMGR.getTerrainArtInfo( getArtDefineTag());
}

//======================================================================================================
//					CvInterfaceModeInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvInterfaceModeInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvInterfaceModeInfo::CvInterfaceModeInfo() :
m_iCursorIndex(NO_CURSOR),
m_iMissionType(NO_MISSION),
m_bVisible(false),
m_bGotoPlot(false),
m_bHighlightPlot(false),
m_bSelectType(false),
m_bSelectAll(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvInterfaceModeInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvInterfaceModeInfo::~CvInterfaceModeInfo()
{
}

int CvInterfaceModeInfo::getCursorIndex() const
{
	return m_iCursorIndex;
}

int CvInterfaceModeInfo::getMissionType() const
{
	return m_iMissionType;
}

bool CvInterfaceModeInfo::getVisible() const
{
	return m_bVisible;
}

bool CvInterfaceModeInfo::getGotoPlot() const
{
	return m_bGotoPlot;
}

bool CvInterfaceModeInfo::getHighlightPlot() const
{
	return m_bHighlightPlot;
}

bool CvInterfaceModeInfo::getSelectType() const
{
	return m_bSelectType;
}

bool CvInterfaceModeInfo::getSelectAll() const
{
	return m_bSelectAll;
}

bool CvInterfaceModeInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "CursorType");
	m_iCursorIndex = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Mission");
	m_iMissionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");
	pXML->GetChildXmlValByName(&m_bGotoPlot, "bGotoPlot");
	pXML->GetChildXmlValByName(&m_bHighlightPlot, "bHighlightPlot");
	pXML->GetChildXmlValByName(&m_bSelectType, "bSelectType");
	pXML->GetChildXmlValByName(&m_bSelectAll, "bSelectAll");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvInterfaceModeInfo::copyNonDefaults(CvInterfaceModeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getCursorIndex()	== NO_CURSOR)	m_iCursorIndex		= pClassInfo->getCursorIndex();
	if (getMissionType()	== NO_MISSION)	m_iMissionType		= pClassInfo->getMissionType();
	if (getVisible()		== false)		m_bVisible			= pClassInfo->getVisible();
	if (getGotoPlot()		== false)		m_bGotoPlot			= pClassInfo->getGotoPlot();
	if (getHighlightPlot()	== false)		m_bHighlightPlot	= pClassInfo->getHighlightPlot();
	if (getSelectType()		== false)		m_bSelectType		= pClassInfo->getSelectType();
	if (getSelectAll()		== false)		m_bSelectAll		= pClassInfo->getSelectAll();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAdvisorInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAdvisorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAdvisorInfo::CvAdvisorInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAdvisorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAdvisorInfo::~CvAdvisorInfo()
{
}

const TCHAR* CvAdvisorInfo::getTexture() const
{
	return m_szTexture;
}

void CvAdvisorInfo::setTexture(const TCHAR* szVal)
{
	m_szTexture = szVal;
}

int CvAdvisorInfo::getNumCodes() const
{
	return m_vctEnableDisableCodes.size();
}

int CvAdvisorInfo::getEnableCode(uint uiCode) const
{
	FAssert( uiCode < m_vctEnableDisableCodes.size() );
	return m_vctEnableDisableCodes[uiCode].first;
}

int CvAdvisorInfo::getDisableCode(uint uiCode) const
{
	FAssert( uiCode < m_vctEnableDisableCodes.size() );
	return m_vctEnableDisableCodes[uiCode].second;
}

bool CvAdvisorInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Texture");
	setTexture( szTextVal );

	gDLL->getXMLIFace()->SetToChild( pXML->GetXML() );
	while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "EventCodes"))
	{
		int iEnableCode, iDisableCode;
		pXML->GetChildXmlValByName(&iEnableCode, "iEnableCode");
		pXML->GetChildXmlValByName(&iDisableCode, "iDisableCode");
		m_vctEnableDisableCodes.push_back( std::make_pair( iEnableCode, iDisableCode ));
	}
	gDLL->getXMLIFace()->SetToParent( pXML->GetXML() );

	return true;
}

//======================================================================================================
//					CvAlignmentAttitudeModifierInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAlignmentAttitudeModifierInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAlignmentAttitudeModifierInfo::CvAlignmentAttitudeModifierInfo() :
m_iToGood(0),
m_iToNeutral(0),
m_iToEvil(0)
{
}

int CvAlignmentAttitudeModifierInfo::getToGood() const
{
	return m_iToGood;
}

int CvAlignmentAttitudeModifierInfo::getToNeutral() const
{
	return m_iToNeutral;
}

int CvAlignmentAttitudeModifierInfo::getToEvil() const
{
	return m_iToEvil;
}

void CvAlignmentAttitudeModifierInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iToGood);
	stream->Read(&m_iToNeutral);
	stream->Read(&m_iToEvil);
}

void CvAlignmentAttitudeModifierInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iToGood);
	stream->Write(m_iToNeutral);
	stream->Write(m_iToEvil);
}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
//======================================================================================================
//					CvEthicalAlignmentAttitudeModifierInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvEthicalAlignmentAttitudeModifierInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvEthicalAlignmentAttitudeModifierInfo::CvEthicalAlignmentAttitudeModifierInfo() :
m_iToLawful(0),
m_iToEthicalNeutral(0),
m_iToChaotic(0)
{
}

int CvEthicalAlignmentAttitudeModifierInfo::getToLawful() const
{
	return m_iToLawful;
}

int CvEthicalAlignmentAttitudeModifierInfo::getToEthicalNeutral() const
{
	return m_iToEthicalNeutral;
}

int CvEthicalAlignmentAttitudeModifierInfo::getToChaotic() const
{
	return m_iToChaotic;
}

void CvEthicalAlignmentAttitudeModifierInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iToLawful);
	stream->Read(&m_iToEthicalNeutral);
	stream->Read(&m_iToChaotic);
}

void CvEthicalAlignmentAttitudeModifierInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iToLawful);
	stream->Write(m_iToEthicalNeutral);
	stream->Write(m_iToChaotic);
}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAdvisorInfo::copyNonDefaults(CvAdvisorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTexture()	== cDefault)	setTexture(			pClassInfo->getTexture());

	if (getNumCodes()	== 0)  //Only copy old values if the new doesn't hold a tag
	{
		for (int iI = 0; iI < pClassInfo->getNumCodes(); iI++)
		{
			int iEnableCode, iDisableCode;
			iEnableCode =									pClassInfo->getEnableCode(iI);
			iDisableCode =									pClassInfo->getDisableCode(iI);
										m_vctEnableDisableCodes.push_back( std::make_pair( iEnableCode, iDisableCode ));
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvLeaderHeadInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvLeaderHeadInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderHeadInfo::CvLeaderHeadInfo() :
m_iWonderConstructRand(0),
m_iBaseAttitude(0),
m_iBasePeaceWeight(0),
m_iPeaceWeightRand(0),
m_iWarmongerRespect(0),
m_iEspionageWeight(0),
m_iRefuseToTalkWarThreshold(0),
m_iNoTechTradeThreshold(0),
m_iTechTradeKnownPercent(0),
m_iMaxGoldTradePercent(0),
m_iMaxGoldPerTurnTradePercent(0),
m_iMaxWarRand(0),
m_iMaxWarNearbyPowerRatio(0),
m_iMaxWarDistantPowerRatio(0),
m_iMaxWarMinAdjacentLandPercent(0),
m_iLimitedWarRand(0),
m_iLimitedWarPowerRatio(0),
m_iDogpileWarRand(0),
m_iMakePeaceRand(0),
m_iDeclareWarTradeRand(0),
m_iDemandRebukedSneakProb(0),
m_iDemandRebukedWarProb(0),
m_iRazeCityProb(0),
m_iBuildUnitProb(0),
m_iBaseAttackOddsChange(0),
m_iAttackOddsChangeRand(0),
m_iWorseRankDifferenceAttitudeChange(0),
m_iBetterRankDifferenceAttitudeChange(0),
m_iCloseBordersAttitudeChange(0),
m_iLostWarAttitudeChange(0),
m_iAtWarAttitudeDivisor(0),
m_iAtWarAttitudeChangeLimit(0),
m_iAtPeaceAttitudeDivisor(0),
m_iAtPeaceAttitudeChangeLimit(0),
m_iSameReligionAttitudeChange(0),
m_iSameReligionAttitudeDivisor(0),
m_iSameReligionAttitudeChangeLimit(0),
m_iDifferentReligionAttitudeChange(0),
m_iDifferentReligionAttitudeDivisor(0),
m_iDifferentReligionAttitudeChangeLimit(0),
m_iBonusTradeAttitudeDivisor(0),
m_iBonusTradeAttitudeChangeLimit(0),
m_iOpenBordersAttitudeDivisor(0),
m_iOpenBordersAttitudeChangeLimit(0),
m_iDefensivePactAttitudeDivisor(0),
m_iDefensivePactAttitudeChangeLimit(0),
m_iShareWarAttitudeChange(0),
m_iShareWarAttitudeDivisor(0),
m_iShareWarAttitudeChangeLimit(0),
m_iFavoriteCivicAttitudeChange(0),
m_iFavoriteCivicAttitudeDivisor(0),
m_iFavoriteCivicAttitudeChangeLimit(0),
m_iDemandTributeAttitudeThreshold(NO_ATTITUDE),
m_iNoGiveHelpAttitudeThreshold(NO_ATTITUDE),
m_iTechRefuseAttitudeThreshold(NO_ATTITUDE),
m_iStrategicBonusRefuseAttitudeThreshold(NO_ATTITUDE),
m_iHappinessBonusRefuseAttitudeThreshold(NO_ATTITUDE),
m_iHealthBonusRefuseAttitudeThreshold(NO_ATTITUDE),
m_iMapRefuseAttitudeThreshold(NO_ATTITUDE),
m_iDeclareWarRefuseAttitudeThreshold(NO_ATTITUDE),
m_iDeclareWarThemRefuseAttitudeThreshold(NO_ATTITUDE),
m_iStopTradingRefuseAttitudeThreshold(NO_ATTITUDE),
m_iStopTradingThemRefuseAttitudeThreshold(NO_ATTITUDE),
m_iAdoptCivicRefuseAttitudeThreshold(NO_ATTITUDE),
m_iConvertReligionRefuseAttitudeThreshold(NO_ATTITUDE),
m_iOpenBordersRefuseAttitudeThreshold(NO_ATTITUDE),
m_iDefensivePactRefuseAttitudeThreshold(NO_ATTITUDE),
m_iPermanentAllianceRefuseAttitudeThreshold(NO_ATTITUDE),
m_iVassalRefuseAttitudeThreshold(NO_ATTITUDE),
m_iVassalPowerModifier(0),
m_iFreedomAppreciation(0),
m_iFavoriteCivic(NO_CIVIC),
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iFavoriteReligion(NO_RELIGION),
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
m_pbTraits(NULL),
m_piFlavorValue(NULL),
m_piContactRand(NULL),
m_piContactDelay(NULL),
m_piMemoryDecayRand(NULL),
m_piMemoryAttitudePercent(NULL),
m_piNoWarAttitudeProb(NULL),
m_piUnitAIWeightModifier(NULL),
m_piImprovementWeightModifier(NULL),
m_piDiploPeaceIntroMusicScriptIds(NULL),
m_piDiploPeaceMusicScriptIds(NULL),
m_piDiploWarIntroMusicScriptIds(NULL),
m_piDiploWarMusicScriptIds(NULL),

/*************************************************************************************************/
/**	New Tag Defs	(LeaderInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iEthicalAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iProximityMemoryDecayDelay(0),
m_iProximityMemoryDecayRand(0),
m_iProximityMemoryLimit(0),
m_fProximityMemoryDecaySpeed(0.0f),
m_szDefeatQuote(NULL),
m_szImage(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Added by Kael 08/07/2007
m_piReligionWeightModifier(NULL),
m_bFemale(false),
m_iAlignment(NO_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iEthicalAlignment(NO_ETHICAL_ALIGNMENT),
m_bTrueNeutral(false),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
/*************************************************************************************************/
m_iLeaderClass(NO_LEADERCLASS),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_iAttitudeBadBonus(0),
m_iAttitudeCompassionHigh(0),
m_iAttitudeCompassionLow(0),
m_iAttitudeFromFemales(0),
m_iAttitudeFromMales(0),
m_iAttitudeToFemales(0),
m_iAttitudeToMales(0),

//FfH Card Game: Added by Sto 08/08/2008
m_iSomniumAggressiveness(0),
//FfH: End Add
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iFavoriteTech(NO_TECH),
m_iFavoriteUnitCombat(NO_UNITCOMBAT),
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
m_iFavoriteWonder(NO_BUILDING),
m_iPermanentTrait(NO_TRAIT)
//FfH: End Add

/*************************************************************************************************/
/** BonusAttitudeModifier           Opera   30/07/09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
,m_piBonusAttitudeModifier(NULL)
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** AlignmentAttitudeModifier       Opera   13.09.09         imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
,m_paAlignmentAttitudeModifier(NULL)
/*************************************************************************************************/
/** AlignmentAttitudeModifier                   END                                             **/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
,m_paEthicalAlignmentAttitudeModifier(NULL)
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
,m_piAIVictoryTypes(NULL)
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvLeaderHeadInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderHeadInfo::~CvLeaderHeadInfo()
{
	SAFE_DELETE_ARRAY(m_pbTraits);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piContactRand);
	SAFE_DELETE_ARRAY(m_piContactDelay);
	SAFE_DELETE_ARRAY(m_piMemoryDecayRand);
	SAFE_DELETE_ARRAY(m_piMemoryAttitudePercent);
	SAFE_DELETE_ARRAY(m_piNoWarAttitudeProb);
	SAFE_DELETE_ARRAY(m_piUnitAIWeightModifier);
	SAFE_DELETE_ARRAY(m_piImprovementWeightModifier);
	SAFE_DELETE_ARRAY(m_piDiploPeaceIntroMusicScriptIds);
	SAFE_DELETE_ARRAY(m_piDiploPeaceMusicScriptIds);
	SAFE_DELETE_ARRAY(m_piDiploWarIntroMusicScriptIds);
	SAFE_DELETE_ARRAY(m_piDiploWarMusicScriptIds);

//FfH: Added by Kael 09/29/2007
	SAFE_DELETE_ARRAY(m_piReligionWeightModifier);
//FfH: End Add

/*************************************************************************************************/
/** BonusWeightModifier             Opera   30.07.09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piBonusAttitudeModifier);
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** AlignmentAttitudeModifier       Opera   13.09.09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	if (m_paAlignmentAttitudeModifier != NULL)
	{
		SAFE_DELETE_ARRAY(m_paAlignmentAttitudeModifier);
	}
/*************************************************************************************************/
/** AlignmentAttitudeModifier                   END                                             **/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (m_paEthicalAlignmentAttitudeModifier != NULL)
	{
		SAFE_DELETE_ARRAY(m_paEthicalAlignmentAttitudeModifier);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAIVictoryTypes);
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
}

const TCHAR* CvLeaderHeadInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoLeaderhead * pLeaderheadArtInfo;
	pLeaderheadArtInfo = getArtInfo();
	if (pLeaderheadArtInfo != NULL)
	{
		return pLeaderheadArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

int CvLeaderHeadInfo::getWonderConstructRand() const
{
	return m_iWonderConstructRand;
}

int CvLeaderHeadInfo::getBaseAttitude() const
{
	return m_iBaseAttitude;
}

int CvLeaderHeadInfo::getBasePeaceWeight() const
{
	return m_iBasePeaceWeight;
}

int CvLeaderHeadInfo::getPeaceWeightRand() const
{
	return m_iPeaceWeightRand;
}

int CvLeaderHeadInfo::getWarmongerRespect() const
{
	return m_iWarmongerRespect;
}

int CvLeaderHeadInfo::getEspionageWeight() const
{
	return m_iEspionageWeight;
}

int CvLeaderHeadInfo::getRefuseToTalkWarThreshold() const
{
	return m_iRefuseToTalkWarThreshold;
}

int CvLeaderHeadInfo::getNoTechTradeThreshold() const
{
	return m_iNoTechTradeThreshold;
}

int CvLeaderHeadInfo::getTechTradeKnownPercent() const
{
	return m_iTechTradeKnownPercent;
}

int CvLeaderHeadInfo::getMaxGoldTradePercent() const
{
	return m_iMaxGoldTradePercent;
}

int CvLeaderHeadInfo::getMaxGoldPerTurnTradePercent() const
{
	return m_iMaxGoldPerTurnTradePercent;
}

int CvLeaderHeadInfo::getMaxWarRand() const
{
	return m_iMaxWarRand;
}

int CvLeaderHeadInfo::getMaxWarNearbyPowerRatio() const
{
	return m_iMaxWarNearbyPowerRatio;
}

int CvLeaderHeadInfo::getMaxWarDistantPowerRatio() const
{
	return m_iMaxWarDistantPowerRatio;
}

int CvLeaderHeadInfo::getMaxWarMinAdjacentLandPercent() const
{
	return m_iMaxWarMinAdjacentLandPercent;
}

int CvLeaderHeadInfo::getLimitedWarRand() const
{
	return m_iLimitedWarRand;
}

int CvLeaderHeadInfo::getLimitedWarPowerRatio() const
{
	return m_iLimitedWarPowerRatio;
}

int CvLeaderHeadInfo::getDogpileWarRand() const
{
	return m_iDogpileWarRand;
}

int CvLeaderHeadInfo::getMakePeaceRand() const
{
	return m_iMakePeaceRand;
}

int CvLeaderHeadInfo::getDeclareWarTradeRand() const
{
	return m_iDeclareWarTradeRand;
}

int CvLeaderHeadInfo::getDemandRebukedSneakProb() const
{
	return m_iDemandRebukedSneakProb;
}

int CvLeaderHeadInfo::getDemandRebukedWarProb() const
{
	return m_iDemandRebukedWarProb;
}

int CvLeaderHeadInfo::getRazeCityProb() const
{
	return m_iRazeCityProb;
}

int CvLeaderHeadInfo::getBuildUnitProb() const
{
	return m_iBuildUnitProb;
}

int CvLeaderHeadInfo::getBaseAttackOddsChange() const
{
	return m_iBaseAttackOddsChange;
}

int CvLeaderHeadInfo::getAttackOddsChangeRand() const
{
	return m_iAttackOddsChangeRand;
}

int CvLeaderHeadInfo::getWorseRankDifferenceAttitudeChange() const
{
	return m_iWorseRankDifferenceAttitudeChange;
}

int CvLeaderHeadInfo::getBetterRankDifferenceAttitudeChange() const
{
	return m_iBetterRankDifferenceAttitudeChange;
}

int CvLeaderHeadInfo::getCloseBordersAttitudeChange() const
{
	return m_iCloseBordersAttitudeChange;
}

int CvLeaderHeadInfo::getLostWarAttitudeChange() const
{
	return m_iLostWarAttitudeChange;
}

int CvLeaderHeadInfo::getAtWarAttitudeDivisor() const
{
	return m_iAtWarAttitudeDivisor;
}

int CvLeaderHeadInfo::getAtWarAttitudeChangeLimit() const
{
	return m_iAtWarAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getAtPeaceAttitudeDivisor() const
{
	return m_iAtPeaceAttitudeDivisor;
}

int CvLeaderHeadInfo::getAtPeaceAttitudeChangeLimit() const
{
	return m_iAtPeaceAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getSameReligionAttitudeChange() const
{
	return m_iSameReligionAttitudeChange;
}

int CvLeaderHeadInfo::getSameReligionAttitudeDivisor() const
{
	return m_iSameReligionAttitudeDivisor;
}

int CvLeaderHeadInfo::getSameReligionAttitudeChangeLimit() const
{
	return m_iSameReligionAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getDifferentReligionAttitudeChange() const
{
	return m_iDifferentReligionAttitudeChange;
}

int CvLeaderHeadInfo::getDifferentReligionAttitudeDivisor() const
{
	return m_iDifferentReligionAttitudeDivisor;
}

int CvLeaderHeadInfo::getDifferentReligionAttitudeChangeLimit() const
{
	return m_iDifferentReligionAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getBonusTradeAttitudeDivisor() const
{
	return m_iBonusTradeAttitudeDivisor;
}

int CvLeaderHeadInfo::getBonusTradeAttitudeChangeLimit() const
{
	return m_iBonusTradeAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getOpenBordersAttitudeDivisor() const
{
	return m_iOpenBordersAttitudeDivisor;
}

int CvLeaderHeadInfo::getOpenBordersAttitudeChangeLimit() const
{
	return m_iOpenBordersAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getDefensivePactAttitudeDivisor() const
{
	return m_iDefensivePactAttitudeDivisor;
}

int CvLeaderHeadInfo::getDefensivePactAttitudeChangeLimit() const
{
	return m_iDefensivePactAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getShareWarAttitudeChange() const
{
	return m_iShareWarAttitudeChange;
}

int CvLeaderHeadInfo::getShareWarAttitudeDivisor() const
{
	return m_iShareWarAttitudeDivisor;
}

int CvLeaderHeadInfo::getShareWarAttitudeChangeLimit() const
{
	return m_iShareWarAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getFavoriteCivicAttitudeChange() const
{
	return m_iFavoriteCivicAttitudeChange;
}

int CvLeaderHeadInfo::getFavoriteCivicAttitudeDivisor() const
{
	return m_iFavoriteCivicAttitudeDivisor;
}

int CvLeaderHeadInfo::getFavoriteCivicAttitudeChangeLimit() const
{
	return m_iFavoriteCivicAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getDemandTributeAttitudeThreshold() const
{
	return m_iDemandTributeAttitudeThreshold;
}

int CvLeaderHeadInfo::getNoGiveHelpAttitudeThreshold() const
{
	return m_iNoGiveHelpAttitudeThreshold;
}

int CvLeaderHeadInfo::getTechRefuseAttitudeThreshold() const
{
	return m_iTechRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getStrategicBonusRefuseAttitudeThreshold() const
{
	return m_iStrategicBonusRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getHappinessBonusRefuseAttitudeThreshold() const
{
	return m_iHappinessBonusRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getHealthBonusRefuseAttitudeThreshold() const
{
	return m_iHealthBonusRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getMapRefuseAttitudeThreshold() const
{
	return m_iMapRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getDeclareWarRefuseAttitudeThreshold() const
{
	return m_iDeclareWarRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getDeclareWarThemRefuseAttitudeThreshold() const
{
	return m_iDeclareWarThemRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getStopTradingRefuseAttitudeThreshold() const
{
	return m_iStopTradingRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getStopTradingThemRefuseAttitudeThreshold() const
{
	return m_iStopTradingThemRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getAdoptCivicRefuseAttitudeThreshold() const
{
	return m_iAdoptCivicRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getConvertReligionRefuseAttitudeThreshold() const
{
	return m_iConvertReligionRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getOpenBordersRefuseAttitudeThreshold() const
{
	return m_iOpenBordersRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getDefensivePactRefuseAttitudeThreshold() const
{
	return m_iDefensivePactRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getPermanentAllianceRefuseAttitudeThreshold() const
{
	return m_iPermanentAllianceRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getVassalRefuseAttitudeThreshold() const
{
	return m_iVassalRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getVassalPowerModifier() const
{
	return m_iVassalPowerModifier;
}

int CvLeaderHeadInfo::getFavoriteCivic() const
{
	return m_iFavoriteCivic;
}

int CvLeaderHeadInfo::getFreedomAppreciation() const
{
	return m_iFreedomAppreciation;
}

const TCHAR* CvLeaderHeadInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvLeaderHeadInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

/*************************************************************************************************/
/**	New Tag Defs	(LeaderInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/

int CvLeaderHeadInfo::getProximityMemoryDecayDelay() const      {return m_iProximityMemoryDecayDelay;}
int CvLeaderHeadInfo::getProximityMemoryDecayRand() const       {return m_iProximityMemoryDecayRand;}
int CvLeaderHeadInfo::getProximityMemoryLimit() const           {return m_iProximityMemoryLimit;}
float CvLeaderHeadInfo::getProximityMemoryDecaySpeed() const    {return m_fProximityMemoryDecaySpeed;}
const TCHAR *CvLeaderHeadInfo::getDefeatQuote() const           {return m_szDefeatQuote;}
const TCHAR* CvLeaderHeadInfo::getImage() const                 {return m_szImage;}

/*************************************************************************************************/
/** Alignment (good/bad) Kael 08/07/2007                                                        **/
/*************************************************************************************************/
int CvLeaderHeadInfo::getAlignment() const                      {return m_iAlignment;}
int CvLeaderHeadInfo::getAlignmentModifier() const              {return m_iAlignmentModifier;}
/*************************************************************************************************/
/** Alignment (good/bad) Kael 08/07/2007                                                    END **/
/*************************************************************************************************/

/*************************************************************************************************/
/** Ethical alignment (lawful/chaotic) Valkrionn 11/06/09                                       **/
/*************************************************************************************************/
int CvLeaderHeadInfo::getEthicalAlignment() const               {return m_iEthicalAlignment;}
int CvLeaderHeadInfo::getEthicalAlignmentModifier() const       {return m_iEthicalAlignmentModifier;}
/*************************************************************************************************/
/** Ethical alignment (lawful/chaotic) Valkrionn 11/06/09                                   END **/
/*************************************************************************************************/

bool CvLeaderHeadInfo::isTrueNeutral() const                    {return m_bTrueNeutral;}

/*************************************************************************************************/
/**	LeaderStatus Infos      Valkrionn 10/02/09                                                  **/
/*************************************************************************************************/
int CvLeaderHeadInfo::getLeaderClass() const                   {return m_iLeaderClass;}
/*************************************************************************************************/
/**	LeaderStatus Infos      Valkrionn 10/02/09                                              END **/
/*************************************************************************************************/

int CvLeaderHeadInfo::getAttitudeBadBonus() const
{
	return m_iAttitudeBadBonus;
}

int CvLeaderHeadInfo::getAttitudeCompassionHigh() const
{
	return m_iAttitudeCompassionHigh;
}

int CvLeaderHeadInfo::getAttitudeCompassionLow() const
{
	return m_iAttitudeCompassionLow;
}

int CvLeaderHeadInfo::getAttitudeFromFemales() const
{
	return m_iAttitudeFromFemales;
}

int CvLeaderHeadInfo::getAttitudeFromMales() const
{
	return m_iAttitudeFromMales;
}

int CvLeaderHeadInfo::getAttitudeToFemales() const
{
	return m_iAttitudeToFemales;
}

int CvLeaderHeadInfo::getAttitudeToMales() const
{
	return m_iAttitudeToMales;
}

//FfH Card Game: Added by Sto 08/08/2008
int CvLeaderHeadInfo::getSomniumAggressiveness() const
{
	return m_iSomniumAggressiveness;
}
//FfH: End Add
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvLeaderHeadInfo::getFavoriteTech() const
{
	return m_iFavoriteTech;
}

int CvLeaderHeadInfo::getFavoriteUnitCombat() const
{
	return m_iFavoriteUnitCombat;
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
int CvLeaderHeadInfo::getFavoriteWonder() const
{
	return m_iFavoriteWonder;
}

int CvLeaderHeadInfo::getPermanentTrait() const
{
	return m_iPermanentTrait;
}

/*************************************************************************************************/
/** HatedCivic		Opera		31.05.09        imported by Valkrionn	09.26.09                **/
/*************************************************************************************************/
int CvLeaderHeadInfo::getHatedCivicAttitudeChange() const
{
	return m_iHatedCivicAttitudeChange;
}

int CvLeaderHeadInfo::getHatedCivicAttitudeDivisor() const
{
	return m_iHatedCivicAttitudeDivisor;
}

int CvLeaderHeadInfo::getHatedCivicAttitudeChangeLimit() const
{
	return m_iHatedCivicAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getHatedCivic() const
{
	return m_iHatedCivic;
}
/*************************************************************************************************/
/** End																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
int CvLeaderHeadInfo::getAIVictoryWeight(int i) const
{
	FAssertMsg(i < NUM_AI_VICTORY_WEIGHT, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAIVictoryTypes ? m_piAIVictoryTypes[i] : 0;
}
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/

int CvLeaderHeadInfo::getReligionWeightModifier(int i) const
{
	FAssertMsg(i < GC.getNumReligionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piReligionWeightModifier ? m_piReligionWeightModifier[i] : -1;
}

bool CvLeaderHeadInfo::isFemale() const
{
	return m_bFemale;
}
//FfH: End Add

// Arrays

bool CvLeaderHeadInfo::hasTrait(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTraits ? m_pbTraits[i] : false;
}

int CvLeaderHeadInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvLeaderHeadInfo::getContactRand(int i) const
{
	FAssertMsg(i < NUM_CONTACT_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piContactRand ? m_piContactRand[i] : -1;
}

int CvLeaderHeadInfo::getContactDelay(int i) const
{
	FAssertMsg(i < NUM_CONTACT_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piContactDelay ? m_piContactDelay[i] : -1;
}

int CvLeaderHeadInfo::getMemoryDecayRand(int i) const
{
	FAssertMsg(i < NUM_MEMORY_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piMemoryDecayRand ? m_piMemoryDecayRand[i] : -1;
}

int CvLeaderHeadInfo::getMemoryAttitudePercent(int i) const
{
	FAssertMsg(i < NUM_MEMORY_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piMemoryAttitudePercent ? m_piMemoryAttitudePercent[i] : -1;
}

int CvLeaderHeadInfo::getNoWarAttitudeProb(int i) const
{
	FAssertMsg(i < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piNoWarAttitudeProb ? m_piNoWarAttitudeProb[i] : -1;
}

int CvLeaderHeadInfo::getUnitAIWeightModifier(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitAIWeightModifier ? m_piUnitAIWeightModifier[i] : -1;
}

int CvLeaderHeadInfo::getImprovementWeightModifier(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piImprovementWeightModifier ? m_piImprovementWeightModifier[i] : -1;
}

int CvLeaderHeadInfo::getDiploPeaceIntroMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploPeaceIntroMusicScriptIds ? m_piDiploPeaceIntroMusicScriptIds[i] : -1;
}

int CvLeaderHeadInfo::getDiploPeaceMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploPeaceMusicScriptIds ? m_piDiploPeaceMusicScriptIds[i] : -1;
}

int CvLeaderHeadInfo::getDiploWarIntroMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploWarIntroMusicScriptIds ? m_piDiploWarIntroMusicScriptIds[i] : -1;
}

int CvLeaderHeadInfo::getDiploWarMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploWarMusicScriptIds ? m_piDiploWarMusicScriptIds[i] : -1;
}

/*************************************************************************************************/
/** BonusAttitudeModifier           Opera   30.07.09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
int CvLeaderHeadInfo::getBonusAttitudeModifier(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusAttitudeModifier ? m_piBonusAttitudeModifier[i] : -1;
}
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** AlignmentAttitudeModifier       Opera   13.09.09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
int CvLeaderHeadInfo::getAlignmentAttitudeModifierToGood(int i) const
{
	FAssertMsg(i < GC.getNumAlignmentInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paAlignmentAttitudeModifier[i].m_iToGood;
}

int CvLeaderHeadInfo::getAlignmentAttitudeModifierToNeutral(int i) const
{
	FAssertMsg(i < GC.getNumAlignmentInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paAlignmentAttitudeModifier[i].m_iToNeutral;
}

int CvLeaderHeadInfo::getAlignmentAttitudeModifierToEvil(int i) const
{
	FAssertMsg(i < GC.getNumAlignmentInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paAlignmentAttitudeModifier[i].m_iToEvil;
}
/*************************************************************************************************/
/** AlignmentAttitudeModifier       END                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvLeaderHeadInfo::getEthicalAlignmentAttitudeModifierToLawful(int i) const
{
	FAssertMsg(i < GC.getNumEthicalAlignmentInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paEthicalAlignmentAttitudeModifier[i].m_iToLawful;
}

int CvLeaderHeadInfo::getEthicalAlignmentAttitudeModifierToEthicalNeutral(int i) const
{
	FAssertMsg(i < GC.getNumEthicalAlignmentInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paEthicalAlignmentAttitudeModifier[i].m_iToEthicalNeutral;
}

int CvLeaderHeadInfo::getEthicalAlignmentAttitudeModifierToChaotic(int i) const
{
	FAssertMsg(i < GC.getNumEthicalAlignmentInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paEthicalAlignmentAttitudeModifier[i].m_iToChaotic;
}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

const TCHAR* CvLeaderHeadInfo::getLeaderHead() const
{
	const CvArtInfoLeaderhead * pLeaderheadArtInfo;
	pLeaderheadArtInfo = getArtInfo();
	if (pLeaderheadArtInfo != NULL)
	{
		return pLeaderheadArtInfo->getNIF();
	}
	else
	{
		return NULL;
	}
}

void CvLeaderHeadInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iWonderConstructRand);
	stream->Read(&m_iBaseAttitude);
	stream->Read(&m_iBasePeaceWeight);
	stream->Read(&m_iPeaceWeightRand);
	stream->Read(&m_iWarmongerRespect);
	stream->Read(&m_iEspionageWeight);
	stream->Read(&m_iRefuseToTalkWarThreshold);
	stream->Read(&m_iNoTechTradeThreshold);
	stream->Read(&m_iTechTradeKnownPercent);
	stream->Read(&m_iMaxGoldTradePercent);
	stream->Read(&m_iMaxGoldPerTurnTradePercent);
	stream->Read(&m_iMaxWarRand);
	stream->Read(&m_iMaxWarNearbyPowerRatio);
	stream->Read(&m_iMaxWarDistantPowerRatio);
	stream->Read(&m_iMaxWarMinAdjacentLandPercent);
	stream->Read(&m_iLimitedWarRand);
	stream->Read(&m_iLimitedWarPowerRatio);
	stream->Read(&m_iDogpileWarRand);
	stream->Read(&m_iMakePeaceRand);
	stream->Read(&m_iDeclareWarTradeRand);
	stream->Read(&m_iDemandRebukedSneakProb);
	stream->Read(&m_iDemandRebukedWarProb);
	stream->Read(&m_iRazeCityProb);
	stream->Read(&m_iBuildUnitProb);
	stream->Read(&m_iBaseAttackOddsChange);
	stream->Read(&m_iAttackOddsChangeRand);
	stream->Read(&m_iWorseRankDifferenceAttitudeChange);
	stream->Read(&m_iBetterRankDifferenceAttitudeChange);
	stream->Read(&m_iCloseBordersAttitudeChange);
	stream->Read(&m_iLostWarAttitudeChange);
	stream->Read(&m_iAtWarAttitudeDivisor);
	stream->Read(&m_iAtWarAttitudeChangeLimit);
	stream->Read(&m_iAtPeaceAttitudeDivisor);
	stream->Read(&m_iAtPeaceAttitudeChangeLimit);
	stream->Read(&m_iSameReligionAttitudeChange);
	stream->Read(&m_iSameReligionAttitudeDivisor);
	stream->Read(&m_iSameReligionAttitudeChangeLimit);
	stream->Read(&m_iDifferentReligionAttitudeChange);
	stream->Read(&m_iDifferentReligionAttitudeDivisor);
	stream->Read(&m_iDifferentReligionAttitudeChangeLimit);
	stream->Read(&m_iBonusTradeAttitudeDivisor);
	stream->Read(&m_iBonusTradeAttitudeChangeLimit);
	stream->Read(&m_iOpenBordersAttitudeDivisor);
	stream->Read(&m_iOpenBordersAttitudeChangeLimit);
	stream->Read(&m_iDefensivePactAttitudeDivisor);
	stream->Read(&m_iDefensivePactAttitudeChangeLimit);
	stream->Read(&m_iShareWarAttitudeChange);
	stream->Read(&m_iShareWarAttitudeDivisor);
	stream->Read(&m_iShareWarAttitudeChangeLimit);
	stream->Read(&m_iFavoriteCivicAttitudeChange);
	stream->Read(&m_iFavoriteCivicAttitudeDivisor);
	stream->Read(&m_iFavoriteCivicAttitudeChangeLimit);
	stream->Read(&m_iDemandTributeAttitudeThreshold);
	stream->Read(&m_iNoGiveHelpAttitudeThreshold);
	stream->Read(&m_iTechRefuseAttitudeThreshold);
	stream->Read(&m_iStrategicBonusRefuseAttitudeThreshold);
	stream->Read(&m_iHappinessBonusRefuseAttitudeThreshold);
	stream->Read(&m_iHealthBonusRefuseAttitudeThreshold);
	stream->Read(&m_iMapRefuseAttitudeThreshold);
	stream->Read(&m_iDeclareWarRefuseAttitudeThreshold);
	stream->Read(&m_iDeclareWarThemRefuseAttitudeThreshold);
	stream->Read(&m_iStopTradingRefuseAttitudeThreshold);
	stream->Read(&m_iStopTradingThemRefuseAttitudeThreshold);
	stream->Read(&m_iAdoptCivicRefuseAttitudeThreshold);
	stream->Read(&m_iConvertReligionRefuseAttitudeThreshold);
	stream->Read(&m_iOpenBordersRefuseAttitudeThreshold);
	stream->Read(&m_iDefensivePactRefuseAttitudeThreshold);
	stream->Read(&m_iPermanentAllianceRefuseAttitudeThreshold);
	stream->Read(&m_iVassalRefuseAttitudeThreshold);
	stream->Read(&m_iVassalPowerModifier);
	stream->Read(&m_iFreedomAppreciation);
	stream->Read(&m_iFavoriteCivic);
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iFavoriteReligion);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAIVictoryTypes);
	m_piAIVictoryTypes = new int[GC.getNumAIVictoryTypes()];
	stream->Read(GC.getNumAIVictoryTypes(), m_piAIVictoryTypes);
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
	stream->ReadString(m_szArtDefineTag);

/*************************************************************************************************/
/**	New Tag Defs	(LeaderInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iEthicalAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iProximityMemoryDecayDelay);
	stream->Read(&m_iProximityMemoryDecayRand);
	stream->Read(&m_iProximityMemoryLimit);
	stream->Read(&m_fProximityMemoryDecaySpeed);
	stream->ReadString(m_szDefeatQuote);
	stream->ReadString(m_szImage);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

//FfH: Added by Kael 08/07/2007
	stream->Read(&m_bFemale);
	stream->Read(&m_iAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iEthicalAlignment);
	stream->Read(&m_bTrueNeutral);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
/*************************************************************************************************/
	stream->Read(&m_iLeaderClass);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	stream->Read(&m_iAttitudeBadBonus);
	stream->Read(&m_iAttitudeCompassionHigh);
	stream->Read(&m_iAttitudeCompassionLow);
	stream->Read(&m_iAttitudeFromFemales);
	stream->Read(&m_iAttitudeFromMales);
	stream->Read(&m_iAttitudeToFemales);
	stream->Read(&m_iAttitudeToMales);

//FfH Card Game: Added by Sto 08/08/2008
	stream->Read(&m_iSomniumAggressiveness);
//FfH: End Add
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Read(&m_iFavoriteTech);
	stream->Read(&m_iFavoriteUnitCombat);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	stream->Read(&m_iFavoriteWonder);
	stream->Read(&m_iPermanentTrait);

/*************************************************************************************************/
/** HatedCivic		Opera		31.05.09        imported by Valkrionn	09.26.09        		**/
/*************************************************************************************************/
	stream->Read(&m_iHatedCivicAttitudeChange);
	stream->Read(&m_iHatedCivicAttitudeDivisor);
	stream->Read(&m_iHatedCivicAttitudeChangeLimit);
	stream->Read(&m_iHatedCivic);
/*************************************************************************************************/
/** End 																						**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piReligionWeightModifier);
	m_piReligionWeightModifier = new int[GC.getNumReligionInfos()];
	stream->Read(GC.getNumReligionInfos(), m_piReligionWeightModifier);
//FfH: End Add

	// Arrays

	SAFE_DELETE_ARRAY(m_pbTraits);
	m_pbTraits = new bool[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_pbTraits);

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piContactRand);
	m_piContactRand = new int[NUM_CONTACT_TYPES];
	stream->Read(NUM_CONTACT_TYPES, m_piContactRand);

	SAFE_DELETE_ARRAY(m_piContactDelay);
	m_piContactDelay = new int[NUM_CONTACT_TYPES];
	stream->Read(NUM_CONTACT_TYPES, m_piContactDelay);

	SAFE_DELETE_ARRAY(m_piMemoryDecayRand);
	m_piMemoryDecayRand = new int[NUM_MEMORY_TYPES];
	stream->Read(NUM_MEMORY_TYPES, m_piMemoryDecayRand);

	SAFE_DELETE_ARRAY(m_piMemoryAttitudePercent);
	m_piMemoryAttitudePercent = new int[NUM_MEMORY_TYPES];
	stream->Read(NUM_MEMORY_TYPES, m_piMemoryAttitudePercent);

	SAFE_DELETE_ARRAY(m_piNoWarAttitudeProb);
	m_piNoWarAttitudeProb = new int[NUM_ATTITUDE_TYPES];
	stream->Read(NUM_ATTITUDE_TYPES, m_piNoWarAttitudeProb);

	SAFE_DELETE_ARRAY(m_piUnitAIWeightModifier);
	m_piUnitAIWeightModifier = new int[NUM_UNITAI_TYPES];
	stream->Read(NUM_UNITAI_TYPES, m_piUnitAIWeightModifier);

	SAFE_DELETE_ARRAY(m_piImprovementWeightModifier);
	m_piImprovementWeightModifier = new int[GC.getNumImprovementInfos()];
	stream->Read(GC.getNumImprovementInfos(), m_piImprovementWeightModifier);

	SAFE_DELETE_ARRAY(m_piDiploPeaceIntroMusicScriptIds);
	m_piDiploPeaceIntroMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploPeaceIntroMusicScriptIds);

	SAFE_DELETE_ARRAY(m_piDiploPeaceMusicScriptIds);
	m_piDiploPeaceMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploPeaceMusicScriptIds);

	SAFE_DELETE_ARRAY(m_piDiploWarIntroMusicScriptIds);
	m_piDiploWarIntroMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploWarIntroMusicScriptIds);

	SAFE_DELETE_ARRAY(m_piDiploWarMusicScriptIds);
	m_piDiploWarMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploWarMusicScriptIds);

/*************************************************************************************************/
/** BonusAttitudeModifier          Opera    30.07.09         imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piBonusAttitudeModifier);
	m_piBonusAttitudeModifier = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusAttitudeModifier);
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** AlignmentAttitudeModifier       Opera   13.09.09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paAlignmentAttitudeModifier);
	m_paAlignmentAttitudeModifier = new CvAlignmentAttitudeModifierInfo[GC.getNumAlignmentInfos()];
	int i;
	for (i = 0; i < GC.getNumAlignmentInfos(); i++)
	{
		m_paAlignmentAttitudeModifier[i].read(stream);
	}
/*************************************************************************************************/
/** AlignmentAttitudeModifier       END                                                         **/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paEthicalAlignmentAttitudeModifier);
	m_paEthicalAlignmentAttitudeModifier = new CvEthicalAlignmentAttitudeModifierInfo[GC.getNumEthicalAlignmentInfos()];
	for (i = 0; i < GC.getNumEthicalAlignmentInfos(); i++)
	{
		m_paEthicalAlignmentAttitudeModifier[i].read(stream);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
}

void CvLeaderHeadInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iWonderConstructRand);
	stream->Write(m_iBaseAttitude);
	stream->Write(m_iBasePeaceWeight);
	stream->Write(m_iPeaceWeightRand);
	stream->Write(m_iWarmongerRespect);
	stream->Write(m_iEspionageWeight);
	stream->Write(m_iRefuseToTalkWarThreshold);
	stream->Write(m_iNoTechTradeThreshold);
	stream->Write(m_iTechTradeKnownPercent);
	stream->Write(m_iMaxGoldTradePercent);
	stream->Write(m_iMaxGoldPerTurnTradePercent);
	stream->Write(m_iMaxWarRand);
	stream->Write(m_iMaxWarNearbyPowerRatio);
	stream->Write(m_iMaxWarDistantPowerRatio);
	stream->Write(m_iMaxWarMinAdjacentLandPercent);
	stream->Write(m_iLimitedWarRand);
	stream->Write(m_iLimitedWarPowerRatio);
	stream->Write(m_iDogpileWarRand);
	stream->Write(m_iMakePeaceRand);
	stream->Write(m_iDeclareWarTradeRand);
	stream->Write(m_iDemandRebukedSneakProb);
	stream->Write(m_iDemandRebukedWarProb);
	stream->Write(m_iRazeCityProb);
	stream->Write(m_iBuildUnitProb);
	stream->Write(m_iBaseAttackOddsChange);
	stream->Write(m_iAttackOddsChangeRand);
	stream->Write(m_iWorseRankDifferenceAttitudeChange);
	stream->Write(m_iBetterRankDifferenceAttitudeChange);
	stream->Write(m_iCloseBordersAttitudeChange);
	stream->Write(m_iLostWarAttitudeChange);
	stream->Write(m_iAtWarAttitudeDivisor);
	stream->Write(m_iAtWarAttitudeChangeLimit);
	stream->Write(m_iAtPeaceAttitudeDivisor);
	stream->Write(m_iAtPeaceAttitudeChangeLimit);
	stream->Write(m_iSameReligionAttitudeChange);
	stream->Write(m_iSameReligionAttitudeDivisor);
	stream->Write(m_iSameReligionAttitudeChangeLimit);
	stream->Write(m_iDifferentReligionAttitudeChange);
	stream->Write(m_iDifferentReligionAttitudeDivisor);
	stream->Write(m_iDifferentReligionAttitudeChangeLimit);
	stream->Write(m_iBonusTradeAttitudeDivisor);
	stream->Write(m_iBonusTradeAttitudeChangeLimit);
	stream->Write(m_iOpenBordersAttitudeDivisor);
	stream->Write(m_iOpenBordersAttitudeChangeLimit);
	stream->Write(m_iDefensivePactAttitudeDivisor);
	stream->Write(m_iDefensivePactAttitudeChangeLimit);
	stream->Write(m_iShareWarAttitudeChange);
	stream->Write(m_iShareWarAttitudeDivisor);
	stream->Write(m_iShareWarAttitudeChangeLimit);
	stream->Write(m_iFavoriteCivicAttitudeChange);
	stream->Write(m_iFavoriteCivicAttitudeDivisor);
	stream->Write(m_iFavoriteCivicAttitudeChangeLimit);
	stream->Write(m_iDemandTributeAttitudeThreshold);
	stream->Write(m_iNoGiveHelpAttitudeThreshold);
	stream->Write(m_iTechRefuseAttitudeThreshold);
	stream->Write(m_iStrategicBonusRefuseAttitudeThreshold);
	stream->Write(m_iHappinessBonusRefuseAttitudeThreshold);
	stream->Write(m_iHealthBonusRefuseAttitudeThreshold);
	stream->Write(m_iMapRefuseAttitudeThreshold);
	stream->Write(m_iDeclareWarRefuseAttitudeThreshold);
	stream->Write(m_iDeclareWarThemRefuseAttitudeThreshold);
	stream->Write(m_iStopTradingRefuseAttitudeThreshold);
	stream->Write(m_iStopTradingThemRefuseAttitudeThreshold);
	stream->Write(m_iAdoptCivicRefuseAttitudeThreshold);
	stream->Write(m_iConvertReligionRefuseAttitudeThreshold);
	stream->Write(m_iOpenBordersRefuseAttitudeThreshold);
	stream->Write(m_iDefensivePactRefuseAttitudeThreshold);
	stream->Write(m_iPermanentAllianceRefuseAttitudeThreshold);
	stream->Write(m_iVassalRefuseAttitudeThreshold);
	stream->Write(m_iVassalPowerModifier);
	stream->Write(m_iFreedomAppreciation);
	stream->Write(m_iFavoriteCivic);
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iFavoriteReligion);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	stream->Write(&m_piAIVictoryTypes);
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
	stream->WriteString(m_szArtDefineTag);

/*************************************************************************************************/
/**	New Tag Defs	(LeaderInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(&m_iAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iEthicalAlignmentModifier);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(&m_iProximityMemoryDecayDelay);
	stream->Write(&m_iProximityMemoryDecayRand);
	stream->Write(&m_iProximityMemoryLimit);
	stream->Write(&m_fProximityMemoryDecaySpeed);
	stream->WriteString(m_szDefeatQuote);
	stream->WriteString(m_szImage);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

//FfH: Added by Kael 08/07/2007
	stream->Write(m_bFemale);
	stream->Write(m_iAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iEthicalAlignment);
	stream->Write(m_bTrueNeutral);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
/*************************************************************************************************/
	stream->Write(m_iLeaderClass);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	stream->Write(m_iAttitudeBadBonus);
	stream->Write(m_iAttitudeCompassionHigh);
	stream->Write(m_iAttitudeCompassionLow);
	stream->Write(m_iAttitudeFromFemales);
	stream->Write(m_iAttitudeFromMales);
	stream->Write(m_iAttitudeToFemales);
	stream->Write(m_iAttitudeToMales);

//FfH Card Game: Added by Sto 08/08/2008
	stream->Write(m_iSomniumAggressiveness);
//FfH: End Add
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	stream->Write(m_iFavoriteTech);
	stream->Write(m_iFavoriteUnitCombat);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	stream->Write(m_iFavoriteWonder);
	stream->Write(m_iPermanentTrait);

/*************************************************************************************************/
/** HatedCivic		Opera		31.05.09        imported by Valkrionn	09.26.09               	**/
/*************************************************************************************************/
	stream->Write(&m_iHatedCivicAttitudeChange);
	stream->Write(&m_iHatedCivicAttitudeDivisor);
	stream->Write(&m_iHatedCivicAttitudeChangeLimit);
	stream->Write(&m_iHatedCivic);
/*************************************************************************************************/
/** End																							**/
/*************************************************************************************************/

	stream->Write(GC.getNumReligionInfos(), m_piReligionWeightModifier);
//FfH: End Add

	// Arrays

	stream->Write(GC.getNumTraitInfos(), m_pbTraits);

	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(NUM_CONTACT_TYPES, m_piContactRand);
	stream->Write(NUM_CONTACT_TYPES, m_piContactDelay);
	stream->Write(NUM_MEMORY_TYPES, m_piMemoryDecayRand);
	stream->Write(NUM_MEMORY_TYPES, m_piMemoryAttitudePercent);
	stream->Write(NUM_ATTITUDE_TYPES, m_piNoWarAttitudeProb);
	stream->Write(NUM_UNITAI_TYPES, m_piUnitAIWeightModifier);
	stream->Write(GC.getNumImprovementInfos(), m_piImprovementWeightModifier);
	stream->Write(GC.getNumEraInfos(), m_piDiploPeaceIntroMusicScriptIds);
	stream->Write(GC.getNumEraInfos(), m_piDiploPeaceMusicScriptIds);
	stream->Write(GC.getNumEraInfos(), m_piDiploWarIntroMusicScriptIds);
	stream->Write(GC.getNumEraInfos(), m_piDiploWarMusicScriptIds);

/*************************************************************************************************/
/** BonusAttitudeModifier           Opera   30.07.09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	stream->Write(GC.getNumBonusInfos(), m_piBonusAttitudeModifier);
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** AlignmentAttitudeModifier       Opera   13.09.09        imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	int i;
	for (i = 0; i < GC.getNumAlignmentInfos(); i++)
	{
		m_paAlignmentAttitudeModifier[i].write(stream);
	}
/*************************************************************************************************/
/** AlignmentAttitudeModifier       END                                                         **/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	for (i = 0; i < GC.getNumEthicalAlignmentInfos(); i++)
	{
		m_paEthicalAlignmentAttitudeModifier[i].write(stream);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
}

const CvArtInfoLeaderhead* CvLeaderHeadInfo::getArtInfo() const
{
	return ARTFILEMGR.getLeaderheadArtInfo( getArtDefineTag());
}

bool CvLeaderHeadInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	pXML->GetChildXmlValByName(&m_iWonderConstructRand, "iWonderConstructRand");
	pXML->GetChildXmlValByName(&m_iBaseAttitude, "iBaseAttitude");
	pXML->GetChildXmlValByName(&m_iBasePeaceWeight, "iBasePeaceWeight");
	pXML->GetChildXmlValByName(&m_iPeaceWeightRand, "iPeaceWeightRand");
	pXML->GetChildXmlValByName(&m_iWarmongerRespect, "iWarmongerRespect");
	pXML->GetChildXmlValByName(&m_iEspionageWeight, "iEspionageWeight");
	pXML->GetChildXmlValByName(&m_iRefuseToTalkWarThreshold, "iRefuseToTalkWarThreshold");
	pXML->GetChildXmlValByName(&m_iNoTechTradeThreshold, "iNoTechTradeThreshold");
	pXML->GetChildXmlValByName(&m_iTechTradeKnownPercent, "iTechTradeKnownPercent");
	pXML->GetChildXmlValByName(&m_iMaxGoldTradePercent, "iMaxGoldTradePercent");
	pXML->GetChildXmlValByName(&m_iMaxGoldPerTurnTradePercent, "iMaxGoldPerTurnTradePercent");
	pXML->GetChildXmlValByName(&m_iMaxWarRand, "iMaxWarRand");
	pXML->GetChildXmlValByName(&m_iMaxWarNearbyPowerRatio, "iMaxWarNearbyPowerRatio");
	pXML->GetChildXmlValByName(&m_iMaxWarDistantPowerRatio, "iMaxWarDistantPowerRatio");
	pXML->GetChildXmlValByName(&m_iMaxWarMinAdjacentLandPercent, "iMaxWarMinAdjacentLandPercent");
	pXML->GetChildXmlValByName(&m_iLimitedWarRand, "iLimitedWarRand");
	pXML->GetChildXmlValByName(&m_iLimitedWarPowerRatio, "iLimitedWarPowerRatio");
	pXML->GetChildXmlValByName(&m_iDogpileWarRand, "iDogpileWarRand");
	pXML->GetChildXmlValByName(&m_iMakePeaceRand, "iMakePeaceRand");
	pXML->GetChildXmlValByName(&m_iDeclareWarTradeRand, "iDeclareWarTradeRand");
	pXML->GetChildXmlValByName(&m_iDemandRebukedSneakProb, "iDemandRebukedSneakProb");
	pXML->GetChildXmlValByName(&m_iDemandRebukedWarProb, "iDemandRebukedWarProb");
	pXML->GetChildXmlValByName(&m_iRazeCityProb, "iRazeCityProb");
	pXML->GetChildXmlValByName(&m_iBuildUnitProb, "iBuildUnitProb");
	pXML->GetChildXmlValByName(&m_iBaseAttackOddsChange, "iBaseAttackOddsChange");
	pXML->GetChildXmlValByName(&m_iAttackOddsChangeRand, "iAttackOddsChangeRand");
	pXML->GetChildXmlValByName(&m_iWorseRankDifferenceAttitudeChange, "iWorseRankDifferenceAttitudeChange");
	pXML->GetChildXmlValByName(&m_iBetterRankDifferenceAttitudeChange, "iBetterRankDifferenceAttitudeChange");
	pXML->GetChildXmlValByName(&m_iCloseBordersAttitudeChange, "iCloseBordersAttitudeChange");
	pXML->GetChildXmlValByName(&m_iLostWarAttitudeChange, "iLostWarAttitudeChange");
	pXML->GetChildXmlValByName(&m_iAtWarAttitudeDivisor, "iAtWarAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iAtWarAttitudeChangeLimit, "iAtWarAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iAtPeaceAttitudeDivisor, "iAtPeaceAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iAtPeaceAttitudeChangeLimit, "iAtPeaceAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iSameReligionAttitudeChange, "iSameReligionAttitudeChange");
	pXML->GetChildXmlValByName(&m_iSameReligionAttitudeDivisor, "iSameReligionAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iSameReligionAttitudeChangeLimit, "iSameReligionAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iDifferentReligionAttitudeChange, "iDifferentReligionAttitudeChange");
	pXML->GetChildXmlValByName(&m_iDifferentReligionAttitudeDivisor, "iDifferentReligionAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iDifferentReligionAttitudeChangeLimit, "iDifferentReligionAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iBonusTradeAttitudeDivisor, "iBonusTradeAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iBonusTradeAttitudeChangeLimit, "iBonusTradeAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iOpenBordersAttitudeDivisor, "iOpenBordersAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iOpenBordersAttitudeChangeLimit, "iOpenBordersAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iDefensivePactAttitudeDivisor, "iDefensivePactAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iDefensivePactAttitudeChangeLimit, "iDefensivePactAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iShareWarAttitudeChange, "iShareWarAttitudeChange");
	pXML->GetChildXmlValByName(&m_iShareWarAttitudeDivisor, "iShareWarAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iShareWarAttitudeChangeLimit, "iShareWarAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iFavoriteCivicAttitudeChange, "iFavoriteCivicAttitudeChange");
	pXML->GetChildXmlValByName(&m_iFavoriteCivicAttitudeDivisor, "iFavoriteCivicAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iFavoriteCivicAttitudeChangeLimit, "iFavoriteCivicAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iVassalPowerModifier, "iVassalPowerModifier");
	pXML->GetChildXmlValByName(&m_iFreedomAppreciation, "iFreedomAppreciation");
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piAIVictoryTypes, "VictoryAIs", GC.getAIVictoryTypes(), GC.getNumAIVictoryTypes());
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "DemandTributeAttitudeThreshold");
	m_iDemandTributeAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "NoGiveHelpAttitudeThreshold");
	m_iNoGiveHelpAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechRefuseAttitudeThreshold");
	m_iTechRefuseAttitudeThreshold = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StrategicBonusRefuseAttitudeThreshold");
	m_iStrategicBonusRefuseAttitudeThreshold = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "HappinessBonusRefuseAttitudeThreshold");
	m_iHappinessBonusRefuseAttitudeThreshold = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "HealthBonusRefuseAttitudeThreshold");
	m_iHealthBonusRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MapRefuseAttitudeThreshold");
	m_iMapRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DeclareWarRefuseAttitudeThreshold");
	m_iDeclareWarRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DeclareWarThemRefuseAttitudeThreshold");
	m_iDeclareWarThemRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StopTradingRefuseAttitudeThreshold");
	m_iStopTradingRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StopTradingThemRefuseAttitudeThreshold");
	m_iStopTradingThemRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "AdoptCivicRefuseAttitudeThreshold");
	m_iAdoptCivicRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ConvertReligionRefuseAttitudeThreshold");
	m_iConvertReligionRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "OpenBordersRefuseAttitudeThreshold");
	m_iOpenBordersRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DefensivePactRefuseAttitudeThreshold");
	m_iDefensivePactRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PermanentAllianceRefuseAttitudeThreshold");
	m_iPermanentAllianceRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "VassalRefuseAttitudeThreshold");
	m_iVassalRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FavoriteCivic");
	m_iFavoriteCivic = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "FavoriteReligion");
	m_iFavoriteReligion = pXML->FindInInfoClass(szTextVal);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_pbTraits, "Traits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());
	pXML->SetVariableListTagPair(&m_piContactRand, "ContactRands", GC.getContactTypes(), NUM_CONTACT_TYPES);
	pXML->SetVariableListTagPair(&m_piContactDelay, "ContactDelays", GC.getContactTypes(), NUM_CONTACT_TYPES);
	pXML->SetVariableListTagPair(&m_piMemoryDecayRand, "MemoryDecays", sizeof(GC.getMemoryInfo((MemoryTypes)0)), NUM_MEMORY_TYPES);
	pXML->SetVariableListTagPair(&m_piMemoryAttitudePercent, "MemoryAttitudePercents", sizeof(GC.getMemoryInfo((MemoryTypes)0)), NUM_MEMORY_TYPES);
	pXML->SetVariableListTagPair(&m_piNoWarAttitudeProb, "NoWarAttitudeProbs", sizeof(GC.getAttitudeInfo((AttitudeTypes)0)), NUM_ATTITUDE_TYPES);
	pXML->SetVariableListTagPair(&m_piUnitAIWeightModifier, "UnitAIWeightModifiers", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);
	pXML->SetVariableListTagPair(&m_piImprovementWeightModifier, "ImprovementWeightModifiers", sizeof(GC.getImprovementInfo((ImprovementTypes)0)), GC.getNumImprovementInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploPeaceIntroMusicScriptIds, "DiplomacyIntroMusicPeace", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploPeaceMusicScriptIds, "DiplomacyMusicPeace", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploWarIntroMusicScriptIds, "DiplomacyIntroMusicWar", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploWarMusicScriptIds, "DiplomacyMusicWar", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());

/*************************************************************************************************/
/**	New Tag Defs	(LeaderInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iProximityMemoryDecayDelay, "iProximityMemoryDecayDelay");
	pXML->GetChildXmlValByName(&m_iProximityMemoryDecayRand, "iProximityMemoryDecayRand");
	pXML->GetChildXmlValByName(&m_iProximityMemoryLimit, "iProximityMemoryLimit");
	pXML->GetChildXmlValByName(&m_fProximityMemoryDecaySpeed, "fProximityMemoryDecaySpeed");
	pXML->GetChildXmlValByName(m_szDefeatQuote, "DefeatQuote");
	pXML->GetChildXmlValByName(m_szImage, "Image");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Added by Kael 08/07/2007
	pXML->GetChildXmlValByName(&m_bFemale, "bFemale");
	pXML->GetChildXmlValByName(szTextVal, "Alignment");
	m_iAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "EthicalAlignment");
	m_iEthicalAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bTrueNeutral, "bTrueNeutral");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	LeaderStatus Infos      				10/01/09								Valkrionn	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "LeaderClass");
	m_iLeaderClass = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAttitudeBadBonus, "iAttitudeBadBonus");
	pXML->GetChildXmlValByName(&m_iAttitudeCompassionHigh, "iAttitudeCompassionHigh");
	pXML->GetChildXmlValByName(&m_iAttitudeCompassionLow, "iAttitudeCompassionLow");
	pXML->GetChildXmlValByName(&m_iAttitudeFromFemales, "iAttitudeFromFemales");
	pXML->GetChildXmlValByName(&m_iAttitudeFromMales, "iAttitudeFromMales");
	pXML->GetChildXmlValByName(&m_iAttitudeToFemales, "iAttitudeToFemales");
	pXML->GetChildXmlValByName(&m_iAttitudeToMales, "iAttitudeToMales");

//FfH Card Game: Added by Sto 08/08/2008
	pXML->GetChildXmlValByName(&m_iSomniumAggressiveness, "iSomniumAggressiveness");
//FfH: End Add

	pXML->GetChildXmlValByName(szTextVal, "FavoriteWonder");
	m_iFavoriteWonder = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PermanentTrait");
	m_iPermanentTrait = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/** HatedCivic		Opera		31.05.09        imported by Valkrionn	09.26.09        		**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iHatedCivicAttitudeChange, "iHatedCivicAttitudeChange");
	pXML->GetChildXmlValByName(&m_iHatedCivicAttitudeDivisor, "iHatedCivicAttitudeDivisor");
	pXML->GetChildXmlValByName(&m_iHatedCivicAttitudeChangeLimit, "iHatedCivicAttitudeChangeLimit");
	pXML->GetChildXmlValByName(szTextVal, "HatedCivic");
	m_iHatedCivic = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/** End																							**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piReligionWeightModifier, "ReligionWeightModifiers", sizeof(GC.getReligionInfo((ReligionTypes)0)), GC.getNumReligionInfos());
//FfH: End Add

/*************************************************************************************************/
/** BonusAttitudeModifier           Opera   30.07.09         imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piBonusAttitudeModifier, "BonusAttitudeModifiers", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** AlignmentAttitudeModifier       Opera   13.09.09         imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "AlignmentTypeStructs"))
	{
		pXML->SetAlignmentAttitudeModifiers(&m_paAlignmentAttitudeModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitAlignmentAttitudeModifierList(&m_paAlignmentAttitudeModifier, GC.getNumAlignmentInfos());
	}
/*************************************************************************************************/
/** AlignmentAttitudeModifier       END                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "EthicalAlignmentTypeStructs"))
	{
		pXML->SetEthicalAlignmentAttitudeModifiers(&m_paEthicalAlignmentAttitudeModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitEthicalAlignmentAttitudeModifierList(&m_paEthicalAlignmentAttitudeModifier, GC.getNumEthicalAlignmentInfos());
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(LeaderInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvLeaderHeadInfo::copyNonDefaults(CvLeaderHeadInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()								== cDefault)		setArtDefineTag(								pClassInfo->getArtDefineTag());
	//Must do Art Define before Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isFemale()										== false)			m_bFemale										= pClassInfo->isFemale();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (isTrueNeutral()									== false)			m_bTrueNeutral									= pClassInfo->isTrueNeutral();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getWonderConstructRand()						== 0)				m_iWonderConstructRand							= pClassInfo->getWonderConstructRand();
	if (getBaseAttitude()								== 0)				m_iBaseAttitude									= pClassInfo->getBaseAttitude();
	if (getBasePeaceWeight()							== 0)				m_iBasePeaceWeight								= pClassInfo->getBasePeaceWeight();
	if (getPeaceWeightRand()							== 0)				m_iPeaceWeightRand								= pClassInfo->getPeaceWeightRand();
	if (getWarmongerRespect()							== 0)				m_iWarmongerRespect								= pClassInfo->getWarmongerRespect();
	if (getEspionageWeight()							== 0)				m_iEspionageWeight								= pClassInfo->getEspionageWeight();
	if (getRefuseToTalkWarThreshold()					== 0)				m_iRefuseToTalkWarThreshold						= pClassInfo->getRefuseToTalkWarThreshold();
	if (getNoTechTradeThreshold()						== 0)				m_iNoTechTradeThreshold							= pClassInfo->getNoTechTradeThreshold();
	if (getTechTradeKnownPercent()						== 0)				m_iTechTradeKnownPercent						= pClassInfo->getTechTradeKnownPercent();
	if (getMaxGoldTradePercent()						== 0)				m_iMaxGoldTradePercent							= pClassInfo->getMaxGoldTradePercent();
	if (getMaxGoldPerTurnTradePercent()					== 0)				m_iMaxGoldPerTurnTradePercent					= pClassInfo->getMaxGoldPerTurnTradePercent();
	if (getMaxWarRand()									== 0)				m_iMaxWarRand									= pClassInfo->getMaxWarRand();
	if (getMaxWarNearbyPowerRatio()						== 0)				m_iMaxWarNearbyPowerRatio						= pClassInfo->getMaxWarNearbyPowerRatio();
	if (getMaxWarDistantPowerRatio()					== 0)				m_iMaxWarDistantPowerRatio						= pClassInfo->getMaxWarDistantPowerRatio();
	if (getMaxWarMinAdjacentLandPercent()				== 0)				m_iMaxWarMinAdjacentLandPercent					= pClassInfo->getMaxWarMinAdjacentLandPercent();
	if (getLimitedWarRand()								== 0)				m_iLimitedWarRand								= pClassInfo->getLimitedWarRand();
	if (getLimitedWarPowerRatio()						== 0)				m_iLimitedWarPowerRatio							= pClassInfo->getLimitedWarPowerRatio();
	if (getDogpileWarRand()								== 0)				m_iDogpileWarRand								= pClassInfo->getDogpileWarRand();
	if (getMakePeaceRand()								== 0)				m_iMakePeaceRand								= pClassInfo->getMakePeaceRand();
	if (getDeclareWarTradeRand()						== 0)				m_iDeclareWarTradeRand							= pClassInfo->getDeclareWarTradeRand();
	if (getDemandRebukedSneakProb()						== 0)				m_iDemandRebukedSneakProb						= pClassInfo->getDemandRebukedSneakProb();
	if (getDemandRebukedWarProb()						== 0)				m_iDemandRebukedWarProb							= pClassInfo->getDemandRebukedWarProb();
	if (getRazeCityProb()								== 0)				m_iRazeCityProb									= pClassInfo->getRazeCityProb();
	if (getBuildUnitProb()								== 0)				m_iBuildUnitProb								= pClassInfo->getBuildUnitProb();
	if (getBaseAttackOddsChange()						== 0)				m_iBaseAttackOddsChange							= pClassInfo->getBaseAttackOddsChange();
	if (getAttackOddsChangeRand()						== 0)				m_iAttackOddsChangeRand							= pClassInfo->getAttackOddsChangeRand();
	if (getWorseRankDifferenceAttitudeChange()			== 0)				m_iWorseRankDifferenceAttitudeChange			= pClassInfo->getWorseRankDifferenceAttitudeChange();
	if (getBetterRankDifferenceAttitudeChange()			== 0)				m_iBetterRankDifferenceAttitudeChange			= pClassInfo->getBetterRankDifferenceAttitudeChange();
	if (getCloseBordersAttitudeChange()					== 0)				m_iCloseBordersAttitudeChange					= pClassInfo->getCloseBordersAttitudeChange();
	if (getLostWarAttitudeChange()						== 0)				m_iLostWarAttitudeChange						= pClassInfo->getLostWarAttitudeChange();
	if (getAtWarAttitudeDivisor()						== 0)				m_iAtWarAttitudeDivisor							= pClassInfo->getAtWarAttitudeDivisor();
	if (getAtWarAttitudeChangeLimit()					== 0)				m_iAtWarAttitudeChangeLimit						= pClassInfo->getAtWarAttitudeChangeLimit();
	if (getAtPeaceAttitudeDivisor()						== 0)				m_iAtPeaceAttitudeDivisor						= pClassInfo->getAtPeaceAttitudeDivisor();
	if (getAtPeaceAttitudeChangeLimit()					== 0)				m_iAtPeaceAttitudeChangeLimit					= pClassInfo->getAtPeaceAttitudeChangeLimit();
	if (getSameReligionAttitudeChange()					== 0)				m_iSameReligionAttitudeChange					= pClassInfo->getSameReligionAttitudeChange();
	if (getSameReligionAttitudeDivisor()				== 0)				m_iSameReligionAttitudeDivisor					= pClassInfo->getSameReligionAttitudeDivisor();
	if (getSameReligionAttitudeChangeLimit()			== 0)				m_iSameReligionAttitudeChangeLimit				= pClassInfo->getSameReligionAttitudeChangeLimit();
	if (getDifferentReligionAttitudeChange()			== 0)				m_iDifferentReligionAttitudeChange				= pClassInfo->getDifferentReligionAttitudeChange();
	if (getDifferentReligionAttitudeDivisor()			== 0)				m_iDifferentReligionAttitudeDivisor				= pClassInfo->getDifferentReligionAttitudeDivisor();
	if (getDifferentReligionAttitudeChangeLimit()		== 0)				m_iDifferentReligionAttitudeChangeLimit			= pClassInfo->getDifferentReligionAttitudeChangeLimit();
	if (getBonusTradeAttitudeDivisor()					== 0)				m_iBonusTradeAttitudeDivisor					= pClassInfo->getBonusTradeAttitudeDivisor();
	if (getBonusTradeAttitudeChangeLimit()				== 0)				m_iBonusTradeAttitudeChangeLimit				= pClassInfo->getBonusTradeAttitudeChangeLimit();
	if (getOpenBordersAttitudeDivisor()					== 0)				m_iOpenBordersAttitudeDivisor					= pClassInfo->getOpenBordersAttitudeDivisor();
	if (getOpenBordersAttitudeChangeLimit()				== 0)				m_iOpenBordersAttitudeChangeLimit				= pClassInfo->getOpenBordersAttitudeChangeLimit();
	if (getDefensivePactAttitudeDivisor()				== 0)				m_iDefensivePactAttitudeDivisor					= pClassInfo->getDefensivePactAttitudeDivisor();
	if (getDefensivePactAttitudeChangeLimit()			== 0)				m_iDefensivePactAttitudeChangeLimit				= pClassInfo->getDefensivePactAttitudeChangeLimit();
	if (getShareWarAttitudeChange()						== 0)				m_iShareWarAttitudeChange						= pClassInfo->getShareWarAttitudeChange();
	if (getShareWarAttitudeDivisor()					== 0)				m_iShareWarAttitudeDivisor						= pClassInfo->getShareWarAttitudeDivisor();
	if (getShareWarAttitudeChangeLimit()				== 0)				m_iShareWarAttitudeChangeLimit					= pClassInfo->getShareWarAttitudeChangeLimit();
	if (getFavoriteCivicAttitudeChange()				== 0)				m_iFavoriteCivicAttitudeChange					= pClassInfo->getFavoriteCivicAttitudeChange();
	if (getFavoriteCivicAttitudeDivisor()				== 0)				m_iFavoriteCivicAttitudeDivisor					= pClassInfo->getFavoriteCivicAttitudeDivisor();
	if (getFavoriteCivicAttitudeChangeLimit()			== 0)				m_iFavoriteCivicAttitudeChangeLimit				= pClassInfo->getFavoriteCivicAttitudeChangeLimit();
	if (getVassalPowerModifier()						== 0)				m_iVassalPowerModifier							= pClassInfo->getVassalPowerModifier();
	if (getFreedomAppreciation()						== 0)				m_iFreedomAppreciation							= pClassInfo->getFreedomAppreciation();
	if (getAlignmentModifier()							== 0)				m_iAlignmentModifier							= pClassInfo->getAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getEthicalAlignmentModifier()					== 0)				m_iEthicalAlignmentModifier						= pClassInfo->getEthicalAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getAttitudeBadBonus()							== 0)				m_iAttitudeBadBonus								= pClassInfo->getAttitudeBadBonus();
	if (getAttitudeCompassionHigh()						== 0)				m_iAttitudeCompassionHigh						= pClassInfo->getAttitudeCompassionHigh();
	if (getAttitudeCompassionLow()						== 0)				m_iAttitudeCompassionLow						= pClassInfo->getAttitudeCompassionLow();
	if (getAttitudeFromFemales()						== 0)				m_iAttitudeFromFemales							= pClassInfo->getAttitudeFromFemales();
	if (getAttitudeFromMales()							== 0)				m_iAttitudeFromMales							= pClassInfo->getAttitudeFromMales();
	if (getAttitudeToFemales()							== 0)				m_iAttitudeToFemales							= pClassInfo->getAttitudeToFemales();
	if (getAttitudeToMales()							== 0)				m_iAttitudeToMales								= pClassInfo->getAttitudeToMales();
	if (getSomniumAggressiveness()						== 0)				m_iSomniumAggressiveness						= pClassInfo->getSomniumAggressiveness();
	if (getProximityMemoryLimit()						== 0)				m_iProximityMemoryLimit							= pClassInfo->getProximityMemoryLimit();
	if (getProximityMemoryDecayDelay()					== 0)				m_iProximityMemoryDecayDelay					= pClassInfo->getProximityMemoryDecayDelay();
	if (getProximityMemoryDecayRand()					== 0)				m_iProximityMemoryDecayRand						= pClassInfo->getProximityMemoryDecayRand();
	if (getProximityMemoryDecaySpeed()					== 0.0f)			m_fProximityMemoryDecaySpeed					= pClassInfo->getProximityMemoryDecaySpeed();
	if (getDefeatQuote()								== cDefault)		m_szDefeatQuote									= pClassInfo->getDefeatQuote();
	if (getImage()										== cDefault)		m_szImage										= pClassInfo->getImage();
	if (getPermanentTrait()								== NO_TRAIT)		m_iPermanentTrait								= pClassInfo->getPermanentTrait();
	if (getLeaderClass() == NO_LEADERCLASS) m_iLeaderClass = pClassInfo->getLeaderClass();
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getFavoriteTech()								== NO_TECH)			m_iFavoriteTech									= pClassInfo->getFavoriteTech();
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	if (getFavoriteCivic()								== NO_CIVIC)		m_iFavoriteCivic								= pClassInfo->getFavoriteCivic();
	if (getFavoriteWonder()								== NO_BUILDING)		m_iFavoriteWonder								= pClassInfo->getFavoriteWonder();
	if (getDemandTributeAttitudeThreshold()				== NO_ATTITUDE)		m_iDemandTributeAttitudeThreshold				= pClassInfo->getDemandTributeAttitudeThreshold();
	if (getNoGiveHelpAttitudeThreshold()				== NO_ATTITUDE)		m_iNoGiveHelpAttitudeThreshold					= pClassInfo->getNoGiveHelpAttitudeThreshold();
	if (getTechRefuseAttitudeThreshold()				== NO_ATTITUDE)		m_iTechRefuseAttitudeThreshold					= pClassInfo->getTechRefuseAttitudeThreshold();
	if (getStrategicBonusRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iStrategicBonusRefuseAttitudeThreshold		= pClassInfo->getStrategicBonusRefuseAttitudeThreshold();
	if (getHappinessBonusRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iHappinessBonusRefuseAttitudeThreshold		= pClassInfo->getHappinessBonusRefuseAttitudeThreshold();
	if (getHealthBonusRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iHealthBonusRefuseAttitudeThreshold			= pClassInfo->getHealthBonusRefuseAttitudeThreshold();
	if (getMapRefuseAttitudeThreshold()					== NO_ATTITUDE)		m_iMapRefuseAttitudeThreshold					= pClassInfo->getMapRefuseAttitudeThreshold();
	if (getDeclareWarRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iDeclareWarRefuseAttitudeThreshold			= pClassInfo->getDeclareWarRefuseAttitudeThreshold();
	if (getDeclareWarThemRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iDeclareWarThemRefuseAttitudeThreshold		= pClassInfo->getDeclareWarThemRefuseAttitudeThreshold();
	if (getStopTradingRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iStopTradingRefuseAttitudeThreshold			= pClassInfo->getStopTradingRefuseAttitudeThreshold();
	if (getStopTradingThemRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iStopTradingThemRefuseAttitudeThreshold		= pClassInfo->getStopTradingThemRefuseAttitudeThreshold();
	if (getAdoptCivicRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iAdoptCivicRefuseAttitudeThreshold			= pClassInfo->getAdoptCivicRefuseAttitudeThreshold();
	if (getConvertReligionRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iConvertReligionRefuseAttitudeThreshold		= pClassInfo->getConvertReligionRefuseAttitudeThreshold();
	if (getOpenBordersRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iOpenBordersRefuseAttitudeThreshold			= pClassInfo->getOpenBordersRefuseAttitudeThreshold();
	if (getDefensivePactRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iDefensivePactRefuseAttitudeThreshold			= pClassInfo->getDefensivePactRefuseAttitudeThreshold();
	if (getPermanentAllianceRefuseAttitudeThreshold()	== NO_ATTITUDE)		m_iPermanentAllianceRefuseAttitudeThreshold		= pClassInfo->getPermanentAllianceRefuseAttitudeThreshold();
	if (getVassalRefuseAttitudeThreshold()				== NO_ATTITUDE)		m_iVassalRefuseAttitudeThreshold				= pClassInfo->getVassalRefuseAttitudeThreshold();
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getFavoriteReligion()							== NO_RELIGION)		m_iFavoriteReligion								= pClassInfo->getFavoriteReligion();
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								18/01/12								Snarko		**/
/**							Teaching the AI to go for victories.								**/
/*************************************************************************************************/
	for ( int i = 0; i < NUM_AI_VICTORY_WEIGHT; i++ )
	{
		if(getAIVictoryWeight(i)		== 0)					m_piAIVictoryTypes[i]			= pClassInfo->getAIVictoryWeight(i);
	}
/*************************************************************************************************/
/**	Improved AI								END													**/
/*************************************************************************************************/
	if (getAlignment()									== NO_ALIGNMENT)	m_iAlignment									= pClassInfo->getAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getEthicalAlignment()							== NO_ETHICAL_ALIGNMENT)	m_iEthicalAlignment						= pClassInfo->getEthicalAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								25/07/10										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getFavoriteUnitCombat()							== NO_UNITCOMBAT)	m_iFavoriteUnitCombat							= pClassInfo->getFavoriteUnitCombat();
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	for (int j = 0; j < GC.getNumTraitInfos(); j++)
	{
		if (hasTrait(j)									== false)			m_pbTraits[j]									= pClassInfo->hasTrait(j);
	}
	for (int j = 0; j < GC.getNumFlavorTypes(); j++)
	{
		if (getFlavorValue(j)							== 0)				m_piFlavorValue[j]								= pClassInfo->getFlavorValue(j);
	}
	for (int j = 0; j < NUM_CONTACT_TYPES; j++)
	{
		if (getContactRand(j)							== 0)				m_piContactRand[j]								= pClassInfo->getContactRand(j);
		if (getContactDelay(j)							== 0)				m_piContactDelay[j]								= pClassInfo->getContactDelay(j);
	}
	for (int j = 0; j < NUM_MEMORY_TYPES; j++)
	{
		if (getMemoryDecayRand(j)						== 0)				m_piMemoryDecayRand[j]							= pClassInfo->getMemoryDecayRand(j);
		if (getMemoryAttitudePercent(j)					== 0)				m_piMemoryAttitudePercent[j]					= pClassInfo->getMemoryAttitudePercent(j);
	}
	for (int j = 0; j < NUM_ATTITUDE_TYPES; j++)
	{
		if (getNoWarAttitudeProb(j)						== 0)				m_piNoWarAttitudeProb[j]						= pClassInfo->getNoWarAttitudeProb(j);
	}
	for (int j = 0; j < NUM_UNITAI_TYPES; j++)
	{
		if (getUnitAIWeightModifier(j)					== 0)				m_piUnitAIWeightModifier[j]						= pClassInfo->getUnitAIWeightModifier(j);
	}
	for (int j = 0; j < GC.getNumImprovementInfos(); j++)
	{
		if (getImprovementWeightModifier(j)				== 0)				m_piImprovementWeightModifier[j]				= pClassInfo->getImprovementWeightModifier(j);
	}
	for (int j = 0; j < GC.getNumEraInfos(); j++)
	{
		if (getDiploPeaceIntroMusicScriptIds(j)			== -1)				m_piDiploPeaceIntroMusicScriptIds[j]			= pClassInfo->getDiploPeaceIntroMusicScriptIds(j);
		if (getDiploPeaceMusicScriptIds(j)				== -1)				m_piDiploPeaceMusicScriptIds[j]					= pClassInfo->getDiploPeaceMusicScriptIds(j);
		if (getDiploWarIntroMusicScriptIds(j)			== -1)				m_piDiploWarIntroMusicScriptIds[j]				= pClassInfo->getDiploWarIntroMusicScriptIds(j);
		if (getDiploWarMusicScriptIds(j)				== -1)				m_piDiploWarMusicScriptIds[j]					= pClassInfo->getDiploWarMusicScriptIds(j);
	}
	for (int j = 0; j < GC.getNumReligionInfos(); j++)
	{
		if (getReligionWeightModifier(j)				== 0)				m_piReligionWeightModifier[j]			= pClassInfo->getReligionWeightModifier(j);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvWorldInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvWorldInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvWorldInfo::CvWorldInfo() :
m_iDefaultPlayers(0),
m_iUnitNameModifier(0),
m_iTargetNumCities(0),
m_iNumFreeBuildingBonuses(0),
m_iBuildingClassPrereqModifier(0),
m_iMaxConscriptModifier(0),
m_iWarWearinessModifier(0),
m_iGridWidth(0),
m_iGridHeight(0),
m_iTerrainGrainChange(0),
m_iFeatureGrainChange(0),
m_iResearchPercent(0),
m_iTradeProfitPercent(0),
m_iDistanceMaintenancePercent(0),
m_iNumCitiesMaintenancePercent(0),
m_iColonyMaintenancePercent(0),
m_iCorporationMaintenancePercent(0),
m_iNumCitiesAnarchyPercent(0),
m_iAdvancedStartPointsMod(0),

//FfH: Added by Kael 10/01/2007
m_iMaxCitiesMod(0),
m_iUniqueFeatureChance(0)
//FfH: End Add

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvWorldInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvWorldInfo::~CvWorldInfo()
{
}

int CvWorldInfo::getDefaultPlayers() const
{
	return m_iDefaultPlayers;
}

int CvWorldInfo::getUnitNameModifier() const
{
	return m_iUnitNameModifier;
}

int CvWorldInfo::getTargetNumCities() const
{
	return m_iTargetNumCities;
}

int CvWorldInfo::getNumFreeBuildingBonuses() const
{
	return m_iNumFreeBuildingBonuses;
}

int CvWorldInfo::getBuildingClassPrereqModifier() const
{
	return m_iBuildingClassPrereqModifier;
}

int CvWorldInfo::getMaxConscriptModifier() const
{
	return m_iMaxConscriptModifier;
}

int CvWorldInfo::getWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

int CvWorldInfo::getGridWidth() const
{
	return m_iGridWidth;
}

int CvWorldInfo::getGridHeight() const
{
	return m_iGridHeight;
}

int CvWorldInfo::getTerrainGrainChange() const
{
	return m_iTerrainGrainChange;
}

int CvWorldInfo::getFeatureGrainChange() const
{
	return m_iFeatureGrainChange;
}

int CvWorldInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvWorldInfo::getTradeProfitPercent() const
{
	return m_iTradeProfitPercent;
}

int CvWorldInfo::getDistanceMaintenancePercent() const
{
	return m_iDistanceMaintenancePercent;
}

int CvWorldInfo::getNumCitiesMaintenancePercent() const
{
	return m_iNumCitiesMaintenancePercent;
}

int CvWorldInfo::getColonyMaintenancePercent() const
{
	return m_iColonyMaintenancePercent;
}

int CvWorldInfo::getCorporationMaintenancePercent() const
{
	return m_iCorporationMaintenancePercent;
}

int CvWorldInfo::getNumCitiesAnarchyPercent() const
{
	return m_iNumCitiesAnarchyPercent;
}

int CvWorldInfo::getAdvancedStartPointsMod() const
{
	return m_iAdvancedStartPointsMod;
}

//FfH: Added by Kael 10/01/2007
int CvWorldInfo::getMaxCitiesMod() const
{
	return m_iMaxCitiesMod;
}

int CvWorldInfo::getUniqueFeatureChance() const
{
	return m_iUniqueFeatureChance;
}
//FfH: End Add

bool CvWorldInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iDefaultPlayers, "iDefaultPlayers");
	pXML->GetChildXmlValByName(&m_iUnitNameModifier, "iUnitNameModifier");
	pXML->GetChildXmlValByName(&m_iTargetNumCities, "iTargetNumCities");
	pXML->GetChildXmlValByName(&m_iNumFreeBuildingBonuses, "iNumFreeBuildingBonuses");
	pXML->GetChildXmlValByName(&m_iBuildingClassPrereqModifier, "iBuildingClassPrereqModifier");
	pXML->GetChildXmlValByName(&m_iMaxConscriptModifier, "iMaxConscriptModifier");
	pXML->GetChildXmlValByName(&m_iWarWearinessModifier, "iWarWearinessModifier");
	pXML->GetChildXmlValByName(&m_iGridWidth, "iGridWidth");
	pXML->GetChildXmlValByName(&m_iGridHeight, "iGridHeight");
	pXML->GetChildXmlValByName(&m_iTerrainGrainChange, "iTerrainGrainChange");
	pXML->GetChildXmlValByName(&m_iFeatureGrainChange, "iFeatureGrainChange");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iTradeProfitPercent, "iTradeProfitPercent");
	pXML->GetChildXmlValByName(&m_iDistanceMaintenancePercent, "iDistanceMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iNumCitiesMaintenancePercent, "iNumCitiesMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iColonyMaintenancePercent, "iColonyMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iCorporationMaintenancePercent, "iCorporationMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iNumCitiesAnarchyPercent, "iNumCitiesAnarchyPercent");
	pXML->GetChildXmlValByName(&m_iAdvancedStartPointsMod, "iAdvancedStartPointsMod");

//FfH: Added by Kael 10/01/2007
	pXML->GetChildXmlValByName(&m_iMaxCitiesMod, "iMaxCitiesMod");
	pXML->GetChildXmlValByName(&m_iUniqueFeatureChance, "iUniqueFeatureChance");
//FfH: End Add

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvWorldInfo::copyNonDefaults(CvWorldInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefaultPlayers()					== 0)	m_iDefaultPlayers					= pClassInfo->getDefaultPlayers();
	if (getUnitNameModifier()				== 0)	m_iUnitNameModifier					= pClassInfo->getUnitNameModifier();
	if (getTargetNumCities()				== 0)	m_iTargetNumCities					= pClassInfo->getTargetNumCities();
	if (getNumFreeBuildingBonuses()			== 0)	m_iNumFreeBuildingBonuses			= pClassInfo->getNumFreeBuildingBonuses();
	if (getBuildingClassPrereqModifier()	== 0)	m_iBuildingClassPrereqModifier		= pClassInfo->getBuildingClassPrereqModifier();
	if (getMaxConscriptModifier()			== 0)	m_iMaxConscriptModifier				= pClassInfo->getMaxConscriptModifier();
	if (getWarWearinessModifier()			== 0)	m_iWarWearinessModifier				= pClassInfo->getWarWearinessModifier();
	if (getGridWidth()						== 0)	m_iGridWidth						= pClassInfo->getGridWidth();
	if (getGridHeight()						== 0)	m_iGridHeight						= pClassInfo->getGridHeight();
	if (getTerrainGrainChange()				== 0)	m_iTerrainGrainChange				= pClassInfo->getTerrainGrainChange();
	if (getFeatureGrainChange()				== 0)	m_iFeatureGrainChange				= pClassInfo->getFeatureGrainChange();
	if (getResearchPercent()				== 0)	m_iResearchPercent					= pClassInfo->getResearchPercent();
	if (getTradeProfitPercent()				== 0)	m_iTradeProfitPercent				= pClassInfo->getTradeProfitPercent();
	if (getDistanceMaintenancePercent()		== 0)	m_iDistanceMaintenancePercent		= pClassInfo->getDistanceMaintenancePercent();
	if (getNumCitiesMaintenancePercent()	== 0)	m_iNumCitiesMaintenancePercent		= pClassInfo->getNumCitiesMaintenancePercent();
	if (getColonyMaintenancePercent()		== 0)	m_iColonyMaintenancePercent			= pClassInfo->getColonyMaintenancePercent();
	if (getCorporationMaintenancePercent()	== 0)	m_iCorporationMaintenancePercent	= pClassInfo->getCorporationMaintenancePercent();
	if (getNumCitiesAnarchyPercent()		== 0)	m_iNumCitiesAnarchyPercent			= pClassInfo->getNumCitiesAnarchyPercent();
	if (getAdvancedStartPointsMod()			== 0)	m_iAdvancedStartPointsMod			= pClassInfo->getAdvancedStartPointsMod();
	if (getMaxCitiesMod()					== 0)	m_iMaxCitiesMod						= pClassInfo->getMaxCitiesMod();
	if (getUniqueFeatureChance()			== 0)	m_iUniqueFeatureChance				= pClassInfo->getUniqueFeatureChance();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvClimateInfo
//======================================================================================================
CvClimateInfo::CvClimateInfo() :
m_iDesertPercentChange(0),
m_iJungleLatitude(0),
m_iHillRange(0),
m_iPeakPercent(0),
m_fSnowLatitudeChange(0.0f),
m_fTundraLatitudeChange(0.0f),
m_fGrassLatitudeChange(0.0f),
m_fDesertBottomLatitudeChange(0.0f),
m_fDesertTopLatitudeChange(0.0f),
m_fIceLatitude(0.0f),
m_fRandIceLatitude(0.0f)
{
}

CvClimateInfo::~CvClimateInfo()
{
}

int CvClimateInfo::getDesertPercentChange() const
{
	return m_iDesertPercentChange;
}

int CvClimateInfo::getJungleLatitude() const
{
	return m_iJungleLatitude;
}

int CvClimateInfo::getHillRange() const
{
	return m_iHillRange;
}

int CvClimateInfo::getPeakPercent() const
{
	return m_iPeakPercent;
}

float CvClimateInfo::getSnowLatitudeChange() const
{
	return m_fSnowLatitudeChange;
}

float CvClimateInfo::getTundraLatitudeChange() const
{
	return m_fTundraLatitudeChange;
}

float CvClimateInfo::getGrassLatitudeChange() const
{
	return m_fGrassLatitudeChange;
}

float CvClimateInfo::getDesertBottomLatitudeChange() const
{
	return m_fDesertBottomLatitudeChange;
}

float CvClimateInfo::getDesertTopLatitudeChange() const
{
	return m_fDesertTopLatitudeChange;
}

float CvClimateInfo::getIceLatitude() const
{
	return m_fIceLatitude;
}

float CvClimateInfo::getRandIceLatitude() const
{
	return m_fRandIceLatitude;
}

bool CvClimateInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iDesertPercentChange, "iDesertPercentChange");
	pXML->GetChildXmlValByName(&m_iJungleLatitude, "iJungleLatitude");
	pXML->GetChildXmlValByName(&m_iHillRange, "iHillRange");
	pXML->GetChildXmlValByName(&m_iPeakPercent, "iPeakPercent");

	pXML->GetChildXmlValByName(&m_fSnowLatitudeChange, "fSnowLatitudeChange");
	pXML->GetChildXmlValByName(&m_fTundraLatitudeChange, "fTundraLatitudeChange");
	pXML->GetChildXmlValByName(&m_fGrassLatitudeChange, "fGrassLatitudeChange");
	pXML->GetChildXmlValByName(&m_fDesertBottomLatitudeChange, "fDesertBottomLatitudeChange");
	pXML->GetChildXmlValByName(&m_fDesertTopLatitudeChange, "fDesertTopLatitudeChange");
	pXML->GetChildXmlValByName(&m_fIceLatitude, "fIceLatitude");
	pXML->GetChildXmlValByName(&m_fRandIceLatitude, "fRandIceLatitude");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvClimateInfo::copyNonDefaults(CvClimateInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDesertPercentChange()			== 0)		m_iDesertPercentChange			= pClassInfo->getDesertPercentChange();
	if (getJungleLatitude()					== 0)		m_iJungleLatitude				= pClassInfo->getJungleLatitude();
	if (getHillRange()						== 0)		m_iHillRange					= pClassInfo->getHillRange();
	if (getPeakPercent()					== 0)		m_iPeakPercent					= pClassInfo->getPeakPercent();

	if (getSnowLatitudeChange()				== 0.0f)	m_fSnowLatitudeChange			= pClassInfo->getSnowLatitudeChange();
	if (getTundraLatitudeChange()			== 0.0f)	m_fTundraLatitudeChange			= pClassInfo->getTundraLatitudeChange();
	if (getGrassLatitudeChange()			== 0.0f)	m_fGrassLatitudeChange			= pClassInfo->getGrassLatitudeChange();
	if (getDesertBottomLatitudeChange()		== 0.0f)	m_fDesertBottomLatitudeChange	= pClassInfo->getDesertBottomLatitudeChange();
	if (getDesertTopLatitudeChange()		== 0.0f)	m_fDesertTopLatitudeChange		= pClassInfo->getDesertTopLatitudeChange();
	if (getIceLatitude()					== 0.0f)	m_fIceLatitude					= pClassInfo->getIceLatitude();
	if (getRandIceLatitude()				== 0.0f)	m_fRandIceLatitude				= pClassInfo->getRandIceLatitude();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSeaLevelInfo
//======================================================================================================
CvSeaLevelInfo::CvSeaLevelInfo() :
m_iSeaLevelChange(0)
{
}

CvSeaLevelInfo::~CvSeaLevelInfo()
{
}

int CvSeaLevelInfo::getSeaLevelChange() const
{
	return m_iSeaLevelChange;
}

bool CvSeaLevelInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iSeaLevelChange, "iSeaLevelChange");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSeaLevelInfo::copyNonDefaults(CvSeaLevelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getSeaLevelChange()		== 0)	m_iSeaLevelChange	= pClassInfo->getSeaLevelChange();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvProcessInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvProcessInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvProcessInfo::CvProcessInfo() :
m_iTechPrereq(NO_TECH),
m_paiProductionToCommerceModifier(NULL),
m_iProductionToCrimeModifier(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvProcessInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvProcessInfo::~CvProcessInfo()
{
	SAFE_DELETE_ARRAY(m_paiProductionToCommerceModifier);
}

int CvProcessInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

// Arrays
int CvProcessInfo::getProductionToCrimeModifier() const
{
	return m_iProductionToCrimeModifier;
}
int CvProcessInfo::getProductionToCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiProductionToCommerceModifier ? m_paiProductionToCommerceModifier[i] : -1;
}

bool CvProcessInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iProductionToCrimeModifier, "iProductionToCrimeModifier");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ProductionToCommerceModifiers"))
	{
		pXML->SetCommerce(&m_paiProductionToCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiProductionToCommerceModifier, NUM_COMMERCE_TYPES);
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvProcessInfo::copyNonDefaults(CvProcessInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTechPrereq()								== NO_TECH)		m_iTechPrereq							= pClassInfo->getTechPrereq();
	if (getProductionToCrimeModifier == 0) m_iProductionToCrimeModifier = pClassInfo->getProductionToCrimeModifier();
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if (m_paiProductionToCommerceModifier[i]	== 0)			m_paiProductionToCommerceModifier[i]	= pClassInfo->getProductionToCommerceModifier(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvVoteInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvVoteInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvVoteInfo::CvVoteInfo() :
m_iPopulationThreshold(0),
m_iStateReligionVotePercent(0),
m_iTradeRoutes(0),
m_iMinVoters(0),
m_bSecretaryGeneral(false),
m_bVictory(false),
m_bFreeTrade(false),
m_bNoNukes(false),
m_bCityVoting(false),
m_bCivVoting(false),
m_bDefensivePact(false),
m_bOpenBorders(false),
m_bForcePeace(false),
m_bForceNoTrade(false),
m_bForceWar(false),
m_bAssignCity(false),
m_pbForceCivic(NULL),
m_abVoteSourceTypes(NULL),

//FfH: Added by Kael 11/14/2007
m_bGamblingRing(false),
m_bNoOutsideTechTrades(false),
m_bSlaveTrade(false),
m_bSmugglingRing(false),
m_iCost(0),
m_iCrime(0),
m_iFreeUnits(0),
m_iFreeUnitClass(NO_UNITCLASS),
m_iNoBonus(NO_BONUS)
//FfH: End Add

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvVoteInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvVoteInfo::~CvVoteInfo()
{
	SAFE_DELETE_ARRAY(m_pbForceCivic);
	SAFE_DELETE_ARRAY(m_abVoteSourceTypes);
}

int CvVoteInfo::getPopulationThreshold() const
{
	return m_iPopulationThreshold;
}

int CvVoteInfo::getStateReligionVotePercent() const
{
	return m_iStateReligionVotePercent;
}

int CvVoteInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvVoteInfo::getMinVoters() const
{
	return m_iMinVoters;
}

bool CvVoteInfo::isSecretaryGeneral() const
{
	return m_bSecretaryGeneral;
}

bool CvVoteInfo::isVictory() const
{
	return m_bVictory;
}

bool CvVoteInfo::isFreeTrade() const
{
	return m_bFreeTrade;
}

bool CvVoteInfo::isNoNukes() const
{
	return m_bNoNukes;
}

bool CvVoteInfo::isCityVoting() const
{
	return m_bCityVoting;
}

bool CvVoteInfo::isCivVoting() const
{
	return m_bCivVoting;
}

bool CvVoteInfo::isDefensivePact() const
{
	return m_bDefensivePact;
}

bool CvVoteInfo::isOpenBorders() const
{
	return m_bOpenBorders;
}

bool CvVoteInfo::isForcePeace() const
{
	return m_bForcePeace;
}

bool CvVoteInfo::isForceNoTrade() const
{
	return m_bForceNoTrade;
}

bool CvVoteInfo::isForceWar() const
{
	return m_bForceWar;
}

bool CvVoteInfo::isAssignCity() const
{
	return m_bAssignCity;
}

//FfH: Added by Kael 11/14/2007
bool CvVoteInfo::isGamblingRing() const
{
	return m_bGamblingRing;
}

bool CvVoteInfo::isNoOutsideTechTrades() const
{
	return m_bNoOutsideTechTrades;
}

bool CvVoteInfo::isSlaveTrade() const
{
	return m_bSlaveTrade;
}

bool CvVoteInfo::isSmugglingRing() const
{
	return m_bSmugglingRing;
}

int CvVoteInfo::getCost() const
{
	return m_iCost;
}

int CvVoteInfo::getCrime() const
{
	return m_iCrime;
}

int CvVoteInfo::getFreeUnitClass() const
{
	return m_iFreeUnitClass;
}

int CvVoteInfo::getFreeUnits() const
{
	return m_iFreeUnits;
}

int CvVoteInfo::getNoBonus() const
{
	return m_iNoBonus;
}

const TCHAR *CvVoteInfo::getPyResult() const
{
	return m_szPyResult;
}
//FfH: End Add

bool CvVoteInfo::isForceCivic(int i) const
{
	FAssertMsg(i < GC.getNumCivicInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbForceCivic ? m_pbForceCivic[i] : false;
}

bool CvVoteInfo::isVoteSourceType(int i) const
{
	FAssertMsg(i < GC.getNumVoteSourceInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_abVoteSourceTypes ? m_abVoteSourceTypes[i] : false;
}

bool CvVoteInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iPopulationThreshold, "iPopulationThreshold");
	pXML->GetChildXmlValByName(&m_iStateReligionVotePercent, "iStateReligionVotePercent");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_iMinVoters, "iMinVoters");

	pXML->GetChildXmlValByName(&m_bSecretaryGeneral, "bSecretaryGeneral");
	pXML->GetChildXmlValByName(&m_bVictory, "bVictory");
	pXML->GetChildXmlValByName(&m_bFreeTrade, "bFreeTrade");
	pXML->GetChildXmlValByName(&m_bNoNukes, "bNoNukes");
	pXML->GetChildXmlValByName(&m_bCityVoting, "bCityVoting");
	pXML->GetChildXmlValByName(&m_bCivVoting, "bCivVoting");
	pXML->GetChildXmlValByName(&m_bDefensivePact, "bDefensivePact");
	pXML->GetChildXmlValByName(&m_bOpenBorders, "bOpenBorders");
	pXML->GetChildXmlValByName(&m_bForcePeace, "bForcePeace");
	pXML->GetChildXmlValByName(&m_bForceNoTrade, "bForceNoTrade");
	pXML->GetChildXmlValByName(&m_bForceWar, "bForceWar");
	pXML->GetChildXmlValByName(&m_bAssignCity, "bAssignCity");

	pXML->SetVariableListTagPair(&m_pbForceCivic, "ForceCivics", sizeof(GC.getCivicInfo((CivicTypes)0)), GC.getNumCivicInfos());
	pXML->SetVariableListTagPair(&m_abVoteSourceTypes, "DiploVotes", sizeof(GC.getVoteSourceInfo((VoteSourceTypes)0)), GC.getNumVoteSourceInfos());

//FfH: Added by Kael 11/14/2007
	CvString szTextVal;
	pXML->GetChildXmlValByName(&m_bGamblingRing, "bGamblingRing");
	pXML->GetChildXmlValByName(&m_bNoOutsideTechTrades, "bNoOutsideTechTrades");
	pXML->GetChildXmlValByName(&m_bSlaveTrade, "bSlaveTrade");
	pXML->GetChildXmlValByName(&m_bSmugglingRing, "bSmugglingRing");
	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_iCrime, "iCrime");
	pXML->GetChildXmlValByName(&m_iFreeUnits, "iFreeUnits");
	pXML->GetChildXmlValByName(szTextVal, "FreeUnitClass");
	m_iFreeUnitClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "NoBonus");
	m_iNoBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(m_szPyResult, "PyResult");
//FfH: End Add

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvVoteInfo::copyNonDefaults(CvVoteInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isSecretaryGeneral()			== false)			m_bSecretaryGeneral				= pClassInfo->isSecretaryGeneral();
	if (isVictory()						== false)			m_bVictory						= pClassInfo->isVictory();
	if (isFreeTrade()					== false)			m_bFreeTrade					= pClassInfo->isFreeTrade();
	if (isNoNukes()						== false)			m_bNoNukes						= pClassInfo->isNoNukes();
	if (isCityVoting()					== false)			m_bCityVoting					= pClassInfo->isCityVoting();
	if (isCivVoting()					== false)			m_bCivVoting					= pClassInfo->isCivVoting();
	if (isDefensivePact()				== false)			m_bDefensivePact				= pClassInfo->isDefensivePact();
	if (isOpenBorders()					== false)			m_bOpenBorders					= pClassInfo->isOpenBorders();
	if (isForcePeace()					== false)			m_bForcePeace					= pClassInfo->isForcePeace();
	if (isForceNoTrade()				== false)			m_bForceNoTrade					= pClassInfo->isForceNoTrade();
	if (isForceWar()					== false)			m_bForceWar						= pClassInfo->isForceWar();
	if (isAssignCity()					== false)			m_bAssignCity					= pClassInfo->isAssignCity();
	if (isGamblingRing()				== false)			m_bGamblingRing					= pClassInfo->isGamblingRing();
	if (isNoOutsideTechTrades()			== false)			m_bNoOutsideTechTrades			= pClassInfo->isNoOutsideTechTrades();
	if (isSlaveTrade()					== false)			m_bSlaveTrade					= pClassInfo->isSlaveTrade();
	if (isSmugglingRing()				== false)			m_bSmugglingRing				= pClassInfo->isSmugglingRing();
	if (getPopulationThreshold()		== 0)				m_iPopulationThreshold			= pClassInfo->getPopulationThreshold();
	if (getStateReligionVotePercent()	== 0)				m_iStateReligionVotePercent		= pClassInfo->getStateReligionVotePercent();
	if (getTradeRoutes()				== 0)				m_iTradeRoutes					= pClassInfo->getTradeRoutes();
	if (getMinVoters()					== 0)				m_iMinVoters					= pClassInfo->getMinVoters();
	if (getCost()						== 0)				m_iCost							= pClassInfo->getCost();
	if (getCrime()						== 0)				m_iCrime						= pClassInfo->getCrime();
	if (getFreeUnits()					== 0)				m_iFreeUnits					= pClassInfo->getFreeUnits();
	if (getPyResult()					== cDefault)		m_szPyResult					= pClassInfo->getPyResult();
	if (getNoBonus()					== NO_BONUS)		m_iNoBonus						= pClassInfo->getNoBonus();
	if (getFreeUnitClass()				== NO_UNITCLASS)	m_iFreeUnitClass				= pClassInfo->getFreeUnitClass();
	for ( int i = 0; i < GC.getNumCivicInfos(); i++ )
	{
		if (isForceCivic(i)				== false)	m_pbForceCivic[i]				= pClassInfo->isForceCivic(i);
	}

	for ( int i = 0; i < GC.getNumVoteSourceInfos(); i++ )
	{
		if (isVoteSourceType(i)			== false)	m_abVoteSourceTypes[i]			= pClassInfo->isVoteSourceType(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvProjectInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvProjectInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvProjectInfo::CvProjectInfo() :
m_iVictoryPrereq(NO_VICTORY),
m_iTechPrereq(NO_TECH),
m_iAnyoneProjectPrereq(NO_PROJECT),
/*************************************************************************************************/
/**	New Tag Defs	(ProjectInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iMaxGlobalInstances(0),
m_iMaxTeamInstances(0),
/**								----  End Original Code  ----									**/
m_iMaxGlobalInstances(-1),
m_iMaxTeamInstances(-1),
m_bResetProjects(false),
m_bPrereqWar(false),
m_bPrereqBlockBonuses(false),
m_piPrereqAlignments(NULL),
m_iNumPrereqAlignments(0),
m_iPrereqBroadAlignment(0),
m_iAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_piPrereqEthicalAlignments(NULL),
m_iNumPrereqEthicalAlignments(0),
m_iPrereqBroadEthicalAlignment(0),
m_iEthicalAlignmentModifier(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iBlockBonuses(0),
m_iRestoreBonuses(0),
m_iRevealAllBonuses(0),
m_iHideUnits(0),
m_iSeeInvisible(0),
m_iCooldown(-1),
m_bResistable(false),
m_iResistBase(0),
m_iResistMax(0),
m_iResistMin(0),
m_iForcePeaceWithCivilization(NO_CIVILIZATION),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_iProductionCost(0),
m_iNukeInterception(0),
m_iTechShare(0),
m_iEveryoneSpecialUnit(NO_SPECIALUNIT),
m_iEveryoneSpecialBuilding(NO_SPECIALBUILDING),
m_iVictoryDelayPercent(0),
m_iSuccessRate(0),
m_bSpaceship(false),
m_bAllowsNukes(false),
m_piBonusProductionModifier(NULL),
m_piVictoryThreshold(NULL),
m_piVictoryMinThreshold(NULL),
m_piProjectsNeeded(NULL),

//FfH: Added by Kael 08/26/2008
m_iAIWeight(0),
m_iModifyGlobalCounter(0),
m_iNumPrereqCivilizations(0),
m_piPrereqCivilizations(NULL),
m_iPrereqGlobalCounter(0)
//FfH: End Add

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvProjectInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvProjectInfo::~CvProjectInfo()
{
/*************************************************************************************************/
/**	New Tag Defs	(ProjectInfos)			09/12/08								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqAlignments);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	SAFE_DELETE_ARRAY(m_piVictoryThreshold);
	SAFE_DELETE_ARRAY(m_piVictoryMinThreshold);
	SAFE_DELETE_ARRAY(m_piProjectsNeeded);
	SAFE_DELETE_ARRAY(m_piPrereqCivilizations);
}

int CvProjectInfo::getVictoryPrereq() const
{
	return m_iVictoryPrereq;
}

int CvProjectInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvProjectInfo::getAnyoneProjectPrereq() const
{
	return m_iAnyoneProjectPrereq;
}

void CvProjectInfo::setAnyoneProjectPrereq(int i)
{
	m_iAnyoneProjectPrereq = i;
}

/*************************************************************************************************/
/**	New Tag Defs	(ProjectInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvProjectInfo::getPrereqAlignment(int iI) const							{return (getNumPrereqAlignments() > iI) ? m_piPrereqAlignments[iI] : -1;}
int CvProjectInfo::getNumPrereqAlignments() const							{return m_iNumPrereqAlignments;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvProjectInfo::getPrereqEthicalAlignment(int iI) const					{return (getNumPrereqEthicalAlignments() > iI) ? m_piPrereqEthicalAlignments[iI] : -1;}
int CvProjectInfo::getNumPrereqEthicalAlignments() const					{return m_iNumPrereqEthicalAlignments;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
bool CvProjectInfo::isResetProjects() const									{return m_bResetProjects;}
bool CvProjectInfo::isPrereqWar() const										{return m_bPrereqWar;}
bool CvProjectInfo::isPrereqBlockBonuses() const							{return m_bPrereqBlockBonuses;}
int CvProjectInfo::getPrereqBroadAlignment() const							{return m_iPrereqBroadAlignment;}
int CvProjectInfo::getAlignmentModifier() const								{return m_iAlignmentModifier;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvProjectInfo::getPrereqBroadEthicalAlignment() const					{return m_iPrereqBroadEthicalAlignment;}
int CvProjectInfo::getEthicalAlignmentModifier() const						{return m_iEthicalAlignmentModifier;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
int CvProjectInfo::getBlockBonuses() const									{return m_iBlockBonuses;}
int CvProjectInfo::getRestoreBonuses() const								{return m_iRestoreBonuses;}
int CvProjectInfo::getRevealAllBonuses() const								{return m_iRevealAllBonuses;}
int CvProjectInfo::getHideUnits() const										{return m_iHideUnits;}
int CvProjectInfo::getSeeInvisible() const									{return m_iSeeInvisible;}
int CvProjectInfo::getCooldown() const										{return m_iCooldown;}
bool CvProjectInfo::isResistable() const									{return m_bResistable;}
int CvProjectInfo::getResistBase() const									{return m_iResistBase;}
int CvProjectInfo::getResistMax() const										{return m_iResistMax;}
int CvProjectInfo::getResistMin() const										{return m_iResistMin;}
int CvProjectInfo::getForcePeaceWithCivilization() const					{return m_iForcePeaceWithCivilization;}
int CvProjectInfo::getPrereqCivilization(int iI) const				{return (getNumPrereqCivilizations() > iI)	? m_piPrereqCivilizations[iI]					: -1;}
int CvProjectInfo::getNumPrereqCivilizations() const					{return m_iNumPrereqCivilizations;}
CvString CvProjectInfo::getPrereqCivilizationsVectorElement(int i)			{return m_aszPrereqCivilizationsforPass3[i];}
int CvProjectInfo::getForcePeaceWithCivilizationVectorSize()				{return m_aszExtraXML2forPass3.size();}
CvString CvProjectInfo::getForcePeaceWithCivilizationVectorElement(int i)	{return m_aszExtraXML2forPass3[i];}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
int CvProjectInfo::getMaxGlobalInstances() const
{
	return m_iMaxGlobalInstances;
}

int CvProjectInfo::getMaxTeamInstances() const
{
	return m_iMaxTeamInstances;
}

int CvProjectInfo::getProductionCost() const
{
	return m_iProductionCost;
}

int CvProjectInfo::getNukeInterception() const
{
	return m_iNukeInterception;
}

int CvProjectInfo::getTechShare() const
{
	return m_iTechShare;
}

int CvProjectInfo::getEveryoneSpecialUnit() const
{
	return m_iEveryoneSpecialUnit;
}

int CvProjectInfo::getEveryoneSpecialBuilding() const
{
	return m_iEveryoneSpecialBuilding;
}

int CvProjectInfo::getVictoryDelayPercent() const
{
	return m_iVictoryDelayPercent;
}

int CvProjectInfo::getSuccessRate() const
{
	return m_iSuccessRate;
}

bool CvProjectInfo::isSpaceship() const
{
	return m_bSpaceship;
}

bool CvProjectInfo::isAllowsNukes() const
{
	return m_bAllowsNukes;
}

const char* CvProjectInfo::getMovieArtDef() const
{
	return m_szMovieArtDef;
}

const TCHAR* CvProjectInfo::getCreateSound() const
{
	return m_szCreateSound;
}

void CvProjectInfo::setCreateSound(const TCHAR* szVal)
{
	m_szCreateSound = szVal;
}

//FfH: Added by Kael 08/26/2008
int CvProjectInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvProjectInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvProjectInfo::getPrereqGlobalCounter() const
{
	return m_iPrereqGlobalCounter;
}
//FfH: End Add

// Arrays

int CvProjectInfo::getBonusProductionModifier(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusProductionModifier ? m_piBonusProductionModifier[i] : -1;
}

int CvProjectInfo::getVictoryThreshold(int i) const
{
	FAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piVictoryThreshold ? m_piVictoryThreshold[i] : -1;
}

int CvProjectInfo::getVictoryMinThreshold(int i) const
{
	FAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (m_piVictoryMinThreshold && m_piVictoryMinThreshold[i] != 0)
	{
		return m_piVictoryMinThreshold[i];
	}

	return getVictoryThreshold(i);
}

int CvProjectInfo::getProjectsNeeded(int i) const
{
	FAssertMsg(i < GC.getNumProjectInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProjectsNeeded ? m_piProjectsNeeded[i] : false;
}

bool CvProjectInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "VictoryPrereq");
	m_iVictoryPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	New Tag Defs	(ProjectInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(&m_iMaxGlobalInstances, "iMaxGlobalInstances");
	pXML->GetChildXmlValByName(&m_iMaxTeamInstances, "iMaxTeamInstances");
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(&m_iMaxGlobalInstances, "iMaxGlobalInstances", -1);
	pXML->GetChildXmlValByName(&m_iMaxTeamInstances, "iMaxTeamInstances", -1);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqAlignments"))
		pXML->SetIntWithChildList(&m_iNumPrereqAlignments, &m_piPrereqAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqEthicalAlignments"))
		pXML->SetIntWithChildList(&m_iNumPrereqEthicalAlignments, &m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bResetProjects, "bResetProjects");
	pXML->GetChildXmlValByName(&m_bPrereqWar, "bPrereqWar");
	pXML->GetChildXmlValByName(&m_bPrereqBlockBonuses, "bPrereqBlockBonuses");
	pXML->GetChildXmlValByName(&m_iPrereqBroadAlignment, "iPrereqBroadAlignment");
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqBroadEthicalAlignment, "iPrereqBroadEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iRevealAllBonuses, "iRevealAllBonuses");
	pXML->GetChildXmlValByName(&m_iBlockBonuses, "iBlockBonuses");
	pXML->GetChildXmlValByName(&m_iRestoreBonuses, "iRestoreBonuses");
	pXML->GetChildXmlValByName(&m_iHideUnits, "iHideUnits");
	pXML->GetChildXmlValByName(&m_iSeeInvisible, "iSeeInvisible");
	pXML->GetChildXmlValByName(&m_iCooldown, "iCooldown", -1);
	pXML->GetChildXmlValByName(&m_bResistable, "bResistable");
	pXML->GetChildXmlValByName(&m_iResistBase, "iResistBase");
	pXML->GetChildXmlValByName(&m_iResistMax, "iResistMax");
	pXML->GetChildXmlValByName(&m_iResistMin, "iResistMin");
	pXML->GetChildXmlValByName(szTextVal, "ForcePeaceWithCivilization");
	m_aszExtraXML2forPass3.push_back(szTextVal);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iProductionCost, "iCost");
	pXML->GetChildXmlValByName(&m_iNukeInterception, "iNukeInterception");
	pXML->GetChildXmlValByName(&m_iTechShare, "iTechShare");

	pXML->GetChildXmlValByName(szTextVal, "EveryoneSpecialUnit");
	m_iEveryoneSpecialUnit = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "EveryoneSpecialBuilding");
	m_iEveryoneSpecialBuilding = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bSpaceship, "bSpaceship");
	pXML->GetChildXmlValByName(&m_bAllowsNukes, "bAllowsNukes");
	pXML->GetChildXmlValByName(m_szMovieArtDef, "MovieDefineTag");

	pXML->SetVariableListTagPair(&m_piBonusProductionModifier, "BonusProductionModifiers", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piVictoryThreshold, "VictoryThresholds", sizeof(GC.getVictoryInfo((VictoryTypes)0)), GC.getNumVictoryInfos());
	pXML->SetVariableListTagPair(&m_piVictoryMinThreshold, "VictoryMinThresholds", sizeof(GC.getVictoryInfo((VictoryTypes)0)), GC.getNumVictoryInfos());
	pXML->GetChildXmlValByName(&m_iVictoryDelayPercent, "iVictoryDelayPercent");
	pXML->GetChildXmlValByName(&m_iSuccessRate, "iSuccessRate");

	pXML->GetChildXmlValByName(szTextVal, "CreateSound");
	setCreateSound(szTextVal);

//FfH: Added by Kael 08/26/2008
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter, "iModifyGlobalCounter");
	pXML->GetChildXmlValByName(&m_iPrereqGlobalCounter, "iPrereqGlobalCounter");
//FfH: End Add

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqCivilizations"))	pXML->SetStringWithChildList(&m_iNumPrereqCivilizations, &m_aszPrereqCivilizationsforPass3);

	return true;
}

bool CvProjectInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piProjectsNeeded, "PrereqProjects", sizeof(GC.getProjectInfo((ProjectTypes)0)), GC.getNumProjectInfos());

	pXML->GetChildXmlValByName(szTextVal, "AnyonePrereqProject");
	m_iAnyoneProjectPrereq = GC.getInfoTypeForString(szTextVal);

	return true;
}

//FfH: Added by Kael 08/26/2008
bool CvProjectInfo::readPass3()
{
/*************************************************************************************************/
/**	New Tag Defs	(ProjectInfos)			12/31/08								Xienwolf	**/
/**																								**/
/**					Third Pass to reference information which didn't exist before				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_aszExtraXMLforPass3.clear();
/**								----  End Original Code  ----									**/
	m_piPrereqCivilizations = new int[m_iNumPrereqCivilizations];
	for(int iI = 0; iI < m_iNumPrereqCivilizations; iI++)
		m_piPrereqCivilizations[iI] = GC.getInfoTypeForString(m_aszPrereqCivilizationsforPass3[iI]);
	m_aszPrereqCivilizationsforPass3.clear();

	int iSize = m_aszExtraXML2forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML2forPass3[i], true) != -1)
		{
			m_iForcePeaceWithCivilization = GC.getInfoTypeForString(m_aszExtraXML2forPass3[i]);
			break;
		}
	}
	m_aszExtraXML2forPass3.clear();
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(ProjectInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvProjectInfo::copyNonDefaults(CvProjectInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isSpaceship()						== false)				m_bSpaceship					= pClassInfo->isSpaceship();
	if (isAllowsNukes()						== false)				m_bAllowsNukes					= pClassInfo->isAllowsNukes();
	if (isResetProjects()					== false)				m_bResetProjects				= pClassInfo->isResetProjects();
	if (isPrereqWar()						== false)				m_bPrereqWar					= pClassInfo->isPrereqWar();
	if (isPrereqBlockBonuses()				== false)				m_bPrereqBlockBonuses			= pClassInfo->isPrereqBlockBonuses();
	if (isResistable()						== false)				m_bResistable					= pClassInfo->isResistable();
	if (getProductionCost()					== 0)					m_iProductionCost				= pClassInfo->getProductionCost();
	if (getNukeInterception()				== 0)					m_iNukeInterception				= pClassInfo->getNukeInterception();
	if (getTechShare()						== 0)					m_iTechShare					= pClassInfo->getTechShare();
	if (getVictoryDelayPercent()			== 0)					m_iVictoryDelayPercent			= pClassInfo->getVictoryDelayPercent();
	if (getSuccessRate()					== 0)					m_iSuccessRate					= pClassInfo->getSuccessRate();
	if (getPrereqBroadAlignment()			== 0)					m_iPrereqBroadAlignment			= pClassInfo->getPrereqBroadAlignment();
	if (getAlignmentModifier()				== 0)					m_iAlignmentModifier			= pClassInfo->getAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getPrereqBroadEthicalAlignment()    == 0)                   m_iPrereqBroadEthicalAlignment  = pClassInfo->getPrereqBroadEthicalAlignment();
	if (getEthicalAlignmentModifier()       == 0)                   m_iEthicalAlignmentModifier     = pClassInfo->getEthicalAlignmentModifier();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getRevealAllBonuses()				== 0)					m_iRevealAllBonuses				= pClassInfo->getRevealAllBonuses();
	if (getBlockBonuses()					== 0)					m_iBlockBonuses					= pClassInfo->getBlockBonuses();
	if (getRestoreBonuses()					== 0)					m_iRestoreBonuses				= pClassInfo->getRestoreBonuses();
	if (getHideUnits()						== 0)					m_iHideUnits					= pClassInfo->getHideUnits();
	if (getSeeInvisible()					== 0)					m_iSeeInvisible					= pClassInfo->getSeeInvisible();
	if (getResistBase()						== 0)					m_iResistBase					= pClassInfo->getResistBase();
	if (getResistMax()						== 0)					m_iResistMax					= pClassInfo->getResistMax();
	if (getResistMin()						== 0)					m_iResistMin					= pClassInfo->getResistMin();
	if (getPrereqGlobalCounter()			== 0)					m_iPrereqGlobalCounter			= pClassInfo->getPrereqGlobalCounter();
	if (getAIWeight()						== 0)					m_iAIWeight						= pClassInfo->getAIWeight();
	if (getModifyGlobalCounter()			== 0)					m_iModifyGlobalCounter			= pClassInfo->getModifyGlobalCounter();
	if (getCooldown()						== -1)					m_iCooldown						= pClassInfo->getCooldown();
	if (getMaxGlobalInstances()				== -1)					m_iMaxGlobalInstances			= pClassInfo->getMaxGlobalInstances();
	if (getMaxTeamInstances()				== -1)					m_iMaxTeamInstances				= pClassInfo->getMaxTeamInstances();
	if (getMovieArtDef()					== cDefault)			m_szMovieArtDef					= pClassInfo->getMovieArtDef();
	if (getCreateSound()					== cDefault)			setCreateSound(					pClassInfo->getCreateSound());
	if (getTechPrereq()						== NO_TECH)				m_iTechPrereq					= pClassInfo->getTechPrereq();
	if (getVictoryPrereq()					== NO_VICTORY)			m_iVictoryPrereq				= pClassInfo->getVictoryPrereq();
	if (getEveryoneSpecialUnit()			== NO_SPECIALUNIT)		m_iEveryoneSpecialUnit			= pClassInfo->getEveryoneSpecialUnit();
	if (getEveryoneSpecialBuilding()		== NO_SPECIALBUILDING)	m_iEveryoneSpecialBuilding		= pClassInfo->getEveryoneSpecialBuilding();
	for (int i = 0; i < GC.getNumBonusInfos(); i++)
	{
		if (m_piBonusProductionModifier[i]	== 0) 					m_piBonusProductionModifier[i]	= pClassInfo->getBonusProductionModifier(i);
	}
	for (int i = 0; i < GC.getNumVictoryInfos(); i++)
	{
		if (m_piVictoryThreshold[i]			== 0) 					m_piVictoryThreshold[i]			= pClassInfo->getVictoryThreshold(i);
		if (m_piVictoryMinThreshold[i]		== 0)					m_piVictoryMinThreshold[i]		= pClassInfo->getVictoryMinThreshold(i);
	}

	if(pClassInfo->getNumPrereqAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqAlignments() + pClassInfo->getNumPrereqAlignments()];
		for(int i = 0; i< getNumPrereqAlignments(); ++i)
		{
			tempArray[i] = getPrereqAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqAlignments();++j)
			{
				if(pClassInfo->getPrereqAlignment(i) == getPrereqAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqAlignments()] = pClassInfo->getPrereqAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqAlignments);
		int iGoalSize = getNumPrereqAlignments() + iNewItems;
		m_piPrereqAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqAlignments[i] < NUM_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
if(pClassInfo->getNumPrereqEthicalAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqEthicalAlignments() + pClassInfo->getNumPrereqEthicalAlignments()];
		for(int i = 0; i< getNumPrereqEthicalAlignments(); ++i)
		{
			tempArray[i] = getPrereqEthicalAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqEthicalAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqEthicalAlignments();++j)
			{
				if(pClassInfo->getPrereqEthicalAlignment(i) == getPrereqEthicalAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqEthicalAlignments()] = pClassInfo->getPrereqEthicalAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
		int iGoalSize = getNumPrereqEthicalAlignments() + iNewItems;
		m_piPrereqEthicalAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqEthicalAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqEthicalAlignments[i] < NUM_ETHICAL_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqEthicalAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqEthicalAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

	// Readpass2 stuff
	if (m_iAnyoneProjectPrereq				== NO_PROJECT)			m_iAnyoneProjectPrereq			= pClassInfo->getAnyoneProjectPrereq();
	if(!m_piProjectsNeeded)											pXML->InitList(&m_piProjectsNeeded, GC.getNumProjectInfos(), 0);
	for (int i = 0; i < GC.getNumProjectInfos(); ++i)
	{
		if(getProjectsNeeded(i)				== 0)					m_piProjectsNeeded[i]			= pClassInfo->getProjectsNeeded(i);
	}

	// Readpass3 stuff
	for(int i = 0; i < pClassInfo->getNumPrereqCivilizations(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqCivilizations();++j)
		{
			if(pClassInfo->getPrereqCivilizationsVectorElement(i) == getPrereqCivilizationsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqCivilizationsforPass3.push_back(	pClassInfo->getPrereqCivilizationsVectorElement(i));
			m_iNumPrereqCivilizations++;
		}
	}
	for ( int i = 0; i < pClassInfo->getForcePeaceWithCivilizationVectorSize(); i++ )
	{
														m_aszExtraXML2forPass3.push_back(		pClassInfo->getForcePeaceWithCivilizationVectorElement(i));
	}
}

void CvProjectInfo::copyNonDefaultsReadPass2(CvProjectInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if(!m_piProjectsNeeded)											pXML->InitList(&m_piProjectsNeeded, GC.getNumProjectInfos(), 0);
	for (int i = 0; i < GC.getNumProjectInfos(); ++i)
	{
		if(bOver || pClassInfo->getProjectsNeeded(i)	!= 0)		m_piProjectsNeeded[i]			= pClassInfo->getProjectsNeeded(i);
	}

	if (bOver || pClassInfo->getAnyoneProjectPrereq()	!= -1)		m_iAnyoneProjectPrereq			= pClassInfo->getAnyoneProjectPrereq();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvReligionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvReligionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvReligionInfo::CvReligionInfo() :
m_iChar(0),
m_iHolyCityChar(0),
m_iTechPrereq(NO_TECH),
m_iFreeUnitClass(NO_UNITCLASS),
m_iNumFreeUnits(0),
m_iSpreadFactor(0),
m_iMissionType(NO_MISSION),
m_paiGlobalReligionCommerce(NULL),
m_paiHolyCityCommerce(NULL),
m_paiStateReligionCommerce(NULL),
//ClimateSystem:
m_iFormClimateZoneType(NO_CLIMATEZONE),
/*************************************************************************************************/
/**	Stasis									11/17/09								Valkrionn	**/
/**																								**/
/**			Adds new commerces to Religions			**/
/*************************************************************************************************/
m_paiGlobalReligionYield(NULL),
m_paiHolyCityYield(NULL),
m_paiStateReligionYield(NULL),
/*************************************************************************************************/
/**	Stasis									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(ReligionInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iTGAIndex(-1),
m_iAlignmentModifier(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
m_iAlignmentShift(0),
m_iAlignmentShiftModifier(0),
m_iAlignmentShiftTowardsNeutral(-1),
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iEthicalAlignmentModifier(0),
m_iEthicalAlignmentShift(0),
m_iEthicalAlignmentShiftModifier(0),
m_iEthicalAlignmentShiftTowardsNeutral(-1),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Religion: Added by Kael 08/09/2007
m_bHidden(false),
m_bSneakAttack(false),
m_bUpdateSight(false),
m_iGlobalCounterFound(0),
m_iGlobalCounterSpread(0),
m_iAlignment(NO_ALIGNMENT),
m_iAlignmentBest(NO_ALIGNMENT),
m_iAlignmentWorst(NO_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iEthicalAlignment(NO_ETHICAL_ALIGNMENT),
m_iEthicalAlignmentBest(NO_ETHICAL_ALIGNMENT),
m_iEthicalAlignmentWorst(NO_ETHICAL_ALIGNMENT)
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Religion Based Music					02/09/10									Snarko	**/
/**				Changing music from eras to religions (or eras if no religion)					**/
/*************************************************************************************************/
,m_iNumSoundtracks(0),
m_paiSoundtracks(NULL)
/*************************************************************************************************/
/**	Religion Based Music						END												**/
/*************************************************************************************************/
//FfH: End Add

{
	reset();
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvReligionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvReligionInfo::~CvReligionInfo()
{
	SAFE_DELETE_ARRAY(m_paiGlobalReligionCommerce);
	SAFE_DELETE_ARRAY(m_paiHolyCityCommerce);
	SAFE_DELETE_ARRAY(m_paiStateReligionCommerce);
/*************************************************************************************************/
/**	Stasis									11/17/09								Valkrionn	**/
/**																								**/
/**			Adds new commerces to Religions			**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiGlobalReligionYield);
	SAFE_DELETE_ARRAY(m_paiHolyCityYield);
	SAFE_DELETE_ARRAY(m_paiStateReligionYield);
/*************************************************************************************************/
/**	Stasis									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Religion Based Music					02/09/10									Snarko	**/
/**				Changing music from eras to religions (or eras if no religion)					**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiSoundtracks);
/*************************************************************************************************/
/**	Religion Based Music						END												**/
/*************************************************************************************************/
}

int CvReligionInfo::getChar() const
{
	return m_iChar;
}

void CvReligionInfo::setChar(int i,int j)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iChar = i;
/**								----  End Original Code  ----									**/
	if (j == 8483)
	{
		m_iChar = 8550 + m_iTGAIndex * 2;
	}
	else
	{
		m_iChar = 325 + m_iTGAIndex * 2;

	}
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvReligionInfo::getHolyCityChar() const
{
	return m_iHolyCityChar;
}

void CvReligionInfo::setHolyCityChar(int i,int j)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iHolyCityChar = i;
/**								----  End Original Code  ----									**/
	if (j == 8483)
	{
		m_iHolyCityChar = 8551 + m_iTGAIndex * 2;
	}
	else
	{
		m_iHolyCityChar = 326 + m_iTGAIndex * 2;

	}
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvReligionInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvReligionInfo::getFreeUnitClass() const
{
	return m_iFreeUnitClass;
}

int CvReligionInfo::getNumFreeUnits() const
{
	return m_iNumFreeUnits;
}

int CvReligionInfo::getSpreadFactor() const
{
	return m_iSpreadFactor;
}

int CvReligionInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvReligionInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

//ClimateSystem:
int CvReligionInfo::getFormClimateZoneType() const
{
	return m_iFormClimateZoneType;
}

const TCHAR* CvReligionInfo::getTechButton() const
{
	return m_szTechButton;
}

void CvReligionInfo::setTechButton(const TCHAR* szVal)
{
	m_szTechButton=szVal;
}

const TCHAR* CvReligionInfo::getGenericTechButton() const
{
	return m_szGenericTechButton;
}

void CvReligionInfo::setGenericTechButton(const TCHAR* szVal)
{
	m_szGenericTechButton = szVal;
}

const TCHAR* CvReligionInfo::getMovieFile() const
{
	return m_szMovieFile;
}

void CvReligionInfo::setMovieFile(const TCHAR* szVal)
{
	m_szMovieFile = szVal;
}

const TCHAR* CvReligionInfo::getMovieSound() const
{
	return m_szMovieSound;
}

void CvReligionInfo::setMovieSound(const TCHAR* szVal)
{
	m_szMovieSound = szVal;
}

const TCHAR* CvReligionInfo::getButtonDisabled( void ) const
{
	static TCHAR szDisabled[512];

	szDisabled[0] = '\0';

	if ( getButton() && strlen(getButton()) > 4 )
	{
		strncpy( szDisabled, getButton(), strlen(getButton()) - 4 );
		szDisabled[strlen(getButton()) - 4] = '\0';
		strcat( szDisabled, "_D.dds" );
	}

	return szDisabled;
}

const TCHAR* CvReligionInfo::getSound() const
{
	return m_szSound;
}

void CvReligionInfo::setSound(const TCHAR* szVal)
{
	m_szSound=szVal;
}

void CvReligionInfo::setAdjectiveKey(const TCHAR* szVal)
{
	m_szAdjectiveKey = szVal;
}

const wchar* CvReligionInfo::getAdjectiveKey() const
{
	return m_szAdjectiveKey;
}

// Arrays

int CvReligionInfo::getGlobalReligionCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiGlobalReligionCommerce ? m_paiGlobalReligionCommerce[i] : -1;
}

int* CvReligionInfo::getGlobalReligionCommerceArray() const
{
	return m_paiGlobalReligionCommerce;
}

int CvReligionInfo::getHolyCityCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiHolyCityCommerce ? m_paiHolyCityCommerce[i] : -1;
}

int* CvReligionInfo::getHolyCityCommerceArray() const
{
	return m_paiHolyCityCommerce;
}

int CvReligionInfo::getStateReligionCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiStateReligionCommerce ? m_paiStateReligionCommerce[i] : -1;
}

int* CvReligionInfo::getStateReligionCommerceArray() const
{
	return m_paiStateReligionCommerce;
}


/*************************************************************************************************/
/**	Stasis									11/17/09								Valkrionn	**/
/**																								**/
/**			Adds new commerces to Religions			**/
/*************************************************************************************************/

int CvReligionInfo::getGlobalReligionYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiGlobalReligionYield ? m_paiGlobalReligionYield[i] : -1;
}

int* CvReligionInfo::getGlobalReligionYieldArray() const
{
	return m_paiGlobalReligionYield;
}

int CvReligionInfo::getHolyCityYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiHolyCityYield ? m_paiHolyCityYield[i] : -1;
}

int* CvReligionInfo::getHolyCityYieldArray() const
{
	return m_paiHolyCityYield;
}

int CvReligionInfo::getStateReligionYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiStateReligionYield ? m_paiStateReligionYield[i] : -1;
}

int* CvReligionInfo::getStateReligionYieldArray() const
{
	return m_paiStateReligionYield;
}
/*************************************************************************************************/
/**	Stasis									END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	New Tag Defs	(ReligionInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvReligionInfo::getTGAIndex() const						{return m_iTGAIndex;}
void CvReligionInfo::setTGAIndex(int i)						{m_iTGAIndex = i;}
int CvReligionInfo::getAlignmentModifier() const			{return m_iAlignmentModifier;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
int CvReligionInfo::getAlignmentShift() const                          {return m_iAlignmentShift;}
int CvReligionInfo::getAlignmentShiftModifier() const                  {return m_iAlignmentShiftModifier;}
int CvReligionInfo::getAlignmentShiftTowardsNeutral() const            {return m_iAlignmentShiftTowardsNeutral;}
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvReligionInfo::getEthicalAlignmentModifier() const				   	{return m_iEthicalAlignmentModifier;}
int CvReligionInfo::getEthicalAlignmentShift() const                    {return m_iEthicalAlignmentShift;}
int CvReligionInfo::getEthicalAlignmentShiftModifier() const            {return m_iEthicalAlignmentShiftModifier;}
int CvReligionInfo::getEthicalAlignmentShiftTowardsNeutral() const      {return m_iEthicalAlignmentShiftTowardsNeutral;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Religion: Added by Kael 08/09/2007
bool CvReligionInfo::isHidden() const
{
	return m_bHidden;
}

bool CvReligionInfo::isSneakAttack() const
{
	return m_bSneakAttack;
}

bool CvReligionInfo::isUpdateSight() const
{
	return m_bUpdateSight;
}

int CvReligionInfo::getGlobalCounterFound() const
{
	return m_iGlobalCounterFound;
}

int CvReligionInfo::getGlobalCounterSpread() const
{
	return m_iGlobalCounterSpread;
}

int CvReligionInfo::getAlignment() const
{
	return m_iAlignment;
}

int CvReligionInfo::getAlignmentBest() const
{
	return m_iAlignmentBest;
}

int CvReligionInfo::getAlignmentWorst() const
{
	return m_iAlignmentWorst;
}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvReligionInfo::getEthicalAlignment() const
{
	return m_iEthicalAlignment;
}

int CvReligionInfo::getEthicalAlignmentBest() const
{
	return m_iEthicalAlignmentBest;
}

int CvReligionInfo::getEthicalAlignmentWorst() const
{
	return m_iEthicalAlignmentWorst;
}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Religion Based Music					02/09/10									Snarko	**/
/**				Changing music from eras to religions (or eras if no religion)					**/
/*************************************************************************************************/
int CvReligionInfo::getNumSoundtracks() const
{
	return m_iNumSoundtracks;
}

int CvReligionInfo::getSoundtracks(int i) const
{
	FAssertMsg(i < getNumSoundtracks(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	return m_paiSoundtracks ? m_paiSoundtracks[i] : -1;
}
/*************************************************************************************************/
/**	Religion Based Music						END												**/
/*************************************************************************************************/
//FfH: End Add

//
// read from xml
//
bool CvReligionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeUnitClass");
	m_iFreeUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iNumFreeUnits, "iFreeUnits");
	pXML->GetChildXmlValByName(&m_iSpreadFactor, "iSpreadFactor");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalReligionCommerces"))
	{
		pXML->SetCommerce(&m_paiGlobalReligionCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiGlobalReligionCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HolyCityCommerces"))
	{
		pXML->SetCommerce(&m_paiHolyCityCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiHolyCityCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"StateReligionCommerces"))
	{
		pXML->SetCommerce(&m_paiStateReligionCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiStateReligionCommerce, NUM_COMMERCE_TYPES);
	}

/*************************************************************************************************/
/**	Stasis									11/17/09								Valkrionn	**/
/**																								**/
/**			Adds new commerces to Religions			**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalReligionYields"))
	{
		pXML->SetYields(&m_paiGlobalReligionYield);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiGlobalReligionYield, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HolyCityYields"))
	{
		pXML->SetYields(&m_paiHolyCityYield);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiHolyCityYield, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"StateReligionYields"))
	{
		pXML->SetYields(&m_paiStateReligionYield);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiStateReligionYield, NUM_YIELD_TYPES);
	}

/*************************************************************************************************/
/**	Stasis									END													**/
/*************************************************************************************************/

//ClimateSystem:
	pXML->GetChildXmlValByName(szTextVal, "FormClimateZoneType");
	if (szTextVal != "") m_iFormClimateZoneType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechButton");
	setTechButton(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GenericTechButton");
	setGenericTechButton(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieFile");
	setMovieFile(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieSound");
	setMovieSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Adjective");
	setAdjectiveKey(szTextVal);

/*************************************************************************************************/
/**	New Tag Defs	(ReligionInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iTGAIndex, "iTGAIndex");
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentShift, "iAlignmentShift");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftModifier, "iAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iAlignmentShiftTowardsNeutral, "iAlignmentShiftTowardsNeutral");
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShift, "iEthicalAlignmentShift");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftModifier, "iEthicalAlignmentShiftModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentShiftTowardsNeutral, "iEthicalAlignmentShiftTowardsNeutral");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Religions: Added by Kael 08/09/2007
	pXML->GetChildXmlValByName(&m_bHidden, "bHidden");
	pXML->GetChildXmlValByName(&m_bSneakAttack, "bSneakAttack");
	pXML->GetChildXmlValByName(&m_bUpdateSight, "bUpdateSight");
	pXML->GetChildXmlValByName(&m_iGlobalCounterFound, "iGlobalCounterFound");
	pXML->GetChildXmlValByName(&m_iGlobalCounterSpread, "iGlobalCounterSpread");
	pXML->GetChildXmlValByName(szTextVal, "Alignment");
	m_iAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AlignmentBest");
	m_iAlignmentBest = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AlignmentWorst");
	m_iAlignmentWorst = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "EthicalAlignment");
	m_iEthicalAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EthicalAlignmentBest");
	m_iEthicalAlignmentBest = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EthicalAlignmentWorst");
	m_iEthicalAlignmentWorst = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Religion Based Music					02/09/10									Snarko	**/
/**				Changing music from eras to religions (or eras if no religion)					**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ReligionInfoSoundtracks"))
	{
		CvString* pszSoundTrackNames = NULL;
		pXML->SetStringList(&pszSoundTrackNames, &m_iNumSoundtracks);

		if (m_iNumSoundtracks > 0)
		{
			m_paiSoundtracks = new int[m_iNumSoundtracks];

			int j;
			for (j=0;j<m_iNumSoundtracks;j++)
			{
				m_paiSoundtracks[j] = ((!gDLL->getAudioDisabled()) ? gDLL->getAudioTagIndex(pszSoundTrackNames[j], AUDIOTAG_2DSCRIPT) : -1);
			}
		}
		else
		{
			m_paiSoundtracks = NULL;
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

		SAFE_DELETE_ARRAY(pszSoundTrackNames);
	}
/*************************************************************************************************/
/**	Religion Based Music						END												**/
/*************************************************************************************************/
//FfH: End Add

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(ReligionInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvReligionInfo::copyNonDefaults(CvReligionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isHidden()							== false)			m_bHidden								= pClassInfo->isHidden();
	if (isSneakAttack()						== false)			m_bSneakAttack							= pClassInfo->isSneakAttack();
	if (isUpdateSight()						== false)			m_bUpdateSight							= pClassInfo->isUpdateSight();
	if (getNumFreeUnits()					== 0)				m_iNumFreeUnits							= pClassInfo->getNumFreeUnits();
	if (getSpreadFactor()					== 0)				m_iSpreadFactor							= pClassInfo->getSpreadFactor();
	if (getTGAIndex()						== 0)				m_iTGAIndex								= pClassInfo->getTGAIndex();
	if (getAlignmentModifier()				== 0)				m_iAlignmentModifier					= pClassInfo->getAlignmentModifier();
//ClimateSystem:
	if (getFormClimateZoneType()			== NO_CLIMATEZONE)	m_iFormClimateZoneType					= pClassInfo->getFormClimateZoneType();
/*************************************************************************************************/
/**	Expanded Broader Alignments 			11/03/09								Valkrionn	**/
/**																								**/
/**								Used to determine per turn shifts								**/
/*************************************************************************************************/
	if (getAlignmentShift()                 == 0)               m_iAlignmentShift                       = pClassInfo->getAlignmentShift();
	if (getAlignmentShiftModifier()         == 0)               m_iAlignmentShiftModifier               = pClassInfo->getAlignmentShiftModifier();
	if (getAlignmentShiftTowardsNeutral()   == -1)              m_iAlignmentShiftTowardsNeutral         = pClassInfo->getAlignmentShiftTowardsNeutral();
/*************************************************************************************************/
/**	Broader Alignments Expansion				END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getEthicalAlignmentModifier()				== 0)		m_iEthicalAlignmentModifier				= pClassInfo->getEthicalAlignmentModifier();
	if (getEthicalAlignmentShift()                 == 0)        m_iEthicalAlignmentShift                = pClassInfo->getEthicalAlignmentShift();
	if (getEthicalAlignmentShiftModifier()         == 0)        m_iEthicalAlignmentShiftModifier        = pClassInfo->getEthicalAlignmentShiftModifier();
	if (getEthicalAlignmentShiftTowardsNeutral()   == -1)       m_iEthicalAlignmentShiftTowardsNeutral  = pClassInfo->getEthicalAlignmentShiftTowardsNeutral();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getGlobalCounterFound()				== 0)				m_iGlobalCounterFound					= pClassInfo->getGlobalCounterFound();
	if (getGlobalCounterSpread()			== 0)				m_iGlobalCounterSpread					= pClassInfo->getGlobalCounterSpread();
	if (getTechButton()						== cDefault)		setTechButton(							pClassInfo->getTechButton());
	if (getGenericTechButton()				== cDefault)		setGenericTechButton(					pClassInfo->getGenericTechButton());
	if (getMovieFile()						== cDefault)		setMovieFile(							pClassInfo->getMovieFile());
	if (getMovieSound()						== cDefault)		setMovieSound(							pClassInfo->getMovieSound());
	if (getSound()							== cDefault)		setSound(								pClassInfo->getSound());
	if (getAdjectiveKey()					== wDefault)		setAdjectiveKey(CvString::format("%s",	pClassInfo->getAdjectiveKey()).GetCString());
	if (getTechPrereq()						== NO_TECH)			m_iTechPrereq							= pClassInfo->getTechPrereq();
	if (getFreeUnitClass()					== NO_UNITCLASS)	m_iFreeUnitClass						= pClassInfo->getFreeUnitClass();
	if (getAlignment()						== NO_ALIGNMENT)	m_iAlignment							= pClassInfo->getAlignment();
	if (getAlignmentBest()					== NO_ALIGNMENT)	m_iAlignmentBest						= pClassInfo->getAlignmentBest();
	if (getAlignmentWorst()					== NO_ALIGNMENT)	m_iAlignmentWorst						= pClassInfo->getAlignmentWorst();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getEthicalAlignment()				== NO_ETHICAL_ALIGNMENT)	m_iEthicalAlignment						= pClassInfo->getEthicalAlignment();
	if (getEthicalAlignmentBest()			== NO_ETHICAL_ALIGNMENT)	m_iEthicalAlignmentBest					= pClassInfo->getEthicalAlignmentBest();
	if (getEthicalAlignmentWorst()			== NO_ETHICAL_ALIGNMENT)	m_iEthicalAlignmentWorst				= pClassInfo->getEthicalAlignmentWorst();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		if (getGlobalReligionCommerce(i)	== 0)				m_paiGlobalReligionCommerce[i]			= pClassInfo->getGlobalReligionCommerce(i);
		if (getHolyCityCommerce(i)			== 0)				m_paiHolyCityCommerce[i]				= pClassInfo->getHolyCityCommerce(i);
		if (getStateReligionCommerce(i)		== 0)				m_paiStateReligionCommerce[i]			= pClassInfo->getStateReligionCommerce(i);
	}
/*************************************************************************************************/
/**	Stasis									11/17/09								Valkrionn	**/
/**																								**/
/**								Adds new commerces to Religions									**/
/*************************************************************************************************/
	for ( int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (getGlobalReligionYield(i)		== 0)				m_paiGlobalReligionYield[i]				= pClassInfo->getGlobalReligionYield(i);
		if (getHolyCityYield(i)				== 0)				m_paiHolyCityYield[i]					= pClassInfo->getHolyCityYield(i);
		if (getStateReligionYield(i)		== 0)				m_paiStateReligionYield[i]				= pClassInfo->getStateReligionYield(i);
	}
/*************************************************************************************************/
/**	Stasis									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Religion Based Music					02/09/10									Snarko	**/
/**				Changing music from eras to religions (or eras if no religion)					**/
/*************************************************************************************************/
	if (pClassInfo->getNumSoundtracks()	!= 0)
	{
		int iNumSoundTracks = getNumSoundtracks() + pClassInfo->getNumSoundtracks();
		int* m_paiSoundtracksTemp = new int[iNumSoundTracks];
		for (int i = 0; i < iNumSoundTracks; i++)
		{
			if (i < getNumSoundtracks())
			{
				m_paiSoundtracksTemp[i] = getSoundtracks(i);
			}
			else
			{
				m_paiSoundtracksTemp[i] = pClassInfo->getSoundtracks(i - getNumSoundtracks());
			}
		}
		SAFE_DELETE_ARRAY(m_paiSoundtracks);
		m_paiSoundtracks = new int[iNumSoundTracks];
		for (int i = 0; i < iNumSoundTracks; i++)
		{
														m_paiSoundtracks[i]				= m_paiSoundtracksTemp[i];
		}
		SAFE_DELETE_ARRAY(m_paiSoundtracksTemp);
	}
/*************************************************************************************************/
/**	Religion Based Music						END												**/
/*************************************************************************************************/
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCorporationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCorporationInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCorporationInfo::CvCorporationInfo() :
m_iChar(0),
/*************************************************************************************************/
/**	New Tag Defs	(CorporationInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
m_iTGAIndex(-1),
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
m_iHeadquarterChar(0),
m_iTechPrereq(NO_TECH),
m_iFreeUnitClass(NO_UNITCLASS),
m_iSpreadFactor(0),
m_iSpreadCost(0),
m_iMaintenance(0),
m_iMissionType(NO_MISSION),
m_iBonusProduced(NO_BONUS),
m_paiPrereqBonuses(NULL),
m_paiHeadquarterCommerce(NULL),
m_paiCommerceProduced(NULL),
m_paiYieldProduced(NULL)
{
	reset();
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCorporationInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCorporationInfo::~CvCorporationInfo()
{
	SAFE_DELETE_ARRAY(m_paiPrereqBonuses);
	SAFE_DELETE_ARRAY(m_paiHeadquarterCommerce);
	SAFE_DELETE_ARRAY(m_paiCommerceProduced);
	SAFE_DELETE_ARRAY(m_paiYieldProduced);
}

int CvCorporationInfo::getChar() const
{
	return m_iChar;
}

/*************************************************************************************************/
/**	New Tag Defs	(CorporationInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
int CvCorporationInfo::getTGAIndex() const
{
	return m_iTGAIndex;
}

void CvCorporationInfo::setTGAIndex(int i)
{
	m_iTGAIndex = i;
}
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
void CvCorporationInfo::setChar(int i, int j)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iChar = i;
/**								----  End Original Code  ----	
**/
	if (j == 8483)
	{
		m_iChar = 8550 + (GC.getDefineINT("GAMEFONT_TGA_RELIGIONS") + m_iTGAIndex) * 2;
	}
	else
	{
		m_iChar = 325 + (GC.getDefineINT("GAMEFONT_TGA_RELIGIONS") + m_iTGAIndex) * 2;

	}
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvCorporationInfo::getHeadquarterChar() const
{
	return m_iHeadquarterChar;
}

void CvCorporationInfo::setHeadquarterChar(int i,int j)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iHeadquarterChar = i;
/**								----  End Original Code  ----									**/
	if (j == 8483)
	{
		m_iHeadquarterChar = 8551 + (GC.getDefineINT("GAMEFONT_TGA_RELIGIONS") + m_iTGAIndex) * 2;
	}
	else
	{
		m_iHeadquarterChar = 326 + (GC.getDefineINT("GAMEFONT_TGA_RELIGIONS") + m_iTGAIndex) * 2;
	}
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvCorporationInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvCorporationInfo::getFreeUnitClass() const
{
	return m_iFreeUnitClass;
}

int CvCorporationInfo::getSpreadFactor() const
{
	return m_iSpreadFactor;
}

int CvCorporationInfo::getSpreadCost() const
{
	return m_iSpreadCost;
}

int CvCorporationInfo::getMaintenance() const
{
	return m_iMaintenance;
}

int CvCorporationInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvCorporationInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

int CvCorporationInfo::getBonusProduced() const
{
	return m_iBonusProduced;
}

const TCHAR* CvCorporationInfo::getMovieFile() const
{
	return m_szMovieFile;
}

void CvCorporationInfo::setMovieFile(const TCHAR* szVal)
{
	m_szMovieFile = szVal;
}

const TCHAR* CvCorporationInfo::getMovieSound() const
{
	return m_szMovieSound;
}

void CvCorporationInfo::setMovieSound(const TCHAR* szVal)
{
	m_szMovieSound = szVal;
}


const TCHAR* CvCorporationInfo::getSound() const
{
	return m_szSound;
}

void CvCorporationInfo::setSound(const TCHAR* szVal)
{
	m_szSound =szVal;
}

// Arrays

int CvCorporationInfo::getPrereqBonus(int i) const
{
	FAssertMsg(i < GC.getNUM_CORPORATION_PREREQ_BONUSES(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiPrereqBonuses[i];
}

int CvCorporationInfo::getHeadquarterCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiHeadquarterCommerce ? m_paiHeadquarterCommerce[i] : -1;
}

int* CvCorporationInfo::getHeadquarterCommerceArray() const
{
	return m_paiHeadquarterCommerce;
}

int CvCorporationInfo::getCommerceProduced(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiCommerceProduced ? m_paiCommerceProduced[i] : -1;
}

int* CvCorporationInfo::getCommerceProducedArray() const
{
	return m_paiCommerceProduced;
}

int CvCorporationInfo::getYieldProduced(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiYieldProduced ? m_paiYieldProduced[i] : -1;
}

int* CvCorporationInfo::getYieldProducedArray() const
{
	return m_paiYieldProduced;
}


//
// read from xml
//
bool CvCorporationInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeUnitClass");
	m_iFreeUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iSpreadFactor, "iSpreadFactor");
	pXML->GetChildXmlValByName(&m_iSpreadCost, "iSpreadCost");
	pXML->GetChildXmlValByName(&m_iMaintenance, "iMaintenance");
/*************************************************************************************************/
/**	New Tag Defs	(CorporationInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iTGAIndex, "iTGAIndex");
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HeadquarterCommerces"))
	{
		pXML->SetCommerce(&m_paiHeadquarterCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiHeadquarterCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommercesProduced"))
	{
		pXML->SetCommerce(&m_paiCommerceProduced);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiCommerceProduced, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldsProduced"))
	{
		pXML->SetYields(&m_paiYieldProduced);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiYieldProduced, NUM_YIELD_TYPES);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonuses"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg(0 < GC.getNUM_CORPORATION_PREREQ_BONUSES(),"Allocating zero or less memory in CvCorporationInfo::read");
			pXML->InitList(&m_paiPrereqBonuses, GC.getNUM_CORPORATION_PREREQ_BONUSES(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_CORPORATION_PREREQ_BONUSES()) , "There are more siblings than memory allocated for them in CvCorporationInfo::read");
					for (int j=0; j<iNumSibs; ++j)
					{
						m_paiPrereqBonuses[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_paiPrereqBonuses, GC.getNUM_CORPORATION_PREREQ_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "BonusProduced");
	m_iBonusProduced = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "MovieFile");
	setMovieFile(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieSound");
	setMovieSound(szTextVal);
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(szTextVal, "MovieFile", "NONE");
	setMovieFile(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieSound", "NONE");
	setMovieSound(szTextVal);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCorporationInfo::copyNonDefaults(CvCorporationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getTechPrereq()						== NO_TECH)			m_iTechPrereq				= pClassInfo->getTechPrereq();
	if (getFreeUnitClass()					== NO_UNITCLASS)	m_iFreeUnitClass			= pClassInfo->getFreeUnitClass();
	if (getSpreadFactor()					== 0)				m_iSpreadFactor				= pClassInfo->getSpreadFactor();
	if (getSpreadCost()						== 0)				m_iSpreadCost				= pClassInfo->getSpreadCost();
	if (getMaintenance()					== 0)				m_iMaintenance				= pClassInfo->getMaintenance();
	if (getTGAIndex()						== 0)				m_iTGAIndex					= pClassInfo->getTGAIndex();
	if (getBonusProduced()					== NO_BONUS)		m_iBonusProduced			= pClassInfo->getBonusProduced();
	if (getMovieFile()						== cDefault)		setMovieFile(				pClassInfo->getMovieFile());
	if (getMovieSound()						== cDefault)		setMovieSound(				pClassInfo->getMovieSound());
	if (getSound()							== cDefault)		setSound(					pClassInfo->getSound());
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if (m_paiHeadquarterCommerce[i]		== 0)				m_paiHeadquarterCommerce[i]	= pClassInfo->getHeadquarterCommerce(i);
		if (m_paiCommerceProduced[i]		== 0)				m_paiCommerceProduced[i]	= pClassInfo->getCommerceProduced(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_paiYieldProduced[i]			== 0)				m_paiYieldProduced[i]		= pClassInfo->getYieldProduced(i);
	}
	for ( int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); i++ )
	{
		if (m_paiPrereqBonuses[i]			== NO_BONUS)		m_paiPrereqBonuses[i]		= pClassInfo->getPrereqBonus(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvTraitInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTraitInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTraitInfo::CvTraitInfo() :
m_iTraitClass(NO_TRAITCLASS),
m_iNextTrait(NO_TRAIT),
m_iParentTrait(NO_TRAIT),

m_iHealth(0),
m_iHappiness(0),
m_iMaxAnarchy(0),
m_iFreeBuildingClass(NO_BUILDINGCLASS),
m_iUpkeepModifier(0),
m_iDistanceMaintenanceModifier(0),
m_iRitualProductionModifier(0),
m_iMilitaryProductionModifier(0),
m_iLevelExperienceModifier(0),
m_iGreatPeopleRateModifier(0),
m_iGreatGeneralRateModifier(0),
m_iExtraGrowthThreshold(0),
m_iACGrowthThreshold(0),
m_iDomesticGreatGeneralRateModifier(0),
m_iMaxGlobalBuildingProductionModifier(0),
m_iMaxTeamBuildingProductionModifier(0),
m_iMaxPlayerBuildingProductionModifier(0),

//FfH Trait: Added by Kael 08/02/2007
m_iLevel(0),
m_iMinRequiredPoints(0),
m_bCanBeLost(false),
m_bAdaptive(false),
m_bAgnostic(false),
m_bAmphibian(false),
m_bAssimilation(false),
m_bBarbarianAlly(false),
m_bIgnoreFood(false),
m_bIgnoreHealth(false),
m_bInsane(false),
m_bSelectable(false),
m_bSprawling(false),
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
m_bFixedBorders(false),
m_bInfluenceAllowed(false),
m_iVictoryInfluenceModifier(100),
m_iDefeatInfluenceModifier(100),
m_iPillageInfluenceModifier(100),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Multiple Production 					07/10/09									Denev	**/
/**							Merged by Valkrionn		13/01/2010									**/
/**					Allows overflow production to produce multiple units each turn				**/
/*************************************************************************************************/
m_bOverflowProduction(false),
/*************************************************************************************************/
/**	Multiple Production							END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Nomadic								01/15/10									Valkrionn	**/
/**							Addition requested by Sylvain5477									**/
/**						   Allows you to bypass the city check									**/
/*************************************************************************************************/
m_bNomadic(false),
/*************************************************************************************************/
/**	Nomadic									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
m_iFreeXPFromCombat(0),
/**								----  End Original Code  ----									**/
m_iFreeXPFromCombat(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
m_iMaxCities(-1),
m_iPillagingGold(0),
m_iStartingGold(0),
m_iSummonDuration(0),
m_iUpgradeCostModifier(0),
//FfH: End Add

m_paiExtraYieldThreshold(NULL),
m_paiTradeYieldModifier(NULL),
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
m_paiTradeCommerceModifier(NULL),
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(TraitInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iModReligionSpreadChance(0),
m_paiBaseYieldFromUnit(NULL),
m_paiYieldFromUnitModifier(NULL),
m_paiBaseCommerceFromUnit(NULL),
m_paiCommerceFromUnitModifier(NULL),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_paiCommerceChange(NULL),
m_paiCommerceModifier(NULL),
m_pabFreePromotionUnitCombat(NULL),
m_pabFreePromotion(NULL),
m_pabRevealBonus(NULL),
m_pabNoBonus(NULL),
m_pabFreeSpecialistStateReligion(NULL),
m_pabFreeSpecialistNonStateReligion(NULL),
m_paiSpecialistHealthChange(NULL),
m_paiSpecialistHappinessChange(NULL),
m_paiSpecialistCrimeChange(NULL),
m_paiUnitClassPlayerInstancesChange(NULL),
/*************************************************************************************************/
/**	Miner Trait 	 	Orbis from Sanguo Mod		18/02/09	Ahwaric		**/
/*************************************************************************************************/
m_ppaiSpecialistYieldChange(NULL),
m_ppaiSpecialistCommerceChange(NULL),
m_paiPeaceCommerceModifier(NULL),
m_paiFeatureProductionChange(NULL),
m_paiFeatureGrowthChange(NULL),
m_paiPlotEffectSpawnChance(NULL),
m_ppiTerrainYieldChanges(NULL),
m_ppiFeatureYieldChanges(NULL),
m_ppiImprovementYieldChanges(NULL),
m_iHurryPopulationModifier(0),
/*************************************************************************************************/
/**	Miner Trait							END			**/
/*************************************************************************************************/
/*************************************************************************************************/
/** bUniqueCult         Opera for LE/Orbis  06/07/09         imported by Valkrionn	09.26.09    **/
/*************************************************************************************************/
m_bUniqueCult(false),
m_bIntolerant(false),
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
m_iInitialCityCap(0),
m_iMaxCityCap(0)
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTraitInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTraitInfo::~CvTraitInfo()
{
	SAFE_DELETE_ARRAY(m_paiExtraYieldThreshold);
	SAFE_DELETE_ARRAY(m_paiTradeYieldModifier);
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiTradeCommerceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(TraitInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Clear Arrays											**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiBaseYieldFromUnit);
	SAFE_DELETE_ARRAY(m_paiYieldFromUnitModifier);
	SAFE_DELETE_ARRAY(m_paiBaseCommerceFromUnit);
	SAFE_DELETE_ARRAY(m_paiCommerceFromUnitModifier);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCommerceChange);
	SAFE_DELETE_ARRAY(m_paiCommerceModifier);
	SAFE_DELETE_ARRAY(m_pabFreePromotionUnitCombat);
	SAFE_DELETE_ARRAY(m_pabFreePromotion);
	SAFE_DELETE_ARRAY(m_pabRevealBonus);
	SAFE_DELETE_ARRAY(m_pabNoBonus);

	SAFE_DELETE_ARRAY(m_pabFreeSpecialistStateReligion);
	SAFE_DELETE_ARRAY(m_pabFreeSpecialistNonStateReligion);
/*************************************************************************************************/
/**	Miner Trait 	 	Orbis from Sanguo Mod		18/02/09	Ahwaric		**/
/*************************************************************************************************/
	if (m_ppaiSpecialistYieldChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange);
	}

	if (m_ppaiSpecialistCommerceChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange);
	}
	SAFE_DELETE_ARRAY(m_paiPeaceCommerceModifier);

	SAFE_DELETE_ARRAY(m_paiFeatureProductionChange);
	SAFE_DELETE_ARRAY(m_paiFeatureGrowthChange);
	SAFE_DELETE_ARRAY(m_paiPlotEffectSpawnChance);
	if (m_ppiTerrainYieldChanges != NULL)
	{
		for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiTerrainYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiTerrainYieldChanges);
	}
	if (m_ppiFeatureYieldChanges != NULL)
	{
		for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiFeatureYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiFeatureYieldChanges);
	}
	if (m_ppiImprovementYieldChanges != NULL)
	{
		for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges);
	}
/*************************************************************************************************/
/**	Miner Trait							END			**/
/*************************************************************************************************/
}
int CvTraitInfo::getTraitClass() const
{
	return m_iTraitClass;
}
int CvTraitInfo::getNextTrait() const
{
	return m_iNextTrait;
}

int CvTraitInfo::getParentTrait() const
{
	return m_iParentTrait;
}
void CvTraitInfo::setNextTrait(int i)
{
	m_iNextTrait = i;
}

void CvTraitInfo::setParentTrait(int i)
{
	m_iParentTrait = i;
}
int CvTraitInfo::getHealth() const
{
	return m_iHealth;
}

int CvTraitInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvTraitInfo::getMaxAnarchy() const
{
	return m_iMaxAnarchy;
}

int CvTraitInfo::getFreeBuildingClass() const
{
	return m_iFreeBuildingClass;
}
int CvTraitInfo::getUpkeepModifier() const
{
	return m_iUpkeepModifier;
}

int CvTraitInfo::getDistanceMaintenanceModifier() const
{
	return m_iDistanceMaintenanceModifier;
}
int CvTraitInfo::getRitualProductionModifier() const
{
	return m_iRitualProductionModifier;
}
int CvTraitInfo::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}
int CvTraitInfo::getLevelExperienceModifier() const
{
	return m_iLevelExperienceModifier;
}

int CvTraitInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvTraitInfo::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

int CvTraitInfo::getExtraGrowthThreshold() const
{
	return m_iExtraGrowthThreshold;
}

int CvTraitInfo::getACGrowthThreshold() const
{
	return m_iACGrowthThreshold;
}

int CvTraitInfo::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

int CvTraitInfo::getMaxGlobalBuildingProductionModifier() const
{
	return m_iMaxGlobalBuildingProductionModifier;
}

int CvTraitInfo::getMaxTeamBuildingProductionModifier() const
{
	return m_iMaxTeamBuildingProductionModifier;
}

int CvTraitInfo::getMaxPlayerBuildingProductionModifier() const
{
	return m_iMaxPlayerBuildingProductionModifier;
}

int CvTraitInfo::getLevel() const
{
	return m_iLevel;
}
int CvTraitInfo::getMinRequiredPoints() const
{
	return m_iMinRequiredPoints;
}
bool CvTraitInfo::isCanBeLost() const
{
	return m_bCanBeLost;
}

const TCHAR* CvTraitInfo::getShortDescription() const
{
	return m_szShortDescription;
}

void CvTraitInfo::setShortDescription(const TCHAR* szVal)
{
	m_szShortDescription = szVal;
}

//FfH Traits: Added by Kael 08/02/2007
bool CvTraitInfo::isAdaptive() const
{
	return m_bAdaptive;
}

bool CvTraitInfo::isAgnostic() const
{
	return m_bAgnostic;
}

bool CvTraitInfo::isAmphibian() const
{
	return m_bAmphibian;
}

bool CvTraitInfo::isAssimilation() const
{
	return m_bAssimilation;
}

bool CvTraitInfo::isBarbarianAlly() const
{
	return m_bBarbarianAlly;
}

bool CvTraitInfo::isIgnoreFood() const
{
	return m_bIgnoreFood;
}

bool CvTraitInfo::isIgnoreHealth() const
{
	return m_bIgnoreHealth;
}
bool CvTraitInfo::isInsane() const
{
	return m_bInsane;
}

bool CvTraitInfo::isSelectable() const
{
	return m_bSelectable;
}

bool CvTraitInfo::isSprawling() const
{
	return m_bSprawling;
}

/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
bool CvTraitInfo::isFixedBorders() const
{
	return m_bFixedBorders;
}

bool CvTraitInfo::isInfluenceAllowed() const
{
	return m_bInfluenceAllowed;
}

int CvTraitInfo::getVictoryInfluenceModifier() const
{
	return m_iVictoryInfluenceModifier;
}

int CvTraitInfo::getDefeatInfluenceModifier() const
{
	return m_iDefeatInfluenceModifier;
}

int CvTraitInfo::getPillageInfluenceModifier() const
{
	return m_iPillageInfluenceModifier;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Multiple Production 					07/10/09									Denev	**/
/**							Merged by Valkrionn		13/01/2010									**/
/**					Allows overflow production to produce multiple units each turn				**/
/*************************************************************************************************/
bool CvTraitInfo::isOverflowProduction() const
{
	return m_bOverflowProduction;
}
/*************************************************************************************************/
/**	Multiple Production							END												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Nomadic								01/15/10									Valkrionn	**/
/**							Addition requested by Sylvain5477									**/
/**						   Allows you to bypass the city check									**/
/*************************************************************************************************/
bool CvTraitInfo::isNomadic() const
{
	return m_bNomadic;
}
/*************************************************************************************************/
/**	Nomadic									END													**/
/*************************************************************************************************/

int CvTraitInfo::getFreeXPFromCombat() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iFreeXPFromCombat;
/**								----  End Original Code  ----									**/
	return (int)(m_iFreeXPFromCombat*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvTraitInfo::getMaxCities() const
{
	return m_iMaxCities;
}

int CvTraitInfo::getPillagingGold() const
{
	return m_iPillagingGold;
}

int CvTraitInfo::getStartingGold() const
{
	return m_iStartingGold;
}

int CvTraitInfo::getSummonDuration() const
{
	return m_iSummonDuration;
}

int CvTraitInfo::getUpgradeCostModifier() const
{
	return m_iUpgradeCostModifier;
}
//FfH: End Add

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
int CvTraitInfo::getInitialCityCap() const
{
	return m_iInitialCityCap;
}

int CvTraitInfo::getMaxCityCap() const
{
	return m_iMaxCityCap;
}
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/
// Arrays

int CvTraitInfo::getExtraYieldThreshold(int i) const
{
	return m_paiExtraYieldThreshold ? m_paiExtraYieldThreshold[i] : -1;
}

int CvTraitInfo::getTradeYieldModifier(int i) const
{
	return m_paiTradeYieldModifier ? m_paiTradeYieldModifier[i] : -1;
}

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
int CvTraitInfo::getTradeCommerceModifier(int i) const
{
	return m_paiTradeCommerceModifier ? m_paiTradeCommerceModifier[i] : -1;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(TraitInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvTraitInfo::getModReligionSpreadChance() const			{return m_iModReligionSpreadChance;}
int CvTraitInfo::getBaseYieldFromUnit(int i) const			{return m_paiBaseYieldFromUnit			? m_paiBaseYieldFromUnit[i]			: -1;}
int CvTraitInfo::getYieldFromUnitModifier(int i) const		{return m_paiYieldFromUnitModifier		? m_paiYieldFromUnitModifier[i]		: -1;}
int CvTraitInfo::getBaseCommerceFromUnit(int i) const		{return m_paiBaseCommerceFromUnit		? m_paiBaseCommerceFromUnit[i]		: -1;}
int CvTraitInfo::getCommerceFromUnitModifier(int i) const	{return m_paiCommerceFromUnitModifier	? m_paiCommerceFromUnitModifier[i]	: -1;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
int CvTraitInfo::getCommerceChange(int i) const
{
	return m_paiCommerceChange ? m_paiCommerceChange[i] : -1;
}

int CvTraitInfo::getCommerceModifier(int i) const
{
	return m_paiCommerceModifier ? m_paiCommerceModifier[i] : -1;
}

int CvTraitInfo::isRevealBonus(int i) const
{
	return m_pabRevealBonus ? m_pabRevealBonus[i] : -1;
}

int CvTraitInfo::isNoBonus(int i) const
{
	return m_pabNoBonus ? m_pabNoBonus[i] : -1;
}

int CvTraitInfo::isFreeSpecialistStateReligion(int i) const
{
	return m_pabFreeSpecialistStateReligion ? m_pabFreeSpecialistStateReligion[i] : -1;
}

int CvTraitInfo::getSpecialistHappinessChange(int i) const
{
	return m_paiSpecialistHappinessChange ? m_paiSpecialistHappinessChange[i] : -1;
}

int CvTraitInfo::getSpecialistHealthChange(int i) const
{
	return m_paiSpecialistHealthChange ? m_paiSpecialistHealthChange[i] : -1;
}

int CvTraitInfo::getSpecialistCrimeChange(int i) const
{
	return m_paiSpecialistCrimeChange ? m_paiSpecialistCrimeChange[i] : -1;
}

int CvTraitInfo::getUnitClassPlayerInstancesChange(int i) const
{
	return m_paiUnitClassPlayerInstancesChange ? m_paiUnitClassPlayerInstancesChange[i] : -1;
}

int CvTraitInfo::isFreeSpecialistNonStateReligion(int i) const
{
	return m_pabFreeSpecialistNonStateReligion ? m_pabFreeSpecialistNonStateReligion[i] : -1;
}


int CvTraitInfo::isFreePromotion(int i) const
{
	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;
}

int CvTraitInfo::isFreePromotionUnitCombat(int i) const
{
	return m_pabFreePromotionUnitCombat ? m_pabFreePromotionUnitCombat[i] : -1;
}
/*************************************************************************************************/
/**	Miner Trait 	 	Orbis from Sanguo Mod		18/02/09	Ahwaric		**/
/*************************************************************************************************/
int CvTraitInfo::getSpecialistYieldChange(int i, int j) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppaiSpecialistYieldChange ? m_ppaiSpecialistYieldChange[i][j] : -1;
}

int* CvTraitInfo::getSpecialistYieldChangeArray(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppaiSpecialistYieldChange[i];
}

int CvTraitInfo::getSpecialistCommerceChange(int i, int j) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppaiSpecialistCommerceChange ? m_ppaiSpecialistCommerceChange[i][j] : -1;
}

int* CvTraitInfo::getSpecialistCommerceChangeArray(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppaiSpecialistCommerceChange[i];
}
int CvTraitInfo::getPeaceCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiPeaceCommerceModifier ? m_paiPeaceCommerceModifier[i] : -1;
}

int CvTraitInfo::getFeatureProductionChange(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureProductionChange ? m_paiFeatureProductionChange[i] : -1;
}

int CvTraitInfo::getFeatureGrowthChange(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureGrowthChange ? m_paiFeatureGrowthChange[i] : -1;
}

int CvTraitInfo::getPlotEffectSpawnChance(int i) const
{
	FAssertMsg(i < GC.getNumPlotEffectInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiPlotEffectSpawnChance ? m_paiPlotEffectSpawnChance[i] : -1;
}

int CvTraitInfo::getTerrainYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiTerrainYieldChanges[i][j];
}
int* CvTraitInfo::getTerrainYieldChangesArray(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppiTerrainYieldChanges[i];
}

int CvTraitInfo::getFeatureYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiFeatureYieldChanges[i][j];
}
int* CvTraitInfo::getFeatureYieldChangesArray(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppiFeatureYieldChanges[i];
}

int CvTraitInfo::getImprovementYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiImprovementYieldChanges[i][j];
}
int* CvTraitInfo::getImprovementYieldChangesArray(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppiImprovementYieldChanges[i];
}
int CvTraitInfo::getImprovementYieldChangesVectorSize() { return m_aszImprovementYieldChanges.size(); }
CvString CvTraitInfo::getImprovementYieldChangesNamesVectorElement(int i) { return m_aszImprovementYieldChanges[i]; }
int* CvTraitInfo::getImprovementYieldChangesValuesVectorElement(int i) { return m_yiImprovementYieldChanges[i]; }

int CvTraitInfo::getHurryPopulationModifier() const
{
	return m_iHurryPopulationModifier;
}


/*************************************************************************************************/
/**	Miner Trait							END			**/
/*************************************************************************************************/

/*************************************************************************************************/
/** bUniqueCult             Opera for LE/Orbis  06/07/09        imported by Valkrionn	09.26.09**/
/*************************************************************************************************/
bool CvTraitInfo::isUniqueCult() const
{
	return m_bUniqueCult;
}

bool CvTraitInfo::isIntolerant() const
{
	return m_bIntolerant;
}
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

bool CvTraitInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ShortDescription");
	setShortDescription(szTextVal);

	pXML->GetChildXmlValByName(&m_iLevel, "iLevel");
	pXML->GetChildXmlValByName(&m_iMinRequiredPoints, "iMinRequiredPoints");
	pXML->GetChildXmlValByName(&m_bCanBeLost, "bCanBeLost");
	pXML->GetChildXmlValByName(&m_iLevel, "iLevel");
	pXML->GetChildXmlValByName(szTextVal, "TraitClass");
	m_iTraitClass = pXML->FindInInfoClass(szTextVal);
	
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iMaxAnarchy, "iMaxAnarchy", -1);
	pXML->GetChildXmlValByName(szTextVal, "FreeBuilding");
	m_iFreeBuildingClassforPass3 = szTextVal;
	pXML->GetChildXmlValByName(&m_iUpkeepModifier, "iUpkeepModifier");
	pXML->GetChildXmlValByName(&m_iDistanceMaintenanceModifier, "iDistanceMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iRitualProductionModifier, "iRitualProductionModifier");
	pXML->GetChildXmlValByName(&m_iMilitaryProductionModifier, "iMilitaryProductionModifier");
	pXML->GetChildXmlValByName(&m_iLevelExperienceModifier, "iLevelExperienceModifier");
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iGreatGeneralRateModifier, "iGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iExtraGrowthThreshold, "iExtraGrowthThreshold");
	pXML->GetChildXmlValByName(&m_iACGrowthThreshold, "iACGrowthThreshold");
	pXML->GetChildXmlValByName(&m_iDomesticGreatGeneralRateModifier, "iDomesticGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iMaxGlobalBuildingProductionModifier, "iMaxGlobalBuildingProductionModifier");
	pXML->GetChildXmlValByName(&m_iMaxTeamBuildingProductionModifier, "iMaxTeamBuildingProductionModifier");
	pXML->GetChildXmlValByName(&m_iMaxPlayerBuildingProductionModifier, "iMaxPlayerBuildingProductionModifier");

//FfH Traits: Added by Kael 08/02/2007
	pXML->GetChildXmlValByName(&m_bAdaptive, "bAdaptive");
	pXML->GetChildXmlValByName(&m_bAgnostic, "bAgnostic");
	pXML->GetChildXmlValByName(&m_bAmphibian, "bAmphibian");
	pXML->GetChildXmlValByName(&m_bAssimilation, "bAssimilation");
	pXML->GetChildXmlValByName(&m_bBarbarianAlly, "bBarbarianAlly");
	pXML->GetChildXmlValByName(&m_bIgnoreFood, "bIgnoreFood");
	pXML->GetChildXmlValByName(&m_bIgnoreHealth, "bIgnoreHealth");
	pXML->GetChildXmlValByName(&m_bInsane, "bInsane");
	pXML->GetChildXmlValByName(&m_bSelectable, "bSelectable");
	pXML->GetChildXmlValByName(&m_bSprawling, "bSprawling");
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bFixedBorders, "bFixedBorders");
	pXML->GetChildXmlValByName(&m_bInfluenceAllowed, "bInfluenceAllowed");
	pXML->GetChildXmlValByName(&m_iVictoryInfluenceModifier, "iVictoryInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iDefeatInfluenceModifier, "iDefeatInfluenceModifier", 100);
	pXML->GetChildXmlValByName(&m_iPillageInfluenceModifier, "iPillageInfluenceModifier", 100);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Multiple Production 					07/10/09									Denev	**/
/**							Merged by Valkrionn		13/01/2010									**/
/**					Allows overflow production to produce multiple units each turn				**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bOverflowProduction, "bOverflowProduction");
/*************************************************************************************************/
/**	Multiple Production							END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Nomadic								01/15/10									Valkrionn	**/
/**							Addition requested by Sylvain5477									**/
/**						   Allows you to bypass the city check									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bNomadic, "bNomadic");
/*************************************************************************************************/
/**	Nomadic									END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iFreeXPFromCombat, "iFreeXPFromCombat");
	pXML->GetChildXmlValByName(&m_iMaxCities, "iMaxCities", -1);
	pXML->GetChildXmlValByName(&m_iPillagingGold, "iPillagingGold");
	pXML->GetChildXmlValByName(&m_iStartingGold, "iStartingGold");
	pXML->GetChildXmlValByName(&m_iSummonDuration, "iSummonDuration");
	pXML->GetChildXmlValByName(&m_iUpgradeCostModifier, "iUpgradeCostModifier");
//FfH: End Add

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ExtraYieldThresholds"))
	{
		pXML->SetYields(&m_paiExtraYieldThreshold);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiExtraYieldThreshold, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TradeYieldModifiers"))
	{
		pXML->SetYields(&m_paiTradeYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiTradeYieldModifier, NUM_YIELD_TYPES);
	}

/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TradeCommerceModifiers"))
	{
		pXML->SetCommerce(&m_paiTradeCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiTradeCommerceModifier, NUM_COMMERCE_TYPES);
	}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(TraitInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iModReligionSpreadChance, "iModReligionSpreadChance");
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BaseYieldFromUnits"))
	{
		pXML->SetYields(&m_paiBaseYieldFromUnit);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiBaseYieldFromUnit, NUM_YIELD_TYPES);
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "YieldFromUnitModifiers"))
	{
		pXML->SetYields(&m_paiYieldFromUnitModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiYieldFromUnitModifier, NUM_YIELD_TYPES);
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BaseCommerceFromUnits"))
	{
		pXML->SetCommerce(&m_paiBaseCommerceFromUnit);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiBaseCommerceFromUnit, NUM_COMMERCE_TYPES);
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceFromUnitModifiers"))
	{
		pXML->SetCommerce(&m_paiCommerceFromUnitModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiCommerceFromUnitModifier, NUM_COMMERCE_TYPES);
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceChanges"))
	{
		pXML->SetCommerce(&m_paiCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiCommerceChange, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceModifiers"))
	{
		pXML->SetCommerce(&m_paiCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiCommerceModifier, NUM_COMMERCE_TYPES);
	}
	pXML->SetVariableListTagPair(&m_pabRevealBonus, "RevealBonuses", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_pabNoBonus, "NoBonuses", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());

	pXML->SetVariableListTagPair(&m_pabFreeSpecialistStateReligion, "FreeSpecialistsStateReligion", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_pabFreeSpecialistNonStateReligion, "FreeSpecialistsNonStateReligion", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_paiSpecialistHappinessChange, "SpecialistHappinessChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_paiSpecialistHealthChange, "SpecialistHealthChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_paiSpecialistCrimeChange, "SpecialistCrimeChanges", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_paiUnitClassPlayerInstancesChange, "UnitClassPlayerInstancesChanges", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());

	pXML->SetVariableListTagPair(&m_pabFreePromotion, "FreePromotions", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos());

	pXML->SetVariableListTagPair(&m_pabFreePromotionUnitCombat, "FreePromotionUnitCombats", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
/*************************************************************************************************/
/**	Miner        			 	Orbis from Sanguo Mod		18/02/09	Ahwaric				 	**/
/*************************************************************************************************/
	int j=0;						//loop counter
	int k=0;						//loop counter
	int iNumSibs=0;				// the number of siblings the current xml node has
	int iNumChildren;				// the number of children the current node has

	pXML->Init2DIntList(&m_ppaiSpecialistYieldChange, GC.getNumSpecialistInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistYieldChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistYieldChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
					{
						// call the function that sets the yield change variable
						pXML->SetYields(&m_ppaiSpecialistYieldChange[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_ppaiSpecialistYieldChange[k], NUM_YIELD_TYPES);
					}
				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->Init2DIntList(&m_ppaiSpecialistCommerceChange, GC.getNumSpecialistInfos(), NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistCommerceChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistCommerceChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChanges"))
					{
						// call the function that sets the yield change variable
						pXML->SetCommerce(&m_ppaiSpecialistCommerceChange[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_ppaiSpecialistCommerceChange[k], NUM_COMMERCE_TYPES);
					}
				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PeaceCommerceModifiers"))
	{
		pXML->SetCommerce(&m_paiPeaceCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiPeaceCommerceModifier, NUM_COMMERCE_TYPES);
	}

	pXML->SetVariableListTagPair(&m_paiFeatureProductionChange, "FeatureProductionChanges", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_paiFeatureGrowthChange, "FeatureGrowthChanges", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_paiPlotEffectSpawnChance, "PlotEffectSpawnChances", sizeof(GC.getPlotEffectInfo((PlotEffectTypes)0)), GC.getNumPlotEffectInfos());
	pXML->GetChildXmlValByName(&m_iHurryPopulationModifier, "iHurryPopulationModifier");

	// Trait Terrain Yield Changes:
	FAssertMsg((GC.getNumTerrainInfos() > 0) && (NUM_YIELD_TYPES) > 0, "either the number of terrain infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiTerrainYieldChanges, GC.getNumTerrainInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TerrainYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					int iIndex;

					for (j = 0; j < iNumSibs; j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "TerrainType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiTerrainYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TerrainYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiTerrainYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiTerrainYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	// Trait Feature Yield Changes:
	FAssertMsg((GC.getNumFeatureInfos() > 0) && (NUM_YIELD_TYPES) > 0, "either the number of Feature infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiFeatureYieldChanges, GC.getNumFeatureInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "FeatureYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					int iIndex;

					for (j = 0; j < iNumSibs; j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "FeatureType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiFeatureYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "FeatureYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiFeatureYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiFeatureYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	// Trait Improvement Yield Changes:
	//FAssertMsg((GC.getNumImprovementInfos() > 0) && (NUM_YIELD_TYPES) > 0, "either the number of Improvement infos is zero or less or the number of yield types is zero or less");
//	pXML->Init2DIntList(&m_ppiImprovementYieldChanges, GC.getNumImprovementInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ImprovementYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					int iIndex;

					for (j = 0; j < iNumSibs; j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
						m_aszImprovementYieldChanges.push_back(szTextVal);
						//iIndex = pXML->FindInInfoClass(szTextVal);

						//if (iIndex > -1)
						//{
							// delete the array since it will be reallocated
							//SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ImprovementYields"))
							{
								int* tempYield;
								// call the function that sets the yield change variable
								//pXML->SetYields(&m_ppiImprovementYieldChanges[iIndex]);
								pXML->SetYields(&tempYield);
								m_yiImprovementYieldChanges.push_back(tempYield);

								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
						//		pXML->InitList(&m_ppiImprovementYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						//}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	/*************************************************************************************************/
/**	Miner Trait							END			**/
/*************************************************************************************************/

/*************************************************************************************************/
/** bUniqueCult             Opera for LE/Orbis  06/07/09        imported by Valkrionn	09.26.09**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bUniqueCult, "bUniqueCult");
	pXML->GetChildXmlValByName(&m_bIntolerant, "bIntolerant");
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/

/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iInitialCityCap, "iInitialCityCap", 0);
	pXML->GetChildXmlValByName(&m_iMaxCityCap, "iMaxCityCap", 0);
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/


	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(TraitInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTraitInfo::copyNonDefaults(CvTraitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);
	if (getLevel() == 0)			m_iLevel = pClassInfo->getLevel();
	if (getMinRequiredPoints() == 0)			m_iMinRequiredPoints = pClassInfo->getMinRequiredPoints();
	if (isCanBeLost() == false)			m_bCanBeLost = pClassInfo->isCanBeLost();
	if (getTraitClass() == NO_TRAITCLASS)			m_iTraitClass = pClassInfo->getTraitClass();
	if (getNextTrait() == NO_TRAIT)		m_iNextTrait = pClassInfo->getNextTrait();
	if (getParentTrait() == NO_TRAIT)		m_iParentTrait = pClassInfo->getParentTrait();

	if (isAdaptive()								== false)		m_bAdaptive								= pClassInfo->isAdaptive();
	if (isAgnostic()								== false)		m_bAgnostic								= pClassInfo->isAgnostic();
	if (isAmphibian() == false)		m_bAmphibian = pClassInfo->isAmphibian();
	if (isAssimilation()							== false)		m_bAssimilation							= pClassInfo->isAssimilation();
	if (isBarbarianAlly()							== false)		m_bBarbarianAlly						= pClassInfo->isBarbarianAlly();
	if (isIgnoreFood()								== false)		m_bIgnoreFood							= pClassInfo->isIgnoreFood();
	if (isIgnoreHealth() == false)		m_bIgnoreHealth = pClassInfo->isIgnoreHealth();
	if (isInsane()									== false)		m_bInsane								= pClassInfo->isInsane();
	if (isSelectable()								== false)		m_bSelectable							= pClassInfo->isSelectable();
	if (isSprawling()								== false)		m_bSprawling							= pClassInfo->isSprawling();
/************************************************************************************************/
/* Influence Driven War                   06/07/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	if (isFixedBorders()							== false)		m_bFixedBorders							= pClassInfo->isFixedBorders();
	if (isInfluenceAllowed()						== false)		m_bInfluenceAllowed						= pClassInfo->isInfluenceAllowed();
	if (getVictoryInfluenceModifier()				== 100)			m_iVictoryInfluenceModifier				= pClassInfo->getVictoryInfluenceModifier();
	if (getDefeatInfluenceModifier()				== 100)			m_iDefeatInfluenceModifier				= pClassInfo->getDefeatInfluenceModifier();
	if (getPillageInfluenceModifier()				== 100)			m_iPillageInfluenceModifier				= pClassInfo->getPillageInfluenceModifier();
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Multiple Production 					07/10/09									Denev	**/
/**							Merged by Valkrionn		13/01/2010									**/
/**					Allows overflow production to produce multiple units each turn				**/
/*************************************************************************************************/
	if (isOverflowProduction()						== false)		m_bOverflowProduction					= pClassInfo->isOverflowProduction();
/*************************************************************************************************/
/**	Multiple Production							END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Nomadic								01/15/10									Valkrionn	**/
/**							Addition requested by Sylvain5477									**/
/**						   Allows you to bypass the city check									**/
/*************************************************************************************************/
	if (isNomadic()									== false)		m_bNomadic								= pClassInfo->isNomadic();
/*************************************************************************************************/
/**	Nomadic									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/** bUniqueCult             Opera for LE/Orbis  06/07/09        imported by Valkrionn	09.26.09**/
/*************************************************************************************************/
	if (isUniqueCult()								== false)		m_bUniqueCult							= pClassInfo->isUniqueCult();
	if (isIntolerant()								== false)		m_bIntolerant							= pClassInfo->isIntolerant();
/*************************************************************************************************/
/** End                                                                                         **/
/*************************************************************************************************/
/*************************************************************************************************/
/** CityPopCap     Opera  9.8.09            imported by Valkrionn	09.26.09                    **/
/*************************************************************************************************/
	if (getInitialCityCap()							== 0)			m_iInitialCityCap						= pClassInfo->getInitialCityCap();
	if (getMaxCityCap()								== 0)			m_iMaxCityCap							= pClassInfo->getMaxCityCap();
/*************************************************************************************************/
/** CityPopCap                  END                                                             **/
/*************************************************************************************************/
	if (getFreeXPFromCombat()						== 0)			m_iFreeXPFromCombat						= (float)pClassInfo->getFreeXPFromCombat()/100.0f;
	if (getPillagingGold()							== 0)			m_iPillagingGold						= pClassInfo->getPillagingGold();
	if (getHurryPopulationModifier()                == 0)           m_iHurryPopulationModifier              = pClassInfo->getHurryPopulationModifier();
	if (getStartingGold()							== 0)			m_iStartingGold							= pClassInfo->getStartingGold();
	if (getSummonDuration()							== 0)			m_iSummonDuration						= pClassInfo->getSummonDuration();
	if (getUpgradeCostModifier()					== 0)			m_iUpgradeCostModifier					= pClassInfo->getUpgradeCostModifier();
	if (getModReligionSpreadChance()				== 0)			m_iModReligionSpreadChance				= pClassInfo->getModReligionSpreadChance();
	if (getHealth()									== 0)			m_iHealth								= pClassInfo->getHealth();
	if (getHappiness()								== 0)			m_iHappiness							= pClassInfo->getHappiness();
	if (getUpkeepModifier()							== 0)			m_iUpkeepModifier						= pClassInfo->getUpkeepModifier();
	if (getDistanceMaintenanceModifier() == 0)			m_iDistanceMaintenanceModifier = pClassInfo->getDistanceMaintenanceModifier();
	if (getRitualProductionModifier() == 0)			m_iRitualProductionModifier = pClassInfo->getRitualProductionModifier();
	if (getMilitaryProductionModifier() == 0)			m_iMilitaryProductionModifier = pClassInfo->getMilitaryProductionModifier();
	if (getLevelExperienceModifier()				== 0)			m_iLevelExperienceModifier				= pClassInfo->getLevelExperienceModifier();
	if (getGreatPeopleRateModifier()				== 0)			m_iGreatPeopleRateModifier				= pClassInfo->getGreatPeopleRateModifier();
	if (getGreatGeneralRateModifier()				== 0)			m_iGreatGeneralRateModifier				= pClassInfo->getGreatGeneralRateModifier();
	if (getExtraGrowthThreshold() == 0)			m_iExtraGrowthThreshold = pClassInfo->getExtraGrowthThreshold();
	if (getACGrowthThreshold() == 0)			m_iACGrowthThreshold = pClassInfo->getACGrowthThreshold();
	if (getDomesticGreatGeneralRateModifier()		== 0)			m_iDomesticGreatGeneralRateModifier		= pClassInfo->getDomesticGreatGeneralRateModifier();
	if (getMaxGlobalBuildingProductionModifier()	== 0)			m_iMaxGlobalBuildingProductionModifier	= pClassInfo->getMaxGlobalBuildingProductionModifier();
	if (getMaxTeamBuildingProductionModifier()		== 0)			m_iMaxTeamBuildingProductionModifier	= pClassInfo->getMaxTeamBuildingProductionModifier();
	if (getMaxPlayerBuildingProductionModifier()	== 0)			m_iMaxPlayerBuildingProductionModifier	= pClassInfo->getMaxPlayerBuildingProductionModifier();
	if (getMaxCities()								== -1)			m_iMaxCities							= pClassInfo->getMaxCities();
	if (getMaxAnarchy()								== -1)			m_iMaxAnarchy							= pClassInfo->getMaxAnarchy();
	if (getFreeBuildingClass() == NO_BUILDINGCLASS)			m_iFreeBuildingClass = pClassInfo->getFreeBuildingClass();
	if (getShortDescription()						== cDefault)	setShortDescription(					pClassInfo->getShortDescription());
	for (int j = 0; j < NUM_YIELD_TYPES; j++ )
	{
		if (getExtraYieldThreshold(j)				== 0)			m_paiExtraYieldThreshold[j]				= pClassInfo->getExtraYieldThreshold(j);
		if (getTradeYieldModifier(j)				== 0)			m_paiTradeYieldModifier[j]				= pClassInfo->getTradeYieldModifier(j);
		if (getBaseYieldFromUnit(j)					== 0)			m_paiBaseYieldFromUnit[j]				= pClassInfo->getBaseYieldFromUnit(j);
		if (getYieldFromUnitModifier(j)				== 0)			m_paiYieldFromUnitModifier[j]			= pClassInfo->getYieldFromUnitModifier(j);
	}
	for ( int j = 0; j < NUM_COMMERCE_TYPES; j++ )
	{
/*************************************************************************************************/
/**	TradeCommerceModifiers	 				09/05/10								Valkrionn	**/
/**																								**/
/**									Allows trade to grant culture								**/
/*************************************************************************************************/
		if (getTradeCommerceModifier(j)				== 0)			m_paiTradeCommerceModifier[j]			= pClassInfo->getTradeCommerceModifier(j);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
		if (getCommerceChange(j)					== 0)			m_paiCommerceChange[j]					= pClassInfo->getCommerceChange(j);
		if (getCommerceModifier(j)					== 0)			m_paiCommerceModifier[j]				= pClassInfo->getCommerceModifier(j);
		if (getBaseCommerceFromUnit(j)				== 0)			m_paiBaseCommerceFromUnit[j]			= pClassInfo->getBaseCommerceFromUnit(j);
		if (getCommerceFromUnitModifier(j)			== 0)			m_paiCommerceFromUnitModifier[j]		= pClassInfo->getCommerceFromUnitModifier(j);
		if (m_paiPeaceCommerceModifier[j]			== 0)			m_paiPeaceCommerceModifier[j]			= pClassInfo->getPeaceCommerceModifier(j);
	}
	for ( int j = 0; j < GC.getNumPromotionInfos(); j++ )
	{
		if (isFreePromotion(j)						== false)		m_pabFreePromotion[j]					= pClassInfo->isFreePromotion(j);
	}
	for (int j = 0; j < GC.getNumSpecialistInfos(); j++)
	{
		if (isFreeSpecialistNonStateReligion(j) == false)		m_pabFreeSpecialistNonStateReligion[j] = pClassInfo->isFreeSpecialistNonStateReligion(j);
		if (isFreeSpecialistStateReligion(j) == false)		m_pabFreeSpecialistStateReligion[j] = pClassInfo->isFreeSpecialistStateReligion(j);
		if (getSpecialistHappinessChange(j) == 0) m_paiSpecialistHappinessChange[j]= pClassInfo->getSpecialistHappinessChange(j);
		if (getSpecialistHealthChange(j) == 0) m_paiSpecialistHealthChange[j]= pClassInfo->getSpecialistHealthChange(j);
		if (getSpecialistCrimeChange(j) == 0) m_paiSpecialistCrimeChange[j] = pClassInfo->getSpecialistCrimeChange(j);
		if (getUnitClassPlayerInstancesChange(j) == 0) m_paiUnitClassPlayerInstancesChange[j] = pClassInfo->getUnitClassPlayerInstancesChange(j);
	}

	for (int j = 0; j < GC.getNumBonusInfos(); j++)
	{
		if (isRevealBonus(j) == false)		m_pabRevealBonus[j] = pClassInfo->isRevealBonus(j);
		if (isNoBonus(j) == false)		m_pabNoBonus[j] = pClassInfo->isNoBonus(j);
	}
	for ( int j = 0; j < GC.getNumUnitCombatInfos(); j++ )
	{
		if (isFreePromotionUnitCombat(j)			== false)		m_pabFreePromotionUnitCombat[j]			= pClassInfo->isFreePromotionUnitCombat(j);
	}
	for ( int j = 0; j < GC.getNumSpecialistInfos(); j++)
	{
		for ( int i = 0; i < NUM_YIELD_TYPES; i++)
		{
			if (getSpecialistYieldChange(j, i)		== 0)			m_ppaiSpecialistYieldChange[j][i]		= pClassInfo->getSpecialistYieldChange(j, i);
		}
		for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
		{
			if (getSpecialistCommerceChange(j, i)   == 0)			m_ppaiSpecialistCommerceChange[j][i]    = pClassInfo->getSpecialistCommerceChange(j, i);
		}
	}
	for ( int j = 0; j < GC.getNumFeatureInfos(); j++ )
	{
		if (m_paiFeatureGrowthChange[j]				== 0)			m_paiFeatureGrowthChange[j]				= pClassInfo->getFeatureGrowthChange(j);
		if (m_paiFeatureProductionChange[j]         == 0)           m_paiFeatureProductionChange[j]         = pClassInfo->getFeatureProductionChange(j);
		for (int k = 0; k < NUM_YIELD_TYPES; k++)
		{
			if (m_ppiFeatureYieldChanges[j][k] == 0)				m_ppiFeatureYieldChanges[j][k] = pClassInfo->getFeatureYieldChanges(j, k);
		}
	}
	for (int j = 0; j < GC.getNumPlotEffectInfos(); j++)
	{
		if (m_paiPlotEffectSpawnChance[j] == 0)			m_paiPlotEffectSpawnChance[j] = pClassInfo->getPlotEffectSpawnChance(j);
	}
	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiTerrainYieldChanges[i][j] == 0)				m_ppiTerrainYieldChanges[i][j] = pClassInfo->getTerrainYieldChanges(i, j);
		}
	}
	//for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	//{
	//	for (int j = 0; j < NUM_YIELD_TYPES; j++)
	//	{
	//		if (m_ppiImprovementYieldChanges[i][j] == 0)				m_ppiImprovementYieldChanges[i][j] = pClassInfo->getImprovementYieldChanges(i, j);
	//	}
	//}
	for (int i = 0; i < pClassInfo->getImprovementYieldChangesVectorSize(); i++)
	{
		m_aszImprovementYieldChanges.push_back(pClassInfo->getImprovementYieldChangesNamesVectorElement(i));
		m_yiImprovementYieldChanges.push_back(pClassInfo->getImprovementYieldChangesValuesVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
bool CvTraitInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	/*************************************************************************************************/
	/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
	/**	HotkeyInfo will call InfoBase for us, so if we need hotkeys, then we don't need Infobase	**/
	/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
	/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	/*************************************************************************************************/
	/**	TrueModular								END													**/
	/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "NextTrait");
	m_iNextTrait = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ParentTrait");
	m_iParentTrait = GC.getInfoTypeForString(szTextVal);

	return true;
}
void CvTraitInfo::copyNonDefaultsReadPass2(CvTraitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getNextTrait() != NO_TRAIT)		m_iNextTrait = pClassInfo->getNextTrait();
	if (bOver || pClassInfo->getParentTrait() != NO_TRAIT)		m_iParentTrait = pClassInfo->getParentTrait();

}
bool CvTraitInfo::readPass3()
{
	if (m_iFreeBuildingClassforPass3 != NULL)
		m_iFreeBuildingClass = (BuildingClassTypes)GC.getInfoTypeForString(m_iFreeBuildingClassforPass3);

	m_ppiImprovementYieldChanges = new int*[GC.getNumImprovementInfos()];
	for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		m_ppiImprovementYieldChanges[iI] = new int[NUM_YIELD_TYPES];
		for (int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			m_ppiImprovementYieldChanges[iI][iJ] = 0;
		}
	}
	int iNumLoad = m_aszImprovementYieldChanges.size();
	for (iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszImprovementYieldChanges[iI]) >= 0, "Warning, about to leak memory in CvTraitInfo::readPass3");
		for (int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			m_ppiImprovementYieldChanges[GC.getInfoTypeForString(m_aszImprovementYieldChanges[iI])][iJ] = m_yiImprovementYieldChanges[iI][iJ];
		}
	}
	m_aszImprovementYieldChanges.clear();
	m_yiImprovementYieldChanges.clear();
	return true;
}
//======================================================================================================
//					CvCursorInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCursorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCursorInfo::CvCursorInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCursorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCursorInfo::~CvCursorInfo()
{
}

const TCHAR* CvCursorInfo::getPath()
{
	return m_szPath;
}

void CvCursorInfo::setPath(const TCHAR* szVal)
{
	m_szPath = szVal;
}

bool CvCursorInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "CursorPath");
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCursorInfo::copyNonDefaults(CvCursorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvThroneRoomCamera
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvThroneRoomCamera()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomCamera::CvThroneRoomCamera()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvThroneRoomCamera()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomCamera::~CvThroneRoomCamera()
{
}

const TCHAR* CvThroneRoomCamera::getFileName()
{
	return m_szFileName;
}

void CvThroneRoomCamera::setFileName(const TCHAR* szVal)
{
	m_szFileName = szVal;
}

bool CvThroneRoomCamera::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "FileName");
	setFileName(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvThroneRoomCamera::copyNonDefaults(CvThroneRoomCamera* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getFileName()		== cDefault)		setFileName(		pClassInfo->getFileName());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvThroneRoomInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvThroneRoomInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomInfo::CvThroneRoomInfo() :
m_iFromState(0),
m_iToState(0),
m_iAnimation(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvThroneRoomInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomInfo::~CvThroneRoomInfo()
{
}

const TCHAR* CvThroneRoomInfo::getEvent()
{
	return m_szEvent;
}

void CvThroneRoomInfo::setEvent(const TCHAR* szVal)
{
	m_szEvent = szVal;
}

const TCHAR* CvThroneRoomInfo::getNodeName()
{
	return m_szNodeName;
}

void CvThroneRoomInfo::setNodeName(const TCHAR* szVal)
{
	m_szNodeName = szVal;
}

int CvThroneRoomInfo::getFromState()
{
	return m_iFromState;
}

void CvThroneRoomInfo::setFromState(int iVal)
{
	m_iFromState = iVal;
}

int CvThroneRoomInfo::getToState()
{
	return m_iToState;
}

void CvThroneRoomInfo::setToState(int iVal)
{
	m_iToState = iVal;
}

int CvThroneRoomInfo::getAnimation()
{
	return m_iAnimation;
}

void CvThroneRoomInfo::setAnimation(int iVal)
{
	m_iAnimation= iVal;
}

bool CvThroneRoomInfo::read(CvXMLLoadUtility* pXML)
{
	int iVal;
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Event");
	setEvent(szTextVal);
	pXML->GetChildXmlValByName(&iVal, "iFromState" );
	setFromState(iVal);
	pXML->GetChildXmlValByName(&iVal, "iToState" );
	setToState(iVal);
	pXML->GetChildXmlValByName(szTextVal, "NodeName");
	setNodeName(szTextVal);
	pXML->GetChildXmlValByName(&iVal, "iAnimation" );
	setAnimation(iVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvThroneRoomInfo::copyNonDefaults(CvThroneRoomInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getEvent()		== cDefault)	setEvent(			pClassInfo->getEvent());
	if (getNodeName()	== cDefault)	setNodeName(		pClassInfo->getNodeName());
	if (getFromState()	== 0)			setFromState(		pClassInfo->getFromState());
	if (getToState()	== 0)			setToState(			pClassInfo->getToState());
	if (getAnimation()	== 0)			setAnimation(		pClassInfo->getAnimation());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvThroneRoomStyleInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvThroneRoomStyleInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomStyleInfo::CvThroneRoomStyleInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvThroneRoomStyleInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomStyleInfo::~CvThroneRoomStyleInfo()
{
}

const TCHAR* CvThroneRoomStyleInfo::getArtStyleType()
{
	return m_szArtStyleType;
}

void CvThroneRoomStyleInfo::setArtStyleType(const TCHAR* szVal)
{
	m_szArtStyleType = szVal;
}

const TCHAR* CvThroneRoomStyleInfo::getEraType()
{
	return m_szEraType;
}

void CvThroneRoomStyleInfo::setEraType(const TCHAR* szVal)
{
	m_szEraType = szVal;
}

const TCHAR* CvThroneRoomStyleInfo::getFileName()
{
	return m_szFileName;
}

void CvThroneRoomStyleInfo::setFileName(const TCHAR* szVal)
{
	m_szFileName = szVal;
}

bool CvThroneRoomStyleInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ArtStyleType");
	setArtStyleType(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EraType");
	setEraType(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FileName");
	setFileName(szTextVal);

	//node names
	if(gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
	{
		while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "NodeName"))
		{
			pXML->GetXmlVal(szTextVal);
			m_aNodeNames.push_back(szTextVal);
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//texture names
	if(gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
	{
		while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "TextureName"))
		{
			pXML->GetXmlVal(szTextVal);
			m_aTextureNames.push_back(szTextVal);
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvThroneRoomStyleInfo::copyNonDefaults(CvThroneRoomStyleInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getArtStyleType()	== cDefault)	setArtStyleType(	pClassInfo->getArtStyleType());
	if (getEraType()		== cDefault)	setEraType(			pClassInfo->getEraType());
	if (getFileName()		== cDefault)	setFileName(		pClassInfo->getFileName());

	/*
	m_aNodeNames and m_aTextureNames don't seem to be used?
	since I hardly doubt anyone ever touches those XML's anyway, I'll just leave them out
	FOR NOW! */
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSlideShowInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSlideShowInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowInfo::CvSlideShowInfo() :
m_fStartTime(0.0f)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSlideShowInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowInfo::~CvSlideShowInfo()
{
}

const TCHAR* CvSlideShowInfo::getPath()
{
	return m_szPath;
}

void CvSlideShowInfo::setPath(const TCHAR* szVal)
{
	m_szPath = szVal;
}

const TCHAR* CvSlideShowInfo::getTransitionType()
{
	return m_szTransitionType;
}

void CvSlideShowInfo::setTransitionType(const TCHAR* szVal)
{
	m_szTransitionType = szVal;
}

float CvSlideShowInfo::getStartTime()
{
	return m_fStartTime;
}

void CvSlideShowInfo::setStartTime(float fVal)
{
	m_fStartTime = fVal;
}

bool CvSlideShowInfo::read(CvXMLLoadUtility* pXML)
{
	float fVal;
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TransitionType");
	setTransitionType(szTextVal);
	pXML->GetChildXmlValByName(&fVal, "fStartTime");
	setStartTime(fVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSlideShowInfo::copyNonDefaults(CvSlideShowInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPath()				== cDefault)	setPath(				pClassInfo->getPath());
	if (getTransitionType()		== cDefault)	setTransitionType(		pClassInfo->getTransitionType());
	if (getStartTime()			== 0.0f)		setStartTime(			pClassInfo->getStartTime());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSlideShowRandomInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSlideShowRandomInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowRandomInfo::CvSlideShowRandomInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSlideShowRandomInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowRandomInfo::~CvSlideShowRandomInfo()
{
}

const TCHAR* CvSlideShowRandomInfo::getPath()
{
	return m_szPath;
}

void CvSlideShowRandomInfo::setPath(const TCHAR* szVal)
{
	m_szPath = szVal;
}

bool CvSlideShowRandomInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSlideShowRandomInfo::copyNonDefaults(CvSlideShowRandomInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvWorldPickerInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvWorldPickerInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvWorldPickerInfo::CvWorldPickerInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvWorldPickerInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvWorldPickerInfo::~CvWorldPickerInfo()
{
}

const TCHAR* CvWorldPickerInfo::getMapName()
{
	return m_szMapName;
}

void CvWorldPickerInfo::setMapName(const TCHAR* szVal)
{
	m_szMapName = szVal;
}

const TCHAR* CvWorldPickerInfo::getModelFile()
{
	return m_szModelFile;
}

void CvWorldPickerInfo::setModelFile(const TCHAR* szVal)
{
	m_szModelFile = szVal;
}

int CvWorldPickerInfo::getNumSizes()
{
	return m_aSizes.size();
}

float CvWorldPickerInfo::getSize(int index)
{
	return m_aSizes[index];
}

int CvWorldPickerInfo::getNumClimates()
{
	return m_aClimates.size();
}

const TCHAR* CvWorldPickerInfo::getClimatePath(int index)
{
	return m_aClimates[index];
}

int CvWorldPickerInfo::getNumWaterLevelDecals()
{
	return m_aWaterLevelDecals.size();
}

const TCHAR* CvWorldPickerInfo::getWaterLevelDecalPath(int index)
{
	return m_aWaterLevelDecals[index];
}

int CvWorldPickerInfo::getNumWaterLevelGloss()
{
	return m_aWaterLevelGloss.size();
}

const TCHAR* CvWorldPickerInfo::getWaterLevelGlossPath(int index)
{
	return m_aWaterLevelGloss[index];
}

bool CvWorldPickerInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	float fVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "MapName");
	setMapName(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ModelFile");
	setModelFile(szTextVal);

	//sizes
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Sizes"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Size"))
		{
			do
			{
				pXML->GetXmlVal(&fVal);
				m_aSizes.push_back(fVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "Size"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//climates
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Climates"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ClimatePath"))
		{
			do
			{
				pXML->GetXmlVal(szTextVal);
				m_aClimates.push_back(szTextVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "ClimatePath"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//water level decals
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelDecals"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelDecalPath"))
		{
			do
			{
				pXML->GetXmlVal(szTextVal);
				m_aWaterLevelDecals.push_back(szTextVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "WaterLevelDecalPath"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//water level gloss
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelGloss"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelGlossPath"))
		{
			do
			{
				pXML->GetXmlVal(szTextVal);
				m_aWaterLevelGloss.push_back(szTextVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "WaterLevelGlossPath"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvWorldPickerInfo::copyNonDefaults(CvWorldPickerInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getMapName()		== cDefault)		setMapName(							pClassInfo->getMapName());
	if (getModelFile()		== cDefault)		setModelFile(						pClassInfo->getModelFile());
	if (getNumSizes()		== 0)
	{
		for ( int i = 0; i < pClassInfo->getNumSizes(); i++ )
		{
												m_aSizes.push_back(					pClassInfo->getSize(i));
		}
	}

	if (getNumClimates() == 0)
	{
		for ( int i = 0; i < pClassInfo->getNumClimates(); i++ )
		{
												m_aClimates.push_back(				pClassInfo->getClimatePath(i));
		}
	}

	if (getNumWaterLevelDecals() == 0)
	{
		for ( int i = 0; i < pClassInfo->getNumWaterLevelDecals(); i++ )
		{
												m_aWaterLevelDecals.push_back(		pClassInfo->getWaterLevelDecalPath(i));
		}
	}
	if (getNumWaterLevelGloss() == 0)
	{
		for ( int i = 0; i < pClassInfo->getNumWaterLevelGloss(); i++ )
		{
												m_aWaterLevelDecals.push_back(		pClassInfo->getWaterLevelGlossPath(i));
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSpaceShipInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpaceShipInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpaceShipInfo::CvSpaceShipInfo() :
m_eSpaceShipInfoType(SPACE_SHIP_INFO_TYPE_NONE),
m_iPartNumber(-1),
m_iArtType(-1),
m_iEventCode(-1),
m_eProjectType(NO_PROJECT),
m_eCameraUpAxis(AXIS_X)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpaceShipInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpaceShipInfo::~CvSpaceShipInfo()
{
}

const TCHAR* CvSpaceShipInfo::getNodeName()
{
	return m_szNodeName;
}

void CvSpaceShipInfo::setNodeName(const TCHAR* szVal)
{
	m_szNodeName = szVal;
}

const TCHAR* CvSpaceShipInfo::getProjectName()
{
	return m_szProjectName;
}

void CvSpaceShipInfo::setProjectName(const TCHAR* szVal)
{
	m_szProjectName = szVal;
	m_eProjectType = (ProjectTypes) GC.getInfoTypeForString(m_szProjectName, true);
}

ProjectTypes CvSpaceShipInfo::getProjectType()
{
	return m_eProjectType;
}

AxisTypes CvSpaceShipInfo::getCameraUpAxis()
{
	return m_eCameraUpAxis;
}

SpaceShipInfoTypes CvSpaceShipInfo::getSpaceShipInfoType()
{
	return m_eSpaceShipInfoType;
}

int CvSpaceShipInfo::getPartNumber()
{
	return m_iPartNumber;
}

int CvSpaceShipInfo::getArtType()
{
	return m_iArtType;
}

int CvSpaceShipInfo::getEventCode()
{
	return m_iEventCode;
}

bool CvSpaceShipInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "NodeName");
	setNodeName(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ProjectName");
	setProjectName(szTextVal);

	//up axis
	pXML->GetChildXmlValByName(szTextVal, "CameraUpAxis");
	if(szTextVal.CompareNoCase("AXIS_X") == 0)
		m_eCameraUpAxis = AXIS_X;
	else if(szTextVal.CompareNoCase("AXIS_Y") == 0)
		m_eCameraUpAxis = AXIS_Y;
	else if(szTextVal.CompareNoCase("AXIS_Z") == 0)
		m_eCameraUpAxis = AXIS_Z;
	else
	{
		FAssertMsg(false, "[Jason] Unknown Axis Type.");
	}

	pXML->GetChildXmlValByName(&m_iPartNumber, "PartNumber");
	pXML->GetChildXmlValByName(&m_iArtType, "ArtType");
	pXML->GetChildXmlValByName(&m_iEventCode, "EventCode");

	//type
	pXML->GetChildXmlValByName(szTextVal, "InfoType");
	if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_FILENAME") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_FILENAME;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_ALPHA_CENTAURI") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_ALPHA_CENTAURI;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_LAUNCH") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_LAUNCH;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_LAUNCHED") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_LAUNCHED;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_ZOOM_IN") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_ZOOM_IN;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_ZOOM_MOVE") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_ZOOM_MOVE;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_OFF") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_OFF;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_APPEAR") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_APPEAR;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_PREVIEW") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_PREVIEW;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_ON;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_LIGHT_OFF") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_LIGHT_OFF;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_GANTRY_SMOKE_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_GANTRY_SMOKE_ON;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_IN_SPACE_SMOKE_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_IN_SPACE_SMOKE_ON;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_IN_GAME_SMOKE_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_IN_GAME_SMOKE_ON;
	else
	{
		FAssertMsg(false, "[Jason] Unknown SpaceShipInfoType.");
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpaceShipInfo::copyNonDefaults(CvSpaceShipInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getNodeName()			== cDefault)	setNodeName(			pClassInfo->getNodeName());
	if (getProjectName()		== cDefault)	setProjectName(			pClassInfo->getProjectName());
	if (getPartNumber()			== 0)			m_iPartNumber			= pClassInfo->getPartNumber();
	if (getArtType()			== 0)			m_iArtType				= pClassInfo->getArtType();
	if (getEventCode()			== 0)			m_iEventCode			= pClassInfo->getEventCode();

//	if (getCameraUpAxis()		== cDefault)	m_eCameraUpAxis			= pClassInfo->getCameraUpAxis();
//	if (getSpaceShipInfoType()	== cDefault)	m_eSpaceShipInfoType	= pClassInfo->getSpaceShipInfoType();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAnimationPathInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAnimationPathInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationPathInfo::CvAnimationPathInfo() :
	m_bMissionPath(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAnimationPathInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationPathInfo::~CvAnimationPathInfo()
{
}

int CvAnimationPathInfo::getPathCategory( int i )
{
	return (int)m_vctPathDefinition.size() > i ? m_vctPathDefinition[i].first : -1;
}

float CvAnimationPathInfo::getPathParameter( int i )
{
	return (int)m_vctPathDefinition.size() > i ? m_vctPathDefinition[i].second : -1;
}

int CvAnimationPathInfo::getNumPathDefinitions()
{
	return m_vctPathDefinition.size();
}

CvAnimationPathDefinition * CvAnimationPathInfo::getPath( )
{
	return &m_vctPathDefinition;
}

bool CvAnimationPathInfo::isMissionPath() const
{
	return m_bMissionPath;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvAnimationPathInfo::read
//! \brief      Reads in a CvAnimationPathInfo definition from XML
//! \param      pXML Pointer to the XML loading object
//! \retval     true if the definition was read successfully, false otherwise
//------------------------------------------------------------------------------------------------
bool CvAnimationPathInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	TCHAR	szTempString[1024];				// Extracting text
	int		iCurrentCategory;				// The current category information we are building
	float	fParameter;						// Temporary

	pXML->GetChildXmlValByName( &m_bMissionPath, "bMissionPath" );
	gDLL->getXMLIFace()->SetToChild(pXML->GetXML() );
	gDLL->getXMLIFace()->GetLastNodeText(pXML->GetXML(), szTempString);
	gDLL->getXMLIFace()->NextSibling(pXML->GetXML());
	gDLL->getXMLIFace()->NextSibling(pXML->GetXML());
	do
	{
		if ( pXML->GetChildXmlValByName( szTempString, _T("Category") ))
		{
			iCurrentCategory = pXML->FindInInfoClass( szTempString);
			fParameter = 0.0f;
		}
		else
		{
			pXML->GetChildXmlValByName( szTempString, _T("Operator"));
			iCurrentCategory = GC.getTypesEnum(szTempString);
			iCurrentCategory = ((int)ANIMOP_FIRST) + iCurrentCategory;
			if ( !pXML->GetChildXmlValByName( &fParameter, "Parameter" ) )
			{
				fParameter = 0.0f;
			}
		}
			m_vctPathDefinition.push_back( std::make_pair(iCurrentCategory, fParameter ));
	}
	while ( gDLL->getXMLIFace()->NextSibling(pXML->GetXML()));
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAnimationPathInfo::copyNonDefaults(CvAnimationPathInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isMissionPath()				== false)		m_bMissionPath			= pClassInfo->isMissionPath();
	if (m_vctPathDefinition.size()	== 0)
	{
		for ( int i = 0; i < (int)m_vctPathDefinition.size(); i++ )
		{
			int iCurrentCategory											= pClassInfo->getPathCategory(i);
			float fParameter												= pClassInfo->getPathParameter(i);
													m_vctPathDefinition.push_back(std::make_pair(iCurrentCategory, fParameter ));
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAnimationCategoryInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAnimationCategoryInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationCategoryInfo::CvAnimationCategoryInfo()
{
	m_kCategory.second = -7540; // invalid.
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAnimationCategoryInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationCategoryInfo::~CvAnimationCategoryInfo()
{
}

int CvAnimationCategoryInfo::getCategoryBaseID( )
{
	return m_kCategory.first;
}

int CvAnimationCategoryInfo::getCategoryDefaultTo( )
{
	if ( m_kCategory.second < -1 )
	{
		// CvXMLLoadUtility *pXML = new CvXMLLoadUtility();
		m_kCategory.second = CvXMLLoadUtility::FindInInfoClass( m_szDefaultTo);
	}
	return (int)m_kCategory.second;
}

bool CvAnimationCategoryInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int		iBaseID;						// Temporary
	pXML->GetChildXmlValByName( m_szDefaultTo, "DefaultTo");
	pXML->GetChildXmlValByName( &iBaseID, "BaseID");
	m_kCategory.first = iBaseID;
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAnimationCategoryInfo::copyNonDefaults(CvAnimationCategoryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getCategoryBaseID()		== 0)				m_kCategory.first		= pClassInfo->getCategoryBaseID();
	if (getCategoryDefaultTo()	== ANIMCAT_NONE)	m_kCategory.second		= pClassInfo->getCategoryDefaultTo();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvEntityEventInfo
/////////////////////////////////////////////////////////////////////////////////////////////

CvEntityEventInfo::CvEntityEventInfo() :
m_bUpdateFormation(true)
{
}

CvEntityEventInfo::~CvEntityEventInfo()
{
}

bool CvEntityEventInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTmp, szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int iNumSibs, i;

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AnimationPathTypes"))
	{
		// Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				// if the call to the function that sets the current xml node to it's first non-comment
				// child and sets the parameter with the new node's value succeeds
				if (pXML->GetChildXmlVal(szTmp))
				{
					AnimationPathTypes eAnimationPath = (AnimationPathTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
					if ( eAnimationPath > ANIMATIONPATH_NONE )
						m_vctAnimationPathType.push_back( eAnimationPath );

					// loop through all the siblings, we start at 1 since we already have the first value
					for (i=1;i<iNumSibs;i++)
					{
						if (!pXML->GetNextXmlVal(szTmp))
						{
							break;
						}
						AnimationPathTypes eAnimationPath = (AnimationPathTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
						if ( eAnimationPath > ANIMATIONPATH_NONE )
							m_vctAnimationPathType.push_back( eAnimationPath );

					}
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"EffectTypes"))
	{
		// Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				// if the call to the function that sets the current xml node to it's first non-comment
				// child and sets the parameter with the new node's value succeeds
				if (pXML->GetChildXmlVal(szTmp))
				{
					EffectTypes eEffectType = (EffectTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
					if ( eEffectType > NO_EFFECT )
						m_vctEffectTypes.push_back( eEffectType );

					// loop through all the siblings, we start at 1 since we already have the first value
					for (i=1;i<iNumSibs;i++)
					{
						if (!pXML->GetNextXmlVal(szTmp))
						{
							break;
						}
						EffectTypes eEffectType = (EffectTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
						if ( eEffectType > NO_EFFECT )
							m_vctEffectTypes.push_back( eEffectType );
					}
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName( &m_bUpdateFormation, "bUpdateFormation" );

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEntityEventInfo::copyNonDefaults(CvEntityEventInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getUpdateFormation()		== false)		m_bUpdateFormation						= pClassInfo->getUpdateFormation();
	for (int i = 0; i < pClassInfo->getAnimationPathCount(); i++)
	{
		bool bPushBack = true;
		for (int j = 0; j < getAnimationPathCount(); j++)
		{
			if (getAnimationPathType(j) == pClassInfo->getAnimationPathType(i))	bPushBack = false;
		}
		if (bPushBack)								m_vctAnimationPathType.push_back(		pClassInfo->getAnimationPathType(i));
	}

	for (int i = 0; i < pClassInfo->getEffectTypeCount(); i++)
	{
		bool bPushBack = true;
		for (int j = 0; j < getEffectTypeCount(); j++)
		{
			if (getEffectType(j) == pClassInfo->getEffectType(i))	bPushBack = false;
		}
		if (bPushBack)								m_vctEffectTypes.push_back(				pClassInfo->getEffectType(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

AnimationPathTypes CvEntityEventInfo::getAnimationPathType(int iIndex) const
{
	return iIndex >= (int)m_vctAnimationPathType.size() ? ANIMATIONPATH_NONE : m_vctAnimationPathType[iIndex];
}

EffectTypes CvEntityEventInfo::getEffectType(int iIndex) const
{
	return iIndex >= (int)m_vctEffectTypes.size() ? NO_EFFECT : m_vctEffectTypes[iIndex];
}

int CvEntityEventInfo::getAnimationPathCount() const
{
	return m_vctAnimationPathType.size();
}

int CvEntityEventInfo::getEffectTypeCount() const
{
	return m_vctEffectTypes.size();
}

bool CvEntityEventInfo::getUpdateFormation() const
{
	return m_bUpdateFormation;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CvAssetInfoBase
/////////////////////////////////////////////////////////////////////////////////////////////

const TCHAR* CvAssetInfoBase::getTag() const
{
	return getType();
}

void CvAssetInfoBase::setTag(const TCHAR* szDesc)
{
	m_szType = szDesc;
}

const TCHAR* CvAssetInfoBase::getPath() const
{
	return m_szPath;
}

void CvAssetInfoBase::setPath(const TCHAR* szDesc)
{
	m_szPath = szDesc;
}

bool CvAssetInfoBase::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))		// 'tag' is the same as 'type'
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
	setPath(szTextVal);

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoAsset
/////////////////////////////////////////////////////////////////////////////////////////////

const TCHAR* CvArtInfoAsset::getNIF() const
{
	return m_szNIF;
}

const TCHAR* CvArtInfoAsset::getKFM() const
{
	return m_szKFM;
}

void CvArtInfoAsset::setNIF(const TCHAR* szDesc)
{
	m_szNIF = szDesc;
}

void CvArtInfoAsset::setKFM(const TCHAR* szDesc)
{
	m_szKFM = szDesc;
}

bool CvArtInfoAsset::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvAssetInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "NIF");
	setNIF(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "KFM");
	setKFM(szTextVal);


	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoAsset::copyNonDefaults(CvArtInfoAsset* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoBonus
/////////////////////////////////////////////////////////////////////////////////////////////

bool CvArtInfoBonus::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "SHADERNIF");
	setShaderNIF(szTextVal);

	pXML->GetChildXmlValByName(&m_iFontButtonIndex, "FontButtonIndex");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoBonus::copyNonDefaults(CvArtInfoBonus* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

CvArtInfoBonus::CvArtInfoBonus()
{
	m_iFontButtonIndex = 0;
}

int CvArtInfoBonus::getFontButtonIndex() const
{
	return m_iFontButtonIndex;
}

const TCHAR* CvArtInfoBonus::getShaderNIF() const
{
	return m_szShaderNIF;
}
void CvArtInfoBonus::setShaderNIF(const TCHAR* szDesc)
{
	m_szShaderNIF = szDesc;
}

const CvArtInfoBonus* CvBonusInfo::getArtInfo() const
{
	return ARTFILEMGR.getBonusArtInfo( getArtDefineTag());
}


/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoUnit
/////////////////////////////////////////////////////////////////////////////////////////////

CvArtInfoUnit::CvArtInfoUnit() :
m_fShadowScale(0.0f),
m_iDamageStates(0),
m_bActAsRanged(false),
m_bActAsLand(false),
m_bActAsAir(false),
m_bCombatExempt(false),
m_fTrailWidth(0.0f),
m_fTrailLength(0.0f),
m_fTrailTaper(0.0f),
m_fTrailFadeStartTime(0.0f),
m_fTrailFadeFalloff(0.0f),
m_fRangedDeathTime(0.0f),
m_fExchangeAngle(0.0f),
m_bSmoothMove(false),
m_fAngleInterRate(FLT_MAX),
m_fBankRate(0),
m_iRunLoopSoundTag(0),
m_iRunEndSoundTag(0),
m_iSelectionSoundScriptId(0),
m_iActionSoundScriptId(0),
m_iPatrolSoundTag(0)
{
}

CvArtInfoUnit::~CvArtInfoUnit()
{
}

bool CvArtInfoUnit::getActAsRanged() const
{
	return m_bActAsRanged;
}

bool CvArtInfoUnit::getActAsLand() const
{
	return m_bActAsLand;
}

bool CvArtInfoUnit::getActAsAir() const
{
	return m_bActAsAir;
}

const TCHAR* CvArtInfoUnit::getShaderNIF() const
{
	return m_szShaderNIF;
}

void CvArtInfoUnit::setShaderNIF(const TCHAR* szDesc)
{
	m_szShaderNIF = szDesc;
}

const TCHAR* CvArtInfoUnit::getShadowNIF() const
{
	return m_szShadowNIF;
}

float CvArtInfoUnit::getShadowScale() const
{
	return m_fShadowScale;
}

const TCHAR* CvArtInfoUnit::getShadowAttachNode() const
{
	return m_szShadowAttach;
}

int CvArtInfoUnit::getDamageStates() const
{
	return m_iDamageStates;
}


const TCHAR* CvArtInfoUnit::getTrailTexture() const
{
	return m_szTrailTexture;
}

float CvArtInfoUnit::getTrailWidth() const
{
	return m_fTrailWidth;
}

float CvArtInfoUnit::getTrailLength() const
{
	return m_fTrailLength;
}

float CvArtInfoUnit::getTrailTaper() const
{
	return m_fTrailTaper;
}

float CvArtInfoUnit::getTrailFadeStarTime() const
{
	return m_fTrailFadeStartTime;
}

float CvArtInfoUnit::getTrailFadeFalloff() const
{
	return m_fTrailFadeFalloff;
}

float CvArtInfoUnit::getBattleDistance() const
{
	return m_fBattleDistance;
}

float CvArtInfoUnit::getRangedDeathTime() const
{
	return m_fRangedDeathTime;
}

float CvArtInfoUnit::getExchangeAngle() const
{
	return m_fExchangeAngle;
}

bool CvArtInfoUnit::getCombatExempt() const
{
	return m_bCombatExempt;
}

bool CvArtInfoUnit::getSmoothMove() const
{
	return m_bSmoothMove;
}

float CvArtInfoUnit::getAngleInterpRate() const
{
	return m_fAngleInterRate;
}

float CvArtInfoUnit::getBankRate() const
{
	return m_fBankRate;
}

bool CvArtInfoUnit::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	CvString szTextVal;

	pXML->GetChildXmlValByName(szTextVal, "ActionSound");
	m_iActionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;
	pXML->GetChildXmlValByName(szTextVal, "SelectionSound");
	m_iSelectionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;
	pXML->GetChildXmlValByName(szTextVal, "PatrolSound");
	m_iPatrolSoundTag = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;

	pXML->GetChildXmlValByName(szTextVal, "TrainSound");
	setTrainSound(szTextVal);

	pXML->GetChildXmlValByName(&m_bActAsRanged, "bActAsRanged" );
	pXML->GetChildXmlValByName(&m_bActAsLand, "bActAsLand" );
	pXML->GetChildXmlValByName(&m_bActAsAir, "bActAsAir" );
	pXML->GetChildXmlValByName(&m_bCombatExempt, "bCombatExempt", false );
	pXML->GetChildXmlValByName(&m_fExchangeAngle, "fExchangeAngle", 0.0f );
	pXML->GetChildXmlValByName(&m_bSmoothMove, "bSmoothMove", false );
	pXML->GetChildXmlValByName(&m_fAngleInterRate, "fAngleInterpRate", FLT_MAX );
	pXML->GetChildXmlValByName(&m_fBankRate, "fBankRate", 0 );

	pXML->GetChildXmlValByName(szTextVal, "SHADERNIF");
	setShaderNIF(szTextVal);

	if ( gDLL->getXMLIFace()->SetToChildByTagName( pXML->GetXML(), "ShadowDef" ))
	{
		pXML->GetChildXmlValByName( m_szShadowAttach, "ShadowAttachNode" );
		pXML->GetChildXmlValByName(m_szShadowNIF, "ShadowNIF");
		pXML->GetChildXmlValByName(&m_fShadowScale, "fShadowScale");
		gDLL->getXMLIFace()->SetToParent( pXML->GetXML());
	}

	pXML->GetChildXmlValByName(&m_iDamageStates, "iDamageStates", 0);
	pXML->GetChildXmlValByName(&m_fBattleDistance, "fBattleDistance", 0.0f);
	pXML->GetChildXmlValByName(&m_fRangedDeathTime, "fRangedDeathTime", 0.0f );

	m_fTrailWidth = -1.0f; // invalid.
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TrailDefinition"))
	{
		pXML->GetChildXmlValByName(m_szTrailTexture, "Texture" );
		pXML->GetChildXmlValByName(&m_fTrailWidth, "fWidth" );
		pXML->GetChildXmlValByName(&m_fTrailLength, "fLength" );
		pXML->GetChildXmlValByName(&m_fTrailTaper, "fTaper" );
		pXML->GetChildXmlValByName(&m_fTrailFadeStartTime, "fFadeStartTime" );
		pXML->GetChildXmlValByName(&m_fTrailFadeFalloff, "fFadeFalloff" );
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML() );
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AudioRunSounds"))
	{
		pXML->GetChildXmlValByName(szTextVal, "AudioRunTypeLoop");
		m_iRunLoopSoundTag = GC.getFootstepAudioTypeByTag(szTextVal);
		pXML->GetChildXmlValByName(szTextVal, "AudioRunTypeEnd");
		m_iRunEndSoundTag = GC.getFootstepAudioTypeByTag(szTextVal);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoUnit::copyNonDefaults(CvArtInfoUnit* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

const TCHAR* CvArtInfoUnit::getTrainSound() const
{
	return m_szTrainSound;
}

void CvArtInfoUnit::setTrainSound(const TCHAR* szVal)
{
	m_szTrainSound = szVal;
}

int CvArtInfoUnit::getRunLoopSoundTag() const
{
	return m_iRunLoopSoundTag;
}

int CvArtInfoUnit::getRunEndSoundTag() const
{
	return m_iRunEndSoundTag;
}

int CvArtInfoUnit::getPatrolSoundTag() const
{
	return m_iPatrolSoundTag;
}

int CvArtInfoUnit::getSelectionSoundScriptId() const
{
	return m_iSelectionSoundScriptId;
}

int CvArtInfoUnit::getActionSoundScriptId() const
{
	return m_iActionSoundScriptId;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoBuilding
/////////////////////////////////////////////////////////////////////////////////////////////

CvArtInfoBuilding::CvArtInfoBuilding() :
m_bAnimated(false)
{
}

CvArtInfoBuilding::~CvArtInfoBuilding()
{
}

bool CvArtInfoBuilding::isAnimated() const
{
	return m_bAnimated;
}

const TCHAR* CvArtInfoBuilding::getLSystemName() const
{
	return m_szLSystemName;
}

bool CvArtInfoBuilding::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szLSystemName, "LSystem");

	pXML->GetChildXmlValByName(&m_bAnimated, "bAnimated");
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoBuilding::copyNonDefaults(CvArtInfoBuilding* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoCivilization
/////////////////////////////////////////////////////////////////////////////////////////////

CvArtInfoCivilization::CvArtInfoCivilization() :
m_bWhiteFlag(false)
{
}

CvArtInfoCivilization::~CvArtInfoCivilization()
{
}

bool CvArtInfoCivilization::isWhiteFlag() const
{
	return m_bWhiteFlag;
}

bool CvArtInfoCivilization::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bWhiteFlag, "bWhiteFlag");
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoCivilization::copyNonDefaults(CvArtInfoCivilization* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoLeaderhead
/////////////////////////////////////////////////////////////////////////////////////////////

const TCHAR* CvArtInfoLeaderhead::getNoShaderNIF() const
{
	return m_szNoShaderNIF;
}

void CvArtInfoLeaderhead::setNoShaderNIF(const TCHAR* szNIF)
{
	m_szNoShaderNIF = szNIF;
}

const TCHAR* CvArtInfoLeaderhead::getBackgroundKFM() const
{
	return m_szBackgroundKFM;
}

void CvArtInfoLeaderhead::setBackgroundKFM( const TCHAR* szKFM)
{
	m_szBackgroundKFM = szKFM;
}

bool CvArtInfoLeaderhead::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "NoShaderNIF");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setNoShaderNIF(szTextVal);

	if (pXML->GetChildXmlValByName(szTextVal, "BackgroundKFM"))
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		setBackgroundKFM(szTextVal);
/**								----  End Original Code  ----									**/
	{
		p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
		SAFE_DELETE(p_aszDirName);
		setBackgroundKFM(szTextVal);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	else
		setBackgroundKFM("");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoLeaderhead::copyNonDefaults(CvArtInfoLeaderhead* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoScalableAsset
/////////////////////////////////////////////////////////////////////////////////////////////

bool CvArtInfoScalableAsset::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	return CvScalableInfo::read(pXML);
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoScalableAsset::copyNonDefaults(CvArtInfoScalableAsset* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvArtInfoImprovement
//////////////////////////////////////////////////////////////////////////

CvArtInfoImprovement::CvArtInfoImprovement() :
m_bExtraAnimations(false)
{
}

CvArtInfoImprovement::~CvArtInfoImprovement()
{
}

bool CvArtInfoImprovement::isExtraAnimations() const
{
	return m_bExtraAnimations;
}

bool CvArtInfoImprovement::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bExtraAnimations, "bExtraAnimations");

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "SHADERNIF");
	setShaderNIF(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoImprovement::copyNonDefaults(CvArtInfoImprovement* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvArtInfoTerrain
//////////////////////////////////////////////////////////////////////////

CvArtInfoTerrain::CvArtInfoTerrain() :
m_iLayerOrder(0),
m_bAlphaShader(false),
m_numTextureBlends(16),
m_pTextureSlots(NULL)
{
	m_pTextureSlots = new CvTextureBlendSlotList * [m_numTextureBlends];
	for ( int i = 0; i < m_numTextureBlends; i++ )
	{
		m_pTextureSlots[i] = new CvTextureBlendSlotList;
	}

}

CvArtInfoTerrain::~CvArtInfoTerrain()
{
	for ( int i = 0; i < m_numTextureBlends; i++ )
	{
		SAFE_DELETE(m_pTextureSlots[i]);
	}
	SAFE_DELETE_ARRAY( m_pTextureSlots);
}

const TCHAR* CvArtInfoTerrain::getBaseTexture()
{
	return getPath();
}

void CvArtInfoTerrain::setBaseTexture(const TCHAR* szTmp )
{
	setPath(szTmp);
}

const TCHAR* CvArtInfoTerrain::getGridTexture()
{
	return m_szGridTexture;
}

void CvArtInfoTerrain::setGridTexture(const TCHAR* szTmp )
{
	m_szGridTexture = szTmp;
}

const TCHAR* CvArtInfoTerrain::getDetailTexture()
{
	return m_szDetailTexture;
}

void CvArtInfoTerrain::setDetailTexture(const TCHAR* szTmp)
{
	m_szDetailTexture = szTmp;
}

int CvArtInfoTerrain::getLayerOrder()
{
	return m_iLayerOrder;
}

bool CvArtInfoTerrain::useAlphaShader()
{
	return m_bAlphaShader;
}

CvTextureBlendSlotList &CvArtInfoTerrain::getBlendList(int blendMask)
{
	FAssert(blendMask>0 && blendMask<16);
	return *m_pTextureSlots[blendMask];
}

void BuildSlotList( CvTextureBlendSlotList &list, CvString &numlist)
{
	//convert string to
	char seps[]   = " ,\t\n";
	char *token;
	const char *numstring = numlist;
	token = strtok( const_cast<char *>(numstring), seps);
	while( token != NULL )
	{
		int slot = atoi(token);
		token = strtok( NULL, seps);
		int rotation = atoi(token);
		list.push_back(std::make_pair( slot, rotation));
		token = strtok( NULL, seps);
	}
}

bool CvArtInfoTerrain::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Grid");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setGridTexture(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "Detail");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setDetailTexture(szTextVal);
	pXML->GetChildXmlValByName(&m_iLayerOrder, "LayerOrder");
	pXML->GetChildXmlValByName(&m_bAlphaShader, "AlphaShader");

	// Parse texture slots for blend tile lists
	char xmlName[] = "TextureBlend00";
	for(int i =1; i<m_numTextureBlends;i++ )
	{
		sprintf(xmlName+(strlen(xmlName)-2),"%02d",i);
		pXML->GetChildXmlValByName(szTextVal, xmlName);
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
		p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
		SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
		BuildSlotList(*m_pTextureSlots[i], szTextVal);
	}

	return CvArtInfoAsset::read(pXML);
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoTerrain::copyNonDefaults(CvArtInfoTerrain* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvArtInfoFeature
//////////////////////////////////////////////////////////////////////////

CvArtInfoFeature::CvArtInfoFeature() :
m_bAnimated(false),
m_bRiverArt(false),
m_eTileArtType(TILE_ART_TYPE_NONE),
m_eLightType(LIGHT_TYPE_NONE)
{
}

CvArtInfoFeature::~CvArtInfoFeature()
{
}

bool CvArtInfoFeature::isAnimated() const
{
	return m_bAnimated;
}

bool CvArtInfoFeature::isRiverArt() const
{
	return m_bRiverArt;
}

TileArtTypes CvArtInfoFeature::getTileArtType() const
{
	return m_eTileArtType;
}

LightTypes CvArtInfoFeature::getLightType() const
{
	return m_eLightType;
}

bool CvArtInfoFeature::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bAnimated, "bAnimated");
	pXML->GetChildXmlValByName(&m_bRiverArt, "bRiverArt");

	CvString szTemp;
	pXML->GetChildXmlValByName(szTemp, "TileArtType");
	if(szTemp.CompareNoCase("TILE_ART_TYPE_NONE") == 0)
		m_eTileArtType = TILE_ART_TYPE_NONE;
	else if(szTemp.CompareNoCase("TILE_ART_TYPE_TREES") == 0)
		m_eTileArtType = TILE_ART_TYPE_TREES;
	else if(szTemp.CompareNoCase("TILE_ART_TYPE_HALF_TILING") == 0)
		m_eTileArtType = TILE_ART_TYPE_HALF_TILING;
	else if(szTemp.CompareNoCase("TILE_ART_TYPE_PLOT_TILING") == 0)
		m_eTileArtType = TILE_ART_TYPE_PLOT_TILING;
	else
	{
		FAssertMsg(false, "[Jason] Unknown TileArtType.");
	}

	pXML->GetChildXmlValByName(szTemp, "LightType");
	if(szTemp.CompareNoCase("LIGHT_TYPE_NONE") == 0)
		m_eLightType = LIGHT_TYPE_NONE;
	else if(szTemp.CompareNoCase("LIGHT_TYPE_SUN") == 0)
		m_eLightType = LIGHT_TYPE_SUN;
	else if(szTemp.CompareNoCase("LIGHT_TYPE_TERRAIN") == 0)
		m_eLightType = LIGHT_TYPE_TERRAIN;
	else if(szTemp.CompareNoCase("LIGHT_TYPE_UNIT") == 0)
		m_eLightType = LIGHT_TYPE_UNIT;
	else
	{
		FAssertMsg(false, "[Jason] Unknown LightType.");
	}

	//feature varieties
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureVariety"))
	{
		do
		{
			m_aFeatureVarieties.push_back(FeatureVariety());
			FeatureVariety &featureVariety = m_aFeatureVarieties.back();

			//generate rotations
			bool generateRotations = false;
			pXML->GetChildXmlValByName(&generateRotations, "bGenerateRotations");

			//feature art pieces
			if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureArtPieces"))
			{
				if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureArtPiece"))
				{
					do
					{
						//connection mask
						pXML->GetChildXmlValByName(szTemp, "Connections");
						int connectionMask = getConnectionMaskFromString(szTemp);

						//model files
						if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ModelFile"))
						{
							do
							{
								pXML->GetXmlVal(szTemp);
								if(!generateRotations)
								{
									FeatureArtPiece &featureArtPiece = featureVariety.createFeatureArtPieceFromConnectionMask(connectionMask);
									featureArtPiece.m_aArtModels.push_back(FeatureArtModel(szTemp, ROTATE_NONE));
								}
								else
								{
									for(int i=0;i<NUM_ROTATION_TYPES;i++)
									{
										int newConnectionMask = getRotatedConnectionMask(connectionMask, (RotationTypes) i);
										FeatureArtPiece &featureArtPiece = featureVariety.createFeatureArtPieceFromConnectionMask(newConnectionMask);
										featureArtPiece.m_aArtModels.push_back(FeatureArtModel(szTemp, (RotationTypes) i));
									}
								}
							} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "ModelFile"));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}
					} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "FeatureArtPiece"));

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}

			//feature art pieces
			if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureDummyNodes"))
			{
				if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureDummyNode"))
				{
					do
					{
						CvString tagName;
						CvString nodeName;

						//tag name
						pXML->GetChildXmlValByName(tagName, "Tag");

						//node name
						pXML->GetChildXmlValByName(nodeName, "Name");

						featureVariety.createFeatureDummyNode(tagName, nodeName);
					} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "FeatureDummyNode"));

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}

			//variety button
			pXML->GetChildXmlValByName(featureVariety.m_szVarietyButton, "VarietyButton");

		} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "FeatureVariety"));

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoFeature::copyNonDefaults(CvArtInfoFeature* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

const CvArtInfoFeature::FeatureVariety &CvArtInfoFeature::getVariety(int index) const
{
//	FAssertMsg((index >= 0) && (index < (int) m_aFeatureVarieties.size()), "[Jason] Feature Variety index out of range.");
	if (!((index >= 0) && (index < (int)m_aFeatureVarieties.size())))
	{
		index = 0;
	}
	return m_aFeatureVarieties[index];
}

int CvArtInfoFeature::getNumVarieties() const
{
	return m_aFeatureVarieties.size();
}

std::string CvArtInfoFeature::getFeatureDummyNodeName(int variety, std::string tagName)
{
	return getVariety(variety).getFeatureDummyNodeName(tagName);
}

int CvArtInfoFeature::getConnectionMaskFromString(const CvString &connectionString)
{
	if(connectionString.IsEmpty())
		return 0;
	else
	{
		std::vector<CvString> tokens;
		connectionString.getTokens(" \t\n", tokens);

		int connectionMask = 0;
		for(int i=0;i<(int)tokens.size();i++)
		{
			// found a token, parse it.
			CvString &token = tokens[i];
			if(token.CompareNoCase("NW") == 0)
				connectionMask |= DIRECTION_NORTHWEST_MASK;
			else if(token.CompareNoCase("N") == 0)
				connectionMask |= DIRECTION_NORTH_MASK;
			else if(token.CompareNoCase("NE") == 0)
				connectionMask |= DIRECTION_NORTHEAST_MASK;
			else if(token.CompareNoCase("E") == 0)
				connectionMask |= DIRECTION_EAST_MASK;
			else if(token.CompareNoCase("SE") == 0)
				connectionMask |= DIRECTION_SOUTHEAST_MASK;
			else if(token.CompareNoCase("S") == 0)
				connectionMask |= DIRECTION_SOUTH_MASK;
			else if(token.CompareNoCase("SW") == 0)
				connectionMask |= DIRECTION_SOUTHWEST_MASK;
			else if(token.CompareNoCase("W") == 0)
				connectionMask |= DIRECTION_WEST_MASK;
			else
			{
				FAssertMsg(false, "[Jason] Invalid connection direction.");
			}
		}

		FAssertMsg(connectionMask > 0, "[Jason] Did not find feature connection mask.");
		return connectionMask;
	}
}

int CvArtInfoFeature::getRotatedConnectionMask(int connectionMask, RotationTypes rotation)
{
	if(rotation == ROTATE_NONE)
		connectionMask = connectionMask;
	else if(rotation == ROTATE_90CW)
		connectionMask = connectionMask << 2; //rotate two directions CW
	else if(rotation == ROTATE_180CW)
		connectionMask = connectionMask << 4; //rotate four directions CW
	else if(rotation == ROTATE_270CW)
		connectionMask = connectionMask << 6; //rotate six directions CW

	//renormalize directions that wrapped around
	connectionMask = connectionMask | (connectionMask >> 8);
	connectionMask = connectionMask & 255;
	return connectionMask;
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvEmphasizeInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvEmphasizeInfo::CvEmphasizeInfo() :
m_bAvoidGrowth(false),
m_bGreatPeople(false),
/*************************************************************************************************/
/**	New Tag Defs	(CityAIInfos)			11/15/08								Jean Elcard	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_bAvoidAngryCitizens(false),
m_bAvoidUnhealthyCitizens(false),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_piYieldModifiers(NULL),
m_piCommerceModifiers(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvEmphasizeInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvEmphasizeInfo::~CvEmphasizeInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldModifiers);
	SAFE_DELETE_ARRAY(m_piCommerceModifiers);
}

bool CvEmphasizeInfo::isAvoidGrowth() const
{
	return m_bAvoidGrowth;
}

bool CvEmphasizeInfo::isGreatPeople() const
{
	return m_bGreatPeople;
}

/*************************************************************************************************/
/**	New Tag Defs	(CityAIInfos)			11/15/08								Jean Elcard	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
bool CvEmphasizeInfo::isAvoidAngryCitizens() const
{
	return m_bAvoidAngryCitizens;
}

bool CvEmphasizeInfo::isAvoidUnhealthyCitizens() const
{
	return m_bAvoidUnhealthyCitizens;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
// Arrays

int CvEmphasizeInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldModifiers ? m_piYieldModifiers[i] : -1;
}

int CvEmphasizeInfo::getCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceModifiers ? m_piCommerceModifiers[i] : -1;
}

//
// read from XML
//
bool CvEmphasizeInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bAvoidGrowth, "bAvoidGrowth");
	pXML->GetChildXmlValByName(&m_bGreatPeople, "bGreatPeople");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
	{
		pXML->SetYields(&m_piYieldModifiers);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldModifiers, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCommerceModifiers);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceModifiers, NUM_COMMERCE_TYPES);
	}

/*************************************************************************************************/
/**	New Tag Defs	(CityAIInfos)			11/15/08								Jean Elcard	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bAvoidAngryCitizens, "bAvoidAngryCitizens");
	pXML->GetChildXmlValByName(&m_bAvoidUnhealthyCitizens, "bAvoidUnhealthyCitizens");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(CityAIInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEmphasizeInfo::copyNonDefaults(CvEmphasizeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isAvoidGrowth()					== false)		m_bAvoidGrowth				= pClassInfo->isAvoidGrowth();
	if (isGreatPeople()					== false)		m_bGreatPeople				= pClassInfo->isGreatPeople();
	if (isAvoidAngryCitizens()			== false)		m_bAvoidAngryCitizens		= pClassInfo->isAvoidAngryCitizens();
	if (isAvoidUnhealthyCitizens()		== false)		m_bAvoidUnhealthyCitizens	= pClassInfo->isAvoidUnhealthyCitizens();
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_piYieldModifiers[i]		== 0)			m_piYieldModifiers[i]		= pClassInfo->getYieldChange(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if (m_piCommerceModifiers[i]	== 0)			m_piCommerceModifiers[i]	= pClassInfo->getCommerceChange(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  CvUpkeepInfo
//

CvUpkeepInfo::CvUpkeepInfo() :
m_iPopulationPercent(0),
m_iCityPercent(0)
{
}

CvUpkeepInfo::~CvUpkeepInfo()
{
}

int CvUpkeepInfo::getPopulationPercent() const
{
	return m_iPopulationPercent;
}

int CvUpkeepInfo::getCityPercent() const
{
	return m_iCityPercent;
}

bool CvUpkeepInfo::read(CvXMLLoadUtility* pXml)
{
	if (!CvInfoBase::read(pXml))
	{
		return false;
	}

	pXml->GetChildXmlValByName(&m_iPopulationPercent, "iPopulationPercent");
	pXml->GetChildXmlValByName(&m_iCityPercent, "iCityPercent");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUpkeepInfo::copyNonDefaults(CvUpkeepInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPopulationPercent()		== 0)		m_iPopulationPercent		= pClassInfo->getPopulationPercent();
	if (getCityPercent()			== 0)		m_iCityPercent				= pClassInfo->getCityPercent();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  CvCultureLevelInfo
//

CvCultureLevelInfo::CvCultureLevelInfo() :
m_iCityDefenseModifier(0),
m_paiSpeedThreshold(NULL)
{
}

CvCultureLevelInfo::~CvCultureLevelInfo()
{
	SAFE_DELETE_ARRAY(m_paiSpeedThreshold);
}

int CvCultureLevelInfo::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

int CvCultureLevelInfo::getSpeedThreshold(int i) const
{
	FAssert(i < GC.getNumGameSpeedInfos());
	FAssert(i > -1);
	return m_paiSpeedThreshold[i];
}

bool CvCultureLevelInfo::read(CvXMLLoadUtility* pXml)
{
	if (!CvInfoBase::read(pXml))
	{
		return false;
	}

	pXml->GetChildXmlValByName(&m_iCityDefenseModifier, "iCityDefenseModifier");

	pXml->SetVariableListTagPair(&m_paiSpeedThreshold, "SpeedThresholds", sizeof(GC.getGameSpeedInfo((GameSpeedTypes)0)), GC.getNumGameSpeedInfos());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCultureLevelInfo::copyNonDefaults(CvCultureLevelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getCityDefenseModifier()		== 0)		m_iCityDefenseModifier		= pClassInfo->getCityDefenseModifier();
	for ( int i = 0; i < GC.getNumGameSpeedInfos(); i++ )
	{
		if (m_paiSpeedThreshold[i]		== 0)		m_paiSpeedThreshold[i]		= pClassInfo->getSpeedThreshold(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  CvEraInfo
//

CvEraInfo::CvEraInfo() :
m_iStartingUnitMultiplier(0),
m_iStartingDefenseUnits(0),
m_iStartingWorkerUnits(0),
m_iStartingExploreUnits(0),
m_iAdvancedStartPoints(0),
m_iStartingGold(0),
m_iFreePopulation(0),
m_iStartPercent(0),
m_iGrowthPercent(0),
m_iTrainPercent(0),
m_iConstructPercent(0),
m_iCreatePercent(0),
m_iResearchPercent(0),
m_iBuildPercent(0),
m_iImprovementPercent(0),
m_iGreatPeoplePercent(0),
m_iAnarchyPercent(0),
m_iEventChancePerTurn(0),
m_iSoundtrackSpace(0),
m_iNumSoundtracks(0),
m_bNoGoodies(false),
m_bNoAnimals(false),
m_bNoBarbUnits(false),
m_bNoBarbCities(false),
m_bFirstSoundtrackFirst(false),
m_paiCitySoundscapeSciptIds(NULL),
m_paiSoundtracks(NULL)
{
}

CvEraInfo::~CvEraInfo()
{
	SAFE_DELETE_ARRAY(m_paiCitySoundscapeSciptIds);
	SAFE_DELETE_ARRAY(m_paiSoundtracks);
}

int CvEraInfo::getStartingUnitMultiplier() const
{
	return m_iStartingUnitMultiplier;
}

int CvEraInfo::getStartingDefenseUnits() const
{
	return m_iStartingDefenseUnits;
}

int CvEraInfo::getStartingWorkerUnits() const
{
	return m_iStartingWorkerUnits;
}

int CvEraInfo::getStartingExploreUnits() const
{
	return m_iStartingExploreUnits;
}

int CvEraInfo::getAdvancedStartPoints() const
{
	return m_iAdvancedStartPoints;
}

int CvEraInfo::getStartingGold() const
{
	return m_iStartingGold;
}

int CvEraInfo::getFreePopulation() const
{
	return m_iFreePopulation;
}

int CvEraInfo::getStartPercent() const
{
	return m_iStartPercent;
}

int CvEraInfo::getGrowthPercent() const
{
	return m_iGrowthPercent;
}

int CvEraInfo::getTrainPercent() const
{
	return m_iTrainPercent;
}

int CvEraInfo::getConstructPercent() const
{
	return m_iConstructPercent;
}

int CvEraInfo::getCreatePercent() const
{
	return m_iCreatePercent;
}

int CvEraInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvEraInfo::getBuildPercent() const
{
	return m_iBuildPercent;
}

int CvEraInfo::getImprovementPercent() const
{
	return m_iImprovementPercent;
}

int CvEraInfo::getGreatPeoplePercent() const
{
	return m_iGreatPeoplePercent;
}

int CvEraInfo::getAnarchyPercent() const
{
	return m_iAnarchyPercent;
}

int CvEraInfo::getEventChancePerTurn() const
{
	return m_iEventChancePerTurn;
}

int CvEraInfo::getSoundtrackSpace() const
{
	return m_iSoundtrackSpace;
}

bool CvEraInfo::isFirstSoundtrackFirst() const
{
	return m_bFirstSoundtrackFirst;
}

int CvEraInfo::getNumSoundtracks() const
{
	return m_iNumSoundtracks;
}

const TCHAR* CvEraInfo::getAudioUnitVictoryScript() const
{
	return m_szAudioUnitVictoryScript;
}

const TCHAR* CvEraInfo::getAudioUnitDefeatScript() const
{
	return m_szAudioUnitDefeatScript;
}

bool CvEraInfo::isNoGoodies() const
{
	return m_bNoGoodies;
}

bool CvEraInfo::isNoAnimals() const
{
	return m_bNoAnimals;
}

bool CvEraInfo::isNoBarbUnits() const
{
	return m_bNoBarbUnits;
}

bool CvEraInfo::isNoBarbCities() const
{
	return m_bNoBarbCities;
}

// Arrays

int CvEraInfo::getSoundtracks(int i) const
{
	FAssertMsg(i < getNumSoundtracks(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	return m_paiSoundtracks ? m_paiSoundtracks[i] : -1;
}

int CvEraInfo::getCitySoundscapeSciptId(int i) const
{
//	FAssertMsg(i < ?, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiCitySoundscapeSciptIds ? m_paiCitySoundscapeSciptIds[i] : -1;
}

bool CvEraInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bNoGoodies, "bNoGoodies");
	pXML->GetChildXmlValByName(&m_bNoAnimals, "bNoAnimals");
	pXML->GetChildXmlValByName(&m_bNoBarbUnits, "bNoBarbUnits");
	pXML->GetChildXmlValByName(&m_bNoBarbCities, "bNoBarbCities");
	pXML->GetChildXmlValByName(&m_iStartingUnitMultiplier, "iStartingUnitMultiplier");
	pXML->GetChildXmlValByName(&m_iStartingDefenseUnits, "iStartingDefenseUnits");
	pXML->GetChildXmlValByName(&m_iStartingWorkerUnits, "iStartingWorkerUnits");
	pXML->GetChildXmlValByName(&m_iStartingExploreUnits, "iStartingExploreUnits");
	pXML->GetChildXmlValByName(&m_iAdvancedStartPoints, "iAdvancedStartPoints");
	pXML->GetChildXmlValByName(&m_iStartingGold, "iStartingGold");
	pXML->GetChildXmlValByName(&m_iFreePopulation, "iFreePopulation");
	pXML->GetChildXmlValByName(&m_iStartPercent, "iStartPercent");
	pXML->GetChildXmlValByName(&m_iGrowthPercent, "iGrowthPercent");
	pXML->GetChildXmlValByName(&m_iTrainPercent, "iTrainPercent");
	pXML->GetChildXmlValByName(&m_iConstructPercent, "iConstructPercent");
	pXML->GetChildXmlValByName(&m_iCreatePercent, "iCreatePercent");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iBuildPercent, "iBuildPercent");
	pXML->GetChildXmlValByName(&m_iImprovementPercent, "iImprovementPercent");
	pXML->GetChildXmlValByName(&m_iGreatPeoplePercent, "iGreatPeoplePercent");
	pXML->GetChildXmlValByName(&m_iAnarchyPercent, "iAnarchyPercent");
	pXML->GetChildXmlValByName(&m_iEventChancePerTurn, "iEventChancePerTurn");
	pXML->GetChildXmlValByName(&m_iSoundtrackSpace, "iSoundtrackSpace");
	pXML->GetChildXmlValByName(&m_bFirstSoundtrackFirst, "bFirstSoundtrackFirst");
	pXML->GetChildXmlValByName(m_szAudioUnitVictoryScript, "AudioUnitVictoryScript");
	pXML->GetChildXmlValByName(m_szAudioUnitDefeatScript, "AudioUnitDefeatScript");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "EraInfoSoundtracks"))
	{
		CvString* pszSoundTrackNames = NULL;
		pXML->SetStringList(&pszSoundTrackNames, &m_iNumSoundtracks);

		if (m_iNumSoundtracks > 0)
		{
			m_paiSoundtracks = new int[m_iNumSoundtracks];

			int j;
			for (j=0;j<m_iNumSoundtracks;j++)
			{
				m_paiSoundtracks[j] = ((!gDLL->getAudioDisabled()) ? gDLL->getAudioTagIndex(pszSoundTrackNames[j], AUDIOTAG_2DSCRIPT) : -1);
			}
		}
		else
		{
			m_paiSoundtracks = NULL;
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

		SAFE_DELETE_ARRAY(pszSoundTrackNames);
	}

	pXML->SetVariableListTagPairForAudioScripts(&m_paiCitySoundscapeSciptIds, "CitySoundscapes", GC.getCitySizeTypes(), sizeof(GC.getCitySizeTypes((CitySizeTypes)0)));

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEraInfo::copyNonDefaults(CvEraInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isNoGoodies()					== false)		m_bNoGoodies					= pClassInfo->isNoGoodies();
	if (isNoAnimals()					== false)		m_bNoAnimals					= pClassInfo->isNoAnimals();
	if (isNoBarbUnits()					== false)		m_bNoBarbUnits					= pClassInfo->isNoBarbUnits();
	if (isNoBarbCities()				== false)		m_bNoBarbCities					= pClassInfo->isNoBarbCities();
	if (getStartingUnitMultiplier()		== 0)			m_iStartingUnitMultiplier		= pClassInfo->getStartingUnitMultiplier();
	if (getStartingDefenseUnits()		== 0)			m_iStartingDefenseUnits			= pClassInfo->getStartingDefenseUnits();
	if (getStartingWorkerUnits()		== 0)			m_iStartingWorkerUnits			= pClassInfo->getStartingWorkerUnits();
	if (getStartingExploreUnits()		== 0)			m_iStartingExploreUnits			= pClassInfo->getStartingExploreUnits();
	if (getAdvancedStartPoints()		== 0)			m_iAdvancedStartPoints			= pClassInfo->getAdvancedStartPoints();
	if (getStartingGold()				== 0)			m_iStartingGold					= pClassInfo->getStartingGold();
	if (getFreePopulation()				== 0)			m_iFreePopulation				= pClassInfo->getFreePopulation();
	if (getStartPercent()				== 0)			m_iStartPercent					= pClassInfo->getStartPercent();
	if (getGrowthPercent()				== 0)			m_iGrowthPercent				= pClassInfo->getGrowthPercent();
	if (getTrainPercent()				== 0)			m_iTrainPercent					= pClassInfo->getTrainPercent();
	if (getConstructPercent()			== 0)			m_iConstructPercent				= pClassInfo->getConstructPercent();
	if (getCreatePercent()				== 0)			m_iCreatePercent				= pClassInfo->getCreatePercent();
	if (getResearchPercent()			== 0)			m_iResearchPercent				= pClassInfo->getResearchPercent();
	if (getBuildPercent()				== 0)			m_iBuildPercent					= pClassInfo->getBuildPercent();
	if (getImprovementPercent()			== 0)			m_iImprovementPercent			= pClassInfo->getImprovementPercent();
	if (getGreatPeoplePercent()			== 0)			m_iGreatPeoplePercent			= pClassInfo->getGreatPeoplePercent();
	if (getAnarchyPercent()				== 0)			m_iAnarchyPercent				= pClassInfo->getAnarchyPercent();
	if (getEventChancePerTurn()			== 0)			m_iEventChancePerTurn			= pClassInfo->getEventChancePerTurn();
	if (getSoundtrackSpace()			== 0)			m_iSoundtrackSpace				= pClassInfo->getSoundtrackSpace();
	if (isFirstSoundtrackFirst()		== false)		m_bFirstSoundtrackFirst			= pClassInfo->isFirstSoundtrackFirst();
	if (getAudioUnitVictoryScript()		== cDefault)	m_szAudioUnitVictoryScript		= pClassInfo->getAudioUnitVictoryScript();
	if (getAudioUnitDefeatScript()		== cDefault)	m_szAudioUnitDefeatScript		= pClassInfo->getAudioUnitDefeatScript();
	if (pClassInfo->getNumSoundtracks()	!= 0)
	{
		int iNumSoundTracks = getNumSoundtracks() + pClassInfo->getNumSoundtracks();
		int* m_paiSoundtracksTemp = new int[iNumSoundTracks];
		for (int i = 0; i < iNumSoundTracks; i++)
		{
			if (i < getNumSoundtracks())
			{
				m_paiSoundtracksTemp[i] = getSoundtracks(i);
			}
			else
			{
				m_paiSoundtracksTemp[i] = pClassInfo->getSoundtracks(i - getNumSoundtracks());
			}
		}
		SAFE_DELETE_ARRAY(m_paiSoundtracks);
		m_paiSoundtracks = new int[iNumSoundTracks];
		for (int i = 0; i < iNumSoundTracks; i++)
		{
														m_paiSoundtracks[i]				= m_paiSoundtracksTemp[i];
		}
		SAFE_DELETE_ARRAY(m_paiSoundtracksTemp);
	}
	for (int i = 0; i <  GC.getNumCitySizeTypes(); i++)
	{
		if (getCitySoundscapeSciptId(i) == -1)			m_paiCitySoundscapeSciptIds[i]	= pClassInfo->getCitySoundscapeSciptId(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvColorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvColorInfo::CvColorInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvColorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvColorInfo::~CvColorInfo()
{
}

const NiColorA& CvColorInfo::getColor() const
{
	return m_Color;
}

bool CvColorInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	float afColorVals[4];	// array to hold the 4 color values, red, green, blue, and alpha

	pXML->GetChildXmlValByName(&afColorVals[0], "fRed");
	pXML->GetChildXmlValByName(&afColorVals[1], "fGreen");
	pXML->GetChildXmlValByName(&afColorVals[2], "fBlue");
	pXML->GetChildXmlValByName(&afColorVals[3], "fAlpha");

	m_Color = NiColorA(afColorVals[0], afColorVals[1], afColorVals[2], afColorVals[3]);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvColorInfo::copyNonDefaults(CvColorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

//	if (afColorVals[0] == 0.0f && afColorVals[1] == 0.0f && afColorVals[2] == 0.0f
//		 && afColorVals[3] == 0.0f) m_Color = pClassInfo->getColor();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvPlayerColorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvPlayerColorInfo::CvPlayerColorInfo() :
m_iColorTypePrimary(NO_COLOR),
m_iColorTypeSecondary(NO_COLOR),
m_iTextColorType(NO_COLOR)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvPlayerColorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvPlayerColorInfo::~CvPlayerColorInfo()
{
}

int CvPlayerColorInfo::getColorTypePrimary() const
{
	return m_iColorTypePrimary;
}

int CvPlayerColorInfo::getColorTypeSecondary() const
{
	return m_iColorTypeSecondary;
}

int CvPlayerColorInfo::getTextColorType() const
{
	return m_iTextColorType;
}

bool CvPlayerColorInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ColorTypePrimary");
	m_iColorTypePrimary = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ColorTypeSecondary");
	m_iColorTypeSecondary = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TextColorType");
	m_iTextColorType = pXML->FindInInfoClass( szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvPlayerColorInfo::copyNonDefaults(CvPlayerColorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getColorTypePrimary()		== NO_PLAYERCOLOR)		m_iColorTypePrimary		= pClassInfo->getColorTypePrimary();
	if (getColorTypeSecondary()		== NO_PLAYERCOLOR)		m_iColorTypeSecondary	= pClassInfo->getColorTypeSecondary();
	if (getTextColorType()			== NO_PLAYERCOLOR)		m_iTextColorType		= pClassInfo->getTextColorType();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//	CvLandscapeInfo
//
//
CvLandscapeInfo::CvLandscapeInfo() :
m_iFogR(0),
m_iFogG(0),
m_iFogB(0),
m_iHorizontalGameCell(0),
m_iVerticalGameCell(0),
m_iPlotsPerCellX(0),
m_iPlotsPerCellY(0),
m_iHorizontalVertCnt(0),
m_iVerticalVertCnt(0),
m_iWaterHeight(0),
m_fTextureScaleX(0.0f),
m_fTextureScaleY(0.0f),
m_fZScale(0.0f),
m_bUseTerrainShader(false),
m_bUseLightmap(false),
m_bRandomMap(false)
{
}

int CvLandscapeInfo::getFogR() const
{
	return m_iFogR;
}

int CvLandscapeInfo::getFogG() const
{
	return m_iFogG;
}

int CvLandscapeInfo::getFogB() const
{
	return m_iFogB;
}

int CvLandscapeInfo::getHorizontalGameCell() const
{
	return m_iHorizontalGameCell;
}

int CvLandscapeInfo::getVerticalGameCell() const
{
	return m_iVerticalGameCell;
}

int CvLandscapeInfo::getPlotsPerCellX() const
{
	return m_iPlotsPerCellX;
}

int CvLandscapeInfo::getPlotsPerCellY() const
{
	return m_iPlotsPerCellY;
}

int CvLandscapeInfo::getHorizontalVertCnt() const
{
	return m_iHorizontalVertCnt;
}

int CvLandscapeInfo::getVerticalVertCnt() const
{
	return m_iVerticalVertCnt;
}

int CvLandscapeInfo::getWaterHeight() const
{
	return m_iWaterHeight;
}

float CvLandscapeInfo::getTextureScaleX() const
{
	return m_fTextureScaleX;
}

float CvLandscapeInfo::getTextureScaleY() const
{
	return m_fTextureScaleY;
}

float CvLandscapeInfo::getZScale() const
{
	return m_fZScale;
}

bool CvLandscapeInfo::isUseTerrainShader() const
{
	return m_bUseTerrainShader;
}

bool CvLandscapeInfo::isUseLightmap() const
{
	return m_bUseLightmap;
}
float CvLandscapeInfo::getPeakScale() const
{
	return 	m_fPeakScale;
}

float CvLandscapeInfo::getHillScale() const
{
	return 	m_fHillScale;
}

bool CvLandscapeInfo::isRandomMap() const
{
	return m_bRandomMap;
}

const TCHAR* CvLandscapeInfo::getSkyArt()
{
	return m_szSkyArt;
}

void CvLandscapeInfo::setSkyArt(const TCHAR* szPath)
{
	m_szSkyArt = szPath;
}

const TCHAR* CvLandscapeInfo::getHeightMap()
{
	return m_szHeightMap;
}

void CvLandscapeInfo::setHeightMap(const TCHAR* szPath)
{
	m_szHeightMap = szPath;
}

const TCHAR* CvLandscapeInfo::getTerrainMap()
{
	return m_szTerrainMap;
}

void CvLandscapeInfo::setTerrainMap(const TCHAR* szPath)
{
	m_szTerrainMap = szPath;
}

const TCHAR* CvLandscapeInfo::getNormalMap()
{
	return m_szNormalMap;
}

void CvLandscapeInfo::setNormalMap(const TCHAR* szPath)
{
	m_szNormalMap = szPath;
}

const TCHAR* CvLandscapeInfo::getBlendMap()
{
	return m_szBlendMap;
}

void CvLandscapeInfo::setBlendMap(const TCHAR* szPath)
{
	m_szBlendMap = szPath;
}

//
// read from xml
//
bool CvLandscapeInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iWaterHeight, "iWaterHeight");
	pXML->GetChildXmlValByName(&m_bRandomMap, "bRandomMap");

	pXML->GetChildXmlValByName(szTextVal, "HeightMap");
	setHeightMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TerrainMap");
	setTerrainMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "NormalMap");
	setNormalMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "BlendMap");
	setBlendMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SkyArt");
	setSkyArt(szTextVal);

	pXML->GetChildXmlValByName(&m_iFogR, "iFogR");
	pXML->GetChildXmlValByName(&m_iFogG, "iFogG");
	pXML->GetChildXmlValByName(&m_iFogB, "iFogB");

	pXML->GetChildXmlValByName(&m_fTextureScaleX, "fTextureScaleX");
	pXML->GetChildXmlValByName(&m_fTextureScaleY, "fTextureScaleY");

	pXML->GetChildXmlValByName(&m_iHorizontalGameCell, "iGameCellSizeX");
	pXML->GetChildXmlValByName(&m_iVerticalGameCell, "iGameCellSizeY");

	pXML->GetChildXmlValByName(&m_iPlotsPerCellX, "iPlotsPerCellX");
	pXML->GetChildXmlValByName(&m_iPlotsPerCellY, "iPlotsPerCellY");

	m_iHorizontalVertCnt = m_iPlotsPerCellX * m_iHorizontalGameCell - (m_iPlotsPerCellX - 1);
	m_iVerticalVertCnt   = m_iPlotsPerCellY * m_iVerticalGameCell - (m_iPlotsPerCellY - 1);

	pXML->GetChildXmlValByName(&m_fZScale, "fZScale");
	pXML->GetChildXmlValByName(&m_bUseTerrainShader, "bTerrainShader");
	pXML->GetChildXmlValByName(&m_bUseLightmap, "bUseLightmap");
	pXML->GetChildXmlValByName(&m_fPeakScale, "fPeakScale");
	pXML->GetChildXmlValByName(&m_fHillScale, "fHillScale");


	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvLandscapeInfo::copyNonDefaults(CvLandscapeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isRandomMap()			== false)			m_bRandomMap				= pClassInfo->isRandomMap();
	if (isUseTerrainShader()	== false)			m_bUseTerrainShader			= pClassInfo->isUseTerrainShader();
	if (isUseLightmap()			== false)			m_bUseLightmap				= pClassInfo->isUseLightmap();
	if (getHeightMap()			== cDefault)		setHeightMap(				pClassInfo->getHeightMap());
	if (getTerrainMap()			== cDefault)		setTerrainMap(				pClassInfo->getTerrainMap());
	if (getNormalMap()			== cDefault)		setNormalMap(				pClassInfo->getNormalMap());
	if (getBlendMap()			== cDefault)		setBlendMap(				pClassInfo->getBlendMap());
	if (getSkyArt()				== cDefault)		setSkyArt(					pClassInfo->getSkyArt());
	if (getWaterHeight()		== 0)				m_iWaterHeight				= pClassInfo->getWaterHeight();
	if (getFogR()				== 0)				m_iFogR						= pClassInfo->getFogR();
	if (getFogG()				== 0)				m_iFogG						= pClassInfo->getFogG();
	if (getFogB()				== 0)				m_iFogB						= pClassInfo->getFogB();
	if (getHorizontalGameCell()	== 0)				m_iHorizontalGameCell		= pClassInfo->getHorizontalGameCell();
	if (getVerticalGameCell()	== 0)				m_iVerticalGameCell			= pClassInfo->getVerticalGameCell();
	if (getPlotsPerCellX()		== 0)				m_iPlotsPerCellX			= pClassInfo->getPlotsPerCellX();
	if (getPlotsPerCellY()		== 0)				m_iPlotsPerCellY			= pClassInfo->getPlotsPerCellY();
													m_iHorizontalVertCnt		= m_iPlotsPerCellX * m_iHorizontalGameCell - (m_iPlotsPerCellX - 1);
													m_iVerticalVertCnt			= m_iPlotsPerCellY * m_iVerticalGameCell - (m_iPlotsPerCellY - 1);
	if (getTextureScaleX()		== 0.0f)			m_fTextureScaleX			= pClassInfo->getTextureScaleX();
	if (getTextureScaleY()		== 0.0f)			m_fTextureScaleY			= pClassInfo->getTextureScaleY();
	if (getZScale()				== 0.0f)			m_fZScale					= pClassInfo->getZScale();
	if (getPeakScale()			== 0.0f)			m_fPeakScale				= pClassInfo->getPeakScale();
	if (getHillScale()			== 0.0f)			m_fHillScale				= pClassInfo->getHillScale();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvGameText
//////////////////////////////////////////////////////////////////////////

// static
int CvGameText::NUM_LANGUAGES = 0;

int CvGameText::getNumLanguages() const
{
	return NUM_LANGUAGES;
}
void CvGameText::setNumLanguages(int iNum)
{
	NUM_LANGUAGES = iNum;
}

CvGameText::CvGameText() :
	m_szGender("N"),
	m_szPlural("false")
{
}

const wchar* CvGameText::getText() const
{
	return m_szText;
}

void CvGameText::setText(const wchar* szText)
{
	m_szText = szText;
}

bool CvGameText::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	CvWString wszTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	gDLL->getXMLIFace()->SetToChild(pXML->GetXML()); // Move down to Child level
	pXML->GetXmlVal(m_szType);		// TAG

	static const int iMaxNumLanguages = GC.getDefineINT("MAX_NUM_LANGUAGES");
	int iNumLanguages = NUM_LANGUAGES ? NUM_LANGUAGES : iMaxNumLanguages + 1;

	int j=0;
	for (j = 0; j < iNumLanguages; j++)
	{
		pXML->SkipToNextVal();	// skip comments

		if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()) || j == iMaxNumLanguages)
		{
			NUM_LANGUAGES = j;
			break;
		}
		if (j == GAMETEXT.getCurrentLanguage()) // Only add appropriate language Text
		{
			// TEXT
			if (pXML->GetChildXmlValByName(wszTextVal, "Text"))
			{
				setText(wszTextVal);
			}
			else
			{
				pXML->GetXmlVal(wszTextVal);
				setText(wszTextVal);
				if (NUM_LANGUAGES > 0)
				{
					break;
				}
			}

			// GENDER
			if (pXML->GetChildXmlValByName(wszTextVal, "Gender"))
			{
				setGender(wszTextVal);
			}

			// PLURAL
			if (pXML->GetChildXmlValByName(wszTextVal, "Plural"))
			{
				setPlural(wszTextVal);
			}
			if (NUM_LANGUAGES > 0)
			{
				break;
			}
		}
	}

	gDLL->getXMLIFace()->SetToParent(pXML->GetXML()); // Move back up to Parent

	return true;
}

//////////////////////////////////////////////////////////////////////////
//
//	CvDiplomacyTextInfo
//
//

CvDiplomacyTextInfo::CvDiplomacyTextInfo() :
m_iNumResponses(0),
m_pResponses(NULL)
{
}

// note - Response member vars allocated by CvXmlLoadUtility
void CvDiplomacyTextInfo::init(int iNum)
{
	uninit();
	m_pResponses = new Response[iNum];
	m_iNumResponses=iNum;
}

void CvDiplomacyTextInfo::uninit()
{
	SAFE_DELETE_ARRAY(m_pResponses);
}

int CvDiplomacyTextInfo::getNumResponses() const
{
	return m_iNumResponses;
}

bool CvDiplomacyTextInfo::getCivilizationTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbCivilizationTypes[j];
}

bool CvDiplomacyTextInfo::getLeaderHeadTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbLeaderHeadTypes[j];
}

bool CvDiplomacyTextInfo::getAttitudeTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbAttitudeTypes[j];
}

bool CvDiplomacyTextInfo::getDiplomacyPowerTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbDiplomacyPowerTypes[j];
}

int CvDiplomacyTextInfo::getNumDiplomacyText(int i) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pResponses[i].m_iNumDiplomacyText;
}

const TCHAR* CvDiplomacyTextInfo::getDiplomacyText(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < getNumDiplomacyText(i), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_paszDiplomacyText[j];
}

void CvDiplomacyTextInfo::Response::read(FDataStreamBase* stream)
{
	stream->Read(&m_iNumDiplomacyText);

	SAFE_DELETE_ARRAY(m_pbCivilizationTypes);
	m_pbCivilizationTypes = new bool[GC.getNumCivilizationInfos()];
	stream->Read(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);

	SAFE_DELETE_ARRAY(m_pbLeaderHeadTypes);
	m_pbLeaderHeadTypes = new bool[GC.getNumLeaderHeadInfos()];
	stream->Read(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);

	SAFE_DELETE_ARRAY(m_pbAttitudeTypes);
	m_pbAttitudeTypes = new bool[NUM_ATTITUDE_TYPES];
	stream->Read(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);

	SAFE_DELETE_ARRAY(m_pbDiplomacyPowerTypes);
	m_pbDiplomacyPowerTypes = new bool[NUM_DIPLOMACYPOWER_TYPES];
	stream->Read(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);

	SAFE_DELETE_ARRAY(m_paszDiplomacyText);
	m_paszDiplomacyText = new CvString[m_iNumDiplomacyText];
	stream->ReadString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

void CvDiplomacyTextInfo::Response::write(FDataStreamBase* stream)
{
	stream->Write(m_iNumDiplomacyText);

	stream->Write(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);
	stream->Write(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);
	stream->Write(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);
	stream->Write(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);
	stream->WriteString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

void CvDiplomacyTextInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iNumResponses);

	// Arrays

	init(m_iNumResponses);

	for (uint uiIndex = 0; (int) uiIndex < m_iNumResponses; uiIndex++)
	{
		m_pResponses[uiIndex].read(stream);
	}
}

void CvDiplomacyTextInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iNumResponses);

	// Arrays

	for (uint uiIndex = 0; (int) uiIndex < m_iNumResponses; uiIndex++)
	{
		m_pResponses[uiIndex].write(stream);
	}
}

bool CvDiplomacyTextInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j;
	pXML->GetChildXmlValByName(szTextVal, "Type");

	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Responses") )
	{
		int iIndexVal = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "Response");
		init(iIndexVal);

		for (j = 0; j < iIndexVal; j++)
		{
			if (j == 0)
			{
				gDLL->getXMLIFace()->SetToChild(pXML->GetXML());
			}
			// Civilizations
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbCivilizationTypes, "Civilizations", sizeof(GC.getCivilizationInfo((CivilizationTypes)0)), GC.getNumCivilizationInfos());
			// Leaders
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbLeaderHeadTypes, "Leaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());
			// AttitudeTypes
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbAttitudeTypes, "Attitudes", sizeof(GC.getAttitudeInfo((AttitudeTypes)0)), NUM_ATTITUDE_TYPES);
			// PowerTypes
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbDiplomacyPowerTypes, "DiplomacyPowers", GC.getDiplomacyPowerTypes(), NUM_DIPLOMACYPOWER_TYPES);
			// DiplomacyText
			if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"DiplomacyText"))
			{
				pXML->SetStringList(&m_pResponses[j].m_paszDiplomacyText, &m_pResponses[j].m_iNumDiplomacyText);
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}

			if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
			{
				break;
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

	return true;
}


//////////////////////////////////////////////////////////////////////////
//
//	CvEffectInfo			Misc\CIV4EffectInfos.xml
//
//

CvEffectInfo::CvEffectInfo() :
m_fUpdateRate(0.0f),
m_bProjectile(false),
m_bSticky(false),
m_fProjectileSpeed(0.0f),
m_fProjectileArc(0.0f)
{
}

CvEffectInfo::~CvEffectInfo()
{
}

bool CvEffectInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvScalableInfo::read(pXML);

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);

	pXML->GetChildXmlValByName(&m_fUpdateRate, "fUpdateRate" );

	int iTemporary;
	pXML->GetChildXmlValByName(&iTemporary, "bIsProjectile" );
	m_bProjectile = iTemporary != 0;

	pXML->GetChildXmlValByName(&m_fProjectileSpeed, "fSpeed" );
	pXML->GetChildXmlValByName(&m_fProjectileArc, "fArcValue" );
	pXML->GetChildXmlValByName(&m_bSticky, "bSticky", false );
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEffectInfo::copyNonDefaults(CvEffectInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);
	CvScalableInfo::copyNonDefaults(pClassInfo, pXML);

	if (getPath()				== cDefault)	setPath(				pClassInfo->getPath());
	if (getUpdateRate()			== 0.0f)		m_fUpdateRate			= pClassInfo->getUpdateRate();
	if (isProjectile()			== false)		m_bProjectile			= pClassInfo->isProjectile();
	if (getProjectileSpeed()	== 0.0f)		m_fProjectileSpeed		= pClassInfo->getProjectileSpeed();
	if (getProjectileArc()		== 0.0f)		m_fProjectileArc		= pClassInfo->getProjectileArc();
	if (isSticky()				== false)		m_bSticky				= pClassInfo->isSticky();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvAttachableInfo			Misc\CIV4AttachableInfos.xml
//
//
CvAttachableInfo::CvAttachableInfo() :
m_fUpdateRate(0.0f)
{
}

CvAttachableInfo::~CvAttachableInfo()
{
}

bool CvAttachableInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvScalableInfo::read(pXML);

	pXML->GetChildXmlValByName(szTextVal, "Path");
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAttachableInfo::copyNonDefaults(CvAttachableInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);
	CvScalableInfo::copyNonDefaults(pClassInfo, pXML);

	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvCameraInfo			Interface\CIV4CameraInfos.xml
//
//
bool CvCameraInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCameraInfo::copyNonDefaults(CvCameraInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);
	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvQuestInfo			Misc\CIV4QuestInfos.xml
//
//
CvQuestInfo::CvQuestInfo() :
m_iNumQuestMessages(0),
m_iNumQuestLinks(0),
m_iNumQuestSounds(0),
m_paszQuestMessages(NULL),
m_pQuestLinks(NULL),
m_paszQuestSounds(NULL)
{
	m_szQuestScript = "NONE";
}

CvQuestInfo::~CvQuestInfo()
{
	reset();
}


void CvQuestInfo::reset()
{
	CvInfoBase::reset();
	SAFE_DELETE_ARRAY(m_paszQuestMessages);
	SAFE_DELETE_ARRAY(m_pQuestLinks);
	SAFE_DELETE_ARRAY(m_paszQuestSounds);
}

bool CvQuestInfo::initQuestLinks(int iNum)
{
	reset();
	if ( iNum > 0 )
	{
		m_pQuestLinks = new QuestLink[iNum];
		m_iNumQuestLinks = iNum;
		return true;
	}
	return false;
}

const TCHAR* CvQuestInfo::getQuestObjective() const
{
	return m_szQuestObjective;
}

const TCHAR* CvQuestInfo::getQuestBodyText() const
{
	return m_szQuestBodyText;
}

int CvQuestInfo::getNumQuestMessages() const
{
	return m_iNumQuestMessages;
}

const TCHAR* CvQuestInfo::getQuestMessages(int iIndex) const
{
	return m_paszQuestMessages ? m_paszQuestMessages[iIndex] : "";
}

int CvQuestInfo::getNumQuestLinks() const
{
	return m_iNumQuestLinks;
}

const TCHAR* CvQuestInfo::getQuestLinkType(int iIndex)  const
{
	return m_pQuestLinks[iIndex].m_szQuestLinkType;
}

const TCHAR* CvQuestInfo::getQuestLinkName(int iIndex)  const
{
	return m_pQuestLinks[iIndex].m_szQuestLinkName;
}

int CvQuestInfo::getNumQuestSounds() const
{
	return m_iNumQuestSounds;
}

const TCHAR* CvQuestInfo::getQuestSounds(int iIndex) const
{
	return m_paszQuestSounds ? m_paszQuestSounds[iIndex] : "";
}

const TCHAR* CvQuestInfo::getQuestScript() const
{
	return m_szQuestScript;
}

void CvQuestInfo::setQuestObjective(const TCHAR* szText)
{
	m_szQuestObjective = szText;
}

void CvQuestInfo::setQuestBodyText(const TCHAR* szText)
{
	m_szQuestBodyText = szText;
}

void CvQuestInfo::setNumQuestMessages(int iNum)
{
	m_iNumQuestMessages = iNum;
}

void CvQuestInfo::setQuestMessages(int iIndex, const TCHAR* szText)
{
	m_paszQuestMessages[iIndex] = szText;
}

void CvQuestInfo::setNumQuestSounds(int iNum)
{
	m_iNumQuestSounds = iNum;
}

void CvQuestInfo::setQuestSounds(int iIndex, const TCHAR* szText)
{
	m_paszQuestSounds[iIndex] = szText;
}

void CvQuestInfo::setQuestScript(const TCHAR* szText)
{
	m_szQuestScript = szText;
}

bool CvQuestInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "QuestObjective");
	setQuestObjective(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "QuestBodyText");
	setQuestBodyText(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "QuestMessages"))
	{
		pXML->SetStringList(&m_paszQuestMessages, &m_iNumQuestMessages);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"QuestLinks"))
	{
		int iNum;
		iNum = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "QuestLink");

		if (initQuestLinks(iNum))
		{
			int i;
			for (i=0; i<m_iNumQuestLinks; i++)
			{
				pXML->GetChildXmlValByName(szTextVal, "QuestLinkType");
				m_pQuestLinks[i].m_szQuestLinkType = szTextVal;

				pXML->GetChildXmlValByName(szTextVal, "QuestLinkName");
				m_pQuestLinks[i].m_szQuestLinkName = szTextVal;

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "QuestSounds"))
	{
		pXML->SetStringList(&m_paszQuestSounds, &m_iNumQuestSounds);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "QuestScript");
	setQuestScript(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvQuestInfo::copyNonDefaults(CvQuestInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getQuestObjective()		== cDefault)	setQuestObjective(								pClassInfo->getQuestObjective());
	if (getQuestBodyText()		== cDefault)	setQuestBodyText(								pClassInfo->getQuestBodyText());
	if (getQuestScript()		== cDefault)	setQuestScript(									pClassInfo->getQuestScript());

	// Add new QuestMessages
	if (pClassInfo->getNumQuestMessages() != 0)
	{
		CvString* m_paszNewMessages = new CvString[pClassInfo->getNumQuestMessages()];
		for ( int i = 0; i < pClassInfo->getNumQuestMessages(); i++)
		{
			m_paszNewMessages[i] = pClassInfo->getQuestMessages(i);
		}

		CvXMLLoadUtilityModTools* pCurrentInfoClass = new CvXMLLoadUtilityModTools;
		pCurrentInfoClass->StringArrayExtend(	&m_paszQuestMessages, &m_iNumQuestMessages,		&m_paszNewMessages, pClassInfo->getNumQuestMessages());
		SAFE_DELETE_ARRAY(m_paszNewMessages)
	}
	if (pClassInfo->getNumQuestLinks() > 0)
	{
		int m_iNumQuestSoundsTemp = m_iNumQuestSounds + pClassInfo->getNumQuestLinks();
		QuestLink* m_pQuestLinksTemp = new QuestLink[m_iNumQuestSoundsTemp];
		int iCurrentClass = 0;
		for (int i = 0; i < m_iNumQuestSoundsTemp; i++)
		{
			if (i < pClassInfo->getNumQuestLinks())
			{
				m_pQuestLinksTemp[i].m_szQuestLinkType = pClassInfo->getQuestLinkType(i);
				m_pQuestLinksTemp[i].m_szQuestLinkName = pClassInfo->getQuestLinkName(i);
			}
			else
			{
				m_pQuestLinksTemp[i].m_szQuestLinkType = getQuestLinkType(iCurrentClass);
				m_pQuestLinksTemp[i].m_szQuestLinkName = getQuestLinkName(iCurrentClass);
				iCurrentClass++;
			}
		}
		SAFE_DELETE_ARRAY(m_pQuestLinks);
		m_pQuestLinks = new QuestLink[m_iNumQuestSoundsTemp];
		for (int i = 0; i < m_iNumQuestSoundsTemp; i++)
		{
												m_pQuestLinks[i].m_szQuestLinkType				= m_pQuestLinksTemp[i].m_szQuestLinkType;
												m_pQuestLinks[i].m_szQuestLinkName				= m_pQuestLinksTemp[i].m_szQuestLinkName;
		}
		SAFE_DELETE_ARRAY(m_pQuestLinksTemp);
	}
	// Add new QuestSounds
	if (pClassInfo->getNumQuestSounds() != 0)
	{
		CvString* m_paszNewSounds = new CvString[pClassInfo->getNumQuestSounds()];
		for ( int i = 0; i < pClassInfo->getNumQuestSounds(); i++)
		{
			m_paszNewSounds[i] = pClassInfo->getQuestSounds(i);
		}
		CvXMLLoadUtilityModTools* pCurrentInfoClass = new CvXMLLoadUtilityModTools;
		pCurrentInfoClass->StringArrayExtend(	&m_paszQuestSounds, &m_iNumQuestSounds,			&m_paszNewSounds, pClassInfo->getNumQuestSounds());
		SAFE_DELETE_ARRAY(m_paszNewSounds)
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvTutorialMessage
//
CvTutorialMessage::CvTutorialMessage() :
m_iNumTutorialScripts(0),
m_paszTutorialScripts(NULL)
{
	m_szTutorialMessageText = "No Text";
	m_szTutorialMessageImage = "No Text";
	m_szTutorialMessageSound = "No Text";
}

CvTutorialMessage::~CvTutorialMessage()
{
	SAFE_DELETE_ARRAY(m_paszTutorialScripts);
}

const TCHAR* CvTutorialMessage::getText() const
{
	return m_szTutorialMessageText;
}

const TCHAR* CvTutorialMessage::getImage() const
{
	return m_szTutorialMessageImage;
}

const TCHAR* CvTutorialMessage::getSound() const
{
	return m_szTutorialMessageSound;
}

void CvTutorialMessage::setText(const TCHAR* szText)
{
	m_szTutorialMessageText = szText;
}

void CvTutorialMessage::setImage(const TCHAR* szText)
{
	m_szTutorialMessageImage = szText;
}

void CvTutorialMessage::setSound(const TCHAR* szText)
{
	m_szTutorialMessageSound = szText;
}

int CvTutorialMessage::getNumTutorialScripts() const
{
	return m_iNumTutorialScripts;
}

const TCHAR* CvTutorialMessage::getTutorialScriptByIndex(int i) const
{
	return m_paszTutorialScripts[i];
}

bool CvTutorialMessage::read(CvXMLLoadUtility* pXML)
{
	// Skip any comments and stop at the next value we might want
	if (!pXML->SkipToNextVal())
	{
		return false;
	}
	CvString szTextVal;

	pXML->MapChildren();	// try to hash children for fast lookup by name
	if (pXML->GetChildXmlValByName(szTextVal, "TutorialMessageText"))
	{
		setText(szTextVal);
	}
	if (pXML->GetChildXmlValByName(szTextVal, "TutorialMessageImage"))
	{
		setImage(szTextVal);
	}
	if (pXML->GetChildXmlValByName(szTextVal, "TutorialMessageSound"))
	{
		setSound(szTextVal);
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TutorialScripts"))
	{
		pXML->SetStringList(&m_paszTutorialScripts, &m_iNumTutorialScripts);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	return true;
}


CvTutorialInfo::CvTutorialInfo() :
m_iNumTutorialMessages(0),
m_paTutorialMessages(NULL)
{
	m_szNextTutorialInfoType = "NONE";
}

CvTutorialInfo::~CvTutorialInfo()
{
	resetMessages();
}

const TCHAR* CvTutorialInfo::getNextTutorialInfoType()
{
	return m_szNextTutorialInfoType;
}

void CvTutorialInfo::setNextTutorialInfoType(const TCHAR* szVal)
{
	m_szNextTutorialInfoType = szVal;
}

bool CvTutorialInfo::initTutorialMessages(int iNum)
{
	resetMessages();
	m_paTutorialMessages = new CvTutorialMessage[iNum];
	m_iNumTutorialMessages = iNum;
	return true;
}

void CvTutorialInfo::resetMessages()
{
	SAFE_DELETE_ARRAY(m_paTutorialMessages);
	m_iNumTutorialMessages = 0;
}

int CvTutorialInfo::getNumTutorialMessages() const
{
	return m_iNumTutorialMessages;
}

const CvTutorialMessage* CvTutorialInfo::getTutorialMessage(int iIndex) const
{
	return &m_paTutorialMessages[iIndex];
}

bool CvTutorialInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	CvString szTextVal;

	pXML->MapChildren();	// try to hash children for fast lookup by name
	if (pXML->GetChildXmlValByName(szTextVal, "NextTutorialInfoType"))
	{
		setNextTutorialInfoType(szTextVal);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TutorialMessages"))
	{
		int iNum;
		iNum = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "TutorialMessage");
		if ( iNum > 0 )
		{
			gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TutorialMessage");
			initTutorialMessages(iNum);
			for (int i = 0; i<m_iNumTutorialMessages; i++)
			{
				if (!m_paTutorialMessages[i].read(pXML))
				{
					return false;
				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTutorialInfo::copyNonDefaults(CvTutorialInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getNextTutorialInfoType()	== cDefault)	setNextTutorialInfoType(	pClassInfo->getNextTutorialInfoType());

/*	if (pClassInfo->getNumTutorialMessages() > 0)
	{
		int m_iNumTutorialMessagesTemp = m_iNumTutorialMessages + pClassInfo->getNumTutorialMessages();
		CvTutorialMessage* m_paTutorialMessagesTemp = new CvTutorialMessage[m_iNumTutorialMessagesTemp];
		int iCurrentClass = 0;
		for (int i = 0; i < m_iNumTutorialMessagesTemp; i++)
		{
			if (i < pClassInfo->getNumTutorialMessages())
			{
				m_paTutorialMessagesTemp[i] = pClassInfo->getTutorialMessage(i);
			}
			else
			{
				m_paTutorialMessagesTemp[i] = getTutorialMessage(iCurrentClass);
				iCurrentClass++;
			}
		}
		SAFE_DELETE_ARRAY(m_paTutorialMessages);
		m_paTutorialMessages = new CvTutorialMessage[m_iNumTutorialMessagesTemp];

		for (int i = 0; i < m_iNumTutorialMessagesTemp; i++)
		{
													m_paTutorialMessages[i]		= m_paTutorialMessagesTemp[i];
		}
		SAFE_DELETE_ARRAY(m_paTutorialMessagesTemp);
	}
*/
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvGameOptionInfo
//	Game options and their default values
//
//
CvGameOptionInfo::CvGameOptionInfo() :
m_bDefault(false),
m_bVisible(true)
{
}

CvGameOptionInfo::~CvGameOptionInfo()
{
}

bool CvGameOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvGameOptionInfo::getVisible() const
{
	return m_bVisible;
}

bool CvGameOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGameOptionInfo::copyNonDefaults(CvGameOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
	if (getVisible()		== false)		m_bVisible		= pClassInfo->getVisible();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvMPOptionInfo
//	Multiplayer options and their default values
//
//
CvMPOptionInfo::CvMPOptionInfo() :
m_bDefault(false)
{
}

CvMPOptionInfo::~CvMPOptionInfo()
{
}

bool CvMPOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvMPOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvMPOptionInfo::copyNonDefaults(CvMPOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvForceControlInfo
//	Forced Controls and their default values
//
//
CvForceControlInfo::CvForceControlInfo() :
m_bDefault(false)
{
}

CvForceControlInfo::~CvForceControlInfo()
{
}

bool CvForceControlInfo::getDefault() const
{
	return m_bDefault;
}

bool CvForceControlInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvForceControlInfo::copyNonDefaults(CvForceControlInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvPlayerOptionInfo
//	Player options and their default values
//
//
CvPlayerOptionInfo::CvPlayerOptionInfo() :
m_bDefault(false)
{
}

CvPlayerOptionInfo::~CvPlayerOptionInfo()
{
}

bool CvPlayerOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvPlayerOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvPlayerOptionInfo::copyNonDefaults(CvPlayerOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvGraphicOptionInfo
//	Graphic options and their default values
//
//
CvGraphicOptionInfo::CvGraphicOptionInfo() :
m_bDefault(false)
{
}

CvGraphicOptionInfo::~CvGraphicOptionInfo()
{
}

bool CvGraphicOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvGraphicOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGraphicOptionInfo::copyNonDefaults(CvGraphicOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvEventTriggerInfo
//	Event triggers
//
//
CvEventTriggerInfo::CvEventTriggerInfo() :
	m_iPercentGamesActive(0),
	m_iProbability(0),
	m_iNumUnits(0),
	m_iNumBuildings(0),
	m_iNumUnitsGlobal(0),
	m_iNumBuildingsGlobal(0),
	m_iNumPlotsRequired(0),
	m_iPlotType(-1),
	m_iNumReligions(0),
	m_iNumCorporations(0),
	m_iOtherPlayerShareBorders(0),
	m_iOtherPlayerHasTech(NO_TECH),
	m_iCivic(NO_CIVIC),
	m_iMinPopulation(0),
	m_iMaxPopulation(0),
	m_iMinMapLandmass(0),
	m_iMinOurLandmass(0),
	m_iMaxOurLandmass(-1),
	m_iMinDifficulty(NO_HANDICAP),
	m_iAngry(0),
	m_iUnhealthy(0),
	m_iUnitDamagedWeight(0),
	m_iUnitDistanceWeight(0),
	m_iUnitExperienceWeight(0),
	m_iMinTreasury(0),
	m_bSinglePlayer(false),
	m_bTeam(false),
	m_bRecurring(false),
	m_bGlobal(false),
	m_bPickPlayer(false),
	m_bOtherPlayerWar(false),
	m_bOtherPlayerHasReligion(false),
	m_bOtherPlayerHasOtherReligion(false),
	m_bOtherPlayerAI(false),
	m_bPickCity(false),
	m_bPickOtherPlayerCity(false),
	m_bShowPlot(true),
	m_iCityFoodWeight(0),
	m_bUnitsOnPlot(false),
	m_bOwnPlot(false),
	m_bPickReligion(false),
	m_bStateReligion(false),
	m_bHolyCity(false),
	m_bPickCorporation(false),
	m_bHeadquarters(false),
	m_bProbabilityUnitMultiply(false),
	m_bProbabilityBuildingMultiply(false),
	m_bPrereqEventCity(false),

/*************************************************************************************************/
/**	New Tag Defs	(EventTriggerInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
	m_iPrereqBroadAlignment(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	m_iPrereqBroadEthicalAlignment(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Events: Added by Kael 08/08/2007
	m_iPrereqCrime(0),
	m_iPrereqGlobalCounter(0),
	m_iPrereqAlignment(NO_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	m_iPrereqEthicalAlignment(NO_ETHICAL_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	m_iPrereqCivilizationPleased(NO_CIVILIZATION),
	m_iPrereqLeader(NO_LEADER),
	m_iPrereqTrait(NO_TRAIT)
//FfH: End Add

{
}

CvEventTriggerInfo::~CvEventTriggerInfo()
{
}

int CvEventTriggerInfo::getPercentGamesActive() const
{
	return m_iPercentGamesActive;
}

int CvEventTriggerInfo::getProbability() const
{
	return m_iProbability;
}

int CvEventTriggerInfo::getUnitRequired(int i) const
{
	return m_aiUnitsRequired[i];
}

int CvEventTriggerInfo::getNumUnitsRequired() const
{
	return (int)m_aiUnitsRequired.size();
}

int CvEventTriggerInfo::getBuildingRequired(int i) const
{
	return m_aiBuildingsRequired[i];
}

int CvEventTriggerInfo::getNumBuildingsRequired() const
{
	return (int)m_aiBuildingsRequired.size();
}

int CvEventTriggerInfo::getNumUnits() const
{
	return m_iNumUnits;
}

int CvEventTriggerInfo::getNumBuildings() const
{
	return m_iNumBuildings;
}

int CvEventTriggerInfo::getNumUnitsGlobal() const
{
	return m_iNumUnitsGlobal;
}

int CvEventTriggerInfo::getNumBuildingsGlobal() const
{
	return m_iNumBuildingsGlobal;
}

int CvEventTriggerInfo::getNumPlotsRequired() const
{
	return m_iNumPlotsRequired;
}

int CvEventTriggerInfo::getPlotType() const
{
	return m_iPlotType;
}

int CvEventTriggerInfo::getNumReligions() const
{
	return m_iNumReligions;
}

int CvEventTriggerInfo::getNumCorporations() const
{
	return m_iNumCorporations;
}

int CvEventTriggerInfo::getOtherPlayerShareBorders() const
{
	return m_iOtherPlayerShareBorders;
}

int CvEventTriggerInfo::getOtherPlayerHasTech() const
{
	return m_iOtherPlayerHasTech;
}

int CvEventTriggerInfo::getCivic() const
{
	return m_iCivic;
}

int CvEventTriggerInfo::getMinPopulation() const
{
	return m_iMinPopulation;
}

int CvEventTriggerInfo::getMaxPopulation() const
{
	return m_iMaxPopulation;
}

int CvEventTriggerInfo::getMinMapLandmass() const
{
	return m_iMinMapLandmass;
}

int CvEventTriggerInfo::getMinOurLandmass() const
{
	return m_iMinOurLandmass;
}

int CvEventTriggerInfo::getMaxOurLandmass() const
{
	return m_iMaxOurLandmass;
}

int CvEventTriggerInfo::getMinDifficulty() const
{
	return m_iMinDifficulty;
}

int CvEventTriggerInfo::getAngry() const
{
	return m_iAngry;
}

int CvEventTriggerInfo::getUnhealthy() const
{
	return m_iUnhealthy;
}

int CvEventTriggerInfo::getUnitDamagedWeight() const
{
	return m_iUnitDamagedWeight;
}

int CvEventTriggerInfo::getUnitDistanceWeight() const
{
	return m_iUnitDistanceWeight;
}

int CvEventTriggerInfo::getUnitExperienceWeight() const
{
	return m_iUnitExperienceWeight;
}

int CvEventTriggerInfo::getMinTreasury() const
{
	return m_iMinTreasury;
}

int CvEventTriggerInfo::getEvent(int i) const
{
	return m_aiEvents[i];
}

int CvEventTriggerInfo::getNumEvents() const
{
	return (int)m_aiEvents.size();
}

int CvEventTriggerInfo::getPrereqEvent(int i) const
{
	return m_aiPrereqEvents[i];
}

int CvEventTriggerInfo::getNumPrereqEvents() const
{
	return (int)m_aiPrereqEvents.size();
}

int CvEventTriggerInfo::getPrereqOrTechs(int i) const
{
	return m_aiPrereqOrTechs[i];
}

int CvEventTriggerInfo::getNumPrereqOrTechs() const
{
	return (int)m_aiPrereqOrTechs.size();
}

int CvEventTriggerInfo::getPrereqAndTechs(int i) const
{
	return m_aiPrereqAndTechs[i];
}

int CvEventTriggerInfo::getNumPrereqAndTechs() const
{
	return (int)m_aiPrereqAndTechs.size();
}

int CvEventTriggerInfo::getObsoleteTech(int i) const
{
	return m_aiObsoleteTechs[i];
}

int CvEventTriggerInfo::getNumObsoleteTechs() const
{
	return (int)m_aiObsoleteTechs.size();
}

int CvEventTriggerInfo::getFeatureRequired(int i) const
{
	return m_aiFeaturesRequired[i];
}

int CvEventTriggerInfo::getNumFeaturesRequired() const
{
	return (int)m_aiFeaturesRequired.size();
}

int CvEventTriggerInfo::getTerrainRequired(int i) const
{
	return m_aiTerrainsRequired[i];
}

int CvEventTriggerInfo::getNumTerrainsRequired() const
{
	return (int)m_aiTerrainsRequired.size();
}

int CvEventTriggerInfo::getImprovementRequired(int i) const
{
	return m_aiImprovementsRequired[i];
}

int CvEventTriggerInfo::getNumImprovementsRequired() const
{
	return (int)m_aiImprovementsRequired.size();
}

int CvEventTriggerInfo::getBonusRequired(int i) const
{
	return m_aiBonusesRequired[i];
}

int CvEventTriggerInfo::getNumBonusesRequired() const
{
	return (int)m_aiBonusesRequired.size();
}

int CvEventTriggerInfo::getRouteRequired(int i) const
{
	return m_aiRoutesRequired[i];
}

int CvEventTriggerInfo::getNumRoutesRequired() const
{
	return (int)m_aiRoutesRequired.size();
}

int CvEventTriggerInfo::getReligionRequired(int i) const
{
	return m_aiReligionsRequired[i];
}

int CvEventTriggerInfo::getNumReligionsRequired() const
{
	return (int)m_aiReligionsRequired.size();
}

int CvEventTriggerInfo::getCorporationRequired(int i) const
{
	return m_aiCorporationsRequired[i];
}

int CvEventTriggerInfo::getNumCorporationsRequired() const
{
	return (int)m_aiCorporationsRequired.size();
}

bool CvEventTriggerInfo::isSinglePlayer() const
{
	return m_bSinglePlayer;
}

bool CvEventTriggerInfo::isTeam() const
{
	return m_bTeam;
}

const CvWString& CvEventTriggerInfo::getText(int i) const
{
	FAssert(i >= 0 && i < (int)m_aszText.size());
	return m_aszText[i];
}

int CvEventTriggerInfo::getTextEra(int i) const
{
	FAssert(i >= 0 && i < (int)m_aiTextEra.size());
	return m_aiTextEra[i];
}

int CvEventTriggerInfo::getNumTexts() const
{
	FAssert(m_aiTextEra.size() == m_aszText.size());
	return m_aszText.size();
}

const CvWString& CvEventTriggerInfo::getWorldNews(int i) const
{
	FAssert(i >= 0 && i < (int)m_aszWorldNews.size());
	return m_aszWorldNews[i];
}

int CvEventTriggerInfo::getNumWorldNews() const
{
	return m_aszWorldNews.size();
}

bool CvEventTriggerInfo::isRecurring() const
{
	return m_bRecurring;
}

bool CvEventTriggerInfo::isGlobal() const
{
	return m_bGlobal;
}

bool CvEventTriggerInfo::isPickPlayer() const
{
	return m_bPickPlayer;
}

bool CvEventTriggerInfo::isOtherPlayerWar() const
{
	return m_bOtherPlayerWar;
}

bool CvEventTriggerInfo::isOtherPlayerHasReligion() const
{
	return m_bOtherPlayerHasReligion;
}

bool CvEventTriggerInfo::isOtherPlayerHasOtherReligion() const
{
	return m_bOtherPlayerHasOtherReligion;
}

bool CvEventTriggerInfo::isOtherPlayerAI() const
{
	return m_bOtherPlayerAI;
}

bool CvEventTriggerInfo::isPickCity() const
{
	return m_bPickCity;
}

bool CvEventTriggerInfo::isPickOtherPlayerCity() const
{
	return m_bPickOtherPlayerCity;
}

bool CvEventTriggerInfo::isShowPlot() const
{
	return m_bShowPlot;
}

int CvEventTriggerInfo::getCityFoodWeight() const
{
	return m_iCityFoodWeight;
}

bool CvEventTriggerInfo::isUnitsOnPlot() const
{
	return m_bUnitsOnPlot;
}

bool CvEventTriggerInfo::isOwnPlot() const
{
	return m_bOwnPlot;
}

bool CvEventTriggerInfo::isPickReligion() const
{
	return m_bPickReligion;
}

bool CvEventTriggerInfo::isStateReligion() const
{
	return m_bStateReligion;
}

bool CvEventTriggerInfo::isHolyCity() const
{
	return m_bHolyCity;
}

bool CvEventTriggerInfo::isPickCorporation() const
{
	return m_bPickCorporation;
}

bool CvEventTriggerInfo::isHeadquarters() const
{
	return m_bHeadquarters;
}

bool CvEventTriggerInfo::isProbabilityUnitMultiply() const
{
	return m_bProbabilityUnitMultiply;
}

bool CvEventTriggerInfo::isProbabilityBuildingMultiply() const
{
	return m_bProbabilityBuildingMultiply;
}

bool CvEventTriggerInfo::isPrereqEventCity() const
{
	return m_bPrereqEventCity;
}

const char* CvEventTriggerInfo::getPythonCallback() const
{
	return m_szPythonCallback;
}

const char* CvEventTriggerInfo::getPythonCanDo() const
{
	return m_szPythonCanDo;
}

const char* CvEventTriggerInfo::getPythonCanDoCity() const
{
	return m_szPythonCanDoCity;
}

const char* CvEventTriggerInfo::getPythonCanDoUnit() const
{
	return m_szPythonCanDoUnit;
}

/*************************************************************************************************/
/**	New Tag Defs	(EventTriggerInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvEventTriggerInfo::getPrereqBroadAlignment() const			{return m_iPrereqBroadAlignment;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvEventTriggerInfo::getPrereqBroadEthicalAlignment() const			{return m_iPrereqBroadEthicalAlignment;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Events: Added by Kael 08/08/2007
int CvEventTriggerInfo::getPrereqCrime() const
{
	return m_iPrereqCrime;
}

int CvEventTriggerInfo::getPrereqGlobalCounter() const
{
	return m_iPrereqGlobalCounter;
}

int CvEventTriggerInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvEventTriggerInfo::getPrereqEthicalAlignment() const
{
	return m_iPrereqEthicalAlignment;
}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

int CvEventTriggerInfo::getPrereqCivilizationPleased() const
{
	return m_iPrereqCivilizationPleased;
}

int CvEventTriggerInfo::getPrereqLeader() const
{
	return m_iPrereqLeader;
}

int CvEventTriggerInfo::getPrereqTrait() const
{
	return m_iPrereqTrait;
}
//FfH: End Add
//FlagSystem

int CvEventTriggerInfo::getPrereqFlags(int i) const
{
	return m_aiPrereqFlags[i];
}

int CvEventTriggerInfo::getNumPrereqFlags() const
{
	return (int)m_aiPrereqFlags.size();
}
int CvEventTriggerInfo::getPrereqNotFlags(int i) const
{
	return m_aiPrereqNotFlags[i];
}

int CvEventTriggerInfo::getNumPrereqNotFlags() const
{
	return (int)m_aiPrereqNotFlags.size();
}


void CvEventTriggerInfo::read(FDataStreamBase* stream)
{
	int iNumElements;
	int iElement;
	CvWString szElement;

	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iPercentGamesActive);
	stream->Read(&m_iProbability);
	stream->Read(&m_iNumUnits);
	stream->Read(&m_iNumBuildings);
	stream->Read(&m_iNumUnitsGlobal);
	stream->Read(&m_iNumBuildingsGlobal);
	stream->Read(&m_iNumPlotsRequired);
	stream->Read(&m_iPlotType);
	stream->Read(&m_iNumReligions);
	stream->Read(&m_iNumCorporations);
	stream->Read(&m_iOtherPlayerShareBorders);
	stream->Read(&m_iOtherPlayerHasTech);
	stream->Read(&m_iCivic);
	stream->Read(&m_iMinPopulation);
	stream->Read(&m_iMaxPopulation);
	stream->Read(&m_iMinMapLandmass);
	stream->Read(&m_iMinOurLandmass);
	stream->Read(&m_iMaxOurLandmass);
	stream->Read(&m_iMinDifficulty);
	stream->Read(&m_iAngry);
	stream->Read(&m_iUnhealthy);
	stream->Read(&m_iUnitDamagedWeight);
	stream->Read(&m_iUnitDistanceWeight);
	stream->Read(&m_iUnitExperienceWeight);
	stream->Read(&m_iMinTreasury);

	stream->Read(&iNumElements);
	m_aiUnitsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiUnitsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiBuildingsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiBuildingsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiPrereqOrTechs.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqOrTechs.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiPrereqAndTechs.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqAndTechs.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiObsoleteTechs.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiObsoleteTechs.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiEvents.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiEvents.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiPrereqEvents.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqEvents.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiFeaturesRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiFeaturesRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiTerrainsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiTerrainsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiImprovementsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiImprovementsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiBonusesRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiBonusesRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiRoutesRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiRoutesRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiReligionsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiReligionsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiCorporationsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiCorporationsRequired.push_back(iElement);
	}

	stream->Read(&m_bSinglePlayer);
	stream->Read(&m_bTeam);
	stream->Read(&m_bRecurring);
	stream->Read(&m_bGlobal);
	stream->Read(&m_bPickPlayer);
	stream->Read(&m_bOtherPlayerWar);
	stream->Read(&m_bOtherPlayerHasReligion);
	stream->Read(&m_bOtherPlayerHasOtherReligion);
	stream->Read(&m_bOtherPlayerAI);
	stream->Read(&m_bPickCity);
	stream->Read(&m_bPickOtherPlayerCity);
	stream->Read(&m_bShowPlot);
	stream->Read(&m_iCityFoodWeight);
	stream->Read(&m_bUnitsOnPlot);
	stream->Read(&m_bOwnPlot);
	stream->Read(&m_bPickReligion);
	stream->Read(&m_bStateReligion);
	stream->Read(&m_bHolyCity);
	stream->Read(&m_bPickCorporation);
	stream->Read(&m_bHeadquarters);
	stream->Read(&m_bProbabilityUnitMultiply);
	stream->Read(&m_bProbabilityBuildingMultiply);
	stream->Read(&m_bPrereqEventCity);

	stream->Read(&iNumElements);
	m_aszText.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->ReadString(szElement);
		m_aszText.push_back(szElement);
	}

	m_aiTextEra.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiTextEra.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aszWorldNews.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->ReadString(szElement);
		m_aszWorldNews.push_back(szElement);
	}

	stream->ReadString(m_szPythonCallback);
	stream->ReadString(m_szPythonCanDo);
	stream->ReadString(m_szPythonCanDoCity);
	stream->ReadString(m_szPythonCanDoUnit);

/*************************************************************************************************/
/**	New Tag Defs	(EventTriggerInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBroadAlignment);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBroadEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Events: Added by Kael 08/08/2007
	stream->Read(&m_iPrereqCrime);
	stream->Read(&m_iPrereqGlobalCounter);
	stream->Read(&m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqCivilizationPleased);
	stream->Read(&m_iPrereqLeader);
	stream->Read(&m_iPrereqTrait);
//FfH: End Add
	//FlagSystem
	stream->Read(&iNumElements);
	m_aiPrereqFlags.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqFlags.push_back(iElement);
	}
	stream->Read(&iNumElements);
	m_aiPrereqNotFlags.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqNotFlags.push_back(iElement);
	}


}

void CvEventTriggerInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iPercentGamesActive);
	stream->Write(m_iProbability);
	stream->Write(m_iNumUnits);
	stream->Write(m_iNumBuildings);
	stream->Write(m_iNumUnitsGlobal);
	stream->Write(m_iNumBuildingsGlobal);
	stream->Write(m_iNumPlotsRequired);
	stream->Write(m_iPlotType);
	stream->Write(m_iNumReligions);
	stream->Write(m_iNumCorporations);
	stream->Write(m_iOtherPlayerShareBorders);
	stream->Write(m_iOtherPlayerHasTech);
	stream->Write(m_iCivic);
	stream->Write(m_iMinPopulation);
	stream->Write(m_iMaxPopulation);
	stream->Write(m_iMinMapLandmass);
	stream->Write(m_iMinOurLandmass);
	stream->Write(m_iMaxOurLandmass);
	stream->Write(m_iMinDifficulty);
	stream->Write(m_iAngry);
	stream->Write(m_iUnhealthy);
	stream->Write(m_iUnitDamagedWeight);
	stream->Write(m_iUnitDistanceWeight);
	stream->Write(m_iUnitExperienceWeight);
	stream->Write(m_iMinTreasury);

	stream->Write(m_aiUnitsRequired.size());
	for (std::vector<int>::iterator it = m_aiUnitsRequired.begin(); it != m_aiUnitsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiBuildingsRequired.size());
	for (std::vector<int>::iterator it = m_aiBuildingsRequired.begin(); it != m_aiBuildingsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiPrereqOrTechs.size());
	for (std::vector<int>::iterator it = m_aiPrereqOrTechs.begin(); it != m_aiPrereqOrTechs.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiPrereqAndTechs.size());
	for (std::vector<int>::iterator it = m_aiPrereqAndTechs.begin(); it != m_aiPrereqAndTechs.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiObsoleteTechs.size());
	for (std::vector<int>::iterator it = m_aiObsoleteTechs.begin(); it != m_aiObsoleteTechs.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiEvents.size());
	for (std::vector<int>::iterator it = m_aiEvents.begin(); it != m_aiEvents.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiPrereqEvents.size());
	for (std::vector<int>::iterator it = m_aiPrereqEvents.begin(); it != m_aiPrereqEvents.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiFeaturesRequired.size());
	for (std::vector<int>::iterator it = m_aiFeaturesRequired.begin(); it != m_aiFeaturesRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiTerrainsRequired.size());
	for (std::vector<int>::iterator it = m_aiTerrainsRequired.begin(); it != m_aiTerrainsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiImprovementsRequired.size());
	for (std::vector<int>::iterator it = m_aiImprovementsRequired.begin(); it != m_aiImprovementsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiBonusesRequired.size());
	for (std::vector<int>::iterator it = m_aiBonusesRequired.begin(); it != m_aiBonusesRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiRoutesRequired.size());
	for (std::vector<int>::iterator it = m_aiRoutesRequired.begin(); it != m_aiRoutesRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiReligionsRequired.size());
	for (std::vector<int>::iterator it = m_aiReligionsRequired.begin(); it != m_aiReligionsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiCorporationsRequired.size());
	for (std::vector<int>::iterator it = m_aiCorporationsRequired.begin(); it != m_aiCorporationsRequired.end(); ++it)
	{
		stream->Write(*it);
	}

	stream->Write(m_bSinglePlayer);
	stream->Write(m_bTeam);
	stream->Write(m_bRecurring);
	stream->Write(m_bGlobal);
	stream->Write(m_bPickPlayer);
	stream->Write(m_bOtherPlayerWar);
	stream->Write(m_bOtherPlayerHasReligion);
	stream->Write(m_bOtherPlayerHasOtherReligion);
	stream->Write(m_bOtherPlayerAI);
	stream->Write(m_bPickCity);
	stream->Write(m_bPickOtherPlayerCity);
	stream->Write(m_bShowPlot);
	stream->Write(m_iCityFoodWeight);
	stream->Write(m_bUnitsOnPlot);
	stream->Write(m_bOwnPlot);
	stream->Write(m_bPickReligion);
	stream->Write(m_bStateReligion);
	stream->Write(m_bHolyCity);
	stream->Write(m_bPickCorporation);
	stream->Write(m_bHeadquarters);
	stream->Write(m_bProbabilityUnitMultiply);
	stream->Write(m_bProbabilityBuildingMultiply);
	stream->Write(m_bPrereqEventCity);

	stream->Write(m_aszText.size());
	for (std::vector<CvWString>::iterator it = m_aszText.begin(); it != m_aszText.end(); ++it)
	{
		stream->WriteString(*it);
	}
	for (std::vector<int>::iterator it = m_aiTextEra.begin(); it != m_aiTextEra.end(); ++it)
	{
		stream->Write(*it);
	}

	stream->Write(m_aszWorldNews.size());
	for (std::vector<CvWString>::iterator it = m_aszWorldNews.begin(); it != m_aszWorldNews.end(); ++it)
	{
		stream->WriteString(*it);
	}

	stream->WriteString(m_szPythonCallback);
	stream->WriteString(m_szPythonCanDo);
	stream->WriteString(m_szPythonCanDoCity);
	stream->WriteString(m_szPythonCanDoUnit);

/*************************************************************************************************/
/**	New Tag Defs	(EventTriggerInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBroadAlignment);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBroadEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Events: Added by Kael 08/08/2007
	stream->Write(m_iPrereqCrime);
	stream->Write(m_iPrereqGlobalCounter);
	stream->Write(m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iPrereqCivilizationPleased);
	stream->Write(m_iPrereqLeader);
	stream->Write(m_iPrereqTrait);
//FfH: End Add
	//FlagSystem
	stream->Write(m_aiPrereqFlags.size());
	for (std::vector<int>::iterator it = m_aiPrereqFlags.begin(); it != m_aiPrereqFlags.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiPrereqNotFlags.size());
	for (std::vector<int>::iterator it = m_aiPrereqNotFlags.begin(); it != m_aiPrereqNotFlags.end(); ++it)
	{
		stream->Write(*it);
	}

}

bool CvEventTriggerInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iPercentGamesActive, "iPercentGamesActive");
	pXML->GetChildXmlValByName(&m_iProbability, "iWeight");

	pXML->GetChildXmlValByName(&m_iNumUnits, "iNumUnits");
	pXML->GetChildXmlValByName(&m_iNumBuildings, "iNumBuildings");
	pXML->GetChildXmlValByName(&m_iNumUnitsGlobal, "iNumUnitsGlobal");
	pXML->GetChildXmlValByName(&m_iNumBuildingsGlobal, "iNumBuildingsGlobal");

	pXML->GetChildXmlValByName(&m_iNumPlotsRequired, "iNumPlotsRequired");
	pXML->GetChildXmlValByName(&m_iPlotType, "iPlotType", -1);

	pXML->GetChildXmlValByName(&m_iNumReligions, "iNumReligions");
	pXML->GetChildXmlValByName(&m_iNumCorporations, "iNumCorporations");

	pXML->GetChildXmlValByName(&m_iOtherPlayerShareBorders, "iOtherPlayerShareBorders");

	pXML->GetChildXmlValByName(&m_iMinPopulation, "iMinPopulation");
	pXML->GetChildXmlValByName(&m_iMaxPopulation, "iMaxPopulation");

	pXML->GetChildXmlValByName(&m_iMinMapLandmass, "iMinMapLandmass");
	pXML->GetChildXmlValByName(&m_iMinOurLandmass, "iMinOurLandmass");
	pXML->GetChildXmlValByName(&m_iMaxOurLandmass, "iMaxOurLandmass", -1);
	pXML->GetChildXmlValByName(szTextVal, "MinDifficulty");
	m_iMinDifficulty = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iAngry, "iAngry");
	pXML->GetChildXmlValByName(&m_iUnhealthy, "iUnhealthy");
	pXML->GetChildXmlValByName(&m_iUnitDamagedWeight, "iUnitDamagedWeight");
	pXML->GetChildXmlValByName(&m_iUnitDistanceWeight, "iUnitDistanceWeight");
	pXML->GetChildXmlValByName(&m_iUnitExperienceWeight, "iUnitExperienceWeight");
	pXML->GetChildXmlValByName(&m_iMinTreasury, "iMinTreasury");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UnitsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiUnitsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiUnitsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiBuildingsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiBuildingsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"OrPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqOrTechs.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiPrereqOrTechs.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AndPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqAndTechs.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiPrereqAndTechs.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "OtherPlayerHasTech");
	m_iOtherPlayerHasTech = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Civic");
	m_iCivic = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ObsoleteTechs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiObsoleteTechs.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiObsoleteTechs.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Events"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiEvents.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiEvents.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqEvents"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqEvents.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0;j<iNumSibs;j++)
					{
						m_aiPrereqEvents.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeaturesRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiFeaturesRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiFeaturesRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TerrainsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiTerrainsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiTerrainsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiImprovementsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiImprovementsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusesRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiBonusesRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiBonusesRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RoutesRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiRoutesRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiRoutesRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ReligionsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiReligionsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j < iNumSibs; j++)
					{
						m_aiReligionsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiCorporationsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j < iNumSibs; j++)
					{
						m_aiCorporationsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aszText.clear();
	m_aiTextEra.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TriggerTexts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							m_aszText.push_back(szTextVal);
							pXML->GetNextXmlVal(szTextVal);
							m_aiTextEra.push_back(pXML->FindInInfoClass(szTextVal));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aszWorldNews.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"WorldNewsTexts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j<iNumSibs; ++j)
					{
						m_aszWorldNews.push_back(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(&m_bSinglePlayer, "bSinglePlayer");
	pXML->GetChildXmlValByName(&m_bTeam, "bTeam");
	pXML->GetChildXmlValByName(&m_bRecurring, "bRecurring");
	pXML->GetChildXmlValByName(&m_bGlobal, "bGlobal");
	pXML->GetChildXmlValByName(&m_bPickPlayer, "bPickPlayer");
	pXML->GetChildXmlValByName(&m_bOtherPlayerWar, "bOtherPlayerWar");
	pXML->GetChildXmlValByName(&m_bOtherPlayerHasReligion, "bOtherPlayerHasReligion");
	pXML->GetChildXmlValByName(&m_bOtherPlayerHasOtherReligion, "bOtherPlayerHasOtherReligion");
	pXML->GetChildXmlValByName(&m_bOtherPlayerAI, "bOtherPlayerAI");
	pXML->GetChildXmlValByName(&m_bPickCity, "bPickCity");
	pXML->GetChildXmlValByName(&m_bPickOtherPlayerCity, "bPickOtherPlayerCity");
	pXML->GetChildXmlValByName(&m_bShowPlot, "bShowPlot");
	pXML->GetChildXmlValByName(&m_iCityFoodWeight, "iCityFoodWeight");
	pXML->GetChildXmlValByName(&m_bUnitsOnPlot, "bUnitsOnPlot");
	pXML->GetChildXmlValByName(&m_bOwnPlot, "bOwnPlot");
	pXML->GetChildXmlValByName(&m_bPickReligion, "bPickReligion");
	pXML->GetChildXmlValByName(&m_bStateReligion, "bStateReligion");
	pXML->GetChildXmlValByName(&m_bHolyCity, "bHolyCity");
	pXML->GetChildXmlValByName(&m_bPickCorporation, "bPickCorporation");
	pXML->GetChildXmlValByName(&m_bHeadquarters, "bHeadquarters");
	pXML->GetChildXmlValByName(&m_bProbabilityUnitMultiply, "bProbabilityUnitMultiply");
	pXML->GetChildXmlValByName(&m_bProbabilityBuildingMultiply, "bProbabilityBuildingMultiply");
	pXML->GetChildXmlValByName(&m_bPrereqEventCity, "bPrereqEventPlot");

	pXML->GetChildXmlValByName(m_szPythonCallback, "PythonCallback");
	pXML->GetChildXmlValByName(m_szPythonCanDo, "PythonCanDo");
	pXML->GetChildXmlValByName(m_szPythonCanDoCity, "PythonCanDoCity");
	pXML->GetChildXmlValByName(m_szPythonCanDoUnit, "PythonCanDoUnit");

/*************************************************************************************************/
/**	New Tag Defs	(EventTriggerInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqBroadAlignment, "iPrereqBroadAlignment");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iPrereqBroadEthicalAlignment, "iPrereqBroadEthicalAlignment");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH Events: Added by Kael 08/08/2007
	pXML->GetChildXmlValByName(&m_iPrereqCrime, "iPrereqCrime");
	pXML->GetChildXmlValByName(&m_iPrereqGlobalCounter, "iPrereqGlobalCounter");
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqEthicalAlignment");
	m_iPrereqEthicalAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilizationPleased");
	m_iPrereqCivilizationPleased = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqLeader");
	m_iPrereqLeader = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqTrait");
	m_iPrereqTrait = pXML->FindInInfoClass(szTextVal);
//FfH: End Add
	//FlagSystem
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqFlags"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqFlags.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiPrereqFlags.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqNotFlags"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqNotFlags.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiPrereqNotFlags.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(EventTriggerInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEventTriggerInfo::copyNonDefaults(CvEventTriggerInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPercentGamesActive()						== 0)				m_iPercentGamesActive					= pClassInfo->getPercentGamesActive();
	if (getProbability()							== 0)				m_iProbability							= pClassInfo->getProbability();
	if (getNumUnits()								== 0)				m_iNumUnits								= pClassInfo->getNumUnits();
	if (getNumBuildings()							== 0)				m_iNumBuildings							= pClassInfo->getNumBuildings();
	if (getNumUnitsGlobal()							== 0)				m_iNumUnitsGlobal						= pClassInfo->getNumUnitsGlobal();
	if (getNumBuildingsGlobal()						== 0)				m_iNumBuildingsGlobal					= pClassInfo->getNumBuildingsGlobal();
	if (getNumPlotsRequired()						== 0)				m_iNumPlotsRequired						= pClassInfo->getNumPlotsRequired();
	if (getPlotType()								== -1)				m_iPlotType								= pClassInfo->getPlotType();
	if (getNumReligions()							== 0)				m_iNumReligions							= pClassInfo->getNumReligions();
	if (getNumCorporations()						== 0)				m_iNumCorporations						= pClassInfo->getNumCorporations();
	if (getOtherPlayerShareBorders()				== 0)				m_iOtherPlayerShareBorders				= pClassInfo->getOtherPlayerShareBorders();
	if (getMinPopulation()							== 0)				m_iMinPopulation						= pClassInfo->getMinPopulation();
	if (getMaxPopulation()							== 0)				m_iMaxPopulation						= pClassInfo->getMaxPopulation();
	if (getMinMapLandmass()							== 0)				m_iMinMapLandmass						= pClassInfo->getMinMapLandmass();
	if (getMinOurLandmass()							== 0)				m_iMinOurLandmass						= pClassInfo->getMinOurLandmass();
	if (getMaxOurLandmass()							== -1)				m_iMaxOurLandmass						= pClassInfo->getMaxOurLandmass();
	if (getMinDifficulty()							== NO_HANDICAP)		m_iMinDifficulty						= pClassInfo->getMinDifficulty();
	if (getAngry()									== 0)				m_iAngry								= pClassInfo->getAngry();
	if (getUnhealthy()								== 0)				m_iUnhealthy							= pClassInfo->getUnhealthy();
	if (getUnitDamagedWeight()						== 0)				m_iUnitDamagedWeight					= pClassInfo->getUnitDamagedWeight();
	if (getUnitDistanceWeight()						== 0)				m_iUnitDistanceWeight					= pClassInfo->getUnitDistanceWeight();
	if (getUnitExperienceWeight()					== 0)				m_iUnitExperienceWeight					= pClassInfo->getUnitExperienceWeight();
	if (getMinTreasury()							== 0)				m_iMinTreasury							= pClassInfo->getMinTreasury();
	if (getCityFoodWeight()							== 0)				m_iCityFoodWeight						= pClassInfo->getCityFoodWeight();
	if (getOtherPlayerHasTech()						== NO_TECH)			m_iOtherPlayerHasTech					= pClassInfo->getOtherPlayerHasTech();
	if (getCivic()									== NO_CIVIC)		m_iCivic								= pClassInfo->getCivic();
	if (isSinglePlayer()							== false)			m_bSinglePlayer							= pClassInfo->isSinglePlayer();
	if (isTeam()									== false)			m_bTeam									= pClassInfo->isTeam();
	if (isRecurring()								== false)			m_bRecurring							= pClassInfo->isRecurring();
	if (isGlobal()									== false)			m_bGlobal								= pClassInfo->isGlobal();
	if (isPickPlayer()								== false)			m_bPickPlayer							= pClassInfo->isPickPlayer();
	if (isOtherPlayerWar()							== false)			m_bOtherPlayerWar						= pClassInfo->isOtherPlayerWar();
	if (isOtherPlayerHasReligion()					== false)			m_bOtherPlayerHasReligion				= pClassInfo->isOtherPlayerHasReligion();
	if (isOtherPlayerHasOtherReligion()				== false)			m_bOtherPlayerHasOtherReligion			= pClassInfo->isOtherPlayerHasOtherReligion();
	if (isOtherPlayerAI()							== false)			m_bOtherPlayerAI						= pClassInfo->isOtherPlayerAI();
	if (isPickCity()								== false)			m_bPickCity								= pClassInfo->isPickCity();
	if (isPickOtherPlayerCity()						== false)			m_bPickOtherPlayerCity					= pClassInfo->isPickOtherPlayerCity();
	if (isShowPlot()								== false)			m_bShowPlot								= pClassInfo->isShowPlot();
	if (isUnitsOnPlot()								== false)			m_bUnitsOnPlot							= pClassInfo->isUnitsOnPlot();
	if (isOwnPlot()									== false)			m_bOwnPlot								= pClassInfo->isOwnPlot();
	if (isPickReligion()							== false)			m_bPickReligion							= pClassInfo->isPickReligion();
	if (isStateReligion()							== false)			m_bStateReligion						= pClassInfo->isStateReligion();
	if (isHolyCity()								== false)			m_bHolyCity								= pClassInfo->isHolyCity();
	if (isPickCorporation()							== false)			m_bPickCorporation						= pClassInfo->isPickCorporation();
	if (isHeadquarters()							== false)			m_bHeadquarters							= pClassInfo->isHeadquarters();
	if (isProbabilityUnitMultiply()					== false)			m_bProbabilityUnitMultiply				= pClassInfo->isProbabilityUnitMultiply();
	if (isProbabilityBuildingMultiply()				== false)			m_bProbabilityBuildingMultiply			= pClassInfo->isProbabilityBuildingMultiply();
	if (isPrereqEventCity()							== false)			m_bPrereqEventCity						= pClassInfo->isPrereqEventCity();
	if (getPrereqBroadAlignment()					== 0)				m_iPrereqBroadAlignment					= pClassInfo->getPrereqBroadAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getPrereqBroadEthicalAlignment()            == 0)               m_iPrereqBroadEthicalAlignment          = pClassInfo->getPrereqBroadEthicalAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getPrereqGlobalCounter()					== 0)				m_iPrereqGlobalCounter					= pClassInfo->getPrereqGlobalCounter();
	if (getPythonCallback()							== cDefault)		m_szPythonCallback						= pClassInfo->getPythonCallback();
	if (getPythonCanDo()							== cDefault)		m_szPythonCanDo							= pClassInfo->getPythonCanDo();
	if (getPythonCanDoCity()						== cDefault)		m_szPythonCanDoCity						= pClassInfo->getPythonCanDoCity();
	if (getPythonCanDoUnit()						== cDefault)		m_szPythonCanDoUnit						= pClassInfo->getPythonCanDoUnit();
	if (getPrereqTrait()							== NO_TRAIT)		m_iPrereqTrait							= pClassInfo->getPrereqTrait();
	if (getPrereqLeader()							== NO_LEADER)		m_iPrereqLeader							= pClassInfo->getPrereqLeader();
	if (getPrereqAlignment()						== NO_ALIGNMENT)	m_iPrereqAlignment						= pClassInfo->getPrereqAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getPrereqEthicalAlignment()            == NO_ETHICAL_ALIGNMENT) m_iPrereqEthicalAlignment               = pClassInfo->getPrereqEthicalAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getPrereqCivilizationPleased()				== NO_CIVILIZATION)	m_iPrereqCivilizationPleased			= pClassInfo->getPrereqCivilizationPleased();
	for ( int i = 0; i < pClassInfo->getNumUnitsRequired(); i++)
	{
		if (pClassInfo->getUnitRequired(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumUnitsRequired(), &m_aiUnitsRequired[0], pClassInfo->getUnitRequired(i))))
			{
																		m_aiUnitsRequired.push_back(			pClassInfo->getUnitRequired(i));
			}
		}
	}
	for (int i = 0; i < pClassInfo->getNumBuildingsRequired(); i++)
	{
		if ( pClassInfo->getBuildingRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumBuildingsRequired(), &m_aiBuildingsRequired[0], pClassInfo->getBuildingRequired(i))))
			{
																		m_aiBuildingsRequired.push_back(		pClassInfo->getBuildingRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumPrereqOrTechs(); i++)
	{
		if ( pClassInfo->getPrereqOrTechs(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqOrTechs(), &m_aiPrereqOrTechs[0], pClassInfo->getPrereqOrTechs(i))))
			{
																		m_aiPrereqOrTechs.push_back(			pClassInfo->getPrereqOrTechs(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumPrereqAndTechs(); i++)
	{
		if ( pClassInfo->getPrereqAndTechs(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqAndTechs(), &m_aiPrereqAndTechs[0], pClassInfo->getPrereqAndTechs(i))))
			{
																		m_aiPrereqAndTechs.push_back(			pClassInfo->getPrereqAndTechs(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumObsoleteTechs(); i++)
	{
		if ( pClassInfo->getObsoleteTech(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumObsoleteTechs(), &m_aiObsoleteTechs[0], pClassInfo->getObsoleteTech(i))))
			{
																		m_aiObsoleteTechs.push_back(			pClassInfo->getObsoleteTech(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumEvents(); i++)
	{
		if ( pClassInfo->getEvent(i)				!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumEvents(), &m_aiEvents[0], pClassInfo->getEvent(i))))
			{
																		m_aiEvents.push_back(					pClassInfo->getEvent(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumPrereqEvents(); i++)
	{
		if ( pClassInfo->getPrereqEvent(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqEvents(), &m_aiPrereqEvents[0], pClassInfo->getPrereqEvent(i))))
			{
																		m_aiPrereqEvents.push_back(				pClassInfo->getPrereqEvent(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumFeaturesRequired(); i++)
	{
		if ( pClassInfo->getFeatureRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumFeaturesRequired(), &m_aiFeaturesRequired[0], pClassInfo->getFeatureRequired(i))))
			{
																		m_aiFeaturesRequired.push_back(			pClassInfo->getFeatureRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumTerrainsRequired(); i++)
	{
		if ( pClassInfo->getTerrainRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumTerrainsRequired(), &m_aiTerrainsRequired[0], pClassInfo->getTerrainRequired(i))))
			{
																		m_aiTerrainsRequired.push_back(			pClassInfo->getTerrainRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumImprovementsRequired(); i++)
	{
		if ( pClassInfo->getImprovementRequired(i)	!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumImprovementsRequired(), &m_aiImprovementsRequired[0], pClassInfo->getImprovementRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getImprovementRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumBonusesRequired(); i++)
	{
		if ( pClassInfo->getBonusRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumBonusesRequired(), &m_aiBonusesRequired[0], pClassInfo->getBonusRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getBonusRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumRoutesRequired(); i++)
	{
		if ( pClassInfo->getRouteRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumRoutesRequired(), &m_aiRoutesRequired[0], pClassInfo->getRouteRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getRouteRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumReligionsRequired(); i++)
	{
		if ( pClassInfo->getReligionRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumReligionsRequired(), &m_aiReligionsRequired[0], pClassInfo->getReligionRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getReligionRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumCorporationsRequired(); i++)
	{
		if ( pClassInfo->getCorporationRequired(i)	!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumCorporationsRequired(), &m_aiCorporationsRequired[0], pClassInfo->getCorporationRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getCorporationRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumTexts(); i++)
	{
		if (pClassInfo->getText(i)					!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumTexts(), &m_aszText[0], pClassInfo->getText(i))))
			{
																		m_aszText.push_back(					pClassInfo->getText(i));
																		m_aiTextEra.push_back(					pClassInfo->getTextEra(i));
			}
			else //If dupe exist, we want to overwrite whatever it is(assuming the modder changed the Era on purpose)
			{
																		m_aszText[i]							= pClassInfo->getText(i);
																		m_aiTextEra[i]							= pClassInfo->getTextEra(i);
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumWorldNews(); i++)
	{
		if ( pClassInfo->getWorldNews(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumWorldNews(), &m_aszWorldNews[0], pClassInfo->getWorldNews(i))))
			{
																		m_aszWorldNews.push_back(				pClassInfo->getWorldNews(i));
			}
		}
	}
	//FlagSystem

	for (int i = 0; i < pClassInfo->getNumPrereqFlags(); i++)
	{
		if (pClassInfo->getPrereqFlags(i) != NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqFlags(), &m_aiPrereqFlags[0], pClassInfo->getPrereqFlags(i))))
			{
				m_aiPrereqFlags.push_back(pClassInfo->getPrereqFlags(i));
			}
		}
	}

	for (int i = 0; i < pClassInfo->getNumPrereqNotFlags(); i++)
	{
		if (pClassInfo->getPrereqNotFlags(i) != NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqNotFlags(), &m_aiPrereqNotFlags[0], pClassInfo->getPrereqNotFlags(i))))
			{
				m_aiPrereqNotFlags.push_back(pClassInfo->getPrereqNotFlags(i));
			}
		}
	}

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvEventInfo
//	Events
//
//
CvEventInfo::CvEventInfo() :
	m_bQuest(false),
	m_bGlobal(false),
	m_bTeam(false),
	m_bCityEffect(false),
	m_bOtherPlayerCityEffect(false),
	m_bGoldToPlayer(false),
	m_bGoldenAge(false),
	m_bDeclareWar(false),
	m_bDisbandUnit(false),
	m_iGold(0),
	m_iRandomGold(0),
	m_iCulture(0),
	m_iEspionagePoints(0),
	m_iTech(NO_TECH),
	m_iTechPercent(0),
	m_iTechCostPercent(0),
	m_iTechMinTurnsLeft(0),
	m_iPrereqTech(NO_TECH),
	m_iUnitClass(NO_UNITCLASS),
	m_iNumUnits(0),
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iUnitExperience(0),
/**								----  End Original Code  ----									**/
	m_iUnitExperience(0.0f),
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
	m_iUnitImmobileTurns(0),
	m_iBuildingClass(NO_BUILDINGCLASS),
	m_iBuildingChange(0),
	m_iHappy(0),
	m_iHealth(0),
	m_iHurryAnger(0),
	m_iHappyTurns(0),
	m_iFood(0),
	m_iFoodPercent(0),
	m_iFeature(NO_FEATURE),
	m_iFeatureChange(0),
	m_iImprovement(NO_IMPROVEMENT),
	m_iImprovementChange(0),
	m_iBonus(NO_BONUS),
	m_iBonusChange(0),
	m_iRoute(NO_ROUTE),
	m_iRouteChange(0),
	m_iBonusRevealed(NO_BONUS),
	m_iBonusGift(NO_BONUS),
	m_iConvertOwnCities(0),
	m_iConvertOtherCities(0),
	m_iMaxNumReligions(-1),
	m_iOurAttitudeModifier(0),
	m_iAttitudeModifier(0),
	m_iTheirEnemyAttitudeModifier(0),
	m_iPopulationChange(0),
	m_iRevoltTurns(0),
	m_iMinPillage(0),
	m_iMaxPillage(0),
	m_iUnitPromotion(NO_PROMOTION),
	m_iFreeUnitSupport(0),
	m_iInflationModifier(0),
	m_iSpaceProductionModifier(0),
	m_iAIValue(0),

/*************************************************************************************************/
/**	New Tag Defs	(EventInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
	m_iAlignmentModifier(0),
	m_iAlignmentModTowardsNeutral(0),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	m_iEthicalAlignmentModifier(0),
	m_iEthicalAlignmentModTowardsNeutral(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH: Added by Kael 01/21/2008
	m_iCrime(0),
	m_iGlobalCounter(0),
	m_iPrereqAlignment(NO_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	m_iPrereqEthicalAlignment(NO_ETHICAL_ALIGNMENT),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	m_iPrereqBonus(NO_BONUS),
	m_iPrereqCivilization(NO_CIVILIZATION),
	m_iPrereqCorporation(NO_CORPORATION),
	m_iPrereqReligion(NO_RELIGION),
	m_iPrereqStateReligion(NO_RELIGION),
//FfH: End Add

	m_piTechFlavorValue(NULL),
	m_piPlotExtraYields(NULL),
	m_piFreeSpecialistCount(NULL),
	m_piAdditionalEventChance(NULL),
	m_piAdditionalEventTime(NULL),
	m_piClearEventChance(NULL),
	m_piUnitCombatPromotions(NULL),
	m_piUnitClassPromotions(NULL)
{
}

CvEventInfo::~CvEventInfo()
{
	SAFE_DELETE_ARRAY(m_piTechFlavorValue);
	SAFE_DELETE_ARRAY(m_piPlotExtraYields);
	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	SAFE_DELETE_ARRAY(m_piAdditionalEventChance);
	SAFE_DELETE_ARRAY(m_piAdditionalEventTime);
	SAFE_DELETE_ARRAY(m_piClearEventChance);
	SAFE_DELETE_ARRAY(m_piUnitCombatPromotions);
	SAFE_DELETE_ARRAY(m_piUnitClassPromotions);
}

bool CvEventInfo::isGlobal() const
{
	return m_bGlobal;
}

bool CvEventInfo::isQuest() const
{
	return m_bQuest;
}

bool CvEventInfo::isTeam() const
{
	return m_bTeam;
}

bool CvEventInfo::isCityEffect() const
{
	return m_bCityEffect;
}

bool CvEventInfo::isOtherPlayerCityEffect() const
{
	return m_bOtherPlayerCityEffect;
}

bool CvEventInfo::isGoldToPlayer() const
{
	return m_bGoldToPlayer;
}

bool CvEventInfo::isGoldenAge() const
{
	return m_bGoldenAge;
}

bool CvEventInfo::isDeclareWar() const
{
	return m_bDeclareWar;
}

bool CvEventInfo::isDisbandUnit() const
{
	return m_bDisbandUnit;
}

int CvEventInfo::getGold() const
{
	return m_iGold;
}

int CvEventInfo::getRandomGold() const
{
	return m_iRandomGold;
}

int CvEventInfo::getCulture() const
{
	return m_iCulture;
}

int CvEventInfo::getEspionagePoints() const
{
	return m_iEspionagePoints;
}

int CvEventInfo::getTech() const
{
	return m_iTech;
}

int CvEventInfo::getTechPercent() const
{
	return m_iTechPercent;
}

int CvEventInfo::getTechCostPercent() const
{
	return m_iTechCostPercent;
}

int CvEventInfo::getTechMinTurnsLeft() const
{
	return m_iTechMinTurnsLeft;
}

int CvEventInfo::getPrereqTech() const
{
	return m_iPrereqTech;
}

int CvEventInfo::getUnitClass() const
{
	return m_iUnitClass;
}

int CvEventInfo::getNumUnits() const
{
	return m_iNumUnits;
}

int CvEventInfo::getUnitExperience() const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iUnitExperience;
/**								----  End Original Code  ----									**/
	return (int)(m_iUnitExperience*100);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvEventInfo::getUnitImmobileTurns() const
{
	return m_iUnitImmobileTurns;
}

int CvEventInfo::getBuildingClass() const
{
	return m_iBuildingClass;
}

int CvEventInfo::getBuildingChange() const
{
	return m_iBuildingChange;
}

int CvEventInfo::getHappy() const
{
	return m_iHappy;
}

int CvEventInfo::getHealth() const
{
	return m_iHealth;
}

int CvEventInfo::getHurryAnger() const
{
	return m_iHurryAnger;
}

int CvEventInfo::getHappyTurns() const
{
	return m_iHappyTurns;
}

int CvEventInfo::getFood() const
{
	return m_iFood;
}

int CvEventInfo::getFoodPercent() const
{
	return m_iFoodPercent;
}

int CvEventInfo::getFeature() const
{
	return m_iFeature;
}

int CvEventInfo::getFeatureChange() const
{
	return m_iFeatureChange;
}

int CvEventInfo::getImprovement() const
{
	return m_iImprovement;
}

int CvEventInfo::getImprovementChange() const
{
	return m_iImprovementChange;
}

int CvEventInfo::getBonus() const
{
	return m_iBonus;
}

int CvEventInfo::getBonusChange() const
{
	return m_iBonusChange;
}

int CvEventInfo::getRoute() const
{
	return m_iRoute;
}

int CvEventInfo::getRouteChange() const
{
	return m_iRouteChange;
}

int CvEventInfo::getBonusRevealed() const
{
	return m_iBonusRevealed;
}

int CvEventInfo::getBonusGift() const
{
	return m_iBonusGift;
}

int CvEventInfo::getConvertOwnCities() const
{
	return m_iConvertOwnCities;
}

int CvEventInfo::getConvertOtherCities() const
{
	return m_iConvertOtherCities;
}

int CvEventInfo::getMaxNumReligions() const
{
	return m_iMaxNumReligions;
}

int CvEventInfo::getOurAttitudeModifier() const
{
	return m_iOurAttitudeModifier;
}

int CvEventInfo::getAttitudeModifier() const
{
	return m_iAttitudeModifier;
}

int CvEventInfo::getTheirEnemyAttitudeModifier() const
{
	return m_iTheirEnemyAttitudeModifier;
}

int CvEventInfo::getPopulationChange() const
{
	return m_iPopulationChange;
}

int CvEventInfo::getRevoltTurns() const
{
	return m_iRevoltTurns;
}

int CvEventInfo::getMinPillage() const
{
	return m_iMinPillage;
}

int CvEventInfo::getMaxPillage() const
{
	return m_iMaxPillage;
}

int CvEventInfo::getUnitPromotion() const
{
	return m_iUnitPromotion;
}

int CvEventInfo::getFreeUnitSupport() const
{
	return m_iFreeUnitSupport;
}

int CvEventInfo::getInflationModifier() const
{
	return m_iInflationModifier;
}

int CvEventInfo::getSpaceProductionModifier() const
{
	return m_iSpaceProductionModifier;
}

int CvEventInfo::getAIValue() const
{
	return m_iAIValue;
}

/*************************************************************************************************/
/**	New Tag Defs	(EventInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvEventInfo::getAlignmentModifier() const				{return m_iAlignmentModifier;}
int CvEventInfo::getAlignmentModTowardsNeutral() const		{return m_iAlignmentModTowardsNeutral;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvEventInfo::getEthicalAlignmentModifier() const				{return m_iEthicalAlignmentModifier;}
int CvEventInfo::getEthicalAlignmentModTowardsNeutral() const		{return m_iEthicalAlignmentModTowardsNeutral;}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH: Added by Kael 01/21/2008
int CvEventInfo::getCrime() const
{
	return m_iCrime;
}

int CvEventInfo::getGlobalCounter() const
{
	return m_iGlobalCounter;
}

int CvEventInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvEventInfo::getPrereqEthicalAlignment() const
{
	return m_iPrereqEthicalAlignment;
}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

int CvEventInfo::getPrereqBonus() const
{
	return m_iPrereqBonus;
}

int CvEventInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

int CvEventInfo::getPrereqCorporation() const
{
	return m_iPrereqCorporation;
}

int CvEventInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}

int CvEventInfo::getPrereqStateReligion() const
{
	return m_iPrereqStateReligion;
}
//FfH: End Add

int CvEventInfo::getAdditionalEventChance(int i) const
{
	FAssert (i >= 0 && i < GC.getNumEventInfos());
	return m_piAdditionalEventChance ? m_piAdditionalEventChance[i] : 0;
}

int CvEventInfo::getAdditionalEventTime(int i) const
{
	FAssert (i >= 0 && i < GC.getNumEventInfos());
	return m_piAdditionalEventTime ? m_piAdditionalEventTime[i] : 0;
}

int CvEventInfo::getClearEventChance(int i) const
{
	FAssert (i >= 0 && i < GC.getNumEventInfos());
	return m_piClearEventChance ? m_piClearEventChance[i] : 0;
}

int CvEventInfo::getTechFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTechFlavorValue ? m_piTechFlavorValue[i] : -1;
}

int CvEventInfo::getPlotExtraYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPlotExtraYields ? m_piPlotExtraYields[i] : -1;
}

int CvEventInfo::getFreeSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFreeSpecialistCount ? m_piFreeSpecialistCount[i] : -1;
}

int CvEventInfo::getUnitCombatPromotion(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatPromotions ? m_piUnitCombatPromotions[i] : -1;
}

int CvEventInfo::getUnitClassPromotion(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitClassPromotions ? m_piUnitClassPromotions[i] : -1;
}

const CvWString& CvEventInfo::getWorldNews(int i) const
{
	FAssert(i >= 0 && i < (int)m_aszWorldNews.size());
	return m_aszWorldNews[i];
}

int CvEventInfo::getNumWorldNews() const
{
	return m_aszWorldNews.size();
}

int CvEventInfo::getBuildingYieldChange(int iBuildingClass, int iYield) const
{
	for (std::vector<BuildingYieldChange>::const_iterator it = m_aBuildingYieldChanges.begin(); it != m_aBuildingYieldChanges.end(); ++it)
	{
		if ((*it).eBuildingClass == (BuildingClassTypes)iBuildingClass && (*it).eYield == (YieldTypes)iYield)
		{
			return (*it).iChange;
		}
	}

	return 0;
}

int CvEventInfo::getNumBuildingYieldChanges() const
{
	return m_aBuildingYieldChanges.size();
}

int CvEventInfo::getBuildingCommerceChange(int iBuildingClass, int iCommerce) const
{
	for (std::vector<BuildingCommerceChange>::const_iterator it = m_aBuildingCommerceChanges.begin(); it != m_aBuildingCommerceChanges.end(); ++it)
	{
		if ((*it).eBuildingClass == (BuildingClassTypes)iBuildingClass && (*it).eCommerce == (CommerceTypes)iCommerce)
		{
			return (*it).iChange;
		}
	}

	return 0;
}

int CvEventInfo::getNumBuildingCommerceChanges() const
{
	return m_aBuildingCommerceChanges.size();
}

int CvEventInfo::getNumBuildingHappyChanges() const
{
	return m_aBuildingHappyChanges.size();
}

int CvEventInfo::getBuildingHappyChange(int iBuildingClass) const
{
	for (BuildingChangeArray::const_iterator it = m_aBuildingHappyChanges.begin(); it != m_aBuildingHappyChanges.end(); ++it)
	{
		if ((*it).first == (BuildingClassTypes)iBuildingClass)
		{
			return (*it).second;
		}
	}

	return 0;
}

int CvEventInfo::getNumBuildingHealthChanges() const
{
	return m_aBuildingHealthChanges.size();
}

int CvEventInfo::getBuildingHealthChange(int iBuildingClass) const
{
	for (BuildingChangeArray::const_iterator it = m_aBuildingHealthChanges.begin(); it != m_aBuildingHealthChanges.end(); ++it)
	{
		if ((*it).first == (BuildingClassTypes)iBuildingClass)
		{
			return (*it).second;
		}
	}

	return 0;
}

const char* CvEventInfo::getPythonCallback() const
{
	return m_szPythonCallback;
}

const char* CvEventInfo::getPythonExpireCheck() const
{
	return m_szPythonExpireCheck;
}

const char* CvEventInfo::getPythonCanDo() const
{
	return m_szPythonCanDo;
}

const char* CvEventInfo::getPythonHelp() const
{
	return m_szPythonHelp;
}

const wchar* CvEventInfo::getUnitNameKey() const
{
	return m_szUnitName;
}

const wchar* CvEventInfo::getQuestFailTextKey() const
{
	return m_szQuestFailText;
}

const wchar* CvEventInfo::getLocalInfoTextKey() const
{
	return m_szLocalInfoText;
}

const wchar* CvEventInfo::getOtherPlayerPopup() const
{
	return m_szOtherPlayerPopup;
}

void CvEventInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_bQuest);
	stream->Read(&m_bGlobal);
	stream->Read(&m_bTeam);
	stream->Read(&m_bCityEffect);
	stream->Read(&m_bOtherPlayerCityEffect);
	stream->Read(&m_bGoldToPlayer);
	stream->Read(&m_bGoldenAge);
	stream->Read(&m_bDeclareWar);
	stream->Read(&m_bDisbandUnit);
	stream->Read(&m_iGold);
	stream->Read(&m_iRandomGold);
	stream->Read(&m_iCulture);
	stream->Read(&m_iEspionagePoints);
	stream->Read(&m_iTech);
	stream->Read(&m_iTechPercent);
	stream->Read(&m_iTechCostPercent);
	stream->Read(&m_iTechMinTurnsLeft);
	stream->Read(&m_iPrereqTech);
	stream->Read(&m_iUnitClass);
	stream->Read(&m_iNumUnits);
	stream->Read(&m_iUnitExperience);
	stream->Read(&m_iUnitImmobileTurns);
	stream->Read(&m_iBuildingClass);
	stream->Read(&m_iBuildingChange);
	stream->Read(&m_iHappy);
	stream->Read(&m_iHealth);
	stream->Read(&m_iHurryAnger);
	stream->Read(&m_iHappyTurns);
	stream->Read(&m_iFood);
	stream->Read(&m_iFoodPercent);
	stream->Read(&m_iFeature);
	stream->Read(&m_iFeatureChange);
	stream->Read(&m_iImprovement);
	stream->Read(&m_iImprovementChange);
	stream->Read(&m_iBonus);
	stream->Read(&m_iBonusChange);
	stream->Read(&m_iRoute);
	stream->Read(&m_iRouteChange);
	stream->Read(&m_iBonusRevealed);
	stream->Read(&m_iBonusGift);
	stream->Read(&m_iConvertOwnCities);
	stream->Read(&m_iConvertOtherCities);
	stream->Read(&m_iMaxNumReligions);
	stream->Read(&m_iOurAttitudeModifier);
	stream->Read(&m_iAttitudeModifier);
	stream->Read(&m_iTheirEnemyAttitudeModifier);
	stream->Read(&m_iPopulationChange);
	stream->Read(&m_iRevoltTurns);
	stream->Read(&m_iMinPillage);
	stream->Read(&m_iMaxPillage);
	stream->Read(&m_iUnitPromotion);
	stream->Read(&m_iFreeUnitSupport);
	stream->Read(&m_iInflationModifier);
	stream->Read(&m_iSpaceProductionModifier);
	stream->Read(&m_iAIValue);

/*************************************************************************************************/
/**	New Tag Defs	(EventInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Read Data from Save Files									**/
/*************************************************************************************************/
	stream->Read(&m_iAlignmentModifier);
	stream->Read(&m_iAlignmentModTowardsNeutral);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iEthicalAlignmentModifier);
	stream->Read(&m_iEthicalAlignmentModTowardsNeutral);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH: Added by Kael 01/21/2008
	stream->Read(&m_iCrime);
	stream->Read(&m_iGlobalCounter);
	stream->Read(&m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Read(&m_iPrereqBonus);
	stream->Read(&m_iPrereqCivilization);
	stream->Read(&m_iPrereqCorporation);
	stream->Read(&m_iPrereqReligion);
	stream->Read(&m_iPrereqStateReligion);
//FfH: End Add

	SAFE_DELETE_ARRAY(m_piTechFlavorValue);
	m_piTechFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piTechFlavorValue);

	SAFE_DELETE_ARRAY(m_piPlotExtraYields);
	m_piPlotExtraYields = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piPlotExtraYields);

	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	m_piFreeSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);

	SAFE_DELETE_ARRAY(m_piAdditionalEventChance);
	m_piAdditionalEventChance = new int[GC.getNumEventInfos()];
	stream->Read(GC.getNumEventInfos(), m_piAdditionalEventChance);

	SAFE_DELETE_ARRAY(m_piAdditionalEventTime);
	m_piAdditionalEventTime = new int[GC.getNumEventInfos()];
	stream->Read(GC.getNumEventInfos(), m_piAdditionalEventTime);

	SAFE_DELETE_ARRAY(m_piClearEventChance);
	m_piClearEventChance = new int[GC.getNumEventInfos()];
	stream->Read(GC.getNumEventInfos(), m_piClearEventChance);

	SAFE_DELETE_ARRAY(m_piUnitCombatPromotions);
	m_piUnitCombatPromotions = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatPromotions);

	SAFE_DELETE_ARRAY(m_piUnitClassPromotions);
	m_piUnitClassPromotions = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piUnitClassPromotions);

	int iNumElements;
	CvWString szText;
	stream->Read(&iNumElements);
	m_aszWorldNews.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->ReadString(szText);
		m_aszWorldNews.push_back(szText);
	}

	stream->Read(&iNumElements);
	m_aBuildingYieldChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		BuildingYieldChange kChange;
		kChange.read(stream);
		m_aBuildingYieldChanges.push_back(kChange);
	}

	stream->Read(&iNumElements);
	m_aBuildingCommerceChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		BuildingCommerceChange kChange;
		kChange.read(stream);
		m_aBuildingCommerceChanges.push_back(kChange);
	}

	stream->Read(&iNumElements);
	m_aBuildingHappyChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		int iBuildingClass;
		stream->Read(&iBuildingClass);
		int iHappy;
		stream->Read(&iHappy);
		m_aBuildingHappyChanges.push_back(std::make_pair((BuildingClassTypes)iBuildingClass, iHappy));
	}

	stream->Read(&iNumElements);
	m_aBuildingHealthChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		int iBuildingClass;
		stream->Read(&iBuildingClass);
		int iHealthy;
		stream->Read(&iHealthy);
		m_aBuildingHealthChanges.push_back(std::make_pair((BuildingClassTypes)iBuildingClass, iHealthy));
	}

	stream->ReadString(m_szUnitName);
	stream->ReadString(m_szOtherPlayerPopup);
	stream->ReadString(m_szQuestFailText);
	stream->ReadString(m_szLocalInfoText);
	stream->ReadString(m_szPythonCallback);
	stream->ReadString(m_szPythonExpireCheck);
	stream->ReadString(m_szPythonCanDo);
	stream->ReadString(m_szPythonHelp);
}

void CvEventInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_bQuest);
	stream->Write(m_bGlobal);
	stream->Write(m_bTeam);
	stream->Write(m_bCityEffect);
	stream->Write(m_bOtherPlayerCityEffect);
	stream->Write(m_bGoldToPlayer);
	stream->Write(m_bGoldenAge);
	stream->Write(m_bDeclareWar);
	stream->Write(m_bDisbandUnit);
	stream->Write(m_iGold);
	stream->Write(m_iRandomGold);
	stream->Write(m_iCulture);
	stream->Write(m_iEspionagePoints);
	stream->Write(m_iTech);
	stream->Write(m_iTechPercent);
	stream->Write(m_iTechCostPercent);
	stream->Write(m_iTechMinTurnsLeft);
	stream->Write(m_iPrereqTech);
	stream->Write(m_iUnitClass);
	stream->Write(m_iNumUnits);
	stream->Write(m_iUnitExperience);
	stream->Write(m_iUnitImmobileTurns);
	stream->Write(m_iBuildingClass);
	stream->Write(m_iBuildingChange);
	stream->Write(m_iHappy);
	stream->Write(m_iHealth);
	stream->Write(m_iHurryAnger);
	stream->Write(m_iHappyTurns);
	stream->Write(m_iFood);
	stream->Write(m_iFoodPercent);
	stream->Write(m_iFeature);
	stream->Write(m_iFeatureChange);
	stream->Write(m_iImprovement);
	stream->Write(m_iImprovementChange);
	stream->Write(m_iBonus);
	stream->Write(m_iBonusChange);
	stream->Write(m_iRoute);
	stream->Write(m_iRouteChange);
	stream->Write(m_iBonusRevealed);
	stream->Write(m_iBonusGift);
	stream->Write(m_iConvertOwnCities);
	stream->Write(m_iConvertOtherCities);
	stream->Write(m_iMaxNumReligions);
	stream->Write(m_iOurAttitudeModifier);
	stream->Write(m_iAttitudeModifier);
	stream->Write(m_iTheirEnemyAttitudeModifier);
	stream->Write(m_iPopulationChange);
	stream->Write(m_iRevoltTurns);
	stream->Write(m_iMinPillage);
	stream->Write(m_iMaxPillage);
	stream->Write(m_iUnitPromotion);
	stream->Write(m_iFreeUnitSupport);
	stream->Write(m_iInflationModifier);
	stream->Write(m_iSpaceProductionModifier);
	stream->Write(m_iAIValue);

/*************************************************************************************************/
/**	New Tag Defs	(EventInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Write Data to Save Files									**/
/*************************************************************************************************/
	stream->Write(m_iAlignmentModifier);
	stream->Write(m_iAlignmentModTowardsNeutral);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iEthicalAlignmentModifier);
	stream->Write(m_iEthicalAlignmentModTowardsNeutral);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
//FfH: Added by Kael 01/21/2008
	stream->Write(m_iCrime);
	stream->Write(m_iGlobalCounter);
	stream->Write(m_iPrereqAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	stream->Write(m_iPrereqEthicalAlignment);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	stream->Write(m_iPrereqBonus);
	stream->Write(m_iPrereqCivilization);
	stream->Write(m_iPrereqCorporation);
	stream->Write(m_iPrereqReligion);
	stream->Write(m_iPrereqStateReligion);
//FfH: End Add

	stream->Write(GC.getNumFlavorTypes(), m_piTechFlavorValue);
	stream->Write(NUM_YIELD_TYPES, m_piPlotExtraYields);
	stream->Write(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);
	stream->Write(GC.getNumEventInfos(), m_piAdditionalEventChance);
	stream->Write(GC.getNumEventInfos(), m_piAdditionalEventTime);
	stream->Write(GC.getNumEventInfos(), m_piClearEventChance);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatPromotions);
	stream->Write(GC.getNumUnitClassInfos(), m_piUnitClassPromotions);

	stream->Write(m_aszWorldNews.size());
	for (std::vector<CvWString>::iterator it = m_aszWorldNews.begin(); it != m_aszWorldNews.end(); ++it)
	{
		stream->WriteString(*it);
	}

	stream->Write(m_aBuildingYieldChanges.size());
	for (std::vector<BuildingYieldChange>::iterator it = m_aBuildingYieldChanges.begin(); it != m_aBuildingYieldChanges.end(); ++it)
	{
		(*it).write(stream);
	}

	stream->Write(m_aBuildingCommerceChanges.size());
	for (std::vector<BuildingCommerceChange>::iterator it = m_aBuildingCommerceChanges.begin(); it != m_aBuildingCommerceChanges.end(); ++it)
	{
		(*it).write(stream);
	}

	stream->Write(m_aBuildingHappyChanges.size());
	for (BuildingChangeArray::iterator it = m_aBuildingHappyChanges.begin(); it != m_aBuildingHappyChanges.end(); ++it)
	{
		stream->Write((*it).first);
		stream->Write((*it).second);
	}

	stream->Write(m_aBuildingHealthChanges.size());
	for (BuildingChangeArray::iterator it = m_aBuildingHealthChanges.begin(); it != m_aBuildingHealthChanges.end(); ++it)
	{
		stream->Write((*it).first);
		stream->Write((*it).second);
	}

	stream->WriteString(m_szUnitName);
	stream->WriteString(m_szOtherPlayerPopup);
	stream->WriteString(m_szQuestFailText);
	stream->WriteString(m_szLocalInfoText);
	stream->WriteString(m_szPythonCallback);
	stream->WriteString(m_szPythonExpireCheck);
	stream->WriteString(m_szPythonCanDo);
	stream->WriteString(m_szPythonHelp);
}

bool CvEventInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bQuest, "bQuest");
	pXML->GetChildXmlValByName(&m_bGlobal, "bGlobal");
	pXML->GetChildXmlValByName(&m_bTeam, "bTeam");
	pXML->GetChildXmlValByName(&m_bCityEffect, "bPickCity");
	pXML->GetChildXmlValByName(&m_bOtherPlayerCityEffect, "bPickOtherPlayerCity");
	pXML->GetChildXmlValByName(&m_bGoldToPlayer, "bGoldToPlayer");
	pXML->GetChildXmlValByName(&m_bGoldenAge, "bGoldenAge");
	pXML->GetChildXmlValByName(&m_bDeclareWar, "bDeclareWar");
	pXML->GetChildXmlValByName(&m_iGold, "iGold");
	pXML->GetChildXmlValByName(&m_iRandomGold, "iRandomGold");
	pXML->GetChildXmlValByName(&m_iCulture, "iCulture");
	pXML->GetChildXmlValByName(&m_iEspionagePoints, "iEspionagePoints");
	pXML->GetChildXmlValByName(szTextVal, "Tech");
	m_iTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iTechPercent, "iTechPercent");
	pXML->GetChildXmlValByName(&m_iTechCostPercent, "iTechCostPercent");
	pXML->GetChildXmlValByName(&m_iTechMinTurnsLeft, "iTechMinTurnsLeft");
	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iPrereqTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitClass");
	m_iUnitClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iNumUnits, "iNumFreeUnits");
	pXML->GetChildXmlValByName(&m_bDisbandUnit, "bDisbandUnit");
	pXML->GetChildXmlValByName(&m_iUnitExperience, "iUnitExperience");
	pXML->GetChildXmlValByName(&m_iUnitImmobileTurns, "iUnitImmobileTurns");
	pXML->GetChildXmlValByName(szTextVal, "BuildingClass");
	m_iBuildingClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iBuildingChange, "iBuildingChange");

	pXML->GetChildXmlValByName(&m_iHappy, "iHappy");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHurryAnger, "iHurryAnger");
	pXML->GetChildXmlValByName(&m_iHappyTurns, "iHappyTurns");
	pXML->GetChildXmlValByName(&m_iFood, "iFood");
	pXML->GetChildXmlValByName(&m_iFoodPercent, "iFoodPercent");

	pXML->GetChildXmlValByName(szTextVal, "FeatureType");
	m_iFeature = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iFeatureChange, "iFeatureChange");

	pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
	m_iImprovement = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iImprovementChange, "iImprovementChange");

	pXML->GetChildXmlValByName(szTextVal, "BonusType");
	m_iBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iBonusChange, "iBonusChange");

	pXML->GetChildXmlValByName(szTextVal, "RouteType");
	m_iRoute = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iRouteChange, "iRouteChange");

	pXML->GetChildXmlValByName(szTextVal, "BonusRevealed");
	m_iBonusRevealed = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "BonusGift");
	m_iBonusGift = pXML->FindInInfoClass(szTextVal);

	pXML->SetVariableListTagPair(&m_piTechFlavorValue, "TechFlavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());
	pXML->SetVariableListTagPair(&m_piPlotExtraYields, "PlotExtraYields", sizeof(GC.getYieldInfo((YieldTypes)0)), NUM_YIELD_TYPES, 0);
	pXML->SetVariableListTagPair(&m_piFreeSpecialistCount, "FreeSpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	pXML->GetChildXmlValByName(&m_iConvertOwnCities, "iConvertOwnCities");
	pXML->GetChildXmlValByName(&m_iConvertOtherCities, "iConvertOtherCities");
	pXML->GetChildXmlValByName(&m_iMaxNumReligions, "iMaxNumReligions", -1);
	pXML->GetChildXmlValByName(&m_iOurAttitudeModifier, "iOurAttitudeModifier");
	pXML->GetChildXmlValByName(&m_iAttitudeModifier, "iAttitudeModifier");
	pXML->GetChildXmlValByName(&m_iTheirEnemyAttitudeModifier, "iTheirEnemyAttitudeModifier");
	pXML->GetChildXmlValByName(&m_iPopulationChange, "iPopulationChange");
	pXML->GetChildXmlValByName(&m_iRevoltTurns, "iRevoltTurns");
	pXML->GetChildXmlValByName(&m_iMinPillage, "iMinPillage");
	pXML->GetChildXmlValByName(&m_iMaxPillage, "iMaxPillage");
	pXML->GetChildXmlValByName(szTextVal, "UnitPromotion");
	m_iUnitPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iFreeUnitSupport, "iFreeUnitSupport");
	pXML->GetChildXmlValByName(&m_iInflationModifier, "iInflationMod");
	pXML->GetChildXmlValByName(&m_iSpaceProductionModifier, "iSpaceProductionMod");
	pXML->GetChildXmlValByName(&m_iAIValue, "iAIValue");
/*************************************************************************************************/
/**	New Tag Defs	(EventInfos)			05/15/08								Xienwolf	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAlignmentModifier, "iAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iAlignmentModTowardsNeutral, "iAlignmentModTowardsNeutral");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModifier, "iEthicalAlignmentModifier");
	pXML->GetChildXmlValByName(&m_iEthicalAlignmentModTowardsNeutral, "iEthicalAlignmentModTowardsNeutral");
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

//FfH: Added by Kael 01/21/2008
	pXML->GetChildXmlValByName(&m_iCrime, "iCrime");
	pXML->GetChildXmlValByName(&m_iGlobalCounter, "iGlobalCounter");
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqEthicalAlignment");
	m_iPrereqEthicalAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqBonus");
	m_iPrereqBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization");
	m_iPrereqCivilization = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCorporation");
	m_iPrereqCorporation = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqStateReligion");
	m_iPrereqStateReligion = pXML->FindInInfoClass(szTextVal);
//FfH: End Add

	CvString* pszPromotions = NULL;
	FAssertMsg(NULL == m_piUnitCombatPromotions, "Memory leak");
	m_piUnitCombatPromotions = new int[GC.getNumUnitCombatInfos()];
	pXML->SetVariableListTagPair(&pszPromotions, "UnitCombatPromotions", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos(), "NONE");
	for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
	{
		m_piUnitCombatPromotions[i] = pXML->FindInInfoClass(pszPromotions[i]);
	}
	SAFE_DELETE_ARRAY(pszPromotions);

	FAssertMsg(NULL == m_piUnitClassPromotions, "Memory leak");
	m_piUnitClassPromotions = new int[GC.getNumUnitClassInfos()];
	pXML->SetVariableListTagPair(&pszPromotions, "UnitClassPromotions", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos(), "NONE");
	for (int i = 0; i < GC.getNumUnitClassInfos(); ++i)
	{
		m_piUnitClassPromotions[i] = pXML->FindInInfoClass(pszPromotions[i]);
	}
	SAFE_DELETE_ARRAY(pszPromotions);

	pXML->GetChildXmlValByName(m_szUnitName, "UnitName");
	pXML->GetChildXmlValByName(m_szOtherPlayerPopup, "OtherPlayerPopup");
	pXML->GetChildXmlValByName(m_szQuestFailText, "QuestFailText");
	pXML->GetChildXmlValByName(m_szLocalInfoText, "LocalInfoText");
	pXML->GetChildXmlValByName(m_szPythonCallback, "PythonCallback");
	pXML->GetChildXmlValByName(m_szPythonExpireCheck, "PythonExpireCheck");
	pXML->GetChildXmlValByName(m_szPythonCanDo, "PythonCanDo");
	pXML->GetChildXmlValByName(m_szPythonHelp, "PythonHelp");

	m_aszWorldNews.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"WorldNewsTexts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j<iNumSibs; ++j)
					{
						m_aszWorldNews.push_back(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingYieldChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraYields"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingYieldChange kChange;
							kChange.eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(szTextVal);
							kChange.eYield = (YieldTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(&kChange.iChange);
							m_aBuildingYieldChanges.push_back(kChange);

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingCommerceChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraCommerces"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingCommerceChange kChange;
							kChange.eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(szTextVal);
							kChange.eCommerce = (CommerceTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(&kChange.iChange);
							m_aBuildingCommerceChanges.push_back(kChange);

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingHappyChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraHappies"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingClassTypes eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							int iChange;
							pXML->GetNextXmlVal(&iChange);
							m_aBuildingHappyChanges.push_back(std::make_pair(eBuildingClass, iChange));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingHealthChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraHealths"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingClassTypes eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							int iChange;
							pXML->GetNextXmlVal(&iChange);
							m_aBuildingHealthChanges.push_back(std::make_pair(eBuildingClass, iChange));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}

bool CvEventInfo::readPass2(CvXMLLoadUtility* pXML)
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piAdditionalEventChance, "AdditionalEvents", sizeof(GC.getEventInfo((EventTypes)0)), GC.getNumEventInfos(), 0);
	pXML->SetVariableListTagPair(&m_piAdditionalEventTime, "EventTimes", sizeof(GC.getEventInfo((EventTypes)0)), GC.getNumEventInfos(), 0);
	pXML->SetVariableListTagPair(&m_piClearEventChance, "ClearEvents", sizeof(GC.getEventInfo((EventTypes)0)), GC.getNumEventInfos(), 0);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(EventInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEventInfo::copyNonDefaults(CvEventInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isQuest()							== false)				m_bQuest						= pClassInfo->isQuest();
	if (isGlobal()							== false)				m_bGlobal						= pClassInfo->isGlobal();
	if (isTeam()							== false)				m_bTeam							= pClassInfo->isTeam();
	if (isCityEffect()						== false)				m_bCityEffect					= pClassInfo->isCityEffect();
	if (isOtherPlayerCityEffect()			== false)				m_bOtherPlayerCityEffect		= pClassInfo->isOtherPlayerCityEffect();
	if (isGoldToPlayer()					== false)				m_bGoldToPlayer					= pClassInfo->isGoldToPlayer();
	if (isGoldenAge()						== false)				m_bGoldenAge					= pClassInfo->isGoldenAge();
	if (isDeclareWar()						== false)				m_bDeclareWar					= pClassInfo->isDeclareWar();
	if (isDisbandUnit()						== false)				m_bDisbandUnit					= pClassInfo->isDisbandUnit();
	if (getGold()							== 0)					m_iGold							= pClassInfo->getGold();
	if (getRandomGold()						== 0)					m_iRandomGold					= pClassInfo->getRandomGold();
	if (getCulture()						== 0)					m_iCulture						= pClassInfo->getCulture();
	if (getEspionagePoints()				== 0)					m_iEspionagePoints				= pClassInfo->getEspionagePoints();
	if (getTechPercent()					== 0)					m_iTechPercent					= pClassInfo->getTechPercent();
	if (getTechCostPercent()				== 0)					m_iTechCostPercent				= pClassInfo->getTechCostPercent();
	if (getTechMinTurnsLeft()				== 0)					m_iTechMinTurnsLeft				= pClassInfo->getTechMinTurnsLeft();
	if (getNumUnits()						== 0)					m_iNumUnits						= pClassInfo->getNumUnits();
	if (getUnitExperience()					== 0)					m_iUnitExperience				= (float)(pClassInfo->getUnitExperience()/100.0);
	if (getUnitImmobileTurns()				== 0)					m_iUnitImmobileTurns			= pClassInfo->getUnitImmobileTurns();
	if (getBuildingChange()					== 0)					m_iBuildingChange				= pClassInfo->getBuildingChange();
	if (getHappy()							== 0)					m_iHappy						= pClassInfo->getHappy();
	if (getHealth()							== 0)					m_iHealth						= pClassInfo->getHealth();
	if (getHurryAnger()						== 0)					m_iHurryAnger					= pClassInfo->getHurryAnger();
	if (getHappyTurns()						== 0)					m_iHappyTurns					= pClassInfo->getHappyTurns();
	if (getFood()							== 0)					m_iFood							= pClassInfo->getFood();
	if (getFoodPercent()					== 0)					m_iFoodPercent					= pClassInfo->getFoodPercent();
	if (getConvertOwnCities()				== 0)					m_iConvertOwnCities				= pClassInfo->getConvertOwnCities();
	if (getConvertOtherCities()				== 0)					m_iConvertOtherCities			= pClassInfo->getConvertOtherCities();
	if (getMaxNumReligions()				== -1)					m_iMaxNumReligions				= pClassInfo->getMaxNumReligions();
	if (getOurAttitudeModifier()			== 0)					m_iOurAttitudeModifier			= pClassInfo->getOurAttitudeModifier();
	if (getAttitudeModifier()				== 0)					m_iAttitudeModifier				= pClassInfo->getAttitudeModifier();
	if (getTheirEnemyAttitudeModifier()		== 0)					m_iTheirEnemyAttitudeModifier	= pClassInfo->getTheirEnemyAttitudeModifier();
	if (getPopulationChange()				== 0)					m_iPopulationChange				= pClassInfo->getPopulationChange();
	if (getRevoltTurns()					== 0)					m_iRevoltTurns					= pClassInfo->getRevoltTurns();
	if (getMinPillage()						== 0)					m_iMinPillage					= pClassInfo->getMinPillage();
	if (getMaxPillage()						== 0)					m_iMaxPillage					= pClassInfo->getMaxPillage();
	if (getFreeUnitSupport()				== 0)					m_iFreeUnitSupport				= pClassInfo->getFreeUnitSupport();
	if (getInflationModifier()				== 0)					m_iInflationModifier			= pClassInfo->getInflationModifier();
	if (getSpaceProductionModifier()		== 0)					m_iSpaceProductionModifier		= pClassInfo->getSpaceProductionModifier();
	if (getAIValue()						== 0)					m_iAIValue						= pClassInfo->getAIValue();
	if (getFeatureChange()					== 0)					m_iFeatureChange				= pClassInfo->getFeatureChange();
	if (getImprovementChange()				== 0)					m_iImprovementChange			= pClassInfo->getImprovementChange();
	if (getBonusChange()					== 0)					m_iBonusChange					= pClassInfo->getBonusChange();
	if (getRouteChange()					== 0)					m_iRouteChange					= pClassInfo->getRouteChange();
	if (getAlignmentModifier()				== 0)					m_iAlignmentModifier			= pClassInfo->getAlignmentModifier();
	if (getAlignmentModTowardsNeutral()		== 0)					m_iAlignmentModTowardsNeutral	= pClassInfo->getAlignmentModTowardsNeutral();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getEthicalAlignmentModifier()		== 0)					m_iEthicalAlignmentModifier			= pClassInfo->getEthicalAlignmentModifier();
	if (getEthicalAlignmentModTowardsNeutral()	== 0)				m_iEthicalAlignmentModTowardsNeutral	= pClassInfo->getEthicalAlignmentModTowardsNeutral();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getCrime()							== 0)					m_iCrime						= pClassInfo->getCrime();
	if (getGlobalCounter()					== 0)					m_iGlobalCounter				= pClassInfo->getGlobalCounter();
	if (getPrereqBonus()					== NO_BONUS)			m_iPrereqBonus					= pClassInfo->getPrereqBonus();
	if (getBonus()							== NO_BONUS)			m_iBonus						= pClassInfo->getBonus();
	if (getRoute()							== NO_ROUTE)			m_iRoute						= pClassInfo->getRoute();
	if (getBonusRevealed()					== NO_BONUS)			m_iBonusRevealed				= pClassInfo->getBonusRevealed();
	if (getBonusGift()						== NO_BONUS)			m_iBonusGift					= pClassInfo->getBonusGift();
	if (getTech()							== NO_TECH)				m_iTech							= pClassInfo->getTech();
	if (getPrereqTech()						== NO_TECH)				m_iPrereqTech					= pClassInfo->getPrereqTech();
	if (getFeature()						== NO_FEATURE)			m_iFeature						= pClassInfo->getFeature();
	if (getPrereqReligion()					== NO_RELIGION)			m_iPrereqReligion				= pClassInfo->getPrereqReligion();
	if (getPrereqStateReligion()			== NO_RELIGION)			m_iPrereqStateReligion			= pClassInfo->getPrereqStateReligion();
	if (getPrereqAlignment()				== NO_ALIGNMENT)		m_iPrereqAlignment				= pClassInfo->getPrereqAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (getPrereqEthicalAlignment()			== NO_ETHICAL_ALIGNMENT) m_iPrereqEthicalAlignment		= pClassInfo->getPrereqEthicalAlignment();
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	if (getUnitClass()						== NO_UNITCLASS)		m_iUnitClass					= pClassInfo->getUnitClass();
	if (getUnitPromotion()					== NO_PROMOTION)		m_iUnitPromotion				= pClassInfo->getUnitPromotion();
	if (getImprovement()					== NO_IMPROVEMENT)		m_iImprovement					= pClassInfo->getImprovement();
	if (getPrereqCorporation()				== NO_CORPORATION)		m_iPrereqCorporation			= pClassInfo->getPrereqCorporation();
	if (getPrereqCivilization()				== NO_CIVILIZATION)		m_iPrereqCivilization			= pClassInfo->getPrereqCivilization();
	if (getBuildingClass()					== NO_BUILDINGCLASS)	m_iBuildingClass				= pClassInfo->getBuildingClass();
	if (getUnitNameKey()					== wDefault)			m_szUnitName					= pClassInfo->getUnitNameKey();
	if (getOtherPlayerPopup()				== wDefault)			m_szOtherPlayerPopup			= pClassInfo->getOtherPlayerPopup();
	if (getQuestFailTextKey()				== wDefault)			m_szQuestFailText				= pClassInfo->getQuestFailTextKey();
	if (getLocalInfoTextKey()				== wDefault)			m_szLocalInfoText				= pClassInfo->getLocalInfoTextKey();
	if (getPythonCallback()					== cDefault)			m_szPythonCallback				= pClassInfo->getPythonCallback();
	if (getPythonExpireCheck()				== cDefault)			m_szPythonExpireCheck			= pClassInfo->getPythonExpireCheck();
	if (getPythonCanDo()					== cDefault)			m_szPythonCanDo					= pClassInfo->getPythonCanDo();
	if (getPythonHelp()						== cDefault)			m_szPythonHelp					= pClassInfo->getPythonHelp();
	for ( int i = 0; i < GC.getNumFlavorTypes(); i++)
	{
		if (m_piTechFlavorValue[i]			== 0)					m_piTechFlavorValue[i]			= pClassInfo->getTechFlavorValue(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_piPlotExtraYields[i]			== 0)					m_piPlotExtraYields[i]			= pClassInfo->getPlotExtraYield(i);
	}
	for ( int i = 0; i < GC.getNumSpecialistInfos(); i++)
	{
		if (m_piFreeSpecialistCount[i]		== 0)					m_piFreeSpecialistCount[i]		= pClassInfo->getFreeSpecialistCount(i);
	}
	for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
	{
		if (m_piUnitCombatPromotions[i]		== NO_PROMOTION)		m_piUnitCombatPromotions[i]		= pClassInfo->getUnitCombatPromotion(i);
	}
	for (int i = 0; i < GC.getNumUnitClassInfos(); ++i)
	{
		if (m_piUnitClassPromotions[i]		== NO_PROMOTION)		m_piUnitClassPromotions[i]		= pClassInfo->getUnitClassPromotion(i);
	}
	CvWString szwTextVal;
	for (int i = 0; i < pClassInfo->getNumWorldNews(); i++)
	{
		szwTextVal																					= pClassInfo->getWorldNews(i);
																	m_aszWorldNews.push_back(szwTextVal);
	}
	for (int iBuildingClass = 0; iBuildingClass < GC.getNumBuildingClassInfos(); iBuildingClass++)
	{
		for (int iCommerce = 0; iCommerce < NUM_COMMERCE_TYPES; iCommerce++)
		{
			if (pClassInfo->getBuildingYieldChange(iBuildingClass, iCommerce) != 0)
			{
				BuildingCommerceChange kChange;
				kChange.eBuildingClass = (BuildingClassTypes)iBuildingClass;
				kChange.eCommerce = (CommerceTypes)iCommerce;
				kChange.iChange =																	pClassInfo->getBuildingCommerceChange(iBuildingClass, iCommerce);
																	m_aBuildingCommerceChanges.push_back(kChange);
			}
		}
	}
}
void CvEventInfo::copyNonDefaultsReadPass2(CvEventInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if(!m_piAdditionalEventChance)									pXML->InitList(&m_piAdditionalEventChance, GC.getNumEventInfos(), 0);
	if(!m_piAdditionalEventTime)									pXML->InitList(&m_piAdditionalEventTime, GC.getNumEventInfos(), 0);
	if(!m_piClearEventChance)										pXML->InitList(&m_piClearEventChance, GC.getNumEventInfos(), 0);
	for (int i = 0; i < GC.getNumEventInfos(); ++i)
	{
		if(bOver || pClassInfo->getAdditionalEventChance(i)	!= 0)	m_piAdditionalEventChance[i]	= pClassInfo->getAdditionalEventChance(i);
		if(bOver || pClassInfo->getAdditionalEventTime(i)	!= 0)	m_piAdditionalEventTime[i]		= pClassInfo->getAdditionalEventTime(i);
		if(bOver || pClassInfo->getClearEventChance(i)		!= 0)	m_piClearEventChance[i]			= pClassInfo->getClearEventChance(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvEspionageMissionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvEspionageMissionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvEspionageMissionInfo::CvEspionageMissionInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvEspionageMissionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvEspionageMissionInfo::~CvEspionageMissionInfo()
{
}

int CvEspionageMissionInfo::getCost() const
{
	return m_iCost;
}

bool CvEspionageMissionInfo::isPassive() const
{
	return m_bIsPassive;
}

bool CvEspionageMissionInfo::isTwoPhases() const
{
	return m_bIsTwoPhases;
}

bool CvEspionageMissionInfo::isTargetsCity() const
{
	return m_bTargetsCity;
}

bool CvEspionageMissionInfo::isSelectPlot() const
{
	return m_bSelectPlot;
}

int CvEspionageMissionInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvEspionageMissionInfo::getVisibilityLevel() const
{
	return m_iVisibilityLevel;
}

bool CvEspionageMissionInfo::isInvestigateCity() const
{
	return m_bInvestigateCity;
}

bool CvEspionageMissionInfo::isSeeDemographics() const
{
	return m_bSeeDemographics;
}

bool CvEspionageMissionInfo::isNoActiveMissions() const
{
	return m_bNoActiveMissions;
}

bool CvEspionageMissionInfo::isSeeResearch() const
{
	return m_bSeeResearch;
}

bool CvEspionageMissionInfo::isDestroyImprovement() const
{
	return m_bDestroyImprovement;
}

int CvEspionageMissionInfo::getDestroyBuildingCostFactor() const
{
	return m_iDestroyBuildingCostFactor;
}

int CvEspionageMissionInfo::getDestroyUnitCostFactor() const
{
	return m_iDestroyUnitCostFactor;
}

int CvEspionageMissionInfo::getDestroyProjectCostFactor() const
{
	return m_iDestroyProjectCostFactor;
}

int CvEspionageMissionInfo::getDestroyProductionCostFactor() const
{
	return m_iDestroyProductionCostFactor;
}

int CvEspionageMissionInfo::getBuyUnitCostFactor() const
{
	return m_iBuyUnitCostFactor;
}

int CvEspionageMissionInfo::getBuyCityCostFactor() const
{
	return m_iBuyCityCostFactor;
}

int CvEspionageMissionInfo::getStealTreasuryTypes() const
{
	return m_iStealTreasuryTypes;
}

int CvEspionageMissionInfo::getCityInsertCultureAmountFactor() const
{
	return m_iCityInsertCultureAmountFactor;
}

int CvEspionageMissionInfo::getCityInsertCultureCostFactor() const
{
	return m_iCityInsertCultureCostFactor;
}

int CvEspionageMissionInfo::getCityPoisonWaterCounter() const
{
	return m_iCityPoisonWaterCounter;
}

int CvEspionageMissionInfo::getCityUnhappinessCounter() const
{
	return m_iCityUnhappinessCounter;
}

int CvEspionageMissionInfo::getCityRevoltCounter() const
{
	return m_iCityRevoltCounter;
}

int CvEspionageMissionInfo::getBuyTechCostFactor() const
{
	return m_iBuyTechCostFactor;
}

int CvEspionageMissionInfo::getSwitchCivicCostFactor() const
{
	return m_iSwitchCivicCostFactor;
}

int CvEspionageMissionInfo::getSwitchReligionCostFactor() const
{
	return m_iSwitchReligionCostFactor;
}

int CvEspionageMissionInfo::getPlayerAnarchyCounter() const
{
	return m_iPlayerAnarchyCounter;
}

int CvEspionageMissionInfo::getCounterespionageNumTurns() const
{
	return m_iCounterespionageNumTurns;
}

int CvEspionageMissionInfo::getCounterespionageMod() const
{
	return m_iCounterespionageMod;
}

int CvEspionageMissionInfo::getDifficultyMod() const
{
	return m_iDifficultyMod;
}

bool CvEspionageMissionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_bIsPassive, "bIsPassive");
	pXML->GetChildXmlValByName(&m_bIsTwoPhases, "bIsTwoPhases");
	pXML->GetChildXmlValByName(&m_bTargetsCity, "bTargetsCity");
	pXML->GetChildXmlValByName(&m_bSelectPlot, "bSelectPlot");

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iVisibilityLevel, "iVisibilityLevel");
	pXML->GetChildXmlValByName(&m_bInvestigateCity, "bInvestigateCity");
	pXML->GetChildXmlValByName(&m_bSeeDemographics, "bSeeDemographics");
	pXML->GetChildXmlValByName(&m_bNoActiveMissions, "bNoActiveMissions");
	pXML->GetChildXmlValByName(&m_bSeeResearch, "bSeeResearch");

	pXML->GetChildXmlValByName(&m_bDestroyImprovement, "bDestroyImprovement");
	pXML->GetChildXmlValByName(&m_iDestroyBuildingCostFactor, "iDestroyBuildingCostFactor");
	pXML->GetChildXmlValByName(&m_iDestroyUnitCostFactor, "iDestroyUnitCostFactor");
	pXML->GetChildXmlValByName(&m_iDestroyProjectCostFactor, "iDestroyProjectCostFactor");
	pXML->GetChildXmlValByName(&m_iDestroyProductionCostFactor, "iDestroyProductionCostFactor");
	pXML->GetChildXmlValByName(&m_iBuyUnitCostFactor, "iBuyUnitCostFactor");
	pXML->GetChildXmlValByName(&m_iBuyCityCostFactor, "iBuyCityCostFactor");
	pXML->GetChildXmlValByName(&m_iStealTreasuryTypes, "iStealTreasuryTypes");
	pXML->GetChildXmlValByName(&m_iCityInsertCultureAmountFactor, "iCityInsertCultureAmountFactor");
	pXML->GetChildXmlValByName(&m_iCityInsertCultureCostFactor, "iCityInsertCultureCostFactor");
	pXML->GetChildXmlValByName(&m_iCityPoisonWaterCounter, "iCityPoisonWaterCounter");
	pXML->GetChildXmlValByName(&m_iCityUnhappinessCounter, "iCityUnhappinessCounter");
	pXML->GetChildXmlValByName(&m_iCityRevoltCounter, "iCityRevoltCounter");
	pXML->GetChildXmlValByName(&m_iBuyTechCostFactor, "iBuyTechCostFactor");
	pXML->GetChildXmlValByName(&m_iSwitchCivicCostFactor, "iSwitchCivicCostFactor");
	pXML->GetChildXmlValByName(&m_iSwitchReligionCostFactor, "iSwitchReligionCostFactor");
	pXML->GetChildXmlValByName(&m_iPlayerAnarchyCounter, "iPlayerAnarchyCounter");
	pXML->GetChildXmlValByName(&m_iCounterespionageNumTurns, "iCounterespionageNumTurns");
	pXML->GetChildXmlValByName(&m_iCounterespionageMod, "iCounterespionageMod");
	pXML->GetChildXmlValByName(&m_iDifficultyMod, "iDifficultyMod");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEspionageMissionInfo::copyNonDefaults(CvEspionageMissionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isPassive()							== false)		m_bIsPassive						= pClassInfo->isPassive();
	if (isTwoPhases()						== false)		m_bIsTwoPhases						= pClassInfo->isTwoPhases();
	if (isTargetsCity()						== false)		m_bTargetsCity						= pClassInfo->isTargetsCity();
	if (isSelectPlot()						== false)		m_bSelectPlot						= pClassInfo->isSelectPlot();
	if (isInvestigateCity()					== false)		m_bInvestigateCity					= pClassInfo->isInvestigateCity();
	if (isSeeDemographics()					== false)		m_bSeeDemographics					= pClassInfo->isSeeDemographics();
	if (isNoActiveMissions()				== false)		m_bNoActiveMissions					= pClassInfo->isNoActiveMissions();
	if (isSeeResearch()						== false)		m_bSeeResearch						= pClassInfo->isSeeResearch();
	if (isDestroyImprovement()				== false)		m_bDestroyImprovement				= pClassInfo->isDestroyImprovement();
	if (getCost()							== 0)			m_iCost								= pClassInfo->getCost();
	if (getVisibilityLevel()				== 0)			m_iVisibilityLevel					= pClassInfo->getVisibilityLevel();
	if (getDestroyBuildingCostFactor()		== 0)			m_iDestroyBuildingCostFactor		= pClassInfo->getDestroyBuildingCostFactor();
	if (getDestroyUnitCostFactor()			== 0)			m_iDestroyUnitCostFactor			= pClassInfo->getDestroyUnitCostFactor();
	if (getDestroyProjectCostFactor()		== 0)			m_iDestroyProjectCostFactor			= pClassInfo->getDestroyProjectCostFactor();
	if (getDestroyProductionCostFactor()	== 0)			m_iDestroyProductionCostFactor		= pClassInfo->getDestroyProductionCostFactor();
	if (getBuyUnitCostFactor()				== 0)			m_iBuyUnitCostFactor				= pClassInfo->getBuyUnitCostFactor();
	if (getBuyCityCostFactor()				== 0)			m_iBuyCityCostFactor				= pClassInfo->getBuyCityCostFactor();
	if (getStealTreasuryTypes()				== 0)			m_iStealTreasuryTypes				= pClassInfo->getStealTreasuryTypes();
	if (getCityInsertCultureAmountFactor()	== 0)			m_iCityInsertCultureAmountFactor	= pClassInfo->getCityInsertCultureAmountFactor();
	if (getCityInsertCultureCostFactor()	== 0)			m_iCityInsertCultureCostFactor		= pClassInfo->getCityInsertCultureCostFactor();
	if (getCityPoisonWaterCounter()			== 0)			m_iCityPoisonWaterCounter			= pClassInfo->getCityPoisonWaterCounter();
	if (getCityUnhappinessCounter()			== 0)			m_iCityUnhappinessCounter			= pClassInfo->getCityUnhappinessCounter();
	if (getCityRevoltCounter()				== 0)			m_iCityRevoltCounter				= pClassInfo->getCityRevoltCounter();
	if (getBuyTechCostFactor()				== 0)			m_iBuyTechCostFactor				= pClassInfo->getBuyTechCostFactor();
	if (getSwitchCivicCostFactor()			== 0)			m_iSwitchCivicCostFactor			= pClassInfo->getSwitchCivicCostFactor();
	if (getSwitchReligionCostFactor()		== 0)			m_iSwitchReligionCostFactor			= pClassInfo->getSwitchReligionCostFactor();
	if (getPlayerAnarchyCounter()			== 0)			m_iPlayerAnarchyCounter				= pClassInfo->getPlayerAnarchyCounter();
	if (getCounterespionageNumTurns()		== 0)			m_iCounterespionageNumTurns			= pClassInfo->getCounterespionageNumTurns();
	if (getCounterespionageMod()			== 0)			m_iCounterespionageMod				= pClassInfo->getCounterespionageMod();
	if (getDifficultyMod()					== 0)			m_iDifficultyMod					= pClassInfo->getDifficultyMod();
	if (getTechPrereq()						== NO_TECH)		m_iTechPrereq						= pClassInfo->getTechPrereq();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvUnitArtStyleTypeInfo
//  Graphic Flavor Units packages by Impaler[WrG]
//

CvUnitArtStyleTypeInfo::CvUnitArtStyleTypeInfo()
{
}

CvUnitArtStyleTypeInfo::~CvUnitArtStyleTypeInfo()
{
}

const TCHAR* CvUnitArtStyleTypeInfo::getEarlyArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j, int iPromo, bool bbypasssecondarycheck) const
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::const_iterator it = m_azEarlyArtDefineTags.begin(); it != m_azEarlyArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j && (*it).iPromoType==iPromo)
		{
			return (*it).szTag;
		}
	}
	if (!bbypasssecondarycheck)
	{
		for (ArtDefineArray::const_iterator it = m_azEarlyArtDefineTags.begin(); it != m_azEarlyArtDefineTags.end(); ++it)
		{
			if ((*it).iMeshIndex == i && (*it).iUnitType == j && (*it).iPromoType == NO_PROMOTION)
			{
				return (*it).szTag;
			}
		}
	}
	return NULL;
}

void CvUnitArtStyleTypeInfo::setEarlyArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j, const TCHAR* szVal, int iPromo)
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::iterator it = m_azEarlyArtDefineTags.begin(); it != m_azEarlyArtDefineTags.end(); ++it)
	{

		if ((*it).iMeshIndex == i && (*it).iUnitType == j && (*it).iPromoType == iPromo)
		{
			(*it).szTag = szVal;
			return;
		}
	}
	ArtDefneTag kTag;
	kTag.iMeshIndex = i;
	kTag.iUnitType = j;
	kTag.szTag = szVal;
	kTag.iPromoType = iPromo;
	m_azEarlyArtDefineTags.push_back(kTag);
	
}

const TCHAR* CvUnitArtStyleTypeInfo::getLateArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j) const
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::const_iterator it = m_azLateArtDefineTags.begin(); it != m_azLateArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			return (*it).szTag;
		}
	}

	return NULL;
}

void CvUnitArtStyleTypeInfo::setLateArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j, const TCHAR* szVal)
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::iterator it = m_azLateArtDefineTags.begin(); it != m_azLateArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			(*it).szTag = szVal;
			return;
		}
	}

	ArtDefneTag kTag;
	kTag.iMeshIndex = i;
	kTag.iUnitType = j;
	kTag.szTag = szVal;
	m_azLateArtDefineTags.push_back(kTag);
}

const TCHAR* CvUnitArtStyleTypeInfo::getMiddleArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j) const
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::const_iterator it = m_azMiddleArtDefineTags.begin(); it != m_azMiddleArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			return (*it).szTag;
		}
	}

	return NULL;
}

void CvUnitArtStyleTypeInfo::setMiddleArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j, const TCHAR* szVal)
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::iterator it = m_azMiddleArtDefineTags.begin(); it != m_azMiddleArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			(*it).szTag = szVal;
			return;
		}
	}

	ArtDefneTag kTag;
	kTag.iMeshIndex = i;
	kTag.iUnitType = j;
	kTag.szTag = szVal;
	m_azMiddleArtDefineTags.push_back(kTag);
}

int CvUnitArtStyleTypeInfo::getEarlyArtDefineArraySize()
{
	return m_azEarlyArtDefineTags.size();
}
int CvUnitArtStyleTypeInfo::getEarlyArtDefineMesh(int i)
{
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(i < getEarlyArtDefineArraySize(), "Index out of bounds");
	return m_azEarlyArtDefineTags[i].iMeshIndex;
}

int CvUnitArtStyleTypeInfo::getEarlyArtDefineUnit(int i)
{
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(i < getEarlyArtDefineArraySize(), "Index out of bounds");
	return m_azEarlyArtDefineTags[i].iUnitType;
}

int CvUnitArtStyleTypeInfo::getEarlyArtDefinePromo(int i)
{
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(i < getEarlyArtDefineArraySize(), "Index out of bounds");
	return m_azEarlyArtDefineTags[i].iPromoType;
}

CvString CvUnitArtStyleTypeInfo::getEarlyArtDefineTag(int i)
{
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(i < getEarlyArtDefineArraySize(), "Index out of bounds");
	return m_azEarlyArtDefineTags[i].szTag;
}
bool CvUnitArtStyleTypeInfo::read(CvXMLLoadUtility* pXML)
{
	int j, i;
	int iNumSibs;
	int iIndex; // UnitIndex
	int iMesh;  // Mesh Index
	int iPromo; // Promo index

	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"StyleUnits"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					for (i = 0; i < iNumSibs; i++)
					{
						pXML->GetChildXmlValByName(szTextVal, "UnitType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						pXML->GetChildXmlValByName(szTextVal, "PromotionType","NO_PROMOTION");
						if (szTextVal != "NO_PROMOTION")
						{
							iPromo = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							iPromo = NO_PROMOTION;
						}
						if (iIndex > -1)
						{
							iMesh = GC.getUnitInfo((UnitTypes) iIndex).getGroupDefinitions();

							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UnitMeshGroup"))
							{
								for (j = 0; j < iMesh; j++)
								{
									// Overwrite with the Style Art
									pXML->GetChildXmlValByName(szTextVal, "EarlyArtDefineTag");
									setEarlyArtDefineTag(j, iIndex, szTextVal,iPromo);
									pXML->GetChildXmlValByName(szTextVal, "LateArtDefineTag");
									setLateArtDefineTag(j, iIndex, szTextVal);
									pXML->GetChildXmlValByName(szTextVal, "MiddleArtDefineTag");
									setMiddleArtDefineTag(j, iIndex, szTextVal);

									if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
									{
										break;
									}
								}
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitArtStyleTypeInfo::copyNonDefaults(CvUnitArtStyleTypeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	//A bit odd here.  Will only write the new information if previously it was blank?  Seems like it means you can only expand, but that it also relies on the
	//Group Definitions in UnitInfos to determine the size, so you need to have adjusted that first.  Art junk, so for all I know it needs to be this way.
	for (int i = 0; i < pClassInfo->getEarlyArtDefineArraySize(); i++)
	{
		if (getEarlyArtDefineTag(pClassInfo->getEarlyArtDefineMesh(i), pClassInfo->getEarlyArtDefineUnit(i), pClassInfo->getEarlyArtDefinePromo(i),true) == NULL)
		{
			setEarlyArtDefineTag(pClassInfo->getEarlyArtDefineMesh(i), pClassInfo->getEarlyArtDefineUnit(i), pClassInfo->getEarlyArtDefineTag(i), pClassInfo->getEarlyArtDefinePromo(i));
		}
	}

	for (int iUnitIndex = 0; iUnitIndex < GC.getNumUnitInfos(); iUnitIndex++)
	{
		for (int iUnitMesh = 0; iUnitMesh < GC.getUnitInfo((UnitTypes) iUnitIndex).getGroupDefinitions(); iUnitMesh++ )
		{
		//	for (int iPromo = -1; iPromo < GC.getNumPromotionInfos(); iPromo++)
		//	{
		//		if (getEarlyArtDefineTag(iUnitMesh, iUnitIndex,iPromo) == NULL)
		//		{
		//			if (pClassInfo->getEarlyArtDefineTag(iUnitMesh, iUnitIndex,iPromo) != NULL)
		//			{
		//				setEarlyArtDefineTag(iUnitMesh, iUnitIndex, pClassInfo->getEarlyArtDefineTag(iUnitMesh, iUnitIndex,iPromo),iPromo);
		//			}
		//		}
		//	}
			if (getLateArtDefineTag(iUnitMesh, iUnitIndex) == NULL)
			{
				if (pClassInfo->getLateArtDefineTag(iUnitMesh, iUnitIndex) != NULL)
				{
					setLateArtDefineTag(iUnitMesh, iUnitIndex, pClassInfo->getLateArtDefineTag(iUnitMesh, iUnitIndex));
				}
			}

			if (getMiddleArtDefineTag(iUnitMesh, iUnitIndex) == NULL)
			{
				if (pClassInfo->getMiddleArtDefineTag(iUnitMesh, iUnitIndex) != NULL)
				{
					setMiddleArtDefineTag(iUnitMesh, iUnitIndex, pClassInfo->getMiddleArtDefineTag(iUnitMesh, iUnitIndex));
				}
			}
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

CvVoteSourceInfo::CvVoteSourceInfo() :
	m_iVoteInterval(0),
	m_iFreeSpecialist(NO_SPECIALIST),
	m_iCivic(NO_CIVIC),
	m_aiReligionYields(NULL),
	m_aiReligionCommerces(NULL)
{

}

CvVoteSourceInfo::~CvVoteSourceInfo()
{
	SAFE_DELETE_ARRAY(m_aiReligionYields);
	SAFE_DELETE_ARRAY(m_aiReligionCommerces);
}

int CvVoteSourceInfo::getVoteInterval() const
{
	return m_iVoteInterval;
}

int CvVoteSourceInfo::getFreeSpecialist() const
{
	return m_iFreeSpecialist;
}

int CvVoteSourceInfo::getCivic() const
{
	return m_iCivic;
}

int CvVoteSourceInfo::getReligionYield(int i) const
{
	FAssert(i >= 0 && i < NUM_YIELD_TYPES);
	return m_aiReligionYields[i];
}

int CvVoteSourceInfo::getReligionCommerce(int i) const
{
	FAssert(i >= 0 && i < NUM_COMMERCE_TYPES);
	return m_aiReligionCommerces[i];
}

const CvWString CvVoteSourceInfo::getPopupText() const
{
	return gDLL->getText(m_szPopupText);
}

const CvWString CvVoteSourceInfo::getSecretaryGeneralText() const
{
	return gDLL->getText(m_szSecretaryGeneralText);
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
const CvString& CvVoteSourceInfo::getCopyPopupText() const				{return m_szPopupText;}
const CvString& CvVoteSourceInfo::getCopySecretaryGeneralText() const	{return m_szSecretaryGeneralText;}
int CvVoteSourceInfo::getCivicVectorSize()								{return m_aszExtraXMLforPass3.size();}
CvString CvVoteSourceInfo::getCivicVectorElement(int i)					{return m_aszExtraXMLforPass3[i];}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

bool CvVoteSourceInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iVoteInterval, "iVoteInterval");
	pXML->GetChildXmlValByName(m_szPopupText, "PopupText");
	pXML->GetChildXmlValByName(m_szSecretaryGeneralText, "SecretaryGeneralText");

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "FreeSpecialist");
	m_iFreeSpecialist = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Civic");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ReligionYields"))
	{
		pXML->SetCommerce(&m_aiReligionYields);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_aiReligionYields, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ReligionCommerces"))
	{
		pXML->SetCommerce(&m_aiReligionCommerces);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_aiReligionCommerces, NUM_COMMERCE_TYPES);
	}

	return true;
}

bool CvVoteSourceInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iCivic = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_aszExtraXMLforPass3.clear();
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iCivic = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
	m_aszExtraXMLforPass3.clear();
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvVoteSourceInfo::copyNonDefaults(CvVoteSourceInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getVoteInterval()			== 0)				m_iVoteInterval				= pClassInfo->getVoteInterval();
	if (getPopupText()				== wDefault)		m_szPopupText				= pClassInfo->getCopyPopupText();
	if (getSecretaryGeneralText()	== wDefault)		m_szSecretaryGeneralText	= pClassInfo->getCopySecretaryGeneralText();
	if (getFreeSpecialist()			== NO_SPECIALIST)	m_iFreeSpecialist			= pClassInfo->getFreeSpecialist();
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (getReligionYield(i)		== 0)				m_aiReligionYields[i]		= pClassInfo->getReligionYield(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		if (getReligionCommerce(i)	== 0)				m_aiReligionCommerces[i]	= pClassInfo->getReligionCommerce(i);
	}

	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getCivicVectorSize(); i++ )
	{
														m_aszExtraXMLforPass3.push_back(		pClassInfo->getCivicVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

CvMainMenuInfo::CvMainMenuInfo()
{

}

CvMainMenuInfo::~CvMainMenuInfo()
{
}

std::string CvMainMenuInfo::getScene() const
{
	time_t rawtime;
	tm * ptm;

	time ( &rawtime );

	ptm = localtime( &rawtime );

	if (ptm->tm_mon == 3)
	{
		if (ptm->tm_mday == 1)
		{
			return "MAINMENU_SCENE_FAKE";
		}
	}

	return m_szScene;
}

std::string CvMainMenuInfo::getSceneNoShader() const
{
	time_t rawtime;
	tm * ptm;

	time ( &rawtime );

	ptm = localtime( &rawtime );

	if (ptm->tm_mon == 3)
	{
		if (ptm->tm_mday == 1)
		{
			return "MAINMENU_SCENE_FAKE";
		}
	}

	return m_szSceneNoShader;
}

std::string CvMainMenuInfo::getSoundtrack() const
{
	time_t rawtime;
	tm * ptm;

	time ( &rawtime );

	ptm = localtime( &rawtime );

	if (ptm->tm_mon == 3)
	{
		if (ptm->tm_mday == 1)
		{
			return "AS2D_PRINCESSRULE_LOOP";
		}
	}

	return m_szSoundtrack;
}

std::string CvMainMenuInfo::getLoading() const
{
	return m_szLoading;
}

std::string CvMainMenuInfo::getLoadingSlideshow() const
{
	return m_szLoadingSlideshow;
}

bool CvMainMenuInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szScene, "Scene");
	pXML->GetChildXmlValByName(m_szSceneNoShader, "SceneNoShader");
	pXML->GetChildXmlValByName(m_szSoundtrack, "Soundtrack");
	pXML->GetChildXmlValByName(m_szLoading, "Loading");
	pXML->GetChildXmlValByName(m_szLoadingSlideshow, "LoadingSlideshow");

	return true;
}

// Official Belief, created by poyuzhe 12.01.08, added by Opera 31.05.09, added by Valkrionn 09.26.09
//======================================================================================================
//					CvLeaderRelationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvLeaderRelationInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderRelationInfo::CvLeaderRelationInfo() :
m_iLeaderType(NO_LEADER),
m_paiLeaderAttitudeChange(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvLeaderRelationInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderRelationInfo::~CvLeaderRelationInfo()
{
	SAFE_DELETE_ARRAY(m_paiLeaderAttitudeChange);
}

int CvLeaderRelationInfo::getLeaderType() const
{
	return m_iLeaderType;
}

int CvLeaderRelationInfo::getLeaderAttitudeChange(int i) const
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiLeaderAttitudeChange ? m_paiLeaderAttitudeChange[i] : -1;
}

// Arrays

bool CvLeaderRelationInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "Leader");
	m_iLeaderType = pXML->FindInInfoClass(szTextVal);

	pXML->SetVariableListTagPair(&m_paiLeaderAttitudeChange, "LeaderAttitudeChanges", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());

	return true;
}
/*************************************************************************************************/
/** End 																						**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvMainMenuInfo::copyNonDefaults(CvMainMenuInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getScene()				== cDefault)	m_szScene				= pClassInfo->getScene();
	if (getSceneNoShader()		== cDefault)	m_szSceneNoShader		= pClassInfo->getSceneNoShader();
	if (getSoundtrack()			== cDefault)	m_szSoundtrack			= pClassInfo->getSoundtrack();
	if (getLoading()			== cDefault)	m_szLoading				= pClassInfo->getLoading();
	if (getLoadingSlideshow()	== cDefault)	m_szLoadingSlideshow	= pClassInfo->getLoadingSlideshow();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
// Python Modular Loading
CvPythonModulesInfo::CvPythonModulesInfo():
m_bMainInterfaceScreen(false),
m_bCivicScreen(false),
m_bCorporationScreen(false),
m_bDomesticAdvisor(false),
m_bEspionageAdvisor(false),
m_bForeignAdvisor(false),
m_bMilitaryAdvisor(false),
m_bVictoryScreen(false),
m_iScreen(0)
{
}

CvPythonModulesInfo::~CvPythonModulesInfo()
{
}

bool CvPythonModulesInfo::isMainInterfaceScreen()
{
	return m_bMainInterfaceScreen;
}

bool CvPythonModulesInfo::isCivicScreen()
{
	return m_bCivicScreen;
}

bool CvPythonModulesInfo::isCorporationScreen()
{
	return m_bCorporationScreen;
}

bool CvPythonModulesInfo::isDomesticAdvisor()
{
	return m_bDomesticAdvisor;
}

bool CvPythonModulesInfo::isEspionageAdvisor()
{
	return m_bEspionageAdvisor;
}

bool CvPythonModulesInfo::isForeignAdvisor()
{
	return m_bForeignAdvisor;
}

bool CvPythonModulesInfo::isMilitaryAdvisor()
{
	return m_bMilitaryAdvisor;
}

bool CvPythonModulesInfo::isVictoryScreen()
{
	return m_bVictoryScreen;
}

int CvPythonModulesInfo::getScreen()
{
	return m_iScreen;
}

bool CvPythonModulesInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	pXML->GetChildXmlValByName(&m_bMainInterfaceScreen, "bMainInterfaceScreen");
	pXML->GetChildXmlValByName(&m_bCivicScreen, "bCivicScreen");
	pXML->GetChildXmlValByName(&m_bCorporationScreen, "bCorporationScreen");
	pXML->GetChildXmlValByName(&m_bDomesticAdvisor, "bDomesticAdvisor");
	pXML->GetChildXmlValByName(&m_bEspionageAdvisor, "bEspionageAdvisor");
	pXML->GetChildXmlValByName(&m_bForeignAdvisor, "bForeignAdvisor");
	pXML->GetChildXmlValByName(&m_bMilitaryAdvisor, "bMilitaryAdvisor");
	pXML->GetChildXmlValByName(&m_bVictoryScreen, "bVictoryScreen");
	pXML->GetChildXmlValByName(&m_iScreen, "iScreen");
	return true;
}

// MLF loading
CvModLoadControlInfo::CvModLoadControlInfo():
m_iDirDepth(0)
{
}

CvModLoadControlInfo::~CvModLoadControlInfo()
{
}

bool CvModLoadControlInfo::isLoad(int i)
{
	FAssertMsg(i < getNumModules(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_bLoad[i];
}

void CvModLoadControlInfo::setLoad(int i, bool bLoad)
{
	FAssertMsg(i < getNumModules(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_bLoad[i] = bLoad;
}

int CvModLoadControlInfo::getNumModules()
{
	return m_iNumModules;
}

int CvModLoadControlInfo::getDirDepth()
{
	return m_iDirDepth;
}

std::string CvModLoadControlInfo::getModuleFolder(int i)
{
	FAssertMsg(i < getNumModules(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paszModuleFolder[i];
}

std::string CvModLoadControlInfo::getParentFolder()
{
	return m_paszParentFolder;
}

bool CvModLoadControlInfo::read(CvXMLLoadUtility* pXML, CvString szDirDepth, int iDirDepth)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	//Class variables
	m_iDirDepth = iDirDepth;
	m_paszParentFolder = szDirDepth; //verify previous level in CvXMLLoadUtility::getModLoadControlDirectory
	//method variables
	CvString szTextVal;
	std::string m_szDirDepth;
	bool bLoad;

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Modules"))
	{
		if (pXML->SkipToNextVal())
		{
			m_iNumModules = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (0 < m_iNumModules)
			{
				m_paszModuleFolder = new std::string[m_iNumModules];
				m_bLoad = new bool[m_iNumModules];
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int iIndex = 0; iIndex < m_iNumModules; iIndex++)
					{
						m_bLoad[iIndex] = false;	// by default bLoad is false
						if (pXML->GetChildXmlVal(szTextVal))
						{
							pXML->GetNextXmlVal(&bLoad, true);
							if (bLoad)
							{
								m_bLoad[iIndex] = bLoad;	//this Module needs to be loaded
								m_szDirDepth = szDirDepth;
								m_szDirDepth.append(szTextVal);
								m_paszModuleFolder[iIndex] = m_szDirDepth.c_str();
								GC.setTotalNumModules();  //we need this for looping in the XMLLoad class
							}

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	return true;
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	StateNames								12/12/08								Jean Elcard	**/
/**																								**/
/**							Definitions of the State Name class methods.						**/
/*************************************************************************************************/
CvStateNameInfo::CvStateNameInfo() :
m_bFullCiv(false),
m_bMinorCiv(false),
m_bSovereign(false),
m_bVassal(false),
m_bColony(false),
m_bFemaleLeader(false),
m_iMinNumCities(0),
m_iMaxNumCities(MAX_INT),
m_iMinNumCitiesConquered(0),
m_iMinNumVassals(0),
m_iNumPrereqCivics(0),
m_iNumPrereqAlignments(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_iNumPrereqEthicalAlignments(0),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
m_iPrereqCivilization(NO_CIVILIZATION),
m_iPrereqLeader(NO_LEADER),
m_iPrereqReligion(NO_RELIGION),
m_piPrereqCivics(NULL),
m_piPrereqAlignments(NULL),
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
m_piPrereqEthicalAlignments(NULL)
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
{
}

CvStateNameInfo::~CvStateNameInfo()
{
	SAFE_DELETE_ARRAY(m_piPrereqCivics);
	SAFE_DELETE_ARRAY(m_piPrereqAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
}

bool CvStateNameInfo::isFullCiv() const
{
	return m_bFullCiv;
}

bool CvStateNameInfo::isMinorCiv() const
{
	return m_bMinorCiv;
}

bool CvStateNameInfo::isSovereign() const
{
	return m_bSovereign;
}

bool CvStateNameInfo::isVassal() const
{
	return m_bVassal;
}

bool CvStateNameInfo::isColony() const
{
	return m_bColony;
}

bool CvStateNameInfo::isFemaleLeader() const
{
	return m_bFemaleLeader;
}

int CvStateNameInfo::getMinNumCities() const
{
	return m_iMinNumCities;
}

int CvStateNameInfo::getMaxNumCities() const
{
	return m_iMaxNumCities;
}

int CvStateNameInfo::getMinNumCitiesConquered() const
{
	return m_iMinNumCitiesConquered;
}

int CvStateNameInfo::getMinNumVassals() const
{
	return m_iMinNumVassals;
}

int CvStateNameInfo::getPrereqCivic(int iI) const
{
	return (getNumPrereqCivics() > iI) ? m_piPrereqCivics[iI] : -1;
}

int CvStateNameInfo::getNumPrereqCivics() const
{
	return m_iNumPrereqCivics;
}

int CvStateNameInfo::getPrereqAlignment(int iI) const
{
	return (getNumPrereqAlignments() > iI) ? m_piPrereqAlignments[iI] : -1;
}

int CvStateNameInfo::getNumPrereqAlignments() const
{
	return m_iNumPrereqAlignments;
}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
int CvStateNameInfo::getPrereqEthicalAlignment(int iI) const
{
	return (getNumPrereqEthicalAlignments() > iI) ? m_piPrereqEthicalAlignments[iI] : -1;
}

int CvStateNameInfo::getNumPrereqEthicalAlignments() const
{
	return m_iNumPrereqEthicalAlignments;
}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

int CvStateNameInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

int CvStateNameInfo::getPrereqLeader() const
{
	return m_iPrereqLeader;
}

int CvStateNameInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}

bool CvStateNameInfo::read(CvXMLLoadUtility* pXML)
{
	int iI;
	CvString szTextVal;
	std::vector<CvString> aszPrereqCivics;
	std::vector<CvString> aszPrereqAlignments;
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	std::vector<CvString> aszPrereqEthicalAlignments;
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bFullCiv, "bFullCiv");
	pXML->GetChildXmlValByName(&m_bMinorCiv, "bMinorCiv");
	pXML->GetChildXmlValByName(&m_bSovereign, "bSovereign");
	pXML->GetChildXmlValByName(&m_bVassal, "bVassal");
	pXML->GetChildXmlValByName(&m_bColony, "bColony");
	pXML->GetChildXmlValByName(&m_bFemaleLeader, "bFemaleLeader");

	pXML->GetChildXmlValByName(&m_iMinNumCities, "iMinNumCities");
	pXML->GetChildXmlValByName(&m_iMaxNumCities, "iMaxNumCities", MAX_INT);
	pXML->GetChildXmlValByName(&m_iMinNumCitiesConquered, "iMinNumCitiesConquered");
	pXML->GetChildXmlValByName(&m_iMinNumVassals, "iMinNumVassals");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqCivics"))
	{
		pXML->SetStringWithChildList(&m_iNumPrereqCivics, &aszPrereqCivics);
	}

	m_piPrereqCivics = new int[m_iNumPrereqCivics];

	for (iI = 0; iI < m_iNumPrereqCivics; iI++)
	{
		m_piPrereqCivics[iI] = GC.getInfoTypeForString(aszPrereqCivics[iI]);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqAlignments"))
	{
		pXML->SetStringWithChildList(&m_iNumPrereqAlignments, &aszPrereqAlignments);
	}

	m_piPrereqAlignments = new int[m_iNumPrereqAlignments];

	for (iI = 0; iI < m_iNumPrereqAlignments; iI++)
	{
		m_piPrereqAlignments[iI] = GC.getInfoTypeForString(aszPrereqAlignments[iI]);
	}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqEthicalAlignments"))
	{
		pXML->SetStringWithChildList(&m_iNumPrereqEthicalAlignments, &aszPrereqEthicalAlignments);
	}

	m_piPrereqEthicalAlignments = new int[m_iNumPrereqEthicalAlignments];

	for (iI = 0; iI < m_iNumPrereqEthicalAlignments; iI++)
	{
		m_piPrereqEthicalAlignments[iI] = GC.getInfoTypeForString(aszPrereqEthicalAlignments[iI]);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization");
	if (szTextVal != "") m_iPrereqCivilization = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqLeader");
	if (szTextVal != "") m_iPrereqLeader = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	if (szTextVal != "") m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);

	return true;
}

void CvStateNameInfo::copyNonDefaults(CvStateNameInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if(isFullCiv()					== false)				m_bFullCiv					= pClassInfo->isFullCiv();
	if(isMinorCiv()					== false)				m_bMinorCiv					= pClassInfo->isMinorCiv();
	if(isSovereign()				== false)				m_bSovereign				= pClassInfo->isSovereign();
	if(isVassal()					== false)				m_bVassal					= pClassInfo->isVassal();
	if(isColony()					== false)				m_bColony					= pClassInfo->isColony();
	if(isFemaleLeader()				== false)				m_bFemaleLeader				= pClassInfo->isFemaleLeader();
	if(getMinNumCities()			== 0)					m_iMinNumCities				= pClassInfo->getMinNumCities();
	if(getMinNumCitiesConquered()	== 0)					m_iMinNumCitiesConquered	= pClassInfo->getMinNumCitiesConquered();
	if(getMinNumVassals()			== 0)					m_iMinNumVassals			= pClassInfo->getMinNumVassals();
	if(getMaxNumCities()			== MAX_INT)				m_iMaxNumCities				= pClassInfo->getMaxNumCities();
	if(getPrereqLeader()			== NO_LEADER)			m_iPrereqLeader				= pClassInfo->getPrereqLeader();
	if(getPrereqReligion()			== NO_RELIGION)			m_iPrereqReligion			= pClassInfo->getPrereqReligion();
	if(getPrereqCivilization()		== NO_CIVILIZATION)		m_iPrereqCivilization		= pClassInfo->getPrereqCivilization();
	if(pClassInfo->getNumPrereqCivics() > 0)
	{
		int* tempArray = new int[getNumPrereqCivics() + pClassInfo->getNumPrereqCivics()];
		for(int i = 0; i< getNumPrereqCivics(); ++i)
		{
			tempArray[i] = getPrereqCivic(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqCivics(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqCivics();++j)
			{
				if(pClassInfo->getPrereqCivic(i) == getPrereqCivic(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqCivics()] = pClassInfo->getPrereqCivic(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqCivics);
		int iGoalSize = getNumPrereqCivics() + iNewItems;
		m_piPrereqCivics = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqCivics[i] = tempArray[i];
			FAssertMsg(m_piPrereqCivics[i] < GC.getNumCivicInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqCivics[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqCivics = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqAlignments() + pClassInfo->getNumPrereqAlignments()];
		for(int i = 0; i< getNumPrereqAlignments(); ++i)
		{
			tempArray[i] = getPrereqAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqAlignments();++j)
			{
				if(pClassInfo->getPrereqAlignment(i) == getPrereqAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqAlignments()] = pClassInfo->getPrereqAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqAlignments);
		int iGoalSize = getNumPrereqAlignments() + iNewItems;
		m_piPrereqAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqAlignments[i] < NUM_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	if(pClassInfo->getNumPrereqEthicalAlignments() > 0)
	{
		int* tempArray = new int[getNumPrereqEthicalAlignments() + pClassInfo->getNumPrereqEthicalAlignments()];
		for(int i = 0; i< getNumPrereqEthicalAlignments(); ++i)
		{
			tempArray[i] = getPrereqEthicalAlignment(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqEthicalAlignments(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqEthicalAlignments();++j)
			{
				if(pClassInfo->getPrereqEthicalAlignment(i) == getPrereqEthicalAlignment(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqEthicalAlignments()] = pClassInfo->getPrereqEthicalAlignment(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqEthicalAlignments);
		int iGoalSize = getNumPrereqEthicalAlignments() + iNewItems;
		m_piPrereqEthicalAlignments = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqAlignments[i] = tempArray[i];
			FAssertMsg(m_piPrereqEthicalAlignments[i] < NUM_ETHICAL_ALIGNMENT_TYPES ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqEthicalAlignments[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqEthicalAlignments = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
}
/*************************************************************************************************/
/**	StateNames								END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Spawn Groups						08/05/10									Valkrionn	**/
/**																								**/
/**					New spawn mechanic, allowing us to customize stacks							**/
/*************************************************************************************************/
CvSpawnGroupInfo::CvSpawnGroupInfo() :
m_iPrereqMinTurn(0),
m_iPrereqMaxTurn(0),
m_iPrereqMinAC(0),
m_iPrereqMaxAC(0),
m_iPrereqProject(NO_PROJECT),
m_iWeight(0),
m_iNumCommanderUnits(0),
m_iNumGroupPromotions(0),
m_iNumCommanderPromotions(0),
m_iNumSpawnTerrains(0),
m_iNumSpawnFeatures(0),
m_iNumPrereqTechANDs(0),
m_iNumPrereqTechORs(0),
m_iNumBlockTechANDs(0),
m_iNumBlockTechORs(0),
m_bUnique(false),
m_bAlwaysSpawn(false),
m_bNeverSpawn(false),
m_bNaval(false),
m_piCommanderUnits(NULL),
m_piGroupUnits(NULL),
m_piGroupUnitClasses(NULL),
m_piGroupPromotions(NULL),
m_piCommanderPromotions(NULL),
m_piSpawnTerrains(NULL),
m_piSpawnFeatures(NULL),
m_piPrereqTechANDs(0),
m_piPrereqTechORs(0),
m_piBlockTechANDs(0),
m_piBlockTechORs(0),
m_szPyOnSpawn(NULL),
m_szPyRequirement(NULL),
m_szBanner(NULL)
{
}

CvSpawnGroupInfo::~CvSpawnGroupInfo()
{
	SAFE_DELETE_ARRAY(m_piCommanderUnits);
	SAFE_DELETE_ARRAY(m_piGroupUnits);
	SAFE_DELETE_ARRAY(m_piGroupUnitClasses);
	SAFE_DELETE_ARRAY(m_piGroupPromotions);
	SAFE_DELETE_ARRAY(m_piCommanderPromotions);
	SAFE_DELETE_ARRAY(m_piSpawnTerrains);
	SAFE_DELETE_ARRAY(m_piSpawnFeatures);
	SAFE_DELETE_ARRAY(m_piPrereqTechANDs);
	SAFE_DELETE_ARRAY(m_piPrereqTechORs);
	SAFE_DELETE_ARRAY(m_piBlockTechANDs);
	SAFE_DELETE_ARRAY(m_piBlockTechORs);
}

bool CvSpawnGroupInfo::isUnique() const
{
	return m_bUnique;
}

bool CvSpawnGroupInfo::isAlwaysSpawn() const
{
	return m_bAlwaysSpawn;
}

bool CvSpawnGroupInfo::isNeverSpawn() const
{
	return m_bNeverSpawn;
}

bool CvSpawnGroupInfo::isNaval() const
{
	return m_bNaval;
}

int CvSpawnGroupInfo::getPrereqMinTurn() const
{
	return m_iPrereqMinTurn;
}

int CvSpawnGroupInfo::getPrereqMaxTurn() const
{
	return m_iPrereqMaxTurn;
}

int CvSpawnGroupInfo::getPrereqMinAC() const
{
	return m_iPrereqMinAC;
}

int CvSpawnGroupInfo::getPrereqMaxAC() const
{
	return m_iPrereqMaxAC;
}

int CvSpawnGroupInfo::getPrereqProject() const
{
	return m_iPrereqProject;
}

int CvSpawnGroupInfo::getWeight() const
{
	return m_iWeight;
}

int CvSpawnGroupInfo::getGroupPromotions(int iI) const
{
	return (getNumGroupPromotions() > iI) ? m_piGroupPromotions[iI] : -1;
}

int CvSpawnGroupInfo::getNumGroupPromotions() const
{
	return m_iNumGroupPromotions;
}

int CvSpawnGroupInfo::getCommanderPromotions(int iI) const
{
	return (getNumCommanderPromotions() > iI) ? m_piCommanderPromotions[iI] : -1;
}

int CvSpawnGroupInfo::getNumCommanderPromotions() const
{
	return m_iNumCommanderPromotions;
}

int CvSpawnGroupInfo::getCommanderUnits(int iI) const
{
	return (getNumCommanderUnits() > iI) ? m_piCommanderUnits[iI] : -1;
}

int CvSpawnGroupInfo::getNumCommanderUnits() const
{
	return m_iNumCommanderUnits;
}

int CvSpawnGroupInfo::getGroupUnits(int i) const
{
	FAssertMsg(i < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGroupUnits ? m_piGroupUnits[i] : -1;
}

int CvSpawnGroupInfo::getGroupUnitClasses(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGroupUnitClasses ? m_piGroupUnitClasses[i] : -1;
}

int CvSpawnGroupInfo::getSpawnTerrains(int iI) const
{
	return (getNumSpawnTerrains() > iI) ? m_piSpawnTerrains[iI] : -1;
}

int CvSpawnGroupInfo::getNumSpawnTerrains() const
{
	return m_iNumSpawnTerrains;
}

int CvSpawnGroupInfo::getSpawnFeatures(int iI) const
{
	return (getNumSpawnFeatures() > iI) ? m_piSpawnFeatures[iI] : -1;
}

int CvSpawnGroupInfo::getNumSpawnFeatures() const
{
	return m_iNumSpawnFeatures;
}

int CvSpawnGroupInfo::getPrereqTechANDs(int iI) const
{
	return (getNumPrereqTechANDs() > iI) ? m_piPrereqTechANDs[iI] : -1;
}

int CvSpawnGroupInfo::getNumPrereqTechANDs() const
{
	return m_iNumPrereqTechANDs;
}

int CvSpawnGroupInfo::getPrereqTechORs(int iI) const
{
	return (getNumPrereqTechORs() > iI) ? m_piPrereqTechORs[iI] : -1;
}

int CvSpawnGroupInfo::getNumPrereqTechORs() const
{
	return m_iNumPrereqTechORs;
}

int CvSpawnGroupInfo::getBlockTechANDs(int iI) const
{
	return (getNumBlockTechANDs() > iI) ? m_piBlockTechANDs[iI] : -1;
}

int CvSpawnGroupInfo::getNumBlockTechANDs() const
{
	return m_iNumBlockTechANDs;
}

int CvSpawnGroupInfo::getBlockTechORs(int iI) const
{
	return (getNumBlockTechORs() > iI) ? m_piBlockTechORs[iI] : -1;
}

int CvSpawnGroupInfo::getNumBlockTechORs() const
{
	return m_iNumBlockTechORs;
}

const TCHAR *CvSpawnGroupInfo::getPyRequirement() const
{
	return m_szPyRequirement;
}

const TCHAR *CvSpawnGroupInfo::getPyOnSpawn() const
{
	return m_szPyOnSpawn;
}

const TCHAR* CvSpawnGroupInfo::getBanner() const
{
	return m_szBanner;
}

bool CvSpawnGroupInfo::read(CvXMLLoadUtility* pXML)
{
	int iI;
	CvString szTextVal;
	std::vector<CvString> aszCommanderUnits;
	std::vector<CvString> aszGroupPromotions;
	std::vector<CvString> aszCommanderPromotions;
	std::vector<CvString> aszSpawnTerrains;
	std::vector<CvString> aszSpawnFeatures;
	std::vector<CvString> aszPrereqTechANDs;
	std::vector<CvString> aszPrereqTechORs;
	std::vector<CvString> aszBlockTechANDs;
	std::vector<CvString> aszBlockTechORs;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bUnique, "bUnique");
	pXML->GetChildXmlValByName(&m_bAlwaysSpawn, "bAlwaysSpawn");
	pXML->GetChildXmlValByName(&m_bNeverSpawn, "bNeverSpawn");
	pXML->GetChildXmlValByName(&m_bNaval, "bNaval");

	pXML->GetChildXmlValByName(&m_iPrereqMinTurn, "iPrereqMinTurn");
	pXML->GetChildXmlValByName(&m_iPrereqMaxTurn, "iPrereqMaxTurn");
	pXML->GetChildXmlValByName(&m_iPrereqMinAC, "iPrereqMinAC");
	pXML->GetChildXmlValByName(&m_iPrereqMaxAC, "iPrereqMaxAC");
	pXML->GetChildXmlValByName(&m_iWeight, "iWeight");

	pXML->GetChildXmlValByName(szTextVal, "PrereqRitual");
	m_iPrereqProject = GC.getInfoTypeForString(szTextVal);

	pXML->SetVariableListTagPair(&m_piGroupUnits, "GroupUnits", sizeof(GC.getUnitInfo((UnitTypes)0)), GC.getNumUnitInfos());
	pXML->SetVariableListTagPair(&m_piGroupUnitClasses, "GroupUnitClasses", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommanderUnits"))
	{
		pXML->SetStringWithChildList(&m_iNumCommanderUnits, &aszCommanderUnits);
	}

	m_piCommanderUnits = new int[m_iNumCommanderUnits];

	for (iI = 0; iI < m_iNumCommanderUnits; iI++)
	{
		m_piCommanderUnits[iI] = GC.getInfoTypeForString(aszCommanderUnits[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "GroupPromotions"))
	{
		pXML->SetStringWithChildList(&m_iNumGroupPromotions, &aszGroupPromotions);
	}

	m_piGroupPromotions = new int[m_iNumGroupPromotions];

	for (iI = 0; iI < m_iNumGroupPromotions; iI++)
	{
		m_piGroupPromotions[iI] = GC.getInfoTypeForString(aszGroupPromotions[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommanderPromotions"))
	{
		pXML->SetStringWithChildList(&m_iNumCommanderPromotions, &aszCommanderPromotions);
	}

	m_piCommanderPromotions = new int[m_iNumCommanderPromotions];

	for (iI = 0; iI < m_iNumCommanderPromotions; iI++)
	{
		m_piCommanderPromotions[iI] = GC.getInfoTypeForString(aszCommanderPromotions[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "SpawnTerrains"))
	{
		pXML->SetStringWithChildList(&m_iNumSpawnTerrains, &aszSpawnTerrains);
	}

	m_piSpawnTerrains = new int[m_iNumSpawnTerrains];

	for (iI = 0; iI < m_iNumSpawnTerrains; iI++)
	{
		m_piSpawnTerrains[iI] = GC.getInfoTypeForString(aszSpawnTerrains[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "SpawnFeatures"))
	{
		pXML->SetStringWithChildList(&m_iNumSpawnFeatures, &aszSpawnFeatures);
	}

	m_piSpawnFeatures = new int[m_iNumSpawnFeatures];

	for (iI = 0; iI < m_iNumSpawnFeatures; iI++)
	{
		m_piSpawnFeatures[iI] = GC.getInfoTypeForString(aszSpawnFeatures[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqTechANDs"))
	{
		pXML->SetStringWithChildList(&m_iNumPrereqTechANDs, &aszPrereqTechANDs);
	}

	m_piPrereqTechANDs = new int[m_iNumPrereqTechANDs];

	for (iI = 0; iI < m_iNumPrereqTechANDs; iI++)
	{
		m_piPrereqTechANDs[iI] = GC.getInfoTypeForString(aszPrereqTechANDs[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqTechORs"))
	{
		pXML->SetStringWithChildList(&m_iNumPrereqTechORs, &aszPrereqTechORs);
	}

	m_piPrereqTechORs = new int[m_iNumPrereqTechORs];

	for (iI = 0; iI < m_iNumPrereqTechORs; iI++)
	{
		m_piPrereqTechORs[iI] = GC.getInfoTypeForString(aszPrereqTechORs[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BlockTechANDs"))
	{
		pXML->SetStringWithChildList(&m_iNumBlockTechANDs, &aszBlockTechANDs);
	}

	m_piBlockTechANDs = new int[m_iNumBlockTechANDs];

	for (iI = 0; iI < m_iNumBlockTechANDs; iI++)
	{
		m_piBlockTechANDs[iI] = GC.getInfoTypeForString(aszBlockTechANDs[iI]);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BlockTechORs"))
	{
		pXML->SetStringWithChildList(&m_iNumBlockTechORs, &aszBlockTechORs);
	}

	m_piBlockTechORs = new int[m_iNumBlockTechORs];

	for (iI = 0; iI < m_iNumBlockTechORs; iI++)
	{
		m_piBlockTechORs[iI] = GC.getInfoTypeForString(aszBlockTechORs[iI]);
	}


	pXML->GetChildXmlValByName(m_szPyOnSpawn, "PyOnSpawn");
	pXML->GetChildXmlValByName(m_szPyRequirement, "PyRequirement");
	pXML->GetChildXmlValByName(m_szBanner, "Banner");

	return true;
}

void CvSpawnGroupInfo::copyNonDefaults(CvSpawnGroupInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if(isUnique()					== false)				m_bUnique					= pClassInfo->isUnique();
	if(isAlwaysSpawn()				== false)				m_bAlwaysSpawn				= pClassInfo->isAlwaysSpawn();
	if(isNeverSpawn()				== false)				m_bNeverSpawn				= pClassInfo->isNeverSpawn();
	if(isNaval()					== false)				m_bNaval					= pClassInfo->isNaval();
	if(getPrereqMinTurn()			== 0)					m_iPrereqMinTurn			= pClassInfo->getPrereqMinTurn();
	if(getPrereqMaxTurn()			== 0)					m_iPrereqMaxTurn			= pClassInfo->getPrereqMaxTurn();
	if(getPrereqMinAC()				== 0)					m_iPrereqMinAC				= pClassInfo->getPrereqMinAC();
	if(getPrereqMaxAC()				== 0)					m_iPrereqMaxAC				= pClassInfo->getPrereqMaxAC();
	if(getPrereqProject()			== NO_PROJECT)			m_iPrereqProject			= pClassInfo->getPrereqProject();
	if(getWeight()					== 0)					m_iWeight					= pClassInfo->getWeight();
	if(getPyOnSpawn()				== NULL)				m_szPyOnSpawn				= pClassInfo->getPyOnSpawn();
	if(getPyRequirement()			== NULL)				m_szPyRequirement			= pClassInfo->getPyRequirement();
	if(getBanner()					== NULL)				m_szBanner					= pClassInfo->getBanner();

	for ( int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		if(getGroupUnits(i)			== false)				m_piGroupUnits[i]			= pClassInfo->getGroupUnits(i);
	}
	for ( int i = 0; i < GC.getNumUnitClassInfos(); i++)
	{
		if(getGroupUnitClasses(i)	== false)				m_piGroupUnitClasses[i]		= pClassInfo->getGroupUnitClasses(i);
	}

	if(pClassInfo->getNumCommanderUnits() > 0)
	{
		int* tempArray = new int[getNumCommanderUnits() + pClassInfo->getNumCommanderUnits()];
		for(int i = 0; i< getNumCommanderUnits(); ++i)
		{
			tempArray[i] = getCommanderUnits(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumCommanderUnits(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumCommanderUnits();++j)
			{
				if(pClassInfo->getCommanderUnits(i) == getCommanderUnits(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumCommanderUnits()] = pClassInfo->getCommanderUnits(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piCommanderUnits);
		int iGoalSize = getNumCommanderUnits() + iNewItems;
		m_piCommanderUnits = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piCommanderUnits[i] = tempArray[i];
			FAssertMsg(m_piCommanderUnits[i] < GC.getNumUnitInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piCommanderUnits[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumCommanderUnits = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumGroupPromotions() > 0)
	{
		int* tempArray = new int[getNumGroupPromotions() + pClassInfo->getNumGroupPromotions()];
		for(int i = 0; i< getNumGroupPromotions(); ++i)
		{
			tempArray[i] = getGroupPromotions(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumGroupPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumGroupPromotions();++j)
			{
				if(pClassInfo->getGroupPromotions(i) == getGroupPromotions(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumGroupPromotions()] = pClassInfo->getGroupPromotions(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piGroupPromotions);
		int iGoalSize = getNumGroupPromotions() + iNewItems;
		m_piGroupPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piGroupPromotions[i] = tempArray[i];
			FAssertMsg(m_piGroupPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piGroupPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumGroupPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumCommanderPromotions() > 0)
	{
		int* tempArray = new int[getNumCommanderPromotions() + pClassInfo->getNumCommanderPromotions()];
		for(int i = 0; i< getNumCommanderPromotions(); ++i)
		{
			tempArray[i] = getCommanderPromotions(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumCommanderPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumCommanderPromotions();++j)
			{
				if(pClassInfo->getCommanderPromotions(i) == getCommanderPromotions(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumCommanderPromotions()] = pClassInfo->getCommanderPromotions(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piCommanderPromotions);
		int iGoalSize = getNumCommanderPromotions() + iNewItems;
		m_piCommanderPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piCommanderPromotions[i] = tempArray[i];
			FAssertMsg(m_piCommanderPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piCommanderPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumCommanderPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumSpawnTerrains() > 0)
	{
		int* tempArray = new int[getNumSpawnTerrains() + pClassInfo->getNumSpawnTerrains()];
		for(int i = 0; i< getNumSpawnTerrains(); ++i)
		{
			tempArray[i] = getSpawnTerrains(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumSpawnTerrains(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumSpawnTerrains();++j)
			{
				if(pClassInfo->getSpawnTerrains(i) == getSpawnTerrains(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumSpawnTerrains()] = pClassInfo->getSpawnTerrains(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piSpawnTerrains);
		int iGoalSize = getNumSpawnTerrains() + iNewItems;
		m_piSpawnTerrains = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piSpawnTerrains[i] = tempArray[i];
			FAssertMsg(m_piSpawnTerrains[i] < GC.getNumTerrainInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piSpawnTerrains[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumSpawnTerrains = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumSpawnFeatures() > 0)
	{
		int* tempArray = new int[getNumSpawnFeatures() + pClassInfo->getNumSpawnFeatures()];
		for(int i = 0; i< getNumSpawnFeatures(); ++i)
		{
			tempArray[i] = getSpawnFeatures(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumSpawnFeatures(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumSpawnFeatures();++j)
			{
				if(pClassInfo->getSpawnFeatures(i) == getSpawnFeatures(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumSpawnFeatures()] = pClassInfo->getSpawnFeatures(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piSpawnFeatures);
		int iGoalSize = getNumSpawnFeatures() + iNewItems;
		m_piSpawnFeatures = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piSpawnFeatures[i] = tempArray[i];
			FAssertMsg(m_piSpawnFeatures[i] < GC.getNumFeatureInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piSpawnFeatures[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumSpawnFeatures = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqTechANDs() > 0)
	{
		int* tempArray = new int[getNumPrereqTechANDs() + pClassInfo->getNumPrereqTechANDs()];
		for(int i = 0; i< getNumPrereqTechANDs(); ++i)
		{
			tempArray[i] = getPrereqTechANDs(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqTechANDs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqTechANDs();++j)
			{
				if(pClassInfo->getPrereqTechANDs(i) == getPrereqTechANDs(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqTechANDs()] = pClassInfo->getPrereqTechANDs(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqTechANDs);
		int iGoalSize = getNumPrereqTechANDs() + iNewItems;
		m_piPrereqTechANDs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqTechANDs[i] = tempArray[i];
			FAssertMsg(m_piPrereqTechANDs[i] < GC.getNumTechInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqTechANDs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqTechANDs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPrereqTechORs() > 0)
	{
		int* tempArray = new int[getNumPrereqTechORs() + pClassInfo->getNumPrereqTechORs()];
		for(int i = 0; i< getNumPrereqTechORs(); ++i)
		{
			tempArray[i] = getPrereqTechORs(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPrereqTechORs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPrereqTechORs();++j)
			{
				if(pClassInfo->getPrereqTechORs(i) == getPrereqTechORs(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPrereqTechORs()] = pClassInfo->getPrereqTechORs(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqTechORs);
		int iGoalSize = getNumPrereqTechORs() + iNewItems;
		m_piPrereqTechORs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqTechORs[i] = tempArray[i];
			FAssertMsg(m_piPrereqTechORs[i] < GC.getNumTechInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqTechORs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPrereqTechORs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumBlockTechANDs() > 0)
	{
		int* tempArray = new int[getNumBlockTechANDs() + pClassInfo->getNumBlockTechANDs()];
		for(int i = 0; i< getNumBlockTechANDs(); ++i)
		{
			tempArray[i] = getBlockTechANDs(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumBlockTechANDs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumBlockTechANDs();++j)
			{
				if(pClassInfo->getBlockTechANDs(i) == getBlockTechANDs(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumBlockTechANDs()] = pClassInfo->getBlockTechANDs(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piBlockTechANDs);
		int iGoalSize = getNumBlockTechANDs() + iNewItems;
		m_piBlockTechANDs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piBlockTechANDs[i] = tempArray[i];
			FAssertMsg(m_piBlockTechANDs[i] < GC.getNumTechInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piBlockTechANDs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumBlockTechANDs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumBlockTechORs() > 0)
	{
		int* tempArray = new int[getNumBlockTechORs() + pClassInfo->getNumBlockTechORs()];
		for(int i = 0; i< getNumBlockTechORs(); ++i)
		{
			tempArray[i] = getBlockTechORs(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumBlockTechORs(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumBlockTechORs();++j)
			{
				if(pClassInfo->getBlockTechORs(i) == getBlockTechORs(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumBlockTechORs()] = pClassInfo->getBlockTechORs(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piBlockTechORs);
		int iGoalSize = getNumBlockTechORs() + iNewItems;
		m_piBlockTechORs = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piBlockTechORs[i] = tempArray[i];
			FAssertMsg(m_piBlockTechORs[i] < GC.getNumTechInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piBlockTechORs[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumBlockTechORs = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}
/*************************************************************************************************/
/**	Spawn Groups							END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
CvAffinityInfo::CvAffinityInfo() :
m_bNumCitiesEffect(false),
m_bCapitalPopEffect(false),
m_bPopulationEffect(false),
m_bVassalEffect(false),

m_fStrength(0.0f),
m_fStrengthMod(0.0f),
m_fAttackStrength(0.0f),
m_fAttackStrengthMod(0.0f),
m_fDefenseStrength(0.0f),
m_fDefenseStrengthMod(0.0f),
m_fMovement(0.0f),
m_fMovementDiscount(0.0f),
m_fVisibility(0.0f),
m_fPerception(0.0f),
m_fRangedStrength(0.0f),
m_fRangedStrengthMod(0.0f),
m_fRange(0.0f),
m_fRangedLimit(0.0f),
m_fFirstStrikes(0.0f),
m_fFirstStrikeChance(0.0f),
m_fAntiFirstStrikes(0.0f),
m_fDefensiveStrikes(0.0f),
m_fAntiDefensiveStrikes(0.0f),
m_fCapacity(0.0f),
m_fWillpower(0.0f),
m_fWithdrawal(0.0f),
m_fAntiWithdrawal(0.0f),
m_fHealRate(0.0f),
m_fXPFromCombat(0.0f),
m_fXPRate(0.0f),
m_fCommandRange(0.0f),
m_fCommandLimit(0.0f),
m_fWorkRate(0.0f),
m_fCollateral(0.0f),
m_fCollateralLimit(0.0f),
m_fCollateralTargets(0.0f),
m_fVictoryInfluenceModifier(0.0f),
m_fDefeatInfluenceModifier(0.0f),
m_fPillageInfluenceModifier(0.0f),
m_fSlaveChance(0.0f),
m_fCombatHealPercent(0.0f),
m_fEnemyHealChange(0.0f),
m_fNeutralHealChange(0.0f),
m_fFriendlyHealChange(0.0f),

m_iNumBonusTypes(0),
m_piBonusTypes(NULL),
m_iNumAffinityPromotions(0),
m_piAffinityPromotions(NULL),

m_pafDamageTypeCombats(NULL),
m_pafDamageTypeResists(NULL)
{
}

CvAffinityInfo::~CvAffinityInfo()
{
	SAFE_DELETE_ARRAY(m_piBonusTypes);
	SAFE_DELETE_ARRAY(m_piAffinityPromotions);
	SAFE_DELETE_ARRAY(m_pafDamageTypeCombats);
	SAFE_DELETE_ARRAY(m_pafDamageTypeResists);
}

bool CvAffinityInfo::isNumCitiesEffect() const							{return m_bNumCitiesEffect;}
bool CvAffinityInfo::isCapitalPopEffect() const							{return m_bCapitalPopEffect;}
bool CvAffinityInfo::isPopulationEffect() const							{return m_bPopulationEffect;}
bool CvAffinityInfo::isVassalEffect() const								{return m_bVassalEffect;}

float CvAffinityInfo::getStrength() const								{return m_fStrength;}
float CvAffinityInfo::getStrengthMod() const							{return m_fStrengthMod;}
float CvAffinityInfo::getAttackStrength() const							{return m_fAttackStrength;}
float CvAffinityInfo::getAttackStrengthMod() const						{return m_fAttackStrengthMod;}
float CvAffinityInfo::getDefenseStrength() const						{return m_fDefenseStrength;}
float CvAffinityInfo::getDefenseStrengthMod() const						{return m_fDefenseStrengthMod;}
float CvAffinityInfo::getMovement() const								{return m_fMovement;}
float CvAffinityInfo::getMovementDiscount() const						{return m_fMovementDiscount;}
float CvAffinityInfo::getVisibility() const								{return m_fVisibility;}
float CvAffinityInfo::getPerception() const								{return m_fPerception;}
float CvAffinityInfo::getRangedStrength() const							{return m_fRangedStrength;}
float CvAffinityInfo::getRangedStrengthMod() const						{return m_fRangedStrengthMod;}
float CvAffinityInfo::getRange() const									{return m_fRange;}
float CvAffinityInfo::getRangedLimit() const							{return m_fRangedLimit;}
float CvAffinityInfo::getFirstStrikes() const							{return m_fFirstStrikes;}
float CvAffinityInfo::getFirstStrikeChance() const						{return m_fFirstStrikeChance;}
float CvAffinityInfo::getAntiFirstStrikes() const						{return m_fAntiFirstStrikes;}
float CvAffinityInfo::getDefensiveStrikes() const						{return m_fDefensiveStrikes;}
float CvAffinityInfo::getAntiDefensiveStrikes() const					{return m_fAntiDefensiveStrikes;}
float CvAffinityInfo::getCapacity() const								{return m_fCapacity;}
float CvAffinityInfo::getWillpower() const								{return m_fWillpower;}
float CvAffinityInfo::getWithdrawal() const								{return m_fWithdrawal;}
float CvAffinityInfo::getAntiWithdrawal() const							{return m_fAntiWithdrawal;}
float CvAffinityInfo::getHealRate() const								{return m_fHealRate;}
float CvAffinityInfo::getXPFromCombat() const							{return m_fXPFromCombat;}
float CvAffinityInfo::getXPRate() const									{return m_fXPRate;}
float CvAffinityInfo::getCommandRange() const							{return m_fCommandRange;}
float CvAffinityInfo::getCommandLimit() const							{return m_fCommandLimit;}
float CvAffinityInfo::getWorkRate() const								{return m_fWorkRate;}
float CvAffinityInfo::getCollateral() const								{return m_fCollateral;}
float CvAffinityInfo::getCollateralLimit() const						{return m_fCollateralLimit;}
float CvAffinityInfo::getCollateralTargets() const						{return m_fCollateralTargets;}
float CvAffinityInfo::getVictoryInfluenceModifier() const				{return m_fVictoryInfluenceModifier;}
float CvAffinityInfo::getDefeatInfluenceModifier() const				{return m_fDefeatInfluenceModifier;}
float CvAffinityInfo::getPillageInfluenceModifier() const				{return m_fPillageInfluenceModifier;}
float CvAffinityInfo::getSlaveChance() const							{return m_fSlaveChance;}
float CvAffinityInfo::getCombatHealPercent() const						{return m_fCombatHealPercent;}
float CvAffinityInfo::getEnemyHealChange() const						{return m_fEnemyHealChange;}
float CvAffinityInfo::getNeutralHealChange() const						{return m_fNeutralHealChange;}
float CvAffinityInfo::getFriendlyHealChange() const						{return m_fFriendlyHealChange;}

int CvAffinityInfo::getBonusTypes(int iI) const							{return (getNumBonusTypes() > iI) ? m_piBonusTypes[iI] : -1;}
int CvAffinityInfo::getNumBonusTypes() const							{return m_iNumBonusTypes;}
int CvAffinityInfo::getAffinityPromotions(int iI) const					{return (getNumAffinityPromotions() > iI) ? m_piAffinityPromotions[iI] : -1;}
int CvAffinityInfo::getNumAffinityPromotions() const					{return m_iNumAffinityPromotions;}

float CvAffinityInfo::getDamageTypeCombats(int iI) const				{return m_pafDamageTypeCombats[iI];}
float CvAffinityInfo::getDamageTypeResists(int iI) const				{return m_pafDamageTypeResists[iI];}

bool CvAffinityInfo::read(CvXMLLoadUtility* pXML)
{
	int iI;
	CvString szTextVal;
	std::vector<CvString> aszBonusTypes;
	std::vector<CvString> aszAffinityPromotions;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bNumCitiesEffect, "bNumCitiesEffect");
	pXML->GetChildXmlValByName(&m_bCapitalPopEffect, "bCapitalPopEffect");
	pXML->GetChildXmlValByName(&m_bPopulationEffect, "bPopulationEffect");
	pXML->GetChildXmlValByName(&m_bVassalEffect, "bVassalEffect");

	pXML->GetChildXmlValByName(&m_fStrength, "fStrength");
	pXML->GetChildXmlValByName(&m_fStrengthMod, "fStrengthMod");
	pXML->GetChildXmlValByName(&m_fAttackStrength, "fAttackStrength");
	pXML->GetChildXmlValByName(&m_fAttackStrengthMod, "fAttackStrengthMod");
	pXML->GetChildXmlValByName(&m_fDefenseStrength, "fDefenseStrength");
	pXML->GetChildXmlValByName(&m_fDefenseStrengthMod, "fDefenseStrengthMod");
	pXML->GetChildXmlValByName(&m_fMovement, "fMovement");
	pXML->GetChildXmlValByName(&m_fMovementDiscount, "fMovementDiscount");
	pXML->GetChildXmlValByName(&m_fVisibility, "fVisibility");
	pXML->GetChildXmlValByName(&m_fPerception, "fPerception");
	pXML->GetChildXmlValByName(&m_fRangedStrength, "fRangedStrength");
	pXML->GetChildXmlValByName(&m_fRangedStrengthMod, "fRangedStrengthMod");
	pXML->GetChildXmlValByName(&m_fRange, "fRange");
	pXML->GetChildXmlValByName(&m_fRangedLimit, "fRangedLimit");
	pXML->GetChildXmlValByName(&m_fFirstStrikes, "fFirstStrikes");
	pXML->GetChildXmlValByName(&m_fFirstStrikeChance, "fFirstStrikeChance");
	pXML->GetChildXmlValByName(&m_fAntiFirstStrikes, "fAntiFirstStrikes");
	pXML->GetChildXmlValByName(&m_fDefensiveStrikes, "fDefensiveStrikes");
	pXML->GetChildXmlValByName(&m_fAntiDefensiveStrikes, "fAntiDefensiveStrikes");
	pXML->GetChildXmlValByName(&m_fCapacity, "fCapacity");
	pXML->GetChildXmlValByName(&m_fWillpower, "fWillpower");
	pXML->GetChildXmlValByName(&m_fWithdrawal, "fWithdrawal");
	pXML->GetChildXmlValByName(&m_fAntiWithdrawal, "fAntiWithdrawal");
	pXML->GetChildXmlValByName(&m_fHealRate, "fHealRate");
	pXML->GetChildXmlValByName(&m_fXPFromCombat, "fXPFromCombat");
	pXML->GetChildXmlValByName(&m_fXPRate, "fXPRate");
	pXML->GetChildXmlValByName(&m_fCommandRange, "fCommandRange");
	pXML->GetChildXmlValByName(&m_fCommandLimit, "fCommandLimit");
	pXML->GetChildXmlValByName(&m_fWorkRate, "fWorkRate");
	pXML->GetChildXmlValByName(&m_fCollateral, "fCollateral");
	pXML->GetChildXmlValByName(&m_fCollateralLimit, "fCollateralLimit");
	pXML->GetChildXmlValByName(&m_fCollateralTargets, "fCollateralTargets");
	pXML->GetChildXmlValByName(&m_fVictoryInfluenceModifier, "fVictoryInfluenceModifier");
	pXML->GetChildXmlValByName(&m_fDefeatInfluenceModifier, "fDefeatInfluenceModifier");
	pXML->GetChildXmlValByName(&m_fPillageInfluenceModifier, "fPillageInfluenceModifier");
	pXML->GetChildXmlValByName(&m_fSlaveChance, "fSlaveChance");
	pXML->GetChildXmlValByName(&m_fCombatHealPercent, "fCombatHealPercent");
	pXML->GetChildXmlValByName(&m_fEnemyHealChange, "fEnemyHealChange");
	pXML->GetChildXmlValByName(&m_fNeutralHealChange, "fNeutralHealChange");
	pXML->GetChildXmlValByName(&m_fFriendlyHealChange, "fFriendlyHealChange");

	pXML->SetVariableListTagPair(&m_pafDamageTypeCombats, "AffinityDamageTypes", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
	pXML->SetVariableListTagPair(&m_pafDamageTypeResists, "AffinityDamageResists", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "BonusTypes"))
	{
		pXML->SetStringWithChildList(&m_iNumBonusTypes, &aszBonusTypes);
	}

	m_piBonusTypes = new int[m_iNumBonusTypes];

	for (iI = 0; iI < m_iNumBonusTypes; iI++)
	{
		m_piBonusTypes[iI] = GC.getInfoTypeForString(aszBonusTypes[iI]);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "AffinityPromotions"))
	{
		pXML->SetStringWithChildList(&m_iNumAffinityPromotions, &aszAffinityPromotions);
	}

	m_piAffinityPromotions = new int[m_iNumAffinityPromotions];

	for (iI = 0; iI < m_iNumAffinityPromotions; iI++)
	{
		m_piAffinityPromotions[iI] = GC.getInfoTypeForString(aszAffinityPromotions[iI]);
	}

	return true;
}

void CvAffinityInfo::copyNonDefaults(CvAffinityInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if(isNumCitiesEffect()				== false)				m_bNumCitiesEffect				= pClassInfo->isNumCitiesEffect();
	if(isCapitalPopEffect()				== false)				m_bCapitalPopEffect				= pClassInfo->isCapitalPopEffect();
	if(isPopulationEffect()				== false)				m_bPopulationEffect				= pClassInfo->isPopulationEffect();
	if(isVassalEffect()					== false)				m_bVassalEffect					= pClassInfo->isVassalEffect();

	if(getStrength()					== 0.0f)				m_fStrength						= pClassInfo->getStrength();
	if(getStrengthMod()					== 0.0f)				m_fStrengthMod					= pClassInfo->getStrengthMod();
	if(getAttackStrength()				== 0.0f)				m_fAttackStrength				= pClassInfo->getAttackStrength();
	if(getAttackStrengthMod()			== 0.0f)				m_fAttackStrengthMod			= pClassInfo->getAttackStrengthMod();
	if(getDefenseStrength()				== 0.0f)				m_fDefenseStrength				= pClassInfo->getDefenseStrength();
	if(getDefenseStrengthMod()			== 0.0f)				m_fDefenseStrengthMod			= pClassInfo->getDefenseStrengthMod();
	if(getMovement()					== 0.0f)				m_fMovement						= pClassInfo->getMovement();
	if(getMovementDiscount()			== 0.0f)				m_fMovementDiscount				= pClassInfo->getMovementDiscount();
	if(getVisibility()					== 0.0f)				m_fVisibility					= pClassInfo->getVisibility();
	if(getPerception()					== 0.0f)				m_fPerception					= pClassInfo->getPerception();
	if(getRangedStrength()				== 0.0f)				m_fRangedStrength				= pClassInfo->getRangedStrength();
	if(getRangedStrengthMod()			== 0.0f)				m_fRangedStrengthMod			= pClassInfo->getRangedStrengthMod();
	if(getRange()						== 0.0f)				m_fRange						= pClassInfo->getRange();
	if(getRangedLimit()					== 0.0f)				m_fRangedLimit					= pClassInfo->getRangedLimit();
	if(getFirstStrikes()				== 0.0f)				m_fFirstStrikes					= pClassInfo->getFirstStrikes();
	if(getFirstStrikeChance()			== 0.0f)				m_fFirstStrikeChance			= pClassInfo->getFirstStrikeChance();
	if(getAntiFirstStrikes()			== 0.0f)				m_fAntiFirstStrikes				= pClassInfo->getAntiFirstStrikes();
	if(getDefensiveStrikes()			== 0.0f)				m_fDefensiveStrikes				= pClassInfo->getDefensiveStrikes();
	if(getAntiDefensiveStrikes()		== 0.0f)				m_fAntiDefensiveStrikes			= pClassInfo->getAntiDefensiveStrikes();
	if(getCapacity()					== 0.0f)				m_fCapacity						= pClassInfo->getCapacity();
	if(getWillpower()					== 0.0f)				m_fWillpower					= pClassInfo->getWillpower();
	if(getWithdrawal()					== 0.0f)				m_fWithdrawal					= pClassInfo->getWithdrawal();
	if(getAntiWithdrawal()				== 0.0f)				m_fAntiWithdrawal				= pClassInfo->getAntiWithdrawal();
	if(getHealRate()					== 0.0f)				m_fHealRate						= pClassInfo->getHealRate();
	if(getXPFromCombat()				== 0.0f)				m_fXPFromCombat					= pClassInfo->getXPFromCombat();
	if(getXPRate()						== 0.0f)				m_fXPRate						= pClassInfo->getXPRate();
	if(getCommandRange()				== 0.0f)				m_fCommandRange					= pClassInfo->getCommandRange();
	if(getCommandLimit()				== 0.0f)				m_fCommandLimit					= pClassInfo->getCommandLimit();
	if(getWorkRate()					== 0.0f)				m_fWorkRate						= pClassInfo->getWorkRate();
	if(getCollateral()					== 0.0f)				m_fCollateral					= pClassInfo->getCollateral();
	if(getCollateralLimit()				== 0.0f)				m_fCollateralLimit				= pClassInfo->getCollateralLimit();
	if(getCollateralTargets()			== 0.0f)				m_fCollateralTargets			= pClassInfo->getCollateralTargets();
	if(getVictoryInfluenceModifier()	== 0.0f)				m_fVictoryInfluenceModifier		= pClassInfo->getVictoryInfluenceModifier();
	if(getDefeatInfluenceModifier()		== 0.0f)				m_fDefeatInfluenceModifier		= pClassInfo->getDefeatInfluenceModifier();
	if(getPillageInfluenceModifier()	== 0.0f)				m_fPillageInfluenceModifier		= pClassInfo->getPillageInfluenceModifier();
	if(getSlaveChance()					== 0.0f)				m_fSlaveChance					= pClassInfo->getSlaveChance();
	if(getCombatHealPercent()			== 0.0f)				m_fCombatHealPercent			= pClassInfo->getCombatHealPercent();
	if(getEnemyHealChange()				== 0.0f)				m_fEnemyHealChange				= pClassInfo->getEnemyHealChange();
	if(getNeutralHealChange()			== 0.0f)				m_fNeutralHealChange			= pClassInfo->getNeutralHealChange();
	if(getFriendlyHealChange()			== 0.0f)				m_fFriendlyHealChange			= pClassInfo->getFriendlyHealChange();

	for (int j = 0; j < GC.getNumDamageTypeInfos(); j++)
	{
		if (getDamageTypeCombats(j)		== 0.0f)				m_pafDamageTypeCombats[j]		= pClassInfo->getDamageTypeCombats(j);
		if (getDamageTypeResists(j)		== 0.0f)				m_pafDamageTypeResists[j]		= pClassInfo->getDamageTypeResists(j);
	}

	if(pClassInfo->getNumBonusTypes() > 0)
	{
		int* tempArray = new int[getNumBonusTypes() + pClassInfo->getNumBonusTypes()];
		for(int i = 0; i< getNumBonusTypes(); ++i)
		{
			tempArray[i] = getBonusTypes(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumBonusTypes(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumBonusTypes();++j)
			{
				if(pClassInfo->getBonusTypes(i) == getBonusTypes(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumBonusTypes()] = pClassInfo->getBonusTypes(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piBonusTypes);
		int iGoalSize = getNumBonusTypes() + iNewItems;
		m_piBonusTypes = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piBonusTypes[i] = tempArray[i];
			FAssertMsg(m_piBonusTypes[i] < GC.getNumBonusInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piBonusTypes[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumBonusTypes = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumAffinityPromotions() > 0)
	{
		int* tempArray = new int[getNumAffinityPromotions() + pClassInfo->getNumAffinityPromotions()];
		for(int i = 0; i< getNumAffinityPromotions(); ++i)
		{
			tempArray[i] = getAffinityPromotions(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumAffinityPromotions(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumAffinityPromotions();++j)
			{
				if(pClassInfo->getAffinityPromotions(i) == getAffinityPromotions(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumAffinityPromotions()] = pClassInfo->getAffinityPromotions(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piAffinityPromotions);
		int iGoalSize = getNumAffinityPromotions() + iNewItems;
		m_piAffinityPromotions = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piAffinityPromotions[i] = tempArray[i];
			FAssertMsg(m_piAffinityPromotions[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piAffinityPromotions[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumAffinityPromotions = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/

//FlavourMod: Addded by Jean Elcard (ClimateSystem)
CvClimateZoneInfo::CvClimateZoneInfo() :
m_bOceanicClimate(false),
m_iMinTemperature(MIN_INT),
m_iMaxTemperature(MAX_INT),
m_iMinHumidity(MIN_INT),
m_iMaxHumidity(MAX_INT),
m_iTerrainClass(NO_TERRAINCLASS)
{
}

CvClimateZoneInfo::~CvClimateZoneInfo()
{
}

bool CvClimateZoneInfo::isOceanicClimate() const
{
	return m_bOceanicClimate;
}

int CvClimateZoneInfo::getMinTemperature() const
{
	return m_iMinTemperature;
}

int CvClimateZoneInfo::getMaxTemperature() const
{
	return m_iMaxTemperature;
}

int CvClimateZoneInfo::getMinHumidity() const
{
	return m_iMinHumidity;
}

int CvClimateZoneInfo::getMaxHumidity() const
{
	return m_iMaxHumidity;
}

int CvClimateZoneInfo::getTerrainClass() const
{
	return m_iTerrainClass;
}

bool CvClimateZoneInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvString szTextVal;

	pXML->GetChildXmlValByName(&m_bOceanicClimate, "bOceanicClimate", false);

	pXML->GetChildXmlValByName(&m_iMinTemperature, "iMinTemperature", MIN_INT);
	pXML->GetChildXmlValByName(&m_iMaxTemperature, "iMaxTemperature", MAX_INT);
	pXML->GetChildXmlValByName(&m_iMinHumidity, "iMinHumidity", MIN_INT);
	pXML->GetChildXmlValByName(&m_iMaxHumidity, "iMaxHumidity", MAX_INT);

	pXML->GetChildXmlValByName(szTextVal, "TerrainClass");
	m_iTerrainClass = pXML->FindInInfoClass(szTextVal);

	return true;
}
// FlavourMod: End Add

// FlagSystem Start
//======================================================================================================
//					CvFlagInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvFlagInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvFlagInfo::CvFlagInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvFlagInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvFlagInfo::~CvFlagInfo()
{
}

bool CvFlagInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	return true;
}

// ModuleId Start
//======================================================================================================
//					CvModuleIdInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvModuleIdInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvModuleIdInfo::CvModuleIdInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvModuleIdInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvModuleIdInfo::~CvModuleIdInfo()
{
}

bool CvModuleIdInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	return true;
}

// PlotEffect Start
//======================================================================================================
//					CvPlotEffectInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvPlotEffectInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvPlotEffectInfo::CvPlotEffectInfo() :
	m_iDefaultFeatureGraphics(NO_FEATURE),
	m_iTurnDamage(0),
	m_iDamageLimit(0),
	m_bDispellable(false),
	m_iPerceptionCost(0),
	m_iSeeThroughChange(0),
	m_iDamageType(NO_DAMAGE),
	m_iMaxPlotCounter(-1),
	m_iSpawnChance(0),
	m_iSpreadChance(0),
	m_iDisappearChance(0),
	m_iMoveChance(0),
	m_piYieldChange(NULL),
	m_pbTerrain(NULL)
{}



//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvPlotEffectInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvPlotEffectInfo::~CvPlotEffectInfo()
{

	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_pbTerrain);
}

const int CvPlotEffectInfo::getDefaultFeatureGraphics() const
{
	return m_iDefaultFeatureGraphics;
}
const int CvPlotEffectInfo::getTurnDamage() const
{
	return m_iTurnDamage;
}
const bool CvPlotEffectInfo::isDispellable() const
{
	return m_bDispellable;
}
const int CvPlotEffectInfo::getDamageLimit() const
{
	return m_iDamageLimit;
}
const int CvPlotEffectInfo::getPerceptionCost() const
{
	return m_iPerceptionCost;
}
const int CvPlotEffectInfo::getSeeThroughChange() const
{
	return m_iSeeThroughChange;
}
const int CvPlotEffectInfo::getMaxPlotCounter() const
{
	return m_iMaxPlotCounter;
}
const int CvPlotEffectInfo::getSpawnChance() const
{
	return m_iSpawnChance;
}
const int CvPlotEffectInfo::getSpreadChance() const
{
	return m_iSpreadChance;
}
const int CvPlotEffectInfo::getDisappearChance() const
{
	return m_iDisappearChance;
}
const int CvPlotEffectInfo::getMoveChance() const
{
	return m_iMoveChance;
}
const int CvPlotEffectInfo::getDamageType() const
{
	return m_iDamageType;
}
const TCHAR* CvPlotEffectInfo::getPythonOnMove() const
{
	return m_szPythonOnMove;
}
const TCHAR* CvPlotEffectInfo::getPythonPerTurn() const
{
	return m_szPythonPerTurn;
}
bool CvPlotEffectInfo::isTerrain(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrain ? m_pbTerrain[i] : false;
}
int CvPlotEffectInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

const int* CvPlotEffectInfo::getYieldChangeArray() const
{
	return m_piYieldChange;
}

bool CvPlotEffectInfo::read(CvXMLLoadUtility* pXML)
{
	char szClassVal[256];					// holds the text value of the relevant classinfo

	CvString szTextVal;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szPythonOnMove, "PythonOnMove");

	pXML->GetChildXmlValByName(m_szPythonPerTurn, "PythonPerTurn");
	
	pXML->GetChildXmlValByName(szTextVal, "DefaultFeatureGraphics");
	// call the find in list function to return either -1 if no value is found
	// or the index in the list the match is found at
	m_iDefaultFeatureGraphics = pXML->FindInInfoClass(szTextVal);
	
	pXML->GetChildXmlValByName(&m_iTurnDamage, "iTurnDamage");
	pXML->GetChildXmlValByName(&m_iMaxPlotCounter, "iMaxPlotCounter",-1);
	pXML->GetChildXmlValByName(&m_iSpawnChance, "iSpawnChance");
	pXML->GetChildXmlValByName(&m_bDispellable, "bDispellable");
	pXML->GetChildXmlValByName(&m_iSpreadChance, "iSpreadChance");
	pXML->GetChildXmlValByName(&m_iDisappearChance, "iDisappearChance");
	pXML->GetChildXmlValByName(&m_iMoveChance, "iMoveChance");
	pXML->GetChildXmlValByName(&m_iDamageLimit, "iDamageLimit");
	pXML->GetChildXmlValByName(&m_iPerceptionCost, "iPerceptionCost");
	pXML->GetChildXmlValByName(&m_iSeeThroughChange, "iSeeThrough");
	pXML->GetChildXmlValByName(szTextVal, "DamageType");
	// call the find in list function to return either -1 if no value is found
	// or the index in the list the match is found at
	m_iDamageType = pXML->FindInInfoClass(szTextVal);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Yields"))
	{
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}
	pXML->SetVariableListTagPair(&m_pbTerrain, "TerrainBooleans", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());

	return true;
}
void CvPlotEffectInfo::copyNonDefaults(CvPlotEffectInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefaultFeatureGraphics() == NO_FEATURE)				m_iDefaultFeatureGraphics = (pClassInfo->getDefaultFeatureGraphics());
	if (getMaxPlotCounter() == -1)				m_iMaxPlotCounter = (pClassInfo->getMaxPlotCounter());
	if (isDispellable() == false)				m_bDispellable = (pClassInfo->isDispellable());
	if (getSpawnChance() == 0)				m_iSpawnChance = (pClassInfo->getSpawnChance());
	if (getSpreadChance() == 0)				m_iSpreadChance = (pClassInfo->getSpreadChance());
	if (getDisappearChance() == 0)				m_iDisappearChance = (pClassInfo->getDisappearChance());
	if (getMoveChance() == 0)				m_iMoveChance = (pClassInfo->getMoveChance());
	if (getTurnDamage() == 0)				m_iTurnDamage = (pClassInfo->getTurnDamage());
	if (getDamageLimit() == 0)				m_iDamageLimit = (pClassInfo->getDamageLimit());
	if (getPerceptionCost() == 0)				m_iPerceptionCost = (pClassInfo->getPerceptionCost());
	if (getSeeThroughChange() == 0)				m_iSeeThroughChange = (pClassInfo->getSeeThroughChange());
	if (getDamageType() == NO_DAMAGE)				m_iDamageType = (pClassInfo->getDamageType());
	if (getPythonOnMove() == cDefault)		m_szPythonOnMove = pClassInfo->getPythonOnMove();
	if (getPythonPerTurn() == cDefault)		m_szPythonPerTurn = pClassInfo->getPythonPerTurn();
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (getYieldChange(i) == 0)					m_piYieldChange[i] = pClassInfo->getYieldChange(i);
	}
	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (m_pbTerrain[i] == false)			m_pbTerrain[i] = pClassInfo->isTerrain(i);
	}

}


//PromotionClass
//======================================================================================================
//					CvPromotionClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvPromotionClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvPromotionClassInfo::CvPromotionClassInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvPromotionClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvPromotionClassInfo::~CvPromotionClassInfo()
{
}

bool CvPromotionClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	return true;
}

//======================================================================================================
//					CvCityClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCityClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCityClassInfo::CvCityClassInfo() :
	m_iArtStyleType(NO_ARTSTYLE),
	m_iUnitArtStyleType(NO_UNIT_ARTSTYLE),
	m_piCityClassBuildings(NULL),
	m_piCityClassUnits(NULL),
	m_pbCityClassFreeBuildingClass(NULL),
	m_iDefaultRace(NO_PROMOTION),
	 m_bLimitedSelection(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCityClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCityClassInfo::~CvCityClassInfo()
{
	SAFE_DELETE_ARRAY(m_piCityClassBuildings);
	SAFE_DELETE_ARRAY(m_piCityClassUnits);
	SAFE_DELETE_ARRAY(m_pbCityClassFreeBuildingClass);
}

void CvCityClassInfo::reset()
{
	CvInfoBase::reset();
}

const TCHAR* CvCityClassInfo::getShortDescription() const
{
	return m_szShortDescription;
}

void CvCityClassInfo::setShortDescription(const TCHAR* szVal)
{
	m_szShortDescription = szVal;
}


int CvCityClassInfo::getArtStyleType() const
{
	return m_iArtStyleType;
}

int CvCityClassInfo::getUnitArtStyleType() const
{
	return m_iUnitArtStyleType;
}

int CvCityClassInfo::getDefaultRace() const
{
	return m_iDefaultRace;
}
int CvCityClassInfo::getCityClassBuildings(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCityClassBuildings ? m_piCityClassBuildings[i] : -1;
}

int CvCityClassInfo::getCityClassUnits(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCityClassUnits ? m_piCityClassUnits[i] : -1;
}

bool CvCityClassInfo::isCityClassFreeBuildingClass(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCityClassFreeBuildingClass ? m_pbCityClassFreeBuildingClass[i] : false;
}
bool CvCityClassInfo::isLimitedSelection() const
{
	return m_bLimitedSelection;
}

void CvCityClassInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag = 0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iArtStyleType);
	stream->Read(&m_iUnitArtStyleType);   // FlavorUnits by Impaler[WrG]
	stream->Read(&m_iDefaultRace);

	SAFE_DELETE_ARRAY(m_piCityClassBuildings);
	m_piCityClassBuildings = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piCityClassBuildings);

	SAFE_DELETE_ARRAY(m_piCityClassUnits);
	m_piCityClassUnits = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piCityClassUnits);

	SAFE_DELETE_ARRAY(m_pbCityClassFreeBuildingClass);
	m_pbCityClassFreeBuildingClass = new bool[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_pbCityClassFreeBuildingClass);

	stream->Read(&m_bLimitedSelection);
}

void CvCityClassInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag = 0;
	stream->Write(m_iArtStyleType);
	stream->Write(m_iUnitArtStyleType);
	stream->Write(m_iDefaultRace);
	stream->Write(GC.getNumBuildingClassInfos(), m_piCityClassBuildings);
	stream->Write(GC.getNumUnitClassInfos(), m_piCityClassUnits);
	stream->Write(GC.getNumBuildingClassInfos(), m_pbCityClassFreeBuildingClass);
	stream->Write(m_bLimitedSelection);
}

bool CvCityClassInfo::read(CvXMLLoadUtility* pXML)
{
	char szClassVal[256];					// holds the text value of the relevant classinfo

	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j, iNumSibs;

	pXML->GetChildXmlValByName(&m_bLimitedSelection, "bLimitedSelection");



	pXML->GetChildXmlValByName(szTextVal, "ArtStyleType");
	m_iArtStyleType = GC.getTypesEnum(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "UnitArtStyleType");
	m_iUnitArtStyleType = pXML->FindInInfoClass(szTextVal);

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Buildings"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default CityClass buildings
			pXML->InitBuildingDefaults(&m_piCityClassBuildings);
			/*************************************************************************************************/
			/**	TrimmingFat								01/12/09								Xienwolf	**/
			/**																								**/
			/**						Blocks all Units not specifically authorized for Civ					**/
			/*************************************************************************************************/
			if (m_bLimitedSelection)
			{
				for (int i = 0; i < GC.getNumBuildingClassInfos(); i++)
				{
					m_piCityClassBuildings[i] = -1;
				}
			}
			/*************************************************************************************************/
			/**	TrimmingFat								END													**/
			/*************************************************************************************************/
						// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ((0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())))
			{
				int iBuildingClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumBuildingClassInfos()), "In SetGlobalCityClassInfo iNumSibs is greater than GC.getNumBuildingClassInfos()");

				// loop through all the siblings
				for (j = 0; j < iNumSibs; j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// get the index into the array based on the building class type
						iBuildingClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iBuildingClassIndex)
						{
							// get the next value which should be the building type to set this CityClass's version of this building class too
							pXML->GetNextXmlVal(szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_piCityClassBuildings[iBuildingClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0, "BuildingClass index is -1 in SetGlobalCityClassInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	/*************************************************************************************************/
	/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
	/**		Quickly adjusted to account for bUnique tag, should work as now written, but untested	**/
	/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
	/*************************************************************************************************/
	else
	{
		pXML->InitBuildingDefaults(&m_piCityClassBuildings);
		if (isLimitedSelection())
		{
			for (j = 0; j < GC.getNumBuildingClassInfos(); j++)
			{
				m_piCityClassBuildings[j] = NO_BUILDING;
			}
		}
	}
	/*************************************************************************************************/
	/**	TrueModular								END													**/
	/*************************************************************************************************/

		// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Units"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default CityClass buildings
			pXML->InitUnitDefaults(&m_piCityClassUnits);
			/*************************************************************************************************/
			/**	TrimmingFat								01/12/09								Xienwolf	**/
			/**																								**/
			/**						Blocks all Units not specifically authorized for Civ					**/
			/*************************************************************************************************/
			if (m_bLimitedSelection)
			{
				for (int i = 0; i < GC.getNumUnitClassInfos(); i++)
				{
					m_piCityClassUnits[i] = -1;
				}
			}
			/*************************************************************************************************/
			/**	TrimmingFat								END													**/
			/*************************************************************************************************/
						// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ((0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())))
			{
				int iUnitClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumUnitClassInfos()), "In SetGlobalCityClassInfo iNumSibs is greater than GC.getNumUnitClassInfos()");

				// loop through all the siblings
				for (j = 0; j < iNumSibs; j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// set the unit class index
						iUnitClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iUnitClassIndex)
						{
							// get the next value which should be the building type to set this CityClass's version of this building class too
							pXML->GetNextXmlVal(szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_piCityClassUnits[iUnitClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0, "UnitClass index is -1 in SetGlobalCityClassInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	/*************************************************************************************************/
	/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
	/**		Quickly adjusted to account for bUnique tag, should work as now written, but untested	**/
	/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
	/*************************************************************************************************/
	else
	{
		pXML->InitUnitDefaults(&m_piCityClassUnits);
		if (isLimitedSelection())
		{
			for (j = 0; j < GC.getNumUnitClassInfos(); j++)
			{
				m_piCityClassUnits[j] = NO_UNIT;
			}
		}
	}
	/*************************************************************************************************/
	/**	TrueModular								END													**/
	/*************************************************************************************************/


	pXML->SetVariableListTagPair(&m_pbCityClassFreeBuildingClass, "FreeBuildingClasses", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

	pXML->GetChildXmlValByName(szTextVal, "DefaultRace");
	m_iDefaultRace = GC.getInfoTypeForString(szTextVal);
	
	pXML->GetChildXmlValByName(szTextVal, "ShortDescription");
	setShortDescription(szTextVal);

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(CityClassInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCityClassInfo::copyNonDefaults(CvCityClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isLimitedSelection() == false)				m_bLimitedSelection = (pClassInfo->isLimitedSelection());
	if (getArtStyleType() == NO_ARTSTYLE)			m_iArtStyleType = (pClassInfo->getArtStyleType());
	if (getDefaultRace() == NO_PROMOTION)		m_iDefaultRace = (pClassInfo->getDefaultRace());
	if (getUnitArtStyleType() == NO_UNIT_ARTSTYLE)	m_iUnitArtStyleType = (pClassInfo->getUnitArtStyleType());
	if (getShortDescription() == cDefault)	setShortDescription(pClassInfo->getShortDescription());
	//NEED A MASSIVE RE-WRITE IN HERE FOR FINDING DEFAULT BUILDINGS
	for (int i = 0; i < GC.getNumBuildingClassInfos(); i++)
	{
		int iDefaultBuilding = (GC.getBuildingClassInfo((BuildingClassTypes)i).isUnique() || isLimitedSelection()) ? -1 : GC.getBuildingClassInfo((BuildingClassTypes)i).getDefaultBuildingIndex();
		if (getCityClassBuildings(i) == iDefaultBuilding)	m_piCityClassBuildings[i] = pClassInfo->getCityClassBuildings(i);
		if (isCityClassFreeBuildingClass(i) == false)				m_pbCityClassFreeBuildingClass[i] = pClassInfo->isCityClassFreeBuildingClass(i);
	}
	for (int i = 0; i < GC.getNumUnitClassInfos(); i++)
	{
		int iDefaultUnit = (GC.getUnitClassInfo((UnitClassTypes)i).isUnique() || isLimitedSelection()) ? -1 : GC.getUnitClassInfo((UnitClassTypes)i).getDefaultUnitIndex();
		if (getCityClassUnits(i) == iDefaultUnit)		m_piCityClassUnits[i] = pClassInfo->getCityClassUnits(i);
	}
}

/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

// DynTraits Start
//======================================================================================================
//					CvTraitClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTraitClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTraitClassInfo::CvTraitClassInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTraitClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTraitClassInfo::~CvTraitClassInfo()
{
}

bool CvTraitClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	return true;
}
// DynTraits Start
//======================================================================================================
//					CvLeaderClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvLeaderClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderClassInfo::CvLeaderClassInfo() :
	/*************************************************************************************************/
	/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
	/*************************************************************************************************/
	m_iLeaderStatus(NO_STATUS),
	m_piMaxTraitsPerClass(NULL),
	m_pbTraitClassEvolve(NULL)

/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvLeaderClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderClassInfo::~CvLeaderClassInfo()
{
	SAFE_DELETE_ARRAY(m_piMaxTraitsPerClass);
	SAFE_DELETE_ARRAY(m_pbTraitClassEvolve);

}
/*************************************************************************************************/
/**	LeaderStatus Infos      Valkrionn 10/02/09                                                  **/
/*************************************************************************************************/
int CvLeaderClassInfo::getLeaderStatus() const { return m_iLeaderStatus; }
/*************************************************************************************************/
/**	LeaderStatus Infos      Valkrionn 10/02/09                                              END **/
/*************************************************************************************************/
int CvLeaderClassInfo::getMaxTraitsPerClass(int i) const
{
	FAssertMsg(i < GC.getNumTraitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piMaxTraitsPerClass ? m_piMaxTraitsPerClass[i] : -1;
}
bool CvLeaderClassInfo::isTraitClassEvolve(int i) const
{
	FAssertMsg(i < GC.getNumTraitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTraitClassEvolve ? m_pbTraitClassEvolve[i] : false;
}

bool CvLeaderClassInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	LeaderStatus Infos      				10/01/09								Valkrionn	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "LeaderStatus");
	m_iLeaderStatus = pXML->FindInInfoClass(szTextVal);
	pXML->SetVariableListTagPair(&m_piMaxTraitsPerClass, "MaxTraitsPerClass", sizeof(GC.getTraitClassInfo((TraitClassTypes)0)), GC.getNumTraitClassInfos());
	pXML->SetVariableListTagPair(&m_pbTraitClassEvolve, "EvolveTraitClasses", sizeof(GC.getTraitClassInfo((TraitClassTypes)0)), GC.getNumTraitClassInfos());

	/*************************************************************************************************/
	/**	New Tag Defs							END													**/

	return true;
}

void CvLeaderClassInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);
	/*************************************************************************************************/
/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
/*************************************************************************************************/
	stream->Read(&m_iLeaderStatus);
	/*************************************************************************************************/
	/**	New Tag Defs							END													**/
	/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piMaxTraitsPerClass);
	m_piMaxTraitsPerClass = new int[GC.getNumTraitClassInfos()];
	stream->Read(GC.getNumTraitClassInfos(), m_piMaxTraitsPerClass);
	
	SAFE_DELETE_ARRAY(m_pbTraitClassEvolve);
	m_pbTraitClassEvolve = new bool[GC.getNumTraitClassInfos()];
	stream->Read(GC.getNumTraitClassInfos(), m_pbTraitClassEvolve);

}

void CvLeaderClassInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	/*************************************************************************************************/
/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
/*************************************************************************************************/
	stream->Write(m_iLeaderStatus);
	stream->Write(GC.getNumTraitClassInfos(), m_piMaxTraitsPerClass);
	stream->Write(GC.getNumTraitClassInfos(), m_pbTraitClassEvolve);

	/*************************************************************************************************/
	/**	New Tag Defs							END													**/
	/*************************************************************************************************/

}

void CvLeaderClassInfo::copyNonDefaults(CvLeaderClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getLeaderStatus() == NO_STATUS)			m_iLeaderStatus = (pClassInfo->getLeaderStatus());
	for (int j = 0; j < GC.getNumTraitClassInfos(); j++)
	{
		if (m_piMaxTraitsPerClass[j] == 0)					m_piMaxTraitsPerClass[j] = pClassInfo->getMaxTraitsPerClass(j);
		if (m_pbTraitClassEvolve[j] == false)					m_pbTraitClassEvolve[j] = pClassInfo->isTraitClassEvolve(j);

	}
}



// DynTraits Start
//======================================================================================================
//					CvTraitTriggerInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTraitTriggerInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTraitTriggerInfo::CvTraitTriggerInfo() :
	/*************************************************************************************************/
	/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
	/*************************************************************************************************/
	m_iTraitHookType(NO_TRAITHOOK),
	m_iTraitClassType(NO_TRAITCLASS),
	m_iPrereqReligionType(NO_RELIGION),
	m_iPrereqOldReligionType(NO_RELIGION),
	m_iPrereqCultureLevel(NO_CULTURELEVEL),
	m_iPrereqRace(NO_PROMOTION),
	m_iPrereqKilledRace(NO_PROMOTION),
	m_iPrereqTrade(TRADE_ITEM_NONE),
	m_iPrereqImprovementType(NO_IMPROVEMENT),
	m_iPrereqRouteType(NO_ROUTE),
	m_iPrereqProjectType(NO_PROJECT),
	m_iPrereqTerrainType(NO_TERRAIN),
	m_iPrereqFeatureType(NO_FEATURE),
	m_iPrereqBonusType(NO_BONUS),
	m_iPrereqTechType(NO_TECH),
	m_iPrereqHurryType(NO_HURRY),
	m_iPrereqUnitClassType(NO_UNITCLASS),
	m_iPrereqKilledUnitClassType(NO_UNITCLASS),
	m_iPrereqPromotionType(NO_PROMOTION),
	m_iPrereqSpellType(NO_SPELL),
	m_iPrereqBuildingClassType(NO_BUILDINGCLASS),
	m_iPrereqUnitCombatType(NO_UNITCOMBAT),
	m_iPrereqKilledUnitCombatType(NO_UNITCOMBAT),
	m_iPrereqAlignment(NO_ALIGNMENT),
	m_iPrereqKilledAlignment(NO_ALIGNMENT),
	m_iPrereqEthicalAlignment(NO_ETHICAL_ALIGNMENT),
	m_iPrereqKilledEthicalAlignment(NO_ETHICAL_ALIGNMENT),
	m_iPrereqMinAlignment(0),
	m_iPrereqMaxAlignment(0),
	m_iPrereqThroughAlignment(0),
	m_iPrereqThroughEthicalAlignment(0),
	m_iPrereqMinKilledAlignment(0),
	m_iPrereqMaxKilledAlignment(0),
	m_iPrereqMinEthicalAlignment(0),
	m_iPrereqMaxEthicalAlignment(0),
	m_iPrereqMinKilledEthicalAlignment(0),
	m_iPrereqMaxKilledEthicalAlignment(0),
	m_bFirst(false),
	m_bOncePerPlayer(false),
	m_bCoastal(false),
	m_bConquest(false),
	m_bTrade(false),
	m_bOwnHolyCity(false),
	m_bNotOwnHolyCity(false),
	m_bAnyHolyCity(false),
	m_bWerewolf(false),
	m_bHero(false),
	m_bHiddenNationality(false),
	m_bInBorders(false),
	m_bOutsideBorders(false),
	m_bKilledWerewolf(false),
	m_bKilledHero(false),
	m_bKilledHiddenNationality(false),
	m_bKilledInBorders(false),
	m_bKilledOutsideBorders(false),
	m_iBonusMultiplierType(NO_BONUS),
	m_bPrereqAtWar(false),
	m_bPrereqAtPeace(false),
	m_bPrereqOpposite(false),
	m_bPrereqOppositeEthical(false),
	m_bPrereqHill(false),
	m_bPrereqPeak(false),
	m_bPrereqHappy(false),
	m_bPrereqHealth(false),
	m_bHolyCity(false),
	m_piTraitCounterChange(NULL),
	m_pbTraitClassEvolve(NULL),
	m_iNumPrereqCivics(0),
	m_piPrereqCivics(NULL)



	/*************************************************************************************************/
	/**	New Tag Defs							END													**/
	/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTraitTriggerInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTraitTriggerInfo::~CvTraitTriggerInfo()
{
	SAFE_DELETE_ARRAY(m_piTraitCounterChange);
	SAFE_DELETE_ARRAY(m_pbTraitClassEvolve);
	SAFE_DELETE_ARRAY(m_piPrereqCivics);

}
/*************************************************************************************************/
/**	LeaderStatus Infos      Valkrionn 10/02/09                                                  **/
/*************************************************************************************************/
int CvTraitTriggerInfo::getTraitHookType() const { return m_iTraitHookType; }
int CvTraitTriggerInfo::getTraitClassType() const { return m_iTraitClassType; }
int CvTraitTriggerInfo::getPrereqReligionType() const { return m_iPrereqReligionType; }
int CvTraitTriggerInfo::getPrereqOldReligionType() const { return m_iPrereqOldReligionType; }
int CvTraitTriggerInfo::getPrereqCultureLevel() const { return m_iPrereqCultureLevel; }
int CvTraitTriggerInfo::getPrereqRace() const { return m_iPrereqRace; }
int CvTraitTriggerInfo::getPrereqKilledRace() const { return m_iPrereqKilledRace; }
int CvTraitTriggerInfo::getPrereqTrade() const { return m_iPrereqTrade; }
int CvTraitTriggerInfo::getPrereqImprovementType() const { return m_iPrereqImprovementType; }
int CvTraitTriggerInfo::getPrereqRouteType() const { return m_iPrereqRouteType; }
int CvTraitTriggerInfo::getPrereqProjectType() const { return m_iPrereqProjectType; }
int CvTraitTriggerInfo::getPrereqTerrainType() const { return m_iPrereqTerrainType; }
int CvTraitTriggerInfo::getPrereqFeatureType() const { return m_iPrereqFeatureType; }
int CvTraitTriggerInfo::getPrereqBonusType() const { return m_iPrereqBonusType; }
int CvTraitTriggerInfo::getPrereqTechType() const { return m_iPrereqTechType; }
int CvTraitTriggerInfo::getPrereqHurryType() const { return m_iPrereqHurryType; }
int CvTraitTriggerInfo::getPrereqUnitClassType() const { return m_iPrereqUnitClassType; }
int CvTraitTriggerInfo::getPrereqKilledUnitClassType() const { return m_iPrereqKilledUnitClassType; }
int CvTraitTriggerInfo::getPrereqPromotionType() const { return m_iPrereqPromotionType; }
int CvTraitTriggerInfo::getPrereqSpellType() const { return m_iPrereqSpellType; }
int CvTraitTriggerInfo::getPrereqBuildingClassType() const { return m_iPrereqBuildingClassType; }
int CvTraitTriggerInfo::getPrereqUnitCombatType() const { return m_iPrereqUnitCombatType; }
int CvTraitTriggerInfo::getPrereqKilledUnitCombatType() const { return m_iPrereqKilledUnitCombatType; }
int CvTraitTriggerInfo::getPrereqAlignment() const { return m_iPrereqAlignment; }
int CvTraitTriggerInfo::getPrereqKilledAlignment() const { return m_iPrereqKilledAlignment; }
int CvTraitTriggerInfo::getPrereqEthicalAlignment() const { return m_iPrereqEthicalAlignment; }
int CvTraitTriggerInfo::getPrereqKilledEthicalAlignment() const { return m_iPrereqKilledEthicalAlignment; }
int CvTraitTriggerInfo::getPrereqMinAlignment() const { return m_iPrereqMinAlignment; }
int CvTraitTriggerInfo::getPrereqMaxAlignment() const { return m_iPrereqMaxAlignment; }
int CvTraitTriggerInfo::getPrereqThroughAlignment() const { return m_iPrereqThroughAlignment; }
int CvTraitTriggerInfo::getPrereqThroughEthicalAlignment() const { return m_iPrereqThroughEthicalAlignment; }
int CvTraitTriggerInfo::getPrereqMinKilledAlignment() const { return m_iPrereqMinKilledAlignment; }
int CvTraitTriggerInfo::getPrereqMaxKilledAlignment() const { return m_iPrereqMaxKilledAlignment; }
int CvTraitTriggerInfo::getPrereqMinEthicalAlignment() const { return m_iPrereqMinEthicalAlignment; }
int CvTraitTriggerInfo::getPrereqMaxEthicalAlignment() const { return m_iPrereqMaxEthicalAlignment; }
int CvTraitTriggerInfo::getPrereqMinKilledEthicalAlignment() const { return m_iPrereqMinKilledEthicalAlignment; }
int CvTraitTriggerInfo::getPrereqMaxKilledEthicalAlignment() const { return m_iPrereqMaxKilledEthicalAlignment; }
bool CvTraitTriggerInfo::isFirst() const { return m_bFirst; }
bool CvTraitTriggerInfo::isOncePerPlayer() const { return m_bOncePerPlayer; }
bool CvTraitTriggerInfo::isCoastal() const { return m_bCoastal; }
bool CvTraitTriggerInfo::isPrereqConquest() const { return m_bConquest; }
bool CvTraitTriggerInfo::isPrereqTrade() const { return m_bTrade; }
bool CvTraitTriggerInfo::isCityOwnHolyCity() const { return m_bOwnHolyCity; }
bool CvTraitTriggerInfo::isCityNotOwnHolyCity() const { return m_bNotOwnHolyCity; }
bool CvTraitTriggerInfo::isCityAnyHolyCity() const { return m_bAnyHolyCity; }
bool CvTraitTriggerInfo::isPrereqWerewolf() const { return m_bWerewolf; }
bool CvTraitTriggerInfo::isPrereqHero() const { return m_bHero; }
bool CvTraitTriggerInfo::isPrereqHiddenNationality() const { return m_bHiddenNationality; }
bool CvTraitTriggerInfo::isPrereqInBorders() const { return m_bInBorders; }
bool CvTraitTriggerInfo::isPrereqOutsideBorders() const { return m_bOutsideBorders; }
bool CvTraitTriggerInfo::isPrereqKilledWerewolf() const { return m_bKilledWerewolf; }
bool CvTraitTriggerInfo::isPrereqKilledHero() const { return m_bKilledHero; }
bool CvTraitTriggerInfo::isPrereqKilledHiddenNationality() const { return m_bKilledHiddenNationality; }
bool CvTraitTriggerInfo::isPrereqKilledInBorders() const { return m_bKilledInBorders; }
bool CvTraitTriggerInfo::isPrereqKilledOutsideBorders() const { return m_bKilledOutsideBorders; }
int CvTraitTriggerInfo::getBonusMultiplierType() const { return m_iBonusMultiplierType; }
bool CvTraitTriggerInfo::isPrereqAtWar() const { return m_bPrereqAtWar; }
bool CvTraitTriggerInfo::isPrereqAtPeace() const { return m_bPrereqAtPeace; }
bool CvTraitTriggerInfo::isPrereqOpposite() const { return m_bPrereqOpposite; }
bool CvTraitTriggerInfo::isPrereqOppositeEthical() const { return m_bPrereqOppositeEthical; }
bool CvTraitTriggerInfo::isPrereqHill() const { return m_bPrereqHill; }
bool CvTraitTriggerInfo::isPrereqPeak() const { return m_bPrereqPeak; }
bool CvTraitTriggerInfo::isPrereqHappy() const { return m_bPrereqHappy; }
bool CvTraitTriggerInfo::isPrereqHealth() const { return m_bPrereqHealth; }
bool CvTraitTriggerInfo::isOwnHolyCity() const { return m_bHolyCity; }
/*************************************************************************************************/
/**	LeaderStatus Infos      Valkrionn 10/02/09                                              END **/
/*************************************************************************************************/
int CvTraitTriggerInfo::getTraitCounterChange(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTraitCounterChange ? m_piTraitCounterChange[i] : 0;
}
bool CvTraitTriggerInfo::isTraitClassEvolve(int i) const
{
	FAssertMsg(i < GC.getNumTraitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTraitClassEvolve ? m_pbTraitClassEvolve[i] : false;
}
int CvTraitTriggerInfo::getPrereqCivic(int iI) const { return (getNumPrereqCivics() > iI) ? m_piPrereqCivics[iI] : -1; }
int CvTraitTriggerInfo::getNumPrereqCivics() const { return m_iNumPrereqCivics; }

bool CvTraitTriggerInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	std::vector<CvString> aszPrereqCivics;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	/*************************************************************************************************/
	/**	LeaderStatus Infos      				10/01/09								Valkrionn	**/
	/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "TraitHookType");
	m_iTraitHookType = GC.getTypesEnum(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TraitClassType");
	m_iTraitClassType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligionType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqOldReligion");
	m_iPrereqOldReligionType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCultureLevel");
	m_iPrereqCultureLevel = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqRaceType");
	m_iPrereqRace = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqKilledRaceType");
	m_iPrereqKilledRace = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqTradeableItem");
	m_iPrereqTrade = GC.getTypesEnum(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqImprovementType");
	m_iPrereqImprovementType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqRouteType");
	m_iPrereqRouteType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqProjectType");
	m_iPrereqProjectType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqTerrainType");
	m_iPrereqTerrainType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqFeatureType");
	m_iPrereqFeatureType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqBonusType");
	m_iPrereqBonusType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iPrereqTechType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqHurryType");
	m_iPrereqHurryType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqUnitClassType");
	m_iPrereqUnitClassType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqKilledUnitClassType");
	m_iPrereqKilledUnitClassType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqPromotionType");
	m_iPrereqPromotionType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqSpellType");
	m_iPrereqSpellType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqBuildingClassType");
	m_iPrereqBuildingClassType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqUnitCombatType");
	m_iPrereqUnitCombatType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqKilledUnitCombatType");
	m_iPrereqKilledUnitCombatType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = GC.getTypesEnum(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqKilledAlignment");
	m_iPrereqKilledAlignment = GC.getTypesEnum(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqEthicalAlignment");
	m_iPrereqEthicalAlignment = GC.getTypesEnum(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqKilledEthicalAlignment");
	m_iPrereqKilledEthicalAlignment = GC.getTypesEnum(szTextVal);
	pXML->GetChildXmlValByName(&m_iPrereqMinAlignment, "iPrereqMinAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqMaxAlignment, "iPrereqMaxAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqThroughAlignment, "iPrereqThroughAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqThroughEthicalAlignment, "iPrereqThroughEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqMinKilledAlignment, "iPrereqKilledMinAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqMaxKilledAlignment, "iPrereqKilledMaxAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqMinEthicalAlignment, "iPrereqMinEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqMaxEthicalAlignment, "iPrereqMaxEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqMinKilledEthicalAlignment, "iPrereqKilledMinEthicalAlignment");
	pXML->GetChildXmlValByName(&m_iPrereqMaxKilledEthicalAlignment, "iPrereqKilledMaxEthicalAlignment");
	pXML->GetChildXmlValByName(&m_bFirst, "bFirst");
	pXML->GetChildXmlValByName(&m_bOncePerPlayer, "bOncePerPlayer");
	pXML->GetChildXmlValByName(&m_bCoastal, "bPrereqCoastalCity");
	pXML->GetChildXmlValByName(&m_bConquest, "bPrereqConquest");
	pXML->GetChildXmlValByName(&m_bTrade, "bPrereqTrade");
	pXML->GetChildXmlValByName(&m_bNotOwnHolyCity, "bCityNotOwnHolyCity");
	pXML->GetChildXmlValByName(&m_bOwnHolyCity, "bCityOwnHolyCity");
	pXML->GetChildXmlValByName(&m_bAnyHolyCity, "bCityAnyHolyCity");
	pXML->GetChildXmlValByName(&m_bWerewolf, "bWerewolf");
	pXML->GetChildXmlValByName(&m_bHero, "bHero");
	pXML->GetChildXmlValByName(&m_bHiddenNationality, "bHiddenNationality");
	pXML->GetChildXmlValByName(&m_bInBorders, "bInBorders");
	pXML->GetChildXmlValByName(&m_bOutsideBorders, "bOutsideBorders");
	pXML->GetChildXmlValByName(&m_bKilledWerewolf, "bKilledWerewolf");
	pXML->GetChildXmlValByName(&m_bKilledHero, "bKilledHero");
	pXML->GetChildXmlValByName(&m_bKilledHiddenNationality, "bKilledHiddenNationality");
	pXML->GetChildXmlValByName(&m_bKilledInBorders, "bKilledInBorders");
	pXML->GetChildXmlValByName(&m_bKilledOutsideBorders, "bKilledOutsideBorders");
	pXML->GetChildXmlValByName(szTextVal, "BonusMultiplierType");
	m_iBonusMultiplierType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bPrereqAtWar, "bPrereqWar");
	pXML->GetChildXmlValByName(&m_bPrereqAtPeace, "bPrereqPeace");
	pXML->GetChildXmlValByName(&m_bPrereqOpposite, "bPrereqOppositeAlignment");
	pXML->GetChildXmlValByName(&m_bPrereqOppositeEthical, "bPrereqOppositeEthicalAlignment");
	pXML->GetChildXmlValByName(&m_bPrereqHill, "bPrereqHill");
	pXML->GetChildXmlValByName(&m_bPrereqPeak, "bPrereqPeak");
	pXML->GetChildXmlValByName(&m_bPrereqHappy, "bPrereqHappiness");
	pXML->GetChildXmlValByName(&m_bPrereqHealth, "bPrereqHealth");
	pXML->GetChildXmlValByName(&m_bHolyCity, "bOwnHolyCity");
	pXML->SetVariableListTagPair(&m_piTraitCounterChange, "CounterChanges", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());
	pXML->SetVariableListTagPair(&m_pbTraitClassEvolve, "EvolveTraitClasses", sizeof(GC.getTraitClassInfo((TraitClassTypes)0)), GC.getNumTraitClassInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "PrereqCivics"))
	{
		pXML->SetStringWithChildList(&m_iNumPrereqCivics, &aszPrereqCivics);
	}

	m_piPrereqCivics = new int[m_iNumPrereqCivics];

	for (int iI = 0; iI < m_iNumPrereqCivics; iI++)
	{
		m_piPrereqCivics[iI] = GC.getInfoTypeForString(aszPrereqCivics[iI]);
	}

	/*************************************************************************************************/
	/**	New Tag Defs							END													**/

	return true;
}

void CvTraitTriggerInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);
	/*************************************************************************************************/
/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
/*************************************************************************************************/
	stream->Read(&m_iTraitHookType);
	stream->Read(&m_iTraitClassType);
	stream->Read(&m_iPrereqReligionType);
	stream->Read(&m_iPrereqOldReligionType);
	stream->Read(&m_iPrereqCultureLevel);
	stream->Read(&m_iPrereqRace);
	stream->Read(&m_iPrereqKilledRace);
	stream->Read(&m_iPrereqTrade);
	stream->Read(&m_iPrereqImprovementType);
	stream->Read(&m_iPrereqRouteType);
	stream->Read(&m_iPrereqProjectType);
	stream->Read(&m_iPrereqTerrainType);
	stream->Read(&m_iPrereqFeatureType);
	stream->Read(&m_iPrereqBonusType);
	stream->Read(&m_iPrereqTechType);
	stream->Read(&m_iPrereqHurryType);
	stream->Read(&m_iPrereqUnitClassType);
	stream->Read(&m_iPrereqKilledUnitClassType);
	stream->Read(&m_iPrereqPromotionType);
	stream->Read(&m_iPrereqSpellType);
	stream->Read(&m_iPrereqBuildingClassType);
	stream->Read(&m_iPrereqUnitCombatType);
	stream->Read(&m_iPrereqKilledUnitCombatType);
	stream->Read(&m_iPrereqAlignment);
	stream->Read(&m_iPrereqKilledAlignment);
	stream->Read(&m_iPrereqEthicalAlignment);
	stream->Read(&m_iPrereqKilledEthicalAlignment);
	stream->Read(&m_iPrereqMinAlignment);
	stream->Read(&m_iPrereqMaxAlignment);
	stream->Read(&m_iPrereqThroughAlignment);
	stream->Read(&m_iPrereqThroughEthicalAlignment);
	stream->Read(&m_iPrereqMinKilledAlignment);
	stream->Read(&m_iPrereqMaxKilledAlignment);
	stream->Read(&m_iPrereqMinEthicalAlignment);
	stream->Read(&m_iPrereqMaxEthicalAlignment);
	stream->Read(&m_iPrereqMinKilledEthicalAlignment);
	stream->Read(&m_iPrereqMaxKilledEthicalAlignment);
	stream->Read(&m_bFirst);
	stream->Read(&m_bOncePerPlayer);
	stream->Read(&m_bCoastal);
	stream->Read(&m_bConquest);
	stream->Read(&m_bTrade);
	stream->Read(&m_bOwnHolyCity);
	stream->Read(&m_bNotOwnHolyCity);
	stream->Read(&m_bAnyHolyCity);
	stream->Read(&m_bWerewolf);
	stream->Read(&m_bHero);
	stream->Read(&m_bHiddenNationality);
	stream->Read(&m_bInBorders);
	stream->Read(&m_bOutsideBorders);
	stream->Read(&m_bKilledWerewolf);
	stream->Read(&m_bKilledHero);
	stream->Read(&m_bKilledHiddenNationality);
	stream->Read(&m_bKilledInBorders);
	stream->Read(&m_bKilledOutsideBorders);
	stream->Read(&m_iBonusMultiplierType);
	stream->Read(&m_bPrereqAtWar);
	stream->Read(&m_bPrereqAtPeace);
	stream->Read(&m_bPrereqOpposite);
	stream->Read(&m_bPrereqOppositeEthical);
	stream->Read(&m_bPrereqHill);
	stream->Read(&m_bPrereqPeak);
	stream->Read(&m_bPrereqHappy);
	stream->Read(&m_bPrereqHealth);
	stream->Read(&m_bHolyCity);
	/*************************************************************************************************/
	/**	New Tag Defs							END													**/
	/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piTraitCounterChange);
	m_piTraitCounterChange = new int[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_piTraitCounterChange);

	SAFE_DELETE_ARRAY(m_pbTraitClassEvolve);
	m_pbTraitClassEvolve = new bool[GC.getNumTraitClassInfos()];
	stream->Read(GC.getNumTraitClassInfos(), m_pbTraitClassEvolve);

	stream->Read(&m_iNumPrereqCivics);
	if (m_iNumPrereqCivics > 0)
	{
		SAFE_DELETE_ARRAY(m_piPrereqCivics);
		m_piPrereqCivics = new int[m_iNumPrereqCivics];
		stream->Read(m_iNumPrereqCivics, m_piPrereqCivics);
	}
}

void CvTraitTriggerInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	/*************************************************************************************************/
/**	LeaderStatus Infos      				10/02/09								Valkrionn	**/
/*************************************************************************************************/
	stream->Write(m_iTraitHookType);
	stream->Write(m_iTraitClassType);
	stream->Write(m_iPrereqReligionType);
	stream->Write(m_iPrereqOldReligionType);
	stream->Write(m_iPrereqCultureLevel);
	stream->Write(m_iPrereqRace);
	stream->Write(m_iPrereqKilledRace);
	stream->Write(m_iPrereqTrade);
	stream->Write(m_iPrereqImprovementType);
	stream->Write(m_iPrereqRouteType);
	stream->Write(m_iPrereqProjectType);
	stream->Write(m_iPrereqTerrainType);
	stream->Write(m_iPrereqFeatureType);
	stream->Write(m_iPrereqBonusType);
	stream->Write(m_iPrereqTechType);
	stream->Write(m_iPrereqHurryType);
	stream->Write(m_iPrereqUnitClassType);
	stream->Write(m_iPrereqKilledUnitClassType);
	stream->Write(m_iPrereqPromotionType);
	stream->Write(m_iPrereqSpellType);
	stream->Write(m_iPrereqBuildingClassType);
	stream->Write(m_iPrereqUnitCombatType);
	stream->Write(m_iPrereqKilledUnitCombatType);
	stream->Write(m_iPrereqAlignment);
	stream->Write(m_iPrereqKilledAlignment);
	stream->Write(m_iPrereqEthicalAlignment);
	stream->Write(m_iPrereqKilledEthicalAlignment);
	stream->Write(m_iPrereqMinAlignment);
	stream->Write(m_iPrereqMaxAlignment);
	stream->Write(m_iPrereqThroughAlignment);
	stream->Write(m_iPrereqThroughEthicalAlignment);
	stream->Write(m_iPrereqMinKilledAlignment);
	stream->Write(m_iPrereqMaxKilledAlignment);
	stream->Write(m_iPrereqMinEthicalAlignment);
	stream->Write(m_iPrereqMaxEthicalAlignment);
	stream->Write(m_iPrereqMinKilledEthicalAlignment);
	stream->Write(m_iPrereqMaxKilledEthicalAlignment);
	stream->Write(m_bFirst);
	stream->Write(m_bOncePerPlayer);
	stream->Write(m_bCoastal);
	stream->Write(m_bConquest);
	stream->Write(m_bTrade);
	stream->Write(m_bOwnHolyCity);
	stream->Write(m_bNotOwnHolyCity);
	stream->Write(m_bAnyHolyCity);
	stream->Write(m_bWerewolf);
	stream->Write(m_bHero);
	stream->Write(m_bHiddenNationality);
	stream->Write(m_bInBorders);
	stream->Write(m_bOutsideBorders);
	stream->Write(m_bKilledWerewolf);
	stream->Write(m_bKilledHero);
	stream->Write(m_bKilledHiddenNationality);
	stream->Write(m_bKilledInBorders);
	stream->Write(m_bKilledOutsideBorders);
	stream->Write(m_iBonusMultiplierType);
	stream->Write(m_bPrereqAtWar);
	stream->Write(m_bPrereqAtPeace);
	stream->Write(m_bPrereqOpposite);
	stream->Write(m_bPrereqOppositeEthical);
	stream->Write(m_bPrereqHill);
	stream->Write(m_bPrereqPeak);
	stream->Write(m_bPrereqHappy);
	stream->Write(m_bPrereqHealth);
	stream->Write(m_bHolyCity);

	stream->Write(GC.getNumTraitInfos(), m_piTraitCounterChange);
	stream->Write(GC.getNumTraitClassInfos(), m_pbTraitClassEvolve);
	stream->Write(m_iNumPrereqCivics);
	if (m_iNumPrereqCivics > 0)
		stream->Write(m_iNumPrereqCivics, m_piPrereqCivics);
	/*************************************************************************************************/
	/**	New Tag Defs							END													**/
	/*************************************************************************************************/

}

void CvTraitTriggerInfo::copyNonDefaults(CvTraitTriggerInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTraitHookType() == NO_TRAITHOOK)			m_iTraitHookType = (pClassInfo->getTraitHookType());
	if (getTraitClassType() == NO_TRAITCLASS)			m_iTraitClassType = (pClassInfo->getTraitClassType());
	if (getPrereqReligionType() == NO_RELIGION)			m_iPrereqReligionType = (pClassInfo->getPrereqReligionType());
	if (getPrereqOldReligionType() == NO_RELIGION)			m_iPrereqOldReligionType = (pClassInfo->getPrereqOldReligionType());
	if (getPrereqCultureLevel() == NO_CULTURELEVEL)			m_iPrereqCultureLevel = (pClassInfo->getPrereqCultureLevel());
	if (getPrereqRace() == NO_PROMOTION)			m_iPrereqRace = (pClassInfo->getPrereqRace());
	if (getPrereqKilledRace() == NO_PROMOTION)			m_iPrereqKilledRace = (pClassInfo->getPrereqKilledRace());
	if (getPrereqTrade() == TRADE_ITEM_NONE)			m_iPrereqTrade = (pClassInfo->getPrereqTrade());
	if (getPrereqImprovementType() == NO_IMPROVEMENT)			m_iPrereqImprovementType = (pClassInfo->getPrereqImprovementType());
	if (getPrereqRouteType() == NO_ROUTE)			m_iPrereqRouteType = (pClassInfo->getPrereqRouteType());
	if (getPrereqProjectType() == NO_PROJECT)			m_iPrereqProjectType = (pClassInfo->getPrereqProjectType());
	if (getPrereqTerrainType() == NO_TERRAIN)			m_iPrereqTerrainType = (pClassInfo->getPrereqTerrainType());
	if (getPrereqFeatureType() == NO_FEATURE)			m_iPrereqFeatureType = (pClassInfo->getPrereqFeatureType());
	if (getPrereqBonusType() == NO_BONUS)			m_iPrereqBonusType = (pClassInfo->getPrereqBonusType());
	if (getPrereqTechType() == NO_TECH)			m_iPrereqTechType = (pClassInfo->getPrereqTechType());
	if (getPrereqHurryType() == NO_HURRY)			m_iPrereqHurryType = (pClassInfo->getPrereqHurryType());
	if (getPrereqUnitClassType() == NO_UNITCLASS)			m_iPrereqUnitClassType = (pClassInfo->getPrereqUnitClassType());
	if (getPrereqKilledUnitClassType() == NO_UNITCLASS)			m_iPrereqKilledUnitClassType = (pClassInfo->getPrereqKilledUnitClassType());
	if (getPrereqPromotionType() == NO_PROMOTION)			m_iPrereqPromotionType = (pClassInfo->getPrereqPromotionType());
	if (getPrereqSpellType() == NO_SPELL)			m_iPrereqSpellType = (pClassInfo->getPrereqSpellType());
	if (getPrereqBuildingClassType() == NO_BUILDINGCLASS)			m_iPrereqBuildingClassType = (pClassInfo->getPrereqBuildingClassType());
	if (getPrereqUnitCombatType() == NO_UNITCOMBAT)			m_iPrereqUnitCombatType = (pClassInfo->getPrereqUnitCombatType());
	if (getPrereqKilledUnitCombatType() == NO_UNITCOMBAT)			m_iPrereqKilledUnitCombatType = (pClassInfo->getPrereqKilledUnitCombatType());
	if (getPrereqAlignment() == NO_ALIGNMENT)			m_iPrereqAlignment = (pClassInfo->getPrereqAlignment());
	if (getPrereqKilledAlignment() == NO_ALIGNMENT)			m_iPrereqKilledAlignment = (pClassInfo->getPrereqKilledAlignment());
	if (getPrereqEthicalAlignment() == NO_ETHICAL_ALIGNMENT)			m_iPrereqEthicalAlignment = (pClassInfo->getPrereqEthicalAlignment());
	if (getPrereqKilledEthicalAlignment() == NO_ETHICAL_ALIGNMENT)			m_iPrereqKilledEthicalAlignment = (pClassInfo->getPrereqKilledEthicalAlignment());
	if (getPrereqMinAlignment() == 0)			m_iPrereqMinAlignment = (pClassInfo->getPrereqMinAlignment());
	if (getPrereqMaxAlignment() == 0)			m_iPrereqMaxAlignment = (pClassInfo->getPrereqMaxAlignment());
	if (getPrereqThroughAlignment() == 0)			m_iPrereqThroughAlignment = (pClassInfo->getPrereqThroughAlignment());
	if (getPrereqThroughEthicalAlignment() == 0)			m_iPrereqThroughEthicalAlignment = (pClassInfo->getPrereqThroughEthicalAlignment());
	if (getPrereqMinKilledAlignment() == 0)			m_iPrereqMinKilledAlignment = (pClassInfo->getPrereqMinKilledAlignment());
	if (getPrereqMaxKilledAlignment() == 0)			m_iPrereqMaxKilledAlignment = (pClassInfo->getPrereqMaxKilledAlignment());
	if (getPrereqMinEthicalAlignment() == 0)			m_iPrereqMinEthicalAlignment = (pClassInfo->getPrereqMinEthicalAlignment());
	if (getPrereqMaxEthicalAlignment() == 0)			m_iPrereqMaxEthicalAlignment = (pClassInfo->getPrereqMaxEthicalAlignment());
	if (getPrereqMinKilledEthicalAlignment() == 0)			m_iPrereqMinKilledEthicalAlignment = (pClassInfo->getPrereqMinKilledEthicalAlignment());
	if (getPrereqMaxKilledEthicalAlignment() == 0)			m_iPrereqMaxKilledEthicalAlignment = (pClassInfo->getPrereqMaxKilledEthicalAlignment());
	if (isFirst() == false)			m_bFirst = (pClassInfo->isFirst());
	if (isOncePerPlayer() == false)			m_bOncePerPlayer = (pClassInfo->isOncePerPlayer());
	if (isCoastal() == false)			m_bCoastal = (pClassInfo->isCoastal());
	if (isPrereqConquest() == false)			m_bConquest = (pClassInfo->isPrereqConquest());
	if (isPrereqTrade() == false)			m_bTrade = (pClassInfo->isPrereqTrade());
	if (isCityOwnHolyCity() == false)			m_bOwnHolyCity = (pClassInfo->isCityOwnHolyCity());
	if (isCityNotOwnHolyCity() == false)			m_bNotOwnHolyCity = (pClassInfo->isCityNotOwnHolyCity());
	if (isCityAnyHolyCity() == false)			m_bAnyHolyCity = (pClassInfo->isCityAnyHolyCity());
	if (isPrereqWerewolf() == false)			m_bWerewolf = (pClassInfo->isPrereqWerewolf());
	if (isPrereqHero() == false)			m_bHero = (pClassInfo->isPrereqHero());
	if (isPrereqHiddenNationality() == false)			m_bHiddenNationality = (pClassInfo->isPrereqHiddenNationality());
	if (isPrereqInBorders() == false)			m_bInBorders = (pClassInfo->isPrereqInBorders());
	if (isPrereqOutsideBorders() == false)			m_bOutsideBorders = (pClassInfo->isPrereqOutsideBorders());
	if (isPrereqKilledWerewolf() == false)			m_bKilledWerewolf = (pClassInfo->isPrereqKilledWerewolf());
	if (isPrereqKilledHero() == false)			m_bKilledHero = (pClassInfo->isPrereqKilledHero());
	if (isPrereqKilledHiddenNationality() == false)			m_bKilledHiddenNationality = (pClassInfo->isPrereqKilledHiddenNationality());
	if (isPrereqKilledInBorders() == false)			m_bKilledInBorders = (pClassInfo->isPrereqKilledInBorders());
	if (isPrereqKilledOutsideBorders() == false)			m_bKilledOutsideBorders = (pClassInfo->isPrereqKilledOutsideBorders());
	if (getBonusMultiplierType() == NO_BONUS)			m_iBonusMultiplierType = (pClassInfo->getBonusMultiplierType());
	if (isPrereqAtWar() == false)			m_bPrereqAtWar = (pClassInfo->isPrereqAtWar());
	if (isPrereqAtPeace() == false)			m_bPrereqAtPeace = (pClassInfo->isPrereqAtPeace());
	if (isPrereqOpposite() == false)			m_bPrereqOpposite = (pClassInfo->isPrereqOpposite());
	if (isPrereqOppositeEthical() == false)			m_bPrereqOppositeEthical = (pClassInfo->isPrereqOppositeEthical());
	if (isPrereqHill() == false)			m_bPrereqHill = (pClassInfo->isPrereqHill());
	if (isPrereqPeak() == false)			m_bPrereqPeak = (pClassInfo->isPrereqPeak());
	if (isPrereqHappy() == false)			m_bPrereqHappy = (pClassInfo->isPrereqHappy());
	if (isPrereqHealth() == false)			m_bPrereqHealth = (pClassInfo->isPrereqHealth());
	if (isOwnHolyCity() == false)			m_bHolyCity = (pClassInfo->isOwnHolyCity());
	for (int j = 0; j < GC.getNumTraitClassInfos(); j++)
	{
		if (m_piTraitCounterChange[j] == 0)					m_piTraitCounterChange[j] = pClassInfo->getTraitCounterChange(j);
		if (m_pbTraitClassEvolve[j] == false)					m_pbTraitClassEvolve[j] = pClassInfo->isTraitClassEvolve(j);

	}
	if (pClassInfo->getNumPrereqCivics() > 0)
	{
		int* tempArray = new int[getNumPrereqCivics() + pClassInfo->getNumPrereqCivics()];
		for (int i = 0; i < getNumPrereqCivics(); ++i)
		{
			tempArray[i] = getPrereqCivic(i);
		}
		int iNewItems = 0;
		for (int i = 0; i < pClassInfo->getNumPrereqCivics(); ++i)
		{
			bool bLoad = true;
			for (int j = 0; j < getNumPrereqCivics(); ++j)
			{
				if (pClassInfo->getPrereqCivic(i) == getPrereqCivic(j))
				{
					bLoad = false;
					break;
				}
			}
			if (bLoad)
			{
				tempArray[iNewItems + getNumPrereqCivics()] = pClassInfo->getPrereqCivic(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPrereqCivics);
		int iGoalSize = getNumPrereqCivics() + iNewItems;
		m_piPrereqCivics = new int[iGoalSize];
		for (int i = 0; i < iGoalSize; ++i)
		{
			m_piPrereqCivics[i] = tempArray[i];
			FAssertMsg(m_piPrereqCivics[i] < GC.getNumCivicInfos(), "Out of Bounds Array Melding");
			FAssertMsg(m_piPrereqCivics[i] > -1, "Out of Bounds Array Melding");
		}
		m_iNumPrereqCivics = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
}

// Magic Rework
//======================================================================================================
//					CvSpellClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpellClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpellClassInfo::CvSpellClassInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpellClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpellClassInfo::~CvSpellClassInfo()
{
}

bool CvSpellClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	return true;
}


