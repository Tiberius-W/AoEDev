// unit.cpp

#include "CvGameCoreDLL.h"
#include "CvUnit.h"
#include "CvArea.h"
#include "CvPlot.h"
#include "CvCity.h"
#include "CvGlobals.h"
#include "CvGameCoreUtils.h"
#include "CvGameAI.h"
#include "CvMap.h"
#include "CvPlayerAI.h"
#include "CvRandom.h"
#include "CvTeamAI.h"
#include "CvGameCoreUtils.h"
#include "CyUnit.h"
#include "CyArgsList.h"
#include "CyPlot.h"
#include "CvDLLEntityIFaceBase.h"
#include "CvDLLInterfaceIFaceBase.h"
#include "CvDLLEngineIFaceBase.h"
#include "CvEventReporter.h"
#include "CvDLLPythonIFaceBase.h"
#include "CvDLLFAStarIFaceBase.h"
#include "CvInfos.h"
#include "FProfiler.h"
#include "CvPopupInfo.h"
#include "CvArtFileMgr.h"

// Public Functions...


CvUnit::CvUnit()
{
	m_aiExtraDomainModifier = new int[NUM_DOMAIN_TYPES];

//FfH Damage Types: Added by Kael 08/23/2007
	m_paiBonusAffinity = NULL;
	m_paiBonusAffinityAmount = NULL;
	m_paiDamageTypeCombat = NULL;
	m_paiDamageTypeResist = NULL;
//FfH: End Add

/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_pabHasPromotion = NULL;
/**								----  End Original Code  ----									**/
	m_paiHasPromotion = NULL;
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	m_paiNoBadExploreImprovement = NULL;
	m_paiTerrainDoubleMoveCount = NULL;
	m_paiFeatureDoubleMoveCount = NULL;
	m_paiExtraTerrainAttackPercent = NULL;
	m_paiExtraTerrainDefensePercent = NULL;
	m_paiExtraFeatureAttackPercent = NULL;
	m_paiExtraFeatureDefensePercent = NULL;
	m_paiPlotEffectDoubleMoveCount = NULL;
	m_paiExtraPlotEffectAttackPercent = NULL;
	m_paiExtraPlotEffectDefensePercent = NULL;
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
	m_paiTerrainCost = NULL;
	m_paiFeatureCost = NULL;
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	m_paiExtraUnitCombatModifier = NULL;
	m_paiExtraSpellClassPower = NULL;

/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**										Allocate Memory											**/
/*************************************************************************************************/
	m_pabRealPromotion = NULL;
	m_aiSupplementalPromotions = NULL;
	m_pSlaveUnitList.clear();
	m_pMinionUnitList.clear();
	m_cbCityBonuses.clear();
	m_piYieldFromWin = NULL;
	m_piYieldForLoss = NULL;
	m_piCommerceFromWin = NULL;
	m_piCommerceForLoss = NULL;
	m_piPromotionDuration = NULL;
	m_piAllowPromotion = NULL;
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	m_piSecondaryUnitCombat = NULL;
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	m_piAffinities = NULL;
	m_piAffinityApplications = NULL;
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	m_piDenyPromotion = NULL;
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	CvDLLEntity::createUnitEntity(this);		// create and attach entity to unit

	reset(0, NO_UNIT, NO_PLAYER, true);
}


CvUnit::~CvUnit()
{
	if (!gDLL->GetDone() && GC.IsGraphicsInitialized())						// don't need to remove entity when the app is shutting down, or crash can occur
	{
		gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
		CvDLLEntity::removeEntity();		// remove entity from engine
	}

	CvDLLEntity::destroyEntity();			// delete CvUnitEntity and detach from us

	uninit();

	SAFE_DELETE_ARRAY(m_aiExtraDomainModifier);
}

void CvUnit::reloadEntity()
{

//FfH: Added by Kael 07/05/2009 (fixes a crash when promotions are applid before the game is loaded)
	bool bSelected = IsSelected();
//FfH: End Add

	//destroy old entity
	if (!gDLL->GetDone() && GC.IsGraphicsInitialized())						// don't need to remove entity when the app is shutting down, or crash can occur
	{
		gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
		CvDLLEntity::removeEntity();		// remove entity from engine
	}

	CvDLLEntity::destroyEntity();			// delete CvUnitEntity and detach from us

	//creat new one
	CvDLLEntity::createUnitEntity(this);		// create and attach entity to unit
	setupGraphical();

//FfH: Added by Kael 07/05/2009 (fixes a crash when promotions are applid before the game is loaded)
	if (bSelected)
	{
		gDLL->getInterfaceIFace()->selectUnit(this, false, false, false);
	}
//FfH: End Add

}


void CvUnit::init(int iID, UnitTypes eUnit, UnitAITypes eUnitAI, PlayerTypes eOwner, int iX, int iY, DirectionTypes eFacingDirection)
{
	CvWString szBuffer;
	int iUnitName;
	int iI, iJ;

	FAssert(NO_UNIT != eUnit);

	//--------------------------------
	// Init saved data
	reset(iID, eUnit, eOwner);

	if (eFacingDirection == NO_DIRECTION)
		m_eFacingDirection = DIRECTION_SOUTH;
	else
		m_eFacingDirection = eFacingDirection;

	//--------------------------------
	// Init containers

	//--------------------------------
	// Init pre-setup() data
	setXY(iX, iY, false, false);

	//--------------------------------
	// Init non-saved data
	setupGraphical();

	//--------------------------------
	// Init other game data
	plot()->updateCenterUnit();

	plot()->setFlagDirty(true);

	/*************************************************************************************************/
	/**	Flavor								01/19/09									Xienwolf	**/
	/**																								**/
	/**							Quotes and Images for Popups on special units						**/
	/*************************************************************************************************/
	/**								---- Start Original Code ----									**
		iUnitName = GC.getGameINLINE().getUnitCreatedCount(getUnitType());
		int iNumNames = m_pUnitInfo->getNumUnitNames();
		if (iUnitName < iNumNames)
		{
			int iOffset = GC.getGameINLINE().getSorenRandNum(iNumNames, "Unit name selection");

			for (iI = 0; iI < iNumNames; iI++)
			{
				int iIndex = (iI + iOffset) % iNumNames;
				CvWString szName = gDLL->getText(m_pUnitInfo->getUnitNames(iIndex));
				if (!GC.getGameINLINE().isGreatPersonBorn(szName))
				{
					setName(szName);
	/**								----  End Original Code  ----									**/
	CvWString szQuote = gDLL->getText(m_pUnitInfo->getQuote());
	setQuote(szQuote);
	iUnitName = GC.getGameINLINE().getUnitCreatedCount(getUnitType());
	int iNumNames = m_pUnitInfo->getNumUnitNames();
	int iNumQuotes = m_pUnitInfo->getNumQuotes();
	int iNumImages = m_pUnitInfo->getNumImages();
	if (iUnitName < iNumNames)
	{
		int iOffset = GC.getGameINLINE().getSorenRandNum(iNumNames, "Unit name selection");
		for (iI = 0; iI < iNumNames; iI++)
		{
			int iIndex = (iI + iOffset) % iNumNames;
			int iIndex2 = (iI + iOffset) % iNumQuotes;
			int iIndex3 = (iI + iOffset) % iNumImages;
			CvWString szName = gDLL->getText(m_pUnitInfo->getUnitNames(iIndex));
			szQuote = gDLL->getText(m_pUnitInfo->getQuotes(iIndex2));
			CvString szImage = m_pUnitInfo->getImages(iIndex3);
			if (!GC.getGameINLINE().isGreatPersonBorn(szName))
			{
				setName(szName);
				setQuote(szQuote);
				setImage(szImage);
				/*************************************************************************************************/
				/**	Flavor									END													**/
				/*************************************************************************************************/
				GC.getGameINLINE().addGreatPersonBornName(szName);
				break;
			}
		}
	}

	setGameTurnCreated(GC.getGameINLINE().getGameTurn());

	GC.getGameINLINE().incrementUnitCreatedCount(getUnitType());

	GC.getGameINLINE().incrementUnitClassCreatedCount((UnitClassTypes)(m_pUnitInfo->getUnitClassType()));
	GET_TEAM(getTeam()).changeUnitClassCount(((UnitClassTypes)(m_pUnitInfo->getUnitClassType())), 1);
	GET_PLAYER(getOwnerINLINE()).changeUnitClassCount(((UnitClassTypes)(m_pUnitInfo->getUnitClassType())), 1);

	GET_PLAYER(getOwnerINLINE()).changeExtraUnitCost(m_pUnitInfo->getExtraCost());

	/*************************************************************************************************/
	/**	EquipRedux								05/31/09								Xienwolf	**/
	/**			Adds the "Promotion Glow" to the unit, hard to see in forests otherwise				**/
	/**		Removes the need to add units for each equipment item introduced into the game			**/
	/*************************************************************************************************/
	if (getUnitType() == GC.getDefineINT("EQUIPMENT_HOLDER"))
	{
		gDLL->getEntityIFace()->showPromotionGlow(getUnitEntity(), true);
	}
	/*************************************************************************************************/
	/**	EquipRedux								END													**/
	/*************************************************************************************************/
	/*************************************************************************************************/
	/**	Upkeep									05/31/09								Xienwolf	**/
	/**																								**/
	/**	Since being flagged from UnitInfos won't run changeFreeUnit, need to update here instead	**/
	/*************************************************************************************************/
	if (m_pUnitInfo->isFreeUnit())
	{
		GET_PLAYER(getOwner()).changeBaseFreeUnits(1);
	}
	/*************************************************************************************************/
	/**	Upkeep									END													**/
	/*************************************************************************************************/
	if (m_pUnitInfo->getNukeRange() != -1)
	{
		GET_PLAYER(getOwnerINLINE()).changeNumNukeUnits(1);
	}

	if (m_pUnitInfo->isMilitarySupport())
	{
		GET_PLAYER(getOwnerINLINE()).changeNumMilitaryUnits(1);
	}

	GET_PLAYER(getOwnerINLINE()).changeAssets(m_pUnitInfo->getAssetValue());
	/*************************************************************************************************/
	/**	Unit power						17/02/12										Snarko		**/
	/**																								**/
	/**							Rewriting unit power system											**/
	/*************************************************************************************************/
	/**								---- Start Original Code ----									**
		//This is now handled by calculatePower() automatically
		GET_PLAYER(getOwnerINLINE()).changePower(m_pUnitInfo->getPowerValue());
	/**								----  End Original Code  ----									**/
	/*************************************************************************************************/
	/**	Unit power						END															**/
	/*************************************************************************************************/

	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (m_pUnitInfo->getFreePromotions(iI))
		{
			/*************************************************************************************************/
			/**	1.4										03/28/11								Valkrionn	**/
			/**																								**/
			/**									New tags required for 1.4									**/
			/*************************************************************************************************/
			int iStackAmount = m_pUnitInfo->getNumFreePromotions(iI);

			for (int iK = 0; iK < iStackAmount; iK++)
			{
				setHasPromotion(((PromotionTypes)iI), true);
			}
			/*************************************************************************************************/
			/**												END												**/
			/*************************************************************************************************/
		}
	}

	FAssertMsg((GC.getNumTraitInfos() > 0), "GC.getNumTraitInfos() is less than or equal to zero but is expected to be larger than zero in CvUnit::init");
	for (iI = 0; iI < GC.getNumTraitInfos(); iI++)
	{
		if (GET_PLAYER(getOwnerINLINE()).hasTrait((TraitTypes)iI))
		{
			for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
			{
				if (GC.getTraitInfo((TraitTypes)iI).isFreePromotion(iJ))
				{
					if ((getUnitCombatType() != NO_UNITCOMBAT) && GC.getTraitInfo((TraitTypes)iI).isFreePromotionUnitCombat(getUnitCombatType()))
					{
						setHasPromotion(((PromotionTypes)iJ), true);
					}
				}
			}
		}
	}

	if (NO_UNITCOMBAT != getUnitCombatType())
	{
		for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
		{
			if (GET_PLAYER(getOwnerINLINE()).isFreePromotion(getUnitCombatType(), (PromotionTypes)iJ))
			{
				setHasPromotion(((PromotionTypes)iJ), true);
			}
		}
	}

	if (NO_UNITCLASS != getUnitClassType())
	{
		for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
		{
			if (GET_PLAYER(getOwnerINLINE()).isFreePromotion(getUnitClassType(), (PromotionTypes)iJ))
			{
				setHasPromotion(((PromotionTypes)iJ), true);
			}
		}
	}

	if (getDomainType() == DOMAIN_LAND)
	{
		if (baseCombatStr() > 0)
		{
			if ((GC.getGameINLINE().getBestLandUnit() == NO_UNIT) || (baseCombatStr() > GC.getGameINLINE().getBestLandUnitCombat()))
			{
				GC.getGameINLINE().setBestLandUnit(getUnitType());
			}
		}
	}

	if (getOwnerINLINE() == GC.getGameINLINE().getActivePlayer())
	{
		gDLL->getInterfaceIFace()->setDirty(GameData_DIRTY_BIT, true);
	}

	//FfH: Added by Kael 11/05/2007
	if (isWorldUnitClass((UnitClassTypes)(m_pUnitInfo->getUnitClassType()))
		&& GC.getGameINLINE().getUnitClassCreatedCount((UnitClassTypes)(m_pUnitInfo->getUnitClassType())) == 1)
	{
		for (iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if (GET_PLAYER((PlayerTypes)iI).isAlive())
			{
				if (GET_TEAM(getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iI).getTeam()))
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_SOMEONE_CREATED_UNIT", GET_PLAYER(getOwnerINLINE()).getNameKey(), getNameKey());
					gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
				}
				else
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_UNKNOWN_CREATED_UNIT", getNameKey());
					gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"));
				}
			}
		}

		szBuffer = gDLL->getText("TXT_KEY_MISC_SOMEONE_CREATED_UNIT", GET_PLAYER(getOwnerINLINE()).getNameKey(), getNameKey());
		GC.getGameINLINE().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getOwnerINLINE(), szBuffer, getX_INLINE(), getY_INLINE(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"));
	}

	/*************************************************************************************************/
	/**	Sidar Mist 								25/06/10								Grey Fox	**/
	/*************************************************************************************************/
	int iPerception = GC.getDefineINT("UNIT_BASE_PERCEPTION");
	//iPerception += GC.getGameINLINE().getSorenRandNum(2, "RandomPerception") - 1;
	changePerception(iPerception + m_pUnitInfo->getExtraPerception());
	/*************************************************************************************************/
	/**	END                                                                   						**/
	/*************************************************************************************************/
	if(m_pUnitInfo->isCannotCapture())
	{
		changeCannotCapture(1);
	}
	if (m_pUnitInfo->isImmuneToCapture())
	{
		changeImmuneToCapture(1);
	}

	// Better Affinity - Valkrionn - 01/30/11 - Vastly improved Affinity system, open to many tags
	int iNumAffinities = m_pUnitInfo->getNumAffinities();
	if (iNumAffinities != 0)
	{
		for (iJ = 0; iJ < iNumAffinities; iJ++)
		{
			changeAffinities((AffinityTypes)m_pUnitInfo->getAffinities(iJ), 1);
		}
	}

	AI_init(eUnitAI);

	setSpawnPlot(GC.getMapINLINE().plotINLINE(iX, iY));

	if (getCivilizationType() == (CivilizationTypes)GC.getDefineINT("DEMON_CIVILIZATION"))
		changeExperience(GC.getGameINLINE().getGlobalCounter() * GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getDemonGlobalCounterFreeXPPercent());

	//FfH Units: Added by Kael 04/18/2008
	if (m_pUnitInfo->getFreePromotionPick() > 0)
	{
		changeFreePromotionPick(m_pUnitInfo->getFreePromotionPick());
		setPromotionReady(true);
	}
/*************************************************************************************************/
/**	WorldBreakers						01/05/09									Xienwolf	**/
/**																								**/
/**							Tracks AC Contributions on a player basis							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	GC.getGameINLINE().changeGlobalCounter(m_pUnitInfo->getModifyGlobalCounter());
/**								----  End Original Code  ----									**/
	GET_PLAYER(getOwner()).changeGlobalCounterContrib(m_pUnitInfo->getModifyGlobalCounter());
/*************************************************************************************************/
/**	WorldBreakers							END													**/
/*************************************************************************************************/
	m_iReligion = m_pUnitInfo->getReligionType();
	for (iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		changeBonusAffinity((BonusTypes)iI, m_pUnitInfo->getBonusAffinity((BonusTypes)iI));
	}
	if (m_pUnitInfo->isMechUnit())
	{
		changeAlive(1);
	}
	if (GC.getCivilizationInfo(getCivilizationType()).getDefaultRace() != NO_PROMOTION)
	{
		if (getRace() == NO_PROMOTION)
		{
			if (!::isWorldUnitClass(getUnitClassType()) && !isAnimal() && isAlive() && getDomainType() == DOMAIN_LAND)
			{
				setHasPromotion((PromotionTypes)GC.getCivilizationInfo(getCivilizationType()).getDefaultRace(), true);
			}
		}
	}
//FfH: End Add
/*************************************************************************************************/
/**	AutoBots								07/16/08								Xienwolf	**/
/**																								**/
/**				Automatically applies a Promotion if Unit meets conditions at creation			**/
/*************************************************************************************************/
	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isAutoAcquire() && canPromote((PromotionTypes)iI, -1))
		{
				promote(((PromotionTypes)iI), -1);
		}
	}
/*************************************************************************************************/
/**	AutoBots									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
	calculatePower();
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/

	CvEventReporter::getInstance().unitCreated(this);
}


void CvUnit::uninit()
{

//FfH Damage Types: Added by Kael 08/23/2007
	SAFE_DELETE_ARRAY(m_paiBonusAffinity);
	SAFE_DELETE_ARRAY(m_paiBonusAffinityAmount);
	SAFE_DELETE_ARRAY(m_paiDamageTypeCombat);
	SAFE_DELETE_ARRAY(m_paiDamageTypeResist);
//FfH: End Add

/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	SAFE_DELETE_ARRAY(m_pabHasPromotion);
/**								----  End Original Code  ----									**/
	SAFE_DELETE_ARRAY(m_paiHasPromotion);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiNoBadExploreImprovement);

	SAFE_DELETE_ARRAY(m_paiTerrainDoubleMoveCount);
	SAFE_DELETE_ARRAY(m_paiFeatureDoubleMoveCount);
	SAFE_DELETE_ARRAY(m_paiExtraTerrainAttackPercent);
	SAFE_DELETE_ARRAY(m_paiExtraTerrainDefensePercent);
	SAFE_DELETE_ARRAY(m_paiExtraFeatureAttackPercent);
	SAFE_DELETE_ARRAY(m_paiExtraFeatureDefensePercent);
	SAFE_DELETE_ARRAY(m_paiPlotEffectDoubleMoveCount);
	SAFE_DELETE_ARRAY(m_paiExtraPlotEffectAttackPercent);
	SAFE_DELETE_ARRAY(m_paiExtraPlotEffectDefensePercent);
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiTerrainCost);
	SAFE_DELETE_ARRAY(m_paiFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiExtraUnitCombatModifier);
	SAFE_DELETE_ARRAY(m_paiExtraSpellClassPower);
/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				05/15/08								Xienwolf	**/
/**																								**/
/**											Clears Arrays										**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pabRealPromotion);
	SAFE_DELETE_ARRAY(m_aiSupplementalPromotions);
	m_pSlaveUnitList.clear();
	m_pMinionUnitList.clear();
	m_cbCityBonuses.clear();
	SAFE_DELETE_ARRAY(m_piYieldFromWin);
	SAFE_DELETE_ARRAY(m_piYieldForLoss);
	SAFE_DELETE_ARRAY(m_piCommerceFromWin);
	SAFE_DELETE_ARRAY(m_piCommerceForLoss);
	m_aiInvisibleTypes.clear();
	m_aiSeeInvisibleTypes.clear();
	SAFE_DELETE_ARRAY(m_piPromotionDuration);
	SAFE_DELETE_ARRAY(m_piAllowPromotion);
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piSecondaryUnitCombat);
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piAffinities);
	SAFE_DELETE_ARRAY(m_piAffinityApplications);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_piDenyPromotion);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//Magic Rework
//	SAFE_DELETE_ARRAY(m_piSpellClassExtraPower);

}


// FUNCTION: reset()
// Initializes data members that are serialized.
void CvUnit::reset(int iID, UnitTypes eUnit, PlayerTypes eOwner, bool bConstructorCall)
{
	int iI;

	//--------------------------------
	// Uninit class
	uninit();

	m_iID = iID;
	m_iGroupID = FFreeList::INVALID_INDEX;
	m_iHotKeyNumber = -1;
	m_iX = INVALID_PLOT_COORD;
	m_iY = INVALID_PLOT_COORD;
	m_iLastMoveTurn = 0;
	m_iReconX = INVALID_PLOT_COORD;
	m_iReconY = INVALID_PLOT_COORD;
	m_iGameTurnCreated = 0;
	m_iDamage = 0;
	m_iMoves = 0;
	m_iExperience = 0;
	m_iLevel = 1;
	m_iCargo = 0;
	m_iAttackPlotX = INVALID_PLOT_COORD;
	m_iAttackPlotY = INVALID_PLOT_COORD;
	m_iCombatTimer = 0;
	m_iCombatFirstStrikes = 0;
	m_iFortifyTurns = 0;
	m_iBlitzCount = 0;
	m_iTradeDefenderCount = 0;
	m_iAmphibCount = 0;
	m_iRiverCount = 0;
	m_iEnemyRouteCount = 0;
	m_iAlwaysHealCount = 0;
	m_iHillsDoubleMoveCount = 0;
	m_iImmuneToFirstStrikesCount = 0;
	m_iExtraVisibilityRange = 0;
	m_iExtraMoves = 0;
	m_iExtraMoveDiscount = 0;
	m_iExtraAirRange = 0;
	m_iExtraIntercept = 0;
	m_iExtraEvasion = 0;
	m_iExtraFirstStrikes = 0;
	m_iExtraChanceFirstStrikes = 0;
	m_iExtraWithdrawal = 0;
	m_iExtraEnemyWithdrawal = 0;
	m_iExtraCollateralDamage = 0;
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	m_iExtraFlankingDamage = 0;
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	m_iExtraBombardRate = 0;
	m_iExtraEnemyHeal = 0;
	m_iExtraNeutralHeal = 0;
	m_iExtraFriendlyHeal = 0;
	m_iSameTileHeal = 0;
	m_iAdjacentTileHeal = 0;
	m_iExtraCombatPercent = 0;
	m_iExtraCombatPercentDefense = 0;
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/**		Ensures that stacked promotions are counted equally; Should have no gameplay change		**/
/*************************************************************************************************/
	m_iExtraRangedCombatPercent = 0;
	m_iRangedCombatPercentInBorders = 0;
	m_iRangedCombatPercentGlobalCounter = 0;
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	m_iExtraCityAttackPercent = 0;
	m_iExtraCityDefensePercent = 0;
	m_iExtraHillsAttackPercent = 0;
	m_iExtraHillsDefensePercent = 0;
	m_iRevoltProtection = 0;
	m_iCollateralDamageProtection = 0;
	m_iPillageChange = 0;
	m_iUpgradeDiscount = 0;
	m_iExperiencePercent = 0;
	m_iKamikazePercent = 0;
	m_eFacingDirection = DIRECTION_SOUTH;
	m_iImmobileTimer = 0;

/*************************************************************************************************/
/**	MobileCage								 6/17/2009								Cyther		**/
/**	Expanded by Valkrionn					01/28/2010											**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	m_iLeashX = INVALID_PLOT_COORD;
	m_iLeashY = INVALID_PLOT_COORD;
	m_LeashUnit.reset();
	m_iLeashRange = -1;
	m_iLeashChance = 0;
	m_iRandLeash = 0;
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	m_bLeveledImmortality = false;
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

	m_bMadeAttack = false;
	m_bMadeInterception = false;
	m_bPromotionReady = false;
	m_bDeathDelay = false;
	m_bCombatFocus = false;
	m_bInfoBarDirty = false;
	m_bBlockading = false;
	m_bAirCombat = false;

	m_eOwner = eOwner;
	m_eCapturingPlayer = NO_PLAYER;
	m_eUnitType = eUnit;
	m_pUnitInfo = (NO_UNIT != m_eUnitType) ? &GC.getUnitInfo(m_eUnitType) : NULL;
	m_iBaseCombat = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getCombat() : 0;
	m_eLeaderUnitType = NO_UNIT;
	m_iMaxExpReward = -1;
	m_iCargoCapacity = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getCargoSpace() : 0;

/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	m_bNonInfluence = false;
	m_bInfluence = false;
	m_iVictoryInfluenceModifier = 100;
	m_iDefeatInfluenceModifier = 100;
	m_iPillageInfluenceModifier = 100;
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	m_iPerception = 0;
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**	New Tag Defs	(UnitInfos)				05/15/08											**/
/**										Set Intial Values										**/
/*************************************************************************************************/
	m_iCommandLimit = 0;
	m_iCommandRange = 0;
	m_iCommandXPShareRate = 0;
	m_ePreviousOwner = NO_PLAYER;
	m_iNumPromotions = 0;
	m_iCommunalProperty = 0;
	m_iNeverHostile = 0;
	m_iBlind = 0;
	m_iStrBoost = 0;
	m_iCannotCast = 0;
	m_iFreeUnit = 0;
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	m_iPromotionBuild = 0;
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
	m_iNoSupply = 0;
	m_iTerritorial = 0;
	m_iRivalTerritoryExplore = 0;
	m_iRivalTerritoryBlock = 0;
	m_iPillageOnMove = 0;
	m_iSelfPillage = 0;
	m_iGetCasterXP = 0;
	m_iNonWarWeariness = 0;
	m_iNoMapReveal = 0;
	m_iCannotCapture = 0;
	m_iCityHappy = 0;
	m_iCityNoHappy = 0;
	m_iNoSupport = 0;
	m_iCanPillage = 0;
	m_iCannotPillage = 0;
	m_iCitySpy = 0;
	m_iStartGoldenAge = 0;
	m_iNoDefenseBonus = 0;
	m_iMoveImpassable = 0;
	m_iClimbPeaks = 0;
	m_iFlatMoveCost = 0;
	m_iIgnoreTerrainCosts = 0;
	m_iAttackNoWar = 0;
	m_iAllowAttacks = 0;
	m_iFirstStrikeVulnerable = 0;
	m_iAllowDefenseBonuses = 0;
	m_iNonAbandon = 0;
	m_iIndependant = 0;
	m_iAssetValue = 100;
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iPowerValue = 100;
/**								----  End Original Code  ----									**/
	m_iPower = 0;
	m_iPowerAdd = 0;
	m_iPowerMult = 0;
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	m_iTempUnitCombat = -1;
	m_iFreeXPCap = 0;
	m_fCasterXPRate = 0.0f;
	m_iAirCombat = 0;
	m_iAirCombatLimitBoost = 0;
	m_iExtraDropRange = 0;
	m_iSpellExtraRange = 0;
	m_iCombatConversionChance = 0;
	m_iCombatUnitGenerationChance = 0;
	m_iSlaveGenerationChance = 0;
	m_iGiftableXP = 0;
	m_iCombatExtraDuration = 0;
	m_iDurationPerTurn = 0;
	m_iChangeDuration = 0;
	m_bDisablePyDeath = false;
	m_bMustDie = false;
	m_bNullPromotionAvailable = false;
	m_bNonTemporary = false;
	m_iExtraSupport = 0;
	m_iChanceMiscast = 0;
	m_iCombatDmgCapBoost = 0;
	m_iCollateralLimitCap = 0;
	m_iCollateralLimitBoost = 0;
	m_iCollateralTargetsLimit = 0;
	m_iCollateralExtraTargets = 0;
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	m_iFlankingLimitBoost = 0;
	m_iFlankingExtraTargets = 0;
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	m_iHammerSacrifice = 0;
	m_iExtraHammerPerPop = 0;
	m_iFoodSacrifice = 0;
	m_iPopulationAdd = 0;
	m_iBeakerSacrifice = 0;
	m_iExtraBeakerPerPop = 0;
	m_iGoldSacrifice = 0;
	m_iExtraGoldPerPop = 0;
	m_iCultureSacrifice = 0;
	m_iExtraCulturePerPop = 0;
	m_iXPTranserRate = 0;
	m_iNumForcedMinions = 0;
	m_iCastingLimit = 0;
	m_szNewName.clear();
	m_MasterUnit.reset();
	m_pSlaveUnitList.clear();
	m_CommanderUnit.reset();
	m_pMinionUnitList.clear();
	m_iNumCityBonuses = 0;
	m_cbCityBonuses.clear();
	if (!bConstructorCall)
	{
		m_pabRealPromotion = new bool[GC.getNumPromotionInfos()];
		m_aiSupplementalPromotions = new int[GC.getNumPromotionInfos()];
		for(iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
		{
			m_pabRealPromotion[iI] = false;
			m_aiSupplementalPromotions[iI] = 0;
		}
		m_piYieldFromWin = new int[NUM_YIELD_TYPES];
		m_piYieldForLoss = new int[NUM_YIELD_TYPES];
		for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			m_piYieldFromWin[iI] = 0;
			m_piYieldForLoss[iI] = 0;
		}
		m_piCommerceFromWin = new int[NUM_COMMERCE_TYPES];
		m_piCommerceForLoss = new int[NUM_COMMERCE_TYPES];
		for (iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
		{
			m_piCommerceFromWin[iI] = 0;
			m_piCommerceForLoss[iI] = 0;
		}
		m_piPromotionDuration = new int[GC.getNumPromotionInfos()];
		m_piAllowPromotion = new int[GC.getNumPromotionInfos()];
		m_piDenyPromotion = new int[GC.getNumPromotionInfos()];
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			m_piPromotionDuration[iI] = 0;
			m_piAllowPromotion[iI] = 0;
			m_piDenyPromotion[iI] = 0;
		}
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
		m_piSecondaryUnitCombat = new int[GC.getNumUnitCombatInfos()];
		for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			m_piSecondaryUnitCombat[iI] = 0;
		}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
		m_piAffinities = new int[GC.getNumAffinityInfos()];
		m_piAffinityApplications = new int[GC.getNumAffinityInfos()];
		for (iI = 0; iI < GC.getNumAffinityInfos(); iI++)
		{
			m_piAffinities[iI] = 0;
			m_piAffinityApplications[iI] = 0;
		}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	}
	m_iSpawnPlotX = -1;
	m_iSpawnPlotY = -1;
	m_eSpawnImprovementType = NO_IMPROVEMENT;
	m_iNoBadExplore = 0;
	m_szQuote.clear();
	m_szImage.clear();
	m_bSuppressImage = false;
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Spell System: Added by Kael 07/23/2007
	m_bFleeWithdrawl = false;
	m_bHasCasted = false;
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_bIgnoreHide = false;
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	m_iAlive = 0;
	m_iEnraged = 0;
	m_iBoarding = 0;
	m_iDefensiveStrikeChance = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getDefensiveStrikeChance() : 0;
	m_iDefensiveStrikeDamage = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getDefensiveStrikeDamage() : 0;
	m_iDoubleFortifyBonus = 0;
	m_iFear = 0;
	m_iFlying = 0;
	m_iHeld = 0;
	m_iHiddenNationality = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->isHiddenNationality() : 0;
	m_iIgnoreBuildingDefense = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->isIgnoreBuildingDefense() : 0;
	m_iImmortal = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->isImmortal() : 0;
	m_iImmuneToCapture = 0;
	m_iImmuneToDefensiveStrike = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->isImmuneToDefensiveStrike() : 0;
	m_iImmuneToFear = 0;
	m_iImmuneToMagic = 0;
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iInvisible = 0;
	m_iOnlyDefensive = 0;
	m_iSeeInvisible = 0;
/**								----  End Original Code  ----									**/
	m_iOnlyDefensive = 0;
	m_iBetrayalChance = 0;
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	m_iTargetWeakestUnit = 0;
	m_iTargetWeakestUnitCounter = 0;
	m_iTwincast = 0;
	m_iWaterWalking = 0;
	m_iBaseCombatDefense = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getCombatDefense() : 0;
	m_iBetterDefenderThanPercent = 100;
	m_iCombatHealPercent = 0;
	m_iCombatLimit = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getCombatLimit() : 0;
	m_iCombatPercentInBorders = 0;
	m_iCombatPercentGlobalCounter = 0;
	m_iDelayedSpell = NO_SPELL;
	m_iDuration = 0;
	m_iFreePromotionPick = 0;
/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iGoldFromCombat = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getGoldFromCombat() : 0;
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	m_iGroupSize = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getGroupSize() : 0;
	m_iExtraGroupSize = 0;
/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iInvisibleType = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getInvisibleType() : 0;
/**								----  End Original Code  ----									**/
	if (NO_UNIT != m_eUnitType)
	{
		m_aiInvisibleTypes.clear();
		m_aiSeeInvisibleTypes.clear();
	//	for (iI = 0; iI < m_pUnitInfo->getNumSeeInvisibleTypes(); iI++)
	//	{
	//		m_aiSeeInvisibleTypes.push_back(m_pUnitInfo->getSeeInvisibleType(iI));
	//	}
	//	for (iI = 0; iI < m_pUnitInfo->getNumInvisibleTypes(); iI++)
	//	{
	//		m_aiInvisibleTypes.push_back(m_pUnitInfo->getInvisibleType(iI));
	//	}
		if (m_pUnitInfo->getInvisibleLevel() > 0)
		{
			m_aiInvisibleTypes.push_back(m_pUnitInfo->getInvisibleLevel());
		}
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	m_iRace = NO_PROMOTION;
	m_iGraphicalAddOnPromotion = NO_PROMOTION;
	m_iReligion = NO_RELIGION;
	m_iResist = 0;
	m_iResistModify = 0;
	m_iScenarioCounter = -1;
	m_iSpellCasterXP = 0;
	m_iSpellDamageModify = 0;
	m_iSummoner = -1;
	m_iTotalDamageTypeCombat = 0;
	m_iUnitArtStyleType = NO_UNIT_ARTSTYLE;
	m_iWorkRateModify = 0;
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	m_eAutoCast = NO_SPELL;
	m_bAutoCastPre = false;
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
	m_iNumInquisition = 0;
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
	m_iMissionSpell = NO_SPELL;

	if (!bConstructorCall)
	{
		m_paiDamageTypeCombat = new int[GC.getNumDamageTypeInfos()];
		m_paiDamageTypeResist = new int[GC.getNumDamageTypeInfos()];
		for (iI = 0; iI < GC.getNumDamageTypeInfos(); iI++)
		{
			int iChange = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getDamageTypeCombat(iI) : 0;
			m_paiDamageTypeCombat[iI] = iChange;
			m_paiDamageTypeResist[iI] = 0;
			m_iTotalDamageTypeCombat += iChange;
		}
		m_paiBonusAffinity = new int[GC.getNumBonusInfos()];
		m_paiBonusAffinityAmount = new int[GC.getNumBonusInfos()];
		for (iI = 0; iI < GC.getNumBonusInfos(); iI++)
		{
			m_paiBonusAffinity[iI] = 0;
			m_paiBonusAffinityAmount[iI] = 0;
		}
	}
//FfH: End Add

	m_combatUnit.reset();
	m_transportUnit.reset();

	for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		m_aiExtraDomainModifier[iI] = 0;
	}

	m_szName.clear();
	m_szScriptData ="";
	m_szReplaceArtDefineTag = "";
	m_szExtraArtDefineTag = "";
	m_szExtraArtDefineTag2 = "";
	m_szExtraArtDefineTag3 = "";

	if (!bConstructorCall)
	{
		FAssertMsg((0 < GC.getNumPromotionInfos()), "GC.getNumPromotionInfos() is not greater than zero but an array is being allocated in CvUnit::reset");
/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		m_pabHasPromotion = new bool[GC.getNumPromotionInfos()];
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			m_pabHasPromotion[iI] = false;
		}
/**								----  End Original Code  ----									**/
		m_paiHasPromotion = new int[GC.getNumPromotionInfos()];
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			m_paiHasPromotion[iI] = false;
		}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		FAssertMsg((0 < GC.getNumImprovementInfos()), "GC.getNumImprovementInfos() is not greater than zero but a float array is being allocated in CvUnit::reset");
		m_paiNoBadExploreImprovement = new int[GC.getNumImprovementInfos()];
		for (iI = 0; iI < GC.getNumImprovementInfos(); iI++)
		{
			m_paiNoBadExploreImprovement[iI] = 0;
		}
		FAssertMsg((0 < GC.getNumTerrainInfos()), "GC.getNumTerrainInfos() is not greater than zero but a float array is being allocated in CvUnit::reset");
		m_paiTerrainDoubleMoveCount = new int[GC.getNumTerrainInfos()];
		m_paiExtraTerrainAttackPercent = new int[GC.getNumTerrainInfos()];
		m_paiExtraTerrainDefensePercent = new int[GC.getNumTerrainInfos()];
		m_paiTerrainCost = new int[GC.getNumTerrainInfos()];				// GWS
		for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			m_paiTerrainDoubleMoveCount[iI] = 0;
			m_paiExtraTerrainAttackPercent[iI] = 0;
			m_paiExtraTerrainDefensePercent[iI] = 0;
			m_paiTerrainCost[iI] = 0;										// GWS
		}

		FAssertMsg((0 < GC.getNumFeatureInfos()), "GC.getNumFeatureInfos() is not greater than zero but a float array is being allocated in CvUnit::reset");
		m_paiFeatureDoubleMoveCount = new int[GC.getNumFeatureInfos()];
		m_paiExtraFeatureDefensePercent = new int[GC.getNumFeatureInfos()];
		m_paiExtraFeatureAttackPercent = new int[GC.getNumFeatureInfos()];
		m_paiFeatureCost = new int[GC.getNumFeatureInfos()];				// GWS
		for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			m_paiFeatureDoubleMoveCount[iI] = 0;
			m_paiExtraFeatureAttackPercent[iI] = 0;
			m_paiExtraFeatureDefensePercent[iI] = 0;
			m_paiFeatureCost[iI] = 0;										// GWS
		}
		FAssertMsg((0 < GC.getNumPlotEffectInfos()), "GC.getNumPlotEffectInfos() is not greater than zero but a float array is being allocated in CvUnit::reset");
		m_paiPlotEffectDoubleMoveCount = new int[GC.getNumPlotEffectInfos()];
		m_paiExtraPlotEffectDefensePercent = new int[GC.getNumPlotEffectInfos()];
		m_paiExtraPlotEffectAttackPercent = new int[GC.getNumPlotEffectInfos()];
		for (iI = 0; iI < GC.getNumPlotEffectInfos(); iI++)
		{
			m_paiPlotEffectDoubleMoveCount[iI] = 0;
			m_paiExtraPlotEffectAttackPercent[iI] = 0;
			m_paiExtraPlotEffectDefensePercent[iI] = 0;
		}

		FAssertMsg((0 < GC.getNumUnitCombatInfos()), "GC.getNumUnitCombatInfos() is not greater than zero but an array is being allocated in CvUnit::reset");
		m_paiExtraUnitCombatModifier = new int[GC.getNumUnitCombatInfos()];
		for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			m_paiExtraUnitCombatModifier[iI] = 0;
		}

		FAssertMsg((0 < GC.getNumSpellClassInfos()), "GC.getNu_mSpellClassInfos() is not greater than zero but an array is being allocated in CvUnit::reset");
		m_paiExtraSpellClassPower = new int[GC.getNumSpellClassInfos()];
		for (iI = 0; iI < GC.getNumSpellClassInfos(); iI++)
		{
			m_paiExtraSpellClassPower[iI] = 0;
		}
		AI_reset();
	}
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
	m_iPeakCost = 0;
	m_iHillCost = 0;

	m_iSpecialCargo = NO_SPECIALUNIT;
	m_iDomainCargo = NO_DOMAIN;
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
//Magic Rework
	m_iExtraMagicalPower = 0;
//	m_iExtraDominionCapacity = 0;
//	m_piSpellClassExtraPower = new int[GC.getNumSpellClassInfos()];
//	for (iI = 0; iI < GC.getNumSpellClassInfos(); iI++)
	//{
	//	m_piSpellClassExtraPower[iI] = 0;
	//}
}


//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvUnit::setupGraphical()
{
	if (!GC.IsGraphicsInitialized())
	{
		return;
	}

	CvDLLEntity::setup();

	if (getGroup()->getActivityType() == ACTIVITY_INTERCEPT)
	{
		airCircle(true);
	}
}


void CvUnit::convert(CvUnit* pUnit)
{
	CvPlot* pPlot = plot();

//FfH: Modified by Kael 08/21/2008
//	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
//	{
//		setHasPromotion(((PromotionTypes)iI), (pUnit->isHasPromotion((PromotionTypes)iI) || m_pUnitInfo->getFreePromotions(iI)));
//  }
	if (getRace() != NO_PROMOTION)
	{
		if (!m_pUnitInfo->getFreePromotions(getRace()))
		{
			setHasPromotion(((PromotionTypes)getRace()), false);
		}
//		else
//		{
//			pUnit->setHasPromotion(((PromotionTypes)getRace()), true);
//		}
		if (pUnit->getRace() != NO_PROMOTION)
		{
			setHasPromotion(((PromotionTypes)pUnit->getRace()), true);
		}
	}
	if (pUnit->isHasPromotion((PromotionTypes)GC.getDefineINT("HIDDEN_NATIONALITY_PROMOTION")))
	{
		CvUnit* pLoopUnit;
		CLLNode<IDInfo>* pUnitNode;
		pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->getTeam() != getTeam())
			{
				pUnit->setHasPromotion((PromotionTypes)GC.getDefineINT("HIDDEN_NATIONALITY_PROMOTION"), false);
			}
		}
	}
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (pUnit->isHasPromotion((PromotionTypes)iI))
		{
			if (iI == GC.getDefineINT("MUTATED_PROMOTION"))
			{
/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				m_pabHasPromotion[iI] = pUnit->isHasPromotion((PromotionTypes)iI);
/**								----  End Original Code  ----									**/
				m_paiHasPromotion[iI] = pUnit->isHasPromotion((PromotionTypes)iI);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
			}
			else
			{
				for(int k=0;k<pUnit->countHasPromotion((PromotionTypes)iI);++k)
				{
					setHasPromotion(((PromotionTypes)iI), true);
					if (GC.getPromotionInfo((PromotionTypes)iI).isEquipment())
					{
/*************************************************************************************************/
/**	Xienwolf Tweak							03/27/09											**/
/**																								**/
/**							Disables Special Removal Effects on Promotions						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
					pUnit->setHasPromotion((PromotionTypes)iI, false);
/**								----  End Original Code  ----									**/
						pUnit->setHasPromotion((PromotionTypes)iI, false, true);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
					}
				}
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).isValidate())
			{
/*************************************************************************************************/
/**	PromotionExcludes					12/07/08									Xienwolf	**/
/**																								**/
/**				Clears Promotions which the unit is no longer allowed to possess				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				if (!GC.getPromotionInfo((PromotionTypes)iI).getUnitCombat(getUnitCombatType()))
/**								----  End Original Code  ----									**/
				if ((isDenyPromotion((PromotionTypes)iI) ||
					(GC.getPromotionInfo((PromotionTypes)iI).isRequirePermission() && !isAllowPromotion((PromotionTypes)iI))) ||
					(!isAllowPromotion((PromotionTypes)iI) && !(GC.getPromotionInfo((PromotionTypes)iI).getUnitCombat(getUnitCombatType()) || (getUnitCombatType() == NO_UNITCOMBAT && GC.getPromotionInfo((PromotionTypes)iI).isAllowNULLUnitCombat()))) ||
					(GC.getPromotionInfo((PromotionTypes)iI).getPrereqWeaponTier() != 0 && (m_pUnitInfo->getWeaponTierMax() < GC.getPromotionInfo((PromotionTypes)iI).getPrereqWeaponTier() || m_pUnitInfo->getWeaponTierMin() > GC.getPromotionInfo((PromotionTypes)iI).getPrereqWeaponTier())))
/*************************************************************************************************/
/**	PromotionExcludes						END													**/
/*************************************************************************************************/
				{
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
					bool bSecondaryJob = false;
					for (int iK = 0; iK < GC.getNumUnitCombatInfos(); iK++)
					{
						if (isSecondaryUnitCombat((UnitCombatTypes)iK) && GC.getPromotionInfo((PromotionTypes)iI).getUnitCombat(iK))
						{
							bSecondaryJob = true;
						}
					}
					if (!bSecondaryJob)
					{
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
						for(int k=0;k<countHasPromotion((PromotionTypes)iI);++k)
						{
							setHasPromotion(((PromotionTypes)iI), false);
						}
					}
				}
			}
/*************************************************************************************************/
/**	AutoBots								07/16/08								Xienwolf	**/
/**																								**/
/**				Automatically applies/removes a Promotion when Unit meets conditions			**/
/*************************************************************************************************/
			if (isHasPromotion((PromotionTypes)iI) && GC.getPromotionInfo((PromotionTypes)iI).isMustMaintain() && !canAcquirePromotion((PromotionTypes)iI,true) && !m_pUnitInfo->getFreePromotions(iI))
			{
				for(int k=0;k<countHasPromotion((PromotionTypes)iI);++k)
				{
					setHasPromotion(((PromotionTypes)iI), false);
				}
			}

			if (GC.getPromotionInfo((PromotionTypes)iI).isAutoAcquire() && canPromote((PromotionTypes)iI, -1))
			{
				promote(((PromotionTypes)iI), -1);
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).isLeashed()|| GC.getPromotionInfo((PromotionTypes)iI).getLeashRange()>=0) 
			{
				setHasPromotion((PromotionTypes)iI, false);
			}
/*************************************************************************************************/
/**	AutoBots									END												**/
/*************************************************************************************************/
		}
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							10/03/08											**/
/**																								**/
/**						No longer need the DLL to directly handle Weapon upgrades				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (GC.getDefineINT("WEAPON_PROMOTION_TIER1") != -1 && isHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER1")))
	{
		if (m_pUnitInfo->getWeaponTier() < 1 || isHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER2")) || isHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER3")))
		{
			setHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER1"), false);
		}
	}
	if (GC.getDefineINT("WEAPON_PROMOTION_TIER2") != -1 && isHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER2")))
	{
		if (m_pUnitInfo->getWeaponTier() < 2 || isHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER3")))
		{
			setHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER2"), false);
		}
	}
	if (GC.getDefineINT("WEAPON_PROMOTION_TIER3") != -1 && isHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER3")))
	{
		if (m_pUnitInfo->getWeaponTier() < 3)
		{
			setHasPromotion((PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER3"), false);
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (m_pUnitInfo->getFreePromotionPick() > 0 && getGameTurnCreated() == GC.getGameINLINE().getGameTurn())
	{
		setPromotionReady(true);
	}
	setDuration(pUnit->getDuration());
/*************************************************************************************************/
/**	New Tag Defs	(UnitInfos)				01/22/09								Xienwolf	**/
/**																								**/
/**							Transfers Unit Information on Conversion							**/
/*************************************************************************************************/
	setPreviousOwner(pUnit->getPreviousOwner());
	if (pUnit->getOwner() == getOwner())
	{
		if (pUnit->getNumSlaves() > 0)
		{
			std::list<int> slaveUnits = pUnit->getAllSlaveUnits();
			for (std::list<int>::const_iterator iter = slaveUnits.begin(); iter != slaveUnits.end(); ++iter)
			{
				getUnit(IDInfo(getOwner(),*iter))->getMasterUnit()->removeSlaveUnit(pUnit->getID());
				getUnit(IDInfo(getOwner(),*iter))->setMasterUnit(getIDInfo());
				addSlaveUnit(*iter);
			}
		}

		if (pUnit->getMasterUnit() != NULL)
		{
			setMasterUnit(pUnit->getMasterUnit()->getIDInfo());
			pUnit->getMasterUnit()->addSlaveUnit(getID());
		}

		if (pUnit->getNumMinions() > 0)
		{
			std::list<int> minionUnits = pUnit->getAllMinionUnits();
			for (std::list<int>::const_iterator iter = minionUnits.begin(); iter != minionUnits.end(); ++iter)
			{
				addMinionUnit(*iter);
			}
		}
		if (pUnit->getCommanderUnit() != NULL)
		{
			pUnit->getCommanderUnit()->addMinionUnit(getID());
		}
	}
	else
	{
		if (pUnit->getMasterUnit() != NULL)
		{
			setMustDie(true);
		}
	}
	setSpawnPlot(pUnit->getSpawnPlot());
	changeStrBoost(pUnit->getStrBoost());
	setSuppressImage(pUnit->isSuppressImage());

	if (pUnit->getReligion() != NO_RELIGION && getReligion() == NO_RELIGION)
	{
		setReligion(pUnit->getReligion());
	}
	if (pUnit->isImmortal())
	{
		pUnit->changeImmortal(-1);
	}
	if (pUnit->isHasCasted())
	{
		setHasCasted(true);
	}
	if (pUnit->getScenarioCounter() != -1)
	{
		setScenarioCounter(pUnit->getScenarioCounter());
	}

	setGameTurnCreated(pUnit->getGameTurnCreated());

	// Snarko - Higher hitpoints - 07/04/11 - Makes higher values than 100 HP possible.
	setDamageReal(pUnit->getDamageReal(), NO_PLAYER, false);

	setMoves(pUnit->getMoves());
	setLevel(pUnit->getLevel());
	int iOldModifier = std::max(1, 100 + GET_PLAYER(pUnit->getOwnerINLINE()).getLevelExperienceModifier());
	int iOurModifier = std::max(1, 100 + GET_PLAYER(getOwnerINLINE()).getLevelExperienceModifier());
	setExperience(std::max(0, (pUnit->getExperience() * iOurModifier) / iOldModifier));

	setName(pUnit->getNameNoDesc());
	setLeaderUnitType(pUnit->getLeaderUnitType());

	//FfH: Added by Kael 10/03/2008
	if (!isWorldUnitClass((UnitClassTypes)(m_pUnitInfo->getUnitClassType())) && isWorldUnitClass((UnitClassTypes)(pUnit->getUnitClassType())))
		setName(pUnit->getName());

/*************************************************************************************************/
/**	UnitStatistics							07/18/08	Written: Teg Navanis Imported: Xienwolf	**/
/**																								**/
/**					This copies the unit statistics when a unit is converted					**/
/*************************************************************************************************/
	if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
	{
		setScriptData(pUnit->getScriptData());
		ReportEventToPython(pUnit, "unitConverted");
	}
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/
	CvUnit* pTransportUnit = pUnit->getTransportUnit();
	if (pTransportUnit != NULL)
	{
		pUnit->setTransportUnit(NULL);
		setTransportUnit(pTransportUnit);
	}

	std::vector<CvUnit*> aCargoUnits;
	pUnit->getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
/*************************************************************************************************/
/**	Tweak					 	   10/04/10									Snarko				**/
/**																								**/
/**			Fixes a potential CtD with units loaded on the unit they're converting to			**/
/**							Mostly caused by flying units on water								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		aCargoUnits[i]->setTransportUnit(this);
/**								----  End Original Code  ----									**/
		if (aCargoUnits[i] != this)
		{
			aCargoUnits[i]->setTransportUnit(this);
		}
		else
		{
			setTransportUnit(NULL);
		}
/*************************************************************************************************/
/**	Tweak								END														**/
/*************************************************************************************************/
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							01/23/09											**/
/**																								**/
/**					Ensures that a unit is properly deleted during conversion					**/
/*************************************************************************************************/
	pUnit->setMustDie(true);
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (pUnit->isHasPromotion((PromotionTypes)iI))
		{
			pUnit->setHasPromotion((PromotionTypes)iI, false, true);
		}
	}
	pUnit->changeImmortal(-1);
	pUnit->setDisablePyDeath(true);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	pUnit->kill(true);
}


// Python must NOT kill the unit during this process
void CvUnit::kill(bool bDelay, PlayerTypes ePlayer)
{
	PROFILE_FUNC();

	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pTransportUnit;
	CvUnit* pLoopUnit;
	CvPlot* pPlot;
	CvWString szBuffer;
	PlayerTypes eCapturingPlayer;
	UnitTypes eCaptureUnitType;
	int iRace = getRace();

	pPlot = plot();
	FAssertMsg(pPlot != NULL, "Plot is not assigned a valid value");

	static std::vector<IDInfo> oldUnits;
	oldUnits.clear();
	pUnitNode = pPlot->headUnitNode();

	while (pUnitNode != NULL)
	{
		oldUnits.push_back(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
	}

	// When placed after delay death check, setting recon plot was failing to update vision. Why... I'm not 100% sure. Null unit on second call, is my guess.
	setReconPlot(NULL);
	setBlockading(false);

	// DeathPython - Xienwolf - 12/07/08 - Relocated Immortal Rebirth to pre-empt announcement of death
	// Runs a Python function on the death of a unit, be careful not to call kill on the unit during the python unless you disable the python call
	if (isImmortal())
	{
		if (doImmortalRebirth())
		{
			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if (GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_UNIT_REBORN", getNameKey(), getVisualCivAdjective(GET_PLAYER((PlayerTypes)iI).getTeam()));
					gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_MAJOR_EVENT);
				}
			}
			m_bDeathDelay = false;
		   return;
		}
	}
	if (!CvString(GC.getUnitInfo(getUnitType()).getPyDeath()).empty() && !isDisablePyDeath())
	{
		setDisablePyDeath(true);
		CyUnit* pyCaster = new CyUnit(this);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));
		argsList.add(ePlayer);
		argsList.add(getUnitType());
		long lResult=0;
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "postDeath", argsList.makeFunctionArgs(), &lResult);
		delete pyCaster;
		if (lResult == 1)
		{
			m_bDeathDelay = false;
			return;
		}
	}

	setMustDie(true);
	eCapturingPlayer = getCapturingPlayer();

	//FfH: Modified by Kael 09/01/2007
	//	eCaptureUnitType = ((eCapturingPlayer != NO_PLAYER) ? getCaptureUnitType(GET_PLAYER(eCapturingPlayer).getCivilizationType()) : NO_UNIT);
	eCaptureUnitType = ((eCapturingPlayer != NO_PLAYER) ? getCaptureUnitType(GET_PLAYER(getOwnerINLINE()).getCivilizationType()) : NO_UNIT);
	if (m_pUnitInfo->getUnitCaptureClassType() == getUnitClassType())
	{
		eCaptureUnitType = (UnitTypes)getUnitType();
	}
	CvUnit* pCombatUnit = getCombatUnit();
	if (pCombatUnit != NULL && pCombatUnit->getOwner() == eCapturingPlayer)
	{
		for (int iprom = 0; iprom < GC.getNumPromotionInfos(); iprom++)
		{
			if (pCombatUnit->isHasPromotion((PromotionTypes)iprom) && GC.getPromotionInfo((PromotionTypes)iprom).getCaptureUnitClass() != NO_UNITCLASS)
			{
				eCaptureUnitType = (UnitTypes)GC.getCivilizationInfo(GET_PLAYER(eCapturingPlayer).getCivilizationType()).getCivilizationUnits((UnitClassTypes)GC.getPromotionInfo((PromotionTypes)iprom).getCaptureUnitClass());
				if (eCaptureUnitType == NO_UNIT)
				{
					eCaptureUnitType = (UnitTypes)GC.getUnitClassInfo((UnitClassTypes)GC.getPromotionInfo((PromotionTypes)iprom).getCaptureUnitClass()).getDefaultUnitIndex();
				}
			}
		}
	}

	for (uint i = 0; i < oldUnits.size(); i++)
	{
		pLoopUnit = ::getUnit(oldUnits[i]);

		if (pLoopUnit != NULL)
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				//save old units because kill will clear the static list
				std::vector<IDInfo> tempUnits = oldUnits;

				if (pPlot->isValidDomainForLocation(*pLoopUnit))
				{
					pLoopUnit->setCapturingPlayer(NO_PLAYER);
				}

				pLoopUnit->kill(false, ePlayer);

				oldUnits = tempUnits;
			}
		}
	}

	// Point of no return; everything before this should be OK to trigger repeatedly, after, trigger only once
	if (bDelay)
	{
		startDelayedDeath();
		return;
	}

	if (GET_PLAYER(getOwner()).isBarbarian())
	{
		if (getCombatUnit() != NULL)
		{
			CvUnit* pKiller = getCombatUnit();
			if (pKiller->isTradeDefender())
			{
				CvString szError;

				// szError.Format("found a trade defender ");
				// gDLL->logMsg("tradedef.log", szError);
				CvCity* pClosestCity = GC.getMapINLINE().findCity(getX_INLINE(), getY_INLINE(), pKiller->getOwner());

				// szError.Format("closest city is %s",pClosestCity->getName().c_str());
				// gDLL->logMsg("tradedef.log", szError);
				if (pClosestCity != NULL)
				{
					for (int eIndex = 0; eIndex < GC.getDefineINT("MAX_TRADE_ROUTES"); eIndex++)
					{
						CvCity* pTradeCity = pClosestCity->getTradeCity(eIndex);
						if (pTradeCity != NULL)
						{
							int	eLoopPlayer = pTradeCity->getOwner();
							//	szError.Format("closest city is in trade with player  %i",eLoopPlayer);
							//	gDLL->logMsg("tradedef.log", szError);
							//	szError.Format("attitude before is  %i",GET_PLAYER((PlayerTypes)eLoopPlayer).AI_getAttitudeVal((PlayerTypes)pKiller->getOwner()));
							//	gDLL->logMsg("tradedef.log", szError);
							//	szError.Format(" trade attitude before is  %i",GET_PLAYER((PlayerTypes)eLoopPlayer).getTradeDefenderAttitudeByPlayer((PlayerTypes)pKiller->getOwner()));
							//	gDLL->logMsg("tradedef.log", szError);
							GET_PLAYER((PlayerTypes)eLoopPlayer).changeTradeDefenderAttitudeByPlayer((PlayerTypes)pKiller->getOwner(), 1);
							GET_PLAYER((PlayerTypes)eLoopPlayer).changeTradeDefenderDecayByPlayer((PlayerTypes)pKiller->getOwner(), 10);
							//	szError.Format("attitude after is  %i",GET_PLAYER((PlayerTypes)eLoopPlayer).AI_getAttitudeVal((PlayerTypes)pKiller->getOwner()));
							//	gDLL->logMsg("tradedef.log", szError);
							//	szError.Format(" trade attitude before is  %i",GET_PLAYER((PlayerTypes)eLoopPlayer).getTradeDefenderAttitudeByPlayer((PlayerTypes)pKiller->getOwner()));
							//	gDLL->logMsg("tradedef.log", szError);
						}
					}
				}
			}
		}
	}

	if (ePlayer != NO_PLAYER)
	{
		
		TraitTriggeredData kTriggerData;
		if (getCombatUnit() != NULL)
		{
			CvUnit* pKiller = getCombatUnit();
			kTriggerData.m_iUnitClass = pKiller->getUnitClassType();
			kTriggerData.m_iUnitCombat = pKiller->getUnitCombatType();
			// kTriggerData.eLevel = pKiller->getLevel();
			kTriggerData.m_iRace = (PromotionTypes)pKiller->getRace();
			kTriggerData.m_iReligion = GET_PLAYER(pKiller->getOwner()).getStateReligion();
			kTriggerData.m_iAlignment = GET_PLAYER(pKiller->getOwner()).getBroadAlignment();
			kTriggerData.m_iEthicalAlignment = GET_PLAYER(pKiller->getOwner()).getBroadEthicalAlignment();
			kTriggerData.m_iAlignmentStatus = GET_PLAYER(pKiller->getOwner()).getAlignment();
			kTriggerData.m_iEthicalAlignmentStatus = GET_PLAYER(pKiller->getOwner()).getEthicalAlignment();
			kTriggerData.m_bWerewolf = pKiller->isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_WEREWOLF"));
			kTriggerData.m_bUndead = pKiller->isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_UNDEAD"));
			kTriggerData.m_bHero = pKiller->isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_HERO"));
			kTriggerData.m_bHiddenNationality = pKiller->isHiddenNationality();
			kTriggerData.m_bInBorders = pKiller->getOwner() == pKiller->plot()->getOwner();
			kTriggerData.m_bOutsideBorders = pKiller->getOwner() != pKiller->plot()->getOwner();
		}

		kTriggerData.m_iKilledUnitClass = getUnitClassType();
		kTriggerData.m_iKilledUnitCombat = getUnitCombatType();
		// kTriggerData.m_iKilledLevel = getLevel();
		kTriggerData.m_iKilledRace = (PromotionTypes)getRace();
		// kTriggerData.m_iKilledReligion = GET_PLAYER(getOwner()).getStateReligion();
		kTriggerData.m_iKilledAlignment = GET_PLAYER(getOwner()).getBroadAlignment();
		kTriggerData.m_iKilledEthicalAlignment = GET_PLAYER(getOwner()).getBroadEthicalAlignment();
		kTriggerData.m_iKilledAlignmentStatus = GET_PLAYER(getOwner()).getAlignment();
		kTriggerData.m_iKilledEthicalAlignmentStatus = GET_PLAYER(getOwner()).getEthicalAlignment();
		kTriggerData.m_bKilledWerewolf = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_WEREWOLF"));
		kTriggerData.m_bKilledUndead = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_UNDEAD"));
		kTriggerData.m_bKilledHero = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_HERO"));
		kTriggerData.m_bKilledHiddenNationality = isHiddenNationality();
		kTriggerData.m_bKilledInBorders = getOwner() == plot()->getOwner();
		kTriggerData.m_bKilledOutsideBorders = getOwner() != plot()->getOwner();

		GET_PLAYER(ePlayer).doTraitTriggers(TRAITHOOK_KILL_UNIT, &kTriggerData);
		GET_PLAYER(getOwner()).doTraitTriggers(TRAITHOOK_UNIT_KILLED, &kTriggerData);
		// DynTraits End

		CvEventReporter::getInstance().unitKilled(this, ePlayer);

		if (NO_UNIT != getLeaderUnitType())
		{
			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if (GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_GENERAL_KILLED", getNameKey());
					gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_MAJOR_EVENT);
				}
			}
		}
	}

	// WorldBreakers - Xienwolf - 01/05/09 - Tracks AC Contributions on a player basis
	if (ePlayer == NO_PLAYER)
	{
		GET_PLAYER(getOwner()).changeGlobalCounterContrib(-1 * m_pUnitInfo->getModifyGlobalCounter());
	}
	else
	{
		GET_PLAYER(ePlayer).changeGlobalCounterContrib(-1 * m_pUnitInfo->getModifyGlobalCounter());
	}


	// Xienwolf - 10/03/08 - Removes all Promotions to ensure nothing added elsewhere via promotion is forgottten (& place equipment)
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			PromotionTypes ePromotion = (PromotionTypes)iI;

			// EquipRedux - Xienwolf - 05/31/09 - Removes promotions from the unit and spawns minimal containers to hold them
			if (GC.getPromotionInfo(ePromotion).isEquipment() && getUnitType() != GC.getDefineINT("EQUIPMENT_HOLDER"))
			{
				if (ePromotion != NO_PROMOTION)
				{
					bool bPlaced = false;
					pUnitNode = pPlot->headUnitNode();
					while (pUnitNode != NULL)
					{
						pLoopUnit = ::getUnit(pUnitNode->m_data);
						pUnitNode = pPlot->nextUnitNode(pUnitNode);

						if (pLoopUnit->getUnitType() == GC.getDefineINT("EQUIPMENT_HOLDER"))
						{
							pLoopUnit->setHasPromotion(ePromotion, true);
							bPlaced = true;
						}
					}
					if(!bPlaced)
					{
						pLoopUnit = GET_PLAYER(ORC_PLAYER).initUnit((UnitTypes)GC.getDefineINT("EQUIPMENT_HOLDER"), pPlot->getX(), pPlot->getY());
						pLoopUnit->setHasPromotion(ePromotion, true);
					}
				}
			}

			setHasPromotion(ePromotion, false, true);
		}
	}

	if (isWorldUnitClass((UnitClassTypes)(m_pUnitInfo->getUnitClassType())) && GC.getGameINLINE().getUnitClassCreatedCount((UnitClassTypes)(m_pUnitInfo->getUnitClassType())) == 1)
	{
		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if (GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).isHuman() && getOwner() != iI)
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_SOMEONE_KILLED_UNIT", getNameKey());
				gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
			}
		}
	}
	int iLoop;
	for (pLoopUnit = GET_PLAYER(getOwnerINLINE()).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(getOwnerINLINE()).nextUnit(&iLoop))
	{
		if (pLoopUnit->getSummoner() == getID())
		{
			pLoopUnit->setSummoner(-1);
		}
	}

	if (isMadeAttack() && nukeRange() != -1)
	{
		CvPlot* pTarget = getAttackPlot();
		if (pTarget)
		{
			pTarget->nukeExplosion(nukeRange(), this);
			setAttackPlot(NULL, false);
		}
	}

	finishMoves();

	if (IsSelected())
	{
		if (gDLL->getInterfaceIFace()->getLengthSelectionList() == 1)
		{
			if (!(gDLL->getInterfaceIFace()->isFocused()) && !(gDLL->getInterfaceIFace()->isCitySelection()) && !(gDLL->getInterfaceIFace()->isDiploOrPopupWaiting()))
			{
				GC.getGameINLINE().updateSelectionList();
			}

			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setCycleSelectionCounter(1);
			}
			else
			{
				gDLL->getInterfaceIFace()->setDirty(SelectionCamera_DIRTY_BIT, true);
			}
		}
	}

	gDLL->getInterfaceIFace()->removeFromSelectionList(this);

	// XXX this is NOT a hack, without it, the game crashes.
	gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
	setCombatUnit(NULL);
	FAssertMsg(!isCombat(), "isCombat did not return false as expected");

	pTransportUnit = getTransportUnit();

	if (pTransportUnit != NULL)
	{
		setTransportUnit(NULL);
	}

	FAssertMsg(getAttackPlot() == NULL, "The current unit instance's attack plot is expected to be NULL");
	FAssertMsg(getCombatUnit() == NULL, "The current unit instance's combat unit is expected to be NULL");

	GET_TEAM(getTeam()).changeUnitClassCount((UnitClassTypes)m_pUnitInfo->getUnitClassType(), -1);
	GET_PLAYER(getOwnerINLINE()).changeUnitClassCount((UnitClassTypes)m_pUnitInfo->getUnitClassType(), -1);

	GET_PLAYER(getOwnerINLINE()).changeExtraUnitCost(-(m_pUnitInfo->getExtraCost()));

	// Upkeep - Xienwolf - 07/10/08 - Removes Free Upkeep from Summons on Death
	if (isFreeUnit())
	{
		changeFreeUnit(-1);
	}
	if (isNoSupply())
	{
		changeNoSupply(-1);
	}

	// Spawn plot tracking for lair improvements (Xienwolf original implementation, Blaze edit 08/2025)
	if (getSpawnPlot()->getImprovementType() != NO_IMPROVEMENT)
	{
		if (GC.getImprovementInfo(getSpawnPlot()->getImprovementType()).getImmediateSpawnUnitType() == getUnitType()
		 || GC.getImprovementInfo(getSpawnPlot()->getImprovementType()).getSpawnUnitType() == getUnitType())
		{
			getSpawnPlot()->changeNumLairSpawnsAlive(-1);
		}
	}

	if (m_pUnitInfo->getNukeRange() != -1)
	{
		GET_PLAYER(getOwnerINLINE()).changeNumNukeUnits(-1);
	}

	// MilSupport - Xienwolf - 05/15/08 - Prevents Reduction in Military Support Level of Civ on Unit Death
	if (m_pUnitInfo->isMilitarySupport() && !isNoSupport())
	{
		GET_PLAYER(getOwnerINLINE()).changeNumMilitaryUnits(-1);
	}

	GET_PLAYER(getOwnerINLINE()).changeAssets(-(m_pUnitInfo->getAssetValue()));

	// Unit power - Snarko - 17/02/12 - Rewriting unit power system. Old: .changePower(-(m_pUnitInfo->getPowerValue()));
	GET_PLAYER(getOwnerINLINE()).changePower(-(getPower()));

	GET_PLAYER(getOwnerINLINE()).AI_changeNumAIUnits(AI_getUnitAIType(), -1);

	// Whiplash - Xienwolf - 07/23/08 - Clears record of the Summon from the Master Unit so he may summon a replacement
	// Sets all Units Summoned by the MasterUnit to die at the start of next turn
	if (getMasterUnit() != NULL)
	{
		if (getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL"))
		{
			if (GET_PLAYER(getOwnerINLINE()).getSummonDuration() > 0)
			{
				getMasterUnit()->changeExperience(getExperience() / 2, -1, false, false, false);
			}
			else
			{
				getMasterUnit()->changeExperience(getExperience() / 4, -1, false, false, false);
			}
		}
		getMasterUnit()->removeSlaveUnit(getID());
		getMasterUnit()->getGroup()->clearMissionQueue();
		getMasterUnit()->getGroup()->setActivityType(ACTIVITY_AWAKE);

	}
	if (getNumSlaves() > 0)
	{
		std::list<int> slaveUnits = getAllSlaveUnits();
		for (std::list<int>::const_iterator iter = slaveUnits.begin(); iter != slaveUnits.end(); ++iter)
		{
			getUnit(IDInfo(getOwner(),*iter))->setMustDie(true);
		}
	}
	if (getCommanderUnit() != NULL)
	{
		getCommanderUnit()->getGroup()->clearMissionQueue();
		getCommanderUnit()->getGroup()->setActivityType(ACTIVITY_AWAKE);
		getCommanderUnit()->removeMinionUnit(getID());
	}
	if (getNumMinions() > 0)
	{
		std::list<int> minionUnits = getAllMinionUnits();
		for (std::list<int>::const_iterator iter = minionUnits.begin(); iter != minionUnits.end(); ++iter)
		{
			removeMinionUnit(*iter);
		}
	}


	setXY(INVALID_PLOT_COORD, INVALID_PLOT_COORD, true);

	joinGroup(NULL, false, false);

	CvEventReporter::getInstance().unitLost(this);

	GET_PLAYER(getOwnerINLINE()).deleteUnit(getID());

	// FfH: Modified by Kael 01/19/2008 (Can capture barbs)
	if ((eCapturingPlayer != NO_PLAYER) && (eCaptureUnitType != NO_UNIT))
	{
		if (GET_PLAYER(eCapturingPlayer).isHuman() || GET_PLAYER(eCapturingPlayer).AI_captureUnit(eCaptureUnitType, pPlot) || 0 == GC.getDefineINT("AI_CAN_DISBAND_UNITS"))
		{
			CvUnit* pkCapturedUnit = GET_PLAYER(eCapturingPlayer).initUnit(eCaptureUnitType, pPlot->getX_INLINE(), pPlot->getY_INLINE());

			//FfH: Added by Kael 08/18/2008
			if (pkCapturedUnit->getRace() != NO_PROMOTION)
			{
				pkCapturedUnit->setHasPromotion((PromotionTypes)pkCapturedUnit->getRace(), false);
			}
			if (iRace != NO_PROMOTION)
			{
				pkCapturedUnit->setHasPromotion((PromotionTypes)iRace, true);
			}
			//FfH: End Add

			if (pkCapturedUnit != NULL)
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_CAPTURED_UNIT", GC.getUnitInfo(eCaptureUnitType).getTextKeyWide());
				gDLL->getInterfaceIFace()->addMessage(eCapturingPlayer, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNITCAPTURE", MESSAGE_TYPE_INFO, pkCapturedUnit->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

				// Add a captured mission
				CvMissionDefinition kMission;
				kMission.setMissionTime(GC.getMissionInfo(MISSION_CAPTURED).getTime() * gDLL->getSecsPerTurn());
				kMission.setUnit(BATTLE_UNIT_ATTACKER, pkCapturedUnit);
				kMission.setUnit(BATTLE_UNIT_DEFENDER, NULL);
				kMission.setPlot(pPlot);
				kMission.setMissionType(MISSION_CAPTURED);
				gDLL->getEntityIFace()->AddMission(&kMission);

				pkCapturedUnit->finishMoves();

				if (!GET_PLAYER(eCapturingPlayer).isHuman())
				{
					CvPlot* pPlot = pkCapturedUnit->plot();
					if (pPlot && !pPlot->isCity(false))
					{
						if (GET_PLAYER(eCapturingPlayer).AI_getAnyPlotDanger(pPlot) && GC.getDefineINT("AI_CAN_DISBAND_UNITS")
							//FfH: Added by Kael 12/02/2007
						  && pkCapturedUnit->canScrap())
						{
							pkCapturedUnit->kill(false);
						}
					}
				}
			}
		}
	}
}


void CvUnit::NotifyEntity(MissionTypes eMission)
{
	gDLL->getEntityIFace()->NotifyEntity(getUnitEntity(), eMission);
}


void CvUnit::doTurn()
{
	PROFILE("CvUnit::doTurn()");

	FAssertMsg(!isDead(), "isDead did not return false as expected");
	FAssertMsg(getGroup() != NULL, "getGroup() is not expected to be equal with NULL");

	// EquipRedux - Xienwolf - 05/31/09
	// Cleanup function for cases where somehow the container is empty and alive
	// Removes the need to add units for each equipment item introduced into the game
	if(getUnitType() == GC.getDefineINT("EQUIPMENT_HOLDER"))
	{
		if(getNumPromotions() < 1)
		{
			kill(false);
		}
		return;
		//No reason to run any functions found in this routine for containers, most should be blocked anyway, those which are not would cause issues.
	}
	validateCommanderMinion();

	// PyPromote - Grey Fox, Xienwolf - 04/08/08 - Allows Python Functions to be run each Turn
	if (!CvString(GC.getUnitInfo(getUnitType()).getPyPerTurn()).empty())
	{
		CyUnit* pyUnit = new CyUnit(this);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
		argsList.add(getUnitType());//the unittype #
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "effectUnits", argsList.makeFunctionArgs()); //, &lResult
		delete pyUnit; // python fxn must not hold on to this pointer
	}

	// NOTE: It may be possible, if xml is altered, for the unit to be killed by DoT on terrain / plot effects!
	// This method takes into account healing and turn DoT effects both
	changeDamageReal(-calcTurnHealthChangeReal());

	if (!hasMoved() && !isCargo())
		changeFortifyTurns(1);

	int iI;
	CvPlot* pPlot = plot();

/*************************************************************************************************/
/**	NonAbandon 								05/15/08								Xienwolf	**/
/**							Blocks Abandonment Check from Happening								**/
/**						This is called before promotions can Wear off							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_pUnitInfo->isAbandon())
/**								----  End Original Code  ----									**/
	if (m_pUnitInfo->isAbandon() && !(isNonAbandon()))
/*************************************************************************************************/
/**	NonAbandon 									END												**/
/*************************************************************************************************/
	{
		if (!isBarbarian())
		{
			bool bValid = true;
			if (m_pUnitInfo->getPrereqCivic() != NO_CIVIC)
			{
				bValid = false;
				for (int iI = 0; iI < GC.getDefineINT("MAX_CIVIC_OPTIONS"); iI++)
				{
					if (GET_PLAYER(getOwnerINLINE()).getCivics((CivicOptionTypes)iI) == m_pUnitInfo->getPrereqCivic())
					{
						bValid = true;
					}
				}
				if (GET_PLAYER(getOwnerINLINE()).isAnarchy())
				{
					bValid = true;
				}
			}
			if (bValid == true)
			{
				if (m_pUnitInfo->getStateReligion() != NO_RELIGION)
				{
					bValid = false;
					if (GET_PLAYER(getOwnerINLINE()).getStateReligion() == m_pUnitInfo->getStateReligion())
					{
						bValid = true;
					}
				}
			}
			if (bValid == false)
			{
				gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwnerINLINE(), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), gDLL->getText("TXT_KEY_MESSAGE_UNIT_ABANDON", getNameKey()), GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), plot()->getX_INLINE(), plot()->getY_INLINE());
				kill(true);
				GC.getGameINLINE().decrementUnitCreatedCount(getUnitType());
				GC.getGameINLINE().decrementUnitClassCreatedCount((UnitClassTypes)(m_pUnitInfo->getUnitClassType()));
				return;
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**				These steps are already completed as a part of "kill(true);"					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				GET_TEAM(getTeam()).changeUnitClassCount(((UnitClassTypes)(m_pUnitInfo->getUnitClassType())), -1);
				GET_PLAYER(getOwnerINLINE()).changeUnitClassCount(((UnitClassTypes)(m_pUnitInfo->getUnitClassType())), -1);
				GET_PLAYER(getOwnerINLINE()).changeExtraUnitCost(m_pUnitInfo->getExtraCost() * -1);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
			}
		}
	}
	if (getSpellCasterXP() > 0)
	{
		/*************************************************************************************************/
		/**	DecimalXP							11/21/08									Xienwolf	**/
		/**																								**/
		/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
		/*************************************************************************************************/
		if (getSpellCasterXP() > getExperience())
		{
			int iXPGain = (int)((10000 * (1 + getCasterXPRate())) / ((GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent() / 50) * (getExperience() + 100)));
			changeExperience(std::max((int)(5 * (1 + getCasterXPRate())), iXPGain), -1, false, false, false);
			/*************************************************************************************************/
			/**	DecimalXP									END												**/
			/*************************************************************************************************/
		}
	}

	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
/*************************************************************************************************/
/**	Xienwolf Tweak							11/21/08											**/
/**				Prevents exploitation of Puppets with Summoner Trait Feedback					**/
/**							Ensures that risky spells are always SOME risk						**/
/**								Prevents pointless AI Control Sessions							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			if (GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn() != 0)
			{
				if (getExperience() < GC.getDefineINT("FREE_XP_MAX"))
				{
					changeExperience(GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn(), -1, false, false, false);
				}
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply() != NO_PROMOTION)
			{
				if (!isHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply()))
				{
					if (GC.getGameINLINE().getSorenRandNum(100, "Promotion Random Apply") <= 3)
					{
						setHasPromotion(((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply()), true);
					}
				}
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getBetrayalChance() != 0)
			{
				if (!isImmuneToCapture() && !isBarbarian() && !GC.getGameINLINE().isOption(GAMEOPTION_NO_BARBARIANS))
				{
					if (GC.getGameINLINE().getSorenRandNum(100, "Betrayal Chance") <= GC.getPromotionInfo((PromotionTypes)iI).getBetrayalChance())
					{
						betray(BARBARIAN_PLAYER);
					}
				}
			}
/**								----  End Original Code  ----									**/
			if (GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn() != 0 && getDuration() == 0)
			{
				if (getExperience() < getFreeXPCap())
				{
					changeExperience(GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn() * 100 / GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent(), -1, false, false, false);
				}
			}
			
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply() != NO_PROMOTION)
			{
				if (!isHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply()))
				{
					if (GC.getGameINLINE().getSorenRandNum(100, "Promotion Random Apply") <= GC.getPromotionInfo((PromotionTypes)iI).getRandomApplyChance())
					{
						setHasPromotion(((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply()), true);
					}
				}
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).isEnraged())
			{
				if (area()->getNumUnownedTiles() == 0 && area()->getNumCities() == area()->getCitiesPerPlayer(getOwner()))
				{
					setHasPromotion(((PromotionTypes)iI), false);
				}
			}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	TickTock							11/04/08									Xienwolf	**/
/**																								**/
/**				Establishes set duration and allows chance of expiration after that time		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			if (GC.getPromotionInfo((PromotionTypes)iI).getExpireChance() != 0)
			{
/**								----  End Original Code  ----									**/
			int iPromDuration = getPromotionDuration((PromotionTypes)iI);
			if (iPromDuration != 0)
			{
				setPromotionDuration((PromotionTypes)iI, iPromDuration-1);
				if (iPromDuration == 1 && GC.getPromotionInfo((PromotionTypes)iI).getExpireChance() == 0)
				{
					setHasPromotion(((PromotionTypes)iI), false);
				}
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getExpireChance() != 0 && getTruePromotionDuration((PromotionTypes)iI) == 0)
			{
/*************************************************************************************************/
/**	TickTock									END												**/
/*************************************************************************************************/
				if (GC.getGameINLINE().getSorenRandNum(100, "Promotion Expire") <= GC.getPromotionInfo((PromotionTypes)iI).getExpireChance())
				{
					setHasPromotion(((PromotionTypes)iI), false);
				}
			}
			if (!isHurt())
			{
				if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedWhenHealed())
				{
					setHasPromotion(((PromotionTypes)iI), false);
				}
			}
/*************************************************************************************************/
/**	AutoBots								07/16/08								Xienwolf	**/
/**																								**/
/**				Automatically applies/removes a Promotion when Unit meets conditions			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak								29/01/12										Snarko	**/
/**																								**/
/**		With so many promotions we don't want to check them all if we can avoid it.				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			testPromotionReady();
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
			if (isHasPromotion((PromotionTypes)iI) && GC.getPromotionInfo((PromotionTypes)iI).isMustMaintain() && !canAcquirePromotion((PromotionTypes)iI,true) && !m_pUnitInfo->getFreePromotions(iI))
			{
				for(int k=0;k<countHasPromotion((PromotionTypes)iI);++k)
				{
					setHasPromotion(((PromotionTypes)iI), false);
				}
			}
			if (isHasPromotion((PromotionTypes)iI) && !CvString(GC.getPromotionInfo((PromotionTypes)iI).getPyPerTurn()).empty())
			{
				CyUnit* pyUnit = new CyUnit(this);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
				argsList.add(iI);//the promotion #
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "effect", argsList.makeFunctionArgs()); //, &lResult
				delete pyUnit; // python fxn must not hold on to this pointer
			}

		}

		if (GC.getPromotionInfo((PromotionTypes)iI).isAutoAcquire() && canPromote((PromotionTypes)iI, -1))
		{
			promote(((PromotionTypes)iI), -1);
		}
	
/*************************************************************************************************/
/**	AutoBots									END												**/
/*************************************************************************************************/
	}
	
	if (getBetrayalChance() > 0
	 && !isBarbarian()
	 && GC.getGameINLINE().getSorenRandNum(100, "Betrayal Chance") <= getBetrayalChance())
	{
		if (isImmuneToCapture())
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_LOYAL_TRIGGERED", getNameKey());
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_MELTDOWN", MESSAGE_TYPE_INFO,
				m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_HIGHLIGHT_TEXT"), getX_INLINE(), getY_INLINE());

			for (int iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
			{
				if (isHasPromotion((PromotionTypes)iJ) && GC.getPromotionInfo((PromotionTypes)iJ).isImmuneToCapture())
				{
					setHasPromotion(((PromotionTypes)iJ), false);
					break;
				}
			}
		}
		else if (GC.getGameINLINE().isOption(GAMEOPTION_NO_BARBARIANS))
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_LOYAL_TO_DEATH", getNameKey());
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_MELTDOWN", MESSAGE_TYPE_INFO,
				m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_HIGHLIGHT_TEXT"), getX_INLINE(), getY_INLINE());

			kill(true);
		}
		else
			betray(ORC_PLAYER);
	}


	setHasCasted(false);
/*************************************************************************************************/
/**	Xienwolf Tweak							10/07/08											**/
/**						Allows Twincast to cast a seperate spell, and stack						**/
/**						Gameoption to disable Automatic Worker XP gain							**/
/*************************************************************************************************/
	setCastingLimit(getTwincast());
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (getDuration() > 0)
	{
/*************************************************************************************************/
/**	Renewing								05/19/08								Xienwolf	**/
/**																								**/
/**					Includes new variable with natural duration decay							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		changeDuration(-1);
		if (getDuration() == 0)
		{
			if (isImmortal())
			{
				changeImmortal(-1);
			}
			kill(true);
		}
	}
/**								----  End Original Code  ----									**/
		changeDuration(getDurationPerTurn() - 1);
		if (getDuration() == 0)
		{
			if (isImmortal())
			{
				changeImmortal(-1);
			}
			setMustDie(true);
		}
	}

	if (getDuration() < 0 || isMustDie())
	{
		unloadAll();
		kill(true);
/*************************************************************************************************/
/**	Tweak							09/05/10								Snarko				**/
/**																								**/
/**						The unit is dead, no need to continue here								**/
/*************************************************************************************************/
		return;
/*************************************************************************************************/
/**	Tweak										END												**/
/*************************************************************************************************/
	}
/*************************************************************************************************/
/**	Renewing									END												**/
/*************************************************************************************************/
	if (pPlot->isCity())
	{
		for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			if (pPlot->getPlotCity()->getNumBuilding((BuildingTypes)iI) > 0)
			{
				if (GC.getBuildingInfo((BuildingTypes)iI).getRemovePromotion() != NO_PROMOTION)
				{
					if (isHasPromotion((PromotionTypes)GC.getBuildingInfo((BuildingTypes)iI).getRemovePromotion()))
					{
						setHasPromotion((PromotionTypes)GC.getBuildingInfo((BuildingTypes)iI).getRemovePromotion(), false);
					}
				}
				if (GC.getBuildingInfo((BuildingTypes)iI).isApplyFreePromotionOnMove())
				{
					if (GC.getBuildingInfo((BuildingTypes)iI).getFreePromotion() != NO_PROMOTION)
					{
						if ((getUnitCombatType() != NO_UNITCOMBAT) && GC.getPromotionInfo((PromotionTypes)GC.getBuildingInfo((BuildingTypes)iI).getFreePromotion()).getUnitCombat(getUnitCombatType()))
						{
							setHasPromotion((PromotionTypes)GC.getBuildingInfo((BuildingTypes)iI).getFreePromotion(), true);
						}
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
						for (int iK = 0; iK < GC.getNumUnitCombatInfos(); iK++)
						{
							if ((getUnitCombatType() != NO_UNITCOMBAT) && isSecondaryUnitCombat((UnitCombatTypes)iK) && GC.getPromotionInfo((PromotionTypes)GC.getBuildingInfo((BuildingTypes)iI).getFreePromotion()).getUnitCombat(iK))
							{
								setHasPromotion((PromotionTypes)GC.getBuildingInfo((BuildingTypes)iI).getFreePromotion(), true);
							}
						}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
					}
				}
			}
		}
/*************************************************************************************************/
/**	Xienwolf Tweak							10/03/08											**/
/**						No longer need the DLL to directly handle Weapon upgrades				**/
/**						Autoraze is not required to keep the horsemen roaming					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (m_pUnitInfo->getWeaponTier() > 0)
		{
			setWeapons();
		}
		if (isBarbarian())
		{
			if (m_pUnitInfo->isAutoRaze())
			{
				if (pPlot->getOwner() == getOwnerINLINE())
				{
					pPlot->getPlotCity()->kill(true);
				}
			}
		}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	}
/*************************************************************************************************/
/**	Tweak							11/05/10								Snarko				**/
/**																								**/
/**				No longer needed as spell casting is handled in a better way					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!isHuman())
	{
		int iSpell = chooseSpell();
		if (iSpell != NO_SPELL)
		{
			cast(iSpell);
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (m_pUnitInfo->isImmortal())
	{
		if (!isImmortal())
		{
			changeImmortal(1);
		}
	}
//FfH: End Add

/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**				Allows spending of XP beyond the number of promotions normally available		**/
/**						Enhances AI Aggression with Immortal Units								**/
/**					Enhances Animal Strength as they remain untouched							**/
/*************************************************************************************************/
	if (isImmortal() && !GET_PLAYER((PlayerTypes)getOwner()).isHuman() && canAttack())
	{
		AI_setUnitAIType(UNITAI_ATTACK_CITY);
	}
/*************************************************************************************************/
/**	Tweak								29/01/12										Snarko	**/
/**																								**/
/**		With so many promotions we don't want to check them all if we can avoid it.				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	setNullPromoteAvailable(false);
	if (!canAcquirePromotionAny())
	{
		setNullPromoteAvailable(getUnitCombatType() != NO_UNITCOMBAT);
	}
/**								----  End Original Code  ----									**/
	setNullPromoteAvailable(getUnitCombatType() != NO_UNITCOMBAT);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	if (getTeam() == ANIMAL_TEAM)
	{
		for (int n=0;n<GC.getDefineINT("MAX_ANIMAL_ESCALATIONS");n++)
		{
			if ((GC.getGameINLINE().getGameTurn() - getGameTurnCreated()) - (n+1)*(GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAnimalEscalationTurnsElapsed() * GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent() / 100) == 0)
			{
				changeStrBoost(1);
			}
		}
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	testPromotionReady();

	if (isBlockading())
	{
		collectBlockadeGold();
	}

	// FfH: Modified by Kael 02/03/2009 (spy intercept and feature damage commented out for performance, healing moved to earlier in the function)
	// if (isSpy() && isIntruding() && !isCargo())
	// {
	// 	TeamTypes eTeam = plot()->getTeam();
	// 	if (NO_TEAM != eTeam)
	// 	{
	// 		if (GET_TEAM(getTeam()).isOpenBorders(eTeam))
	// 		{
	// 			testSpyIntercepted(plot()->getOwnerINLINE(), GC.getDefineINT("ESPIONAGE_SPY_NO_INTRUDE_INTERCEPT_MOD"));
	// 		}
	// 		else
	// 		{
	// 			testSpyIntercepted(plot()->getOwnerINLINE(), GC.getDefineINT("ESPIONAGE_SPY_INTERCEPT_MOD"));
	// 		}
	// 	}
	// }

/*************************************************************************************************/
/**	MobileCage								 6/17/2009								Cyther		**/
/**	Expanded by Valkrionn					01/28/2010											**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	if (getLeashChance() > 0)
	{
		if (getRandLeash() > 0)
		{
			changeLeashRange(0 - getRandLeash());
		}
		setRandLeash(0);
		setRandLeash(GC.getGameINLINE().getSorenRandNum(getLeashChance(), "LeashChance"));
		changeLeashRange(getRandLeash());
	}
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	if (isLeveledImmortality())
	{
		int iImmortality = (getLevel() * 50);
		if (iImmortality > 950)
		{
				iImmortality = 950;
		}
		if (isImmortal())
		{
				changeImmortal(-1);
		}
		if (GC.getGameINLINE().getSorenRandNum(1000, "Death") < iImmortality)
		{
				changeImmortal(1);
		}
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	updateAffinity();
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/

	changeImmobileTimer(-1);

	setMadeAttack(false);
	setMadeInterception(false);

	setReconPlot(NULL);

	setMoves(0);
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	if (isAutoCast(true))
	{
		if (canCast((int)getAutoCast(), false))
		{
			cast((int)getAutoCast());
		}
	}

/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
}


void CvUnit::updateAirStrike(CvPlot* pPlot, bool bQuick, bool bFinish)
{
	bool bVisible = false;

	if (!bFinish)
	{
		if (isFighting())
		{
			return;
		}

		if (!bQuick)
		{
			bVisible = isCombatVisible(NULL);
		}

		if (!airStrike(pPlot))
		{
			return;
		}

		if (bVisible)
		{
			CvAirMissionDefinition kAirMission;
			kAirMission.setMissionType(MISSION_AIRSTRIKE);
			kAirMission.setUnit(BATTLE_UNIT_ATTACKER, this);
			kAirMission.setUnit(BATTLE_UNIT_DEFENDER, NULL);
			kAirMission.setDamage(BATTLE_UNIT_DEFENDER, 0);
			kAirMission.setDamage(BATTLE_UNIT_ATTACKER, 0);
			kAirMission.setPlot(pPlot);
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGameINLINE().incrementTurnTimer(getCombatTimer());
			kAirMission.setMissionTime(getCombatTimer() * gDLL->getSecsPerTurn());

			if (pPlot->isActiveVisible(false))
			{
				gDLL->getEntityIFace()->AddMission(&kAirMission);
			}

			return;
		}
	}

	CvUnit *pDefender = getCombatUnit();
	if (pDefender != NULL)
	{
		pDefender->setCombatUnit(NULL);
	}
	setCombatUnit(NULL);
	setAttackPlot(NULL, false);

	getGroup()->clearMissionQueue();

	if (isSuicide() && !isDead())
	{
		kill(true);
	}
}

void CvUnit::resolveAirCombat(CvUnit* pInterceptor, CvPlot* pPlot, CvAirMissionDefinition& kBattle)
{
	CvWString szBuffer;

	int iTheirStrength = (DOMAIN_AIR == pInterceptor->getDomainType() ? pInterceptor->airCurrCombatStr(this) : pInterceptor->currCombatStr(NULL, NULL));
	int iOurStrength = (DOMAIN_AIR == getDomainType() ? airCurrCombatStr(pInterceptor) : currCombatStr(NULL, NULL));
	int iTotalStrength = iOurStrength + iTheirStrength;
	if (0 == iTotalStrength)
	{
		FAssert(false);
		return;
	}

/********************************************************************************/
/* 	BETTER_BTS_AI_MOD						10/19/08	Roland J & jdog5000	*/
/* 																			*/
/* 	Combat mechanics														*/
/********************************************************************************/
	/*
	int iOurOdds = (100 * iOurStrength) / std::max(1, iTotalStrength);

	int iOurRoundDamage = (pInterceptor->currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
	int iTheirRoundDamage = (currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
	if (getDomainType() == DOMAIN_AIR)
	{
		iTheirRoundDamage = std::max(GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"), iTheirRoundDamage);
	}

	//original BTS code
	int iTheirDamage = 0;
	int iOurDamage = 0;

	for (int iRound = 0; iRound < GC.getDefineINT("INTERCEPTION_MAX_ROUNDS"); ++iRound)
	*/
	// For air v air, more rounds and factor in strength for per round damage
	int iOurOdds = (100 * iOurStrength) / std::max(1, iTotalStrength);
	int iMaxRounds = 0;
	int iOurRoundDamage = 0;
	int iTheirRoundDamage = 0;

	// Air v air is more like standard comabt
	// Round damage in this case will now depend on strength and interception probability
	if( GC.getBBAI_AIR_COMBAT() && (DOMAIN_AIR == pInterceptor->getDomainType() && DOMAIN_AIR == getDomainType()) )
	{
		int iBaseDamage = GC.getDefineINT("AIR_COMBAT_DAMAGE");
		int iOurFirepower = ((airMaxCombatStr(pInterceptor) + iOurStrength + 1) / 2);
		int iTheirFirepower = ((pInterceptor->airMaxCombatStr(this) + iTheirStrength + 1) / 2);

		int iStrengthFactor = ((iOurFirepower + iTheirFirepower + 1) / 2);

		int iTheirInterception = std::max(pInterceptor->maxInterceptionProbability(),2*GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"));
		int iOurInterception = std::max(maxInterceptionProbability(),2*GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"));

		iOurRoundDamage = std::max(1, ((iBaseDamage * (iTheirFirepower + iStrengthFactor) * iTheirInterception) / ((iOurFirepower + iStrengthFactor) * 100)));
		iTheirRoundDamage = std::max(1, ((iBaseDamage * (iOurFirepower + iStrengthFactor) * iOurInterception) / ((iTheirFirepower + iStrengthFactor) * 100)));

		iMaxRounds = 2*GC.getDefineINT("INTERCEPTION_MAX_ROUNDS") - 1;
	}
	else
	{
		iOurRoundDamage = (pInterceptor->currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
		iTheirRoundDamage = (currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
		if (getDomainType() == DOMAIN_AIR)
		{
			iTheirRoundDamage = std::max(GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"), iTheirRoundDamage);
		}

		iMaxRounds = GC.getDefineINT("INTERCEPTION_MAX_ROUNDS");
	}

	int iTheirDamage = 0;
	int iOurDamage = 0;

	for (int iRound = 0; iRound < iMaxRounds; ++iRound)
/********************************************************************************/
/* 	BETTER_BTS_AI_MOD						END								*/
/********************************************************************************/
	{
		if (GC.getGameINLINE().getSorenRandNum(100, "Air combat") < iOurOdds)
		{
			if (DOMAIN_AIR == pInterceptor->getDomainType())
			{
				iTheirDamage += iTheirRoundDamage;
				pInterceptor->changeDamage(iTheirRoundDamage, getOwnerINLINE());
				if (pInterceptor->isDead())
				{
					break;
				}
			}
		}
		else
		{
			iOurDamage += iOurRoundDamage;
			changeDamage(iOurRoundDamage, pInterceptor->getOwnerINLINE());
			if (isDead())
			{
				break;
			}
		}
	}

	if (isDead())
	{
		if (iTheirRoundDamage > 0)
		{
			int iExperience = attackXPValue();
			iExperience = (iExperience * iOurStrength) / std::max(1, iTheirStrength);
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			iExperience = range(iExperience, GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), GC.getDefineINT("MAX_EXPERIENCE_PER_COMBAT"));
			pInterceptor->changeExperience(iExperience, maxXPValue(), true, pPlot->getOwnerINLINE() == pInterceptor->getOwnerINLINE(), !isBarbarian());
/**								----  End Original Code  ----									**/
			iExperience = range(iExperience, GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), GC.getDefineINT("MAX_EXPERIENCE_PER_COMBAT")*100);
			pInterceptor->changeExperience(iExperience, maxXPValue(), true, pPlot->getOwnerINLINE() == pInterceptor->getOwnerINLINE(), !isBarbarian(), true);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
		}
	}
	else if (pInterceptor->isDead())
	{
		int iExperience = pInterceptor->defenseXPValue();
		iExperience = (iExperience * iTheirStrength) / std::max(1, iOurStrength);
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		iExperience = range(iExperience, GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), GC.getDefineINT("MAX_EXPERIENCE_PER_COMBAT"));
		changeExperience(iExperience, pInterceptor->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pInterceptor->isBarbarian());
/**								----  End Original Code  ----									**/
		iExperience = range(iExperience, GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), GC.getDefineINT("MAX_EXPERIENCE_PER_COMBAT")*100);
		changeExperience(iExperience, pInterceptor->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pInterceptor->isBarbarian(), true);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
	}
	else if (iOurDamage > 0)
	{
		if (iTheirRoundDamage > 0)
		{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			pInterceptor->changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL"), maxXPValue(), true, pPlot->getOwnerINLINE() == pInterceptor->getOwnerINLINE(), !isBarbarian());
/**								----  End Original Code  ----									**/
			pInterceptor->changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, maxXPValue(), true, pPlot->getOwnerINLINE() == pInterceptor->getOwnerINLINE(), !isBarbarian(), true);
			changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, pInterceptor->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pInterceptor->isBarbarian(), true);
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
		}
	}
	else if (iTheirDamage > 0)
	{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL"), pInterceptor->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pInterceptor->isBarbarian());
	}

/**								----  End Original Code  ----									**/
		changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, pInterceptor->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pInterceptor->isBarbarian(), true);
		pInterceptor->changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, maxXPValue(), true, pPlot->getOwnerINLINE() == pInterceptor->getOwnerINLINE(), !isBarbarian(), true);
	}
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	UnitStatistics							07/18/08	Written: Teg Navanis Imported: Xienwolf	**/
/**																								**/
/**							Sends Aerial Interception Information to Python						**/
/*************************************************************************************************/
	if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
	{
		ReportEventToPython(pInterceptor, iOurDamage, iTheirDamage, "airIntercept");
	}
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/
	kBattle.setDamage(BATTLE_UNIT_ATTACKER, iOurDamage);
	kBattle.setDamage(BATTLE_UNIT_DEFENDER, iTheirDamage);
}


void CvUnit::updateAirCombat(bool bQuick)
{
	CvUnit* pInterceptor = NULL;
	bool bFinish = false;

	FAssert(getDomainType() == DOMAIN_AIR || getDropRange() > 0);

	if (getCombatTimer() > 0)
	{
		changeCombatTimer(-1);

		if (getCombatTimer() > 0)
		{
			return;
		}
		else
		{
			bFinish = true;
		}
	}

	CvPlot* pPlot = getAttackPlot();
	if (pPlot == NULL)
	{
		return;
	}

	if (bFinish)
	{
		pInterceptor = getCombatUnit();
	}
	else
	{
		pInterceptor = bestInterceptor(pPlot);
	}


	if (pInterceptor == NULL)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);

		getGroup()->clearMissionQueue();

		return;
	}

	//check if quick combat
	bool bVisible = false;
	if (!bQuick)
	{
		bVisible = isCombatVisible(pInterceptor);
	}

	//if not finished and not fighting yet, set up combat damage and mission
	if (!bFinish)
	{
		if (!isFighting())
		{
			if (plot()->isFighting() || pPlot->isFighting())
			{
				return;
			}

			setMadeAttack(true);

			setCombatUnit(pInterceptor, true);
			pInterceptor->setCombatUnit(this, false);
		}

		FAssertMsg(pInterceptor != NULL, "Defender is not assigned a valid value");

		FAssertMsg(plot()->isFighting(), "Current unit instance plot is not fighting as expected");
		FAssertMsg(pInterceptor->plot()->isFighting(), "pPlot is not fighting as expected");

		CvAirMissionDefinition kAirMission;
		if (DOMAIN_AIR != getDomainType())
		{
			kAirMission.setMissionType(MISSION_PARADROP);
		}
		else
		{
			kAirMission.setMissionType(MISSION_AIRSTRIKE);
		}
		kAirMission.setUnit(BATTLE_UNIT_ATTACKER, this);
		kAirMission.setUnit(BATTLE_UNIT_DEFENDER, pInterceptor);

		resolveAirCombat(pInterceptor, pPlot, kAirMission);

		if (!bVisible)
		{
			bFinish = true;
		}
		else
		{
			kAirMission.setPlot(pPlot);
			kAirMission.setMissionTime(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime() * gDLL->getSecsPerTurn());
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGameINLINE().incrementTurnTimer(getCombatTimer());

			if (pPlot->isActiveVisible(false))
			{
				gDLL->getEntityIFace()->AddMission(&kAirMission);
			}
		}

		changeMoves(GC.getMOVE_DENOMINATOR());
		if (DOMAIN_AIR != pInterceptor->getDomainType())
		{
			pInterceptor->setMadeInterception(true);
		}

		if (isDead())
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", pInterceptor->getNameKey(), getNameKey(), getVisualCivAdjective(pInterceptor->getTeam()));
			gDLL->getInterfaceIFace()->addMessage(pInterceptor->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", getNameKey(), pInterceptor->getNameKey());
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pInterceptor->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
/*************************************************************************************************/
/**	FoodFromAnimals						01/04/08		Written: DomPedroII	Imported: Xienwolf	**/
/**																								**/
/**						Salvage Function for Aerial Defense Victory								**/
/*************************************************************************************************/
			if (pPlot->getOwnerINLINE() == pInterceptor->getOwnerINLINE())
			{
				pInterceptor->salvage(this);
			}
/*************************************************************************************************/
/**	FoodFromAnimals							END												**/
/*************************************************************************************************/
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_ATTACKER) > 0)
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_HURT_ENEMY_AIR", pInterceptor->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)), getVisualCivAdjective(pInterceptor->getTeam()));
			gDLL->getInterfaceIFace()->addMessage(pInterceptor->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIR_UNIT_HURT", getNameKey(), pInterceptor->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)));
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pInterceptor->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
		}

		if (pInterceptor->isDead())
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", getNameKey(), pInterceptor->getNameKey(), pInterceptor->getVisualCivAdjective(getTeam()));
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", pInterceptor->getNameKey(), getNameKey());
			gDLL->getInterfaceIFace()->addMessage(pInterceptor->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_DEFENDER) > 0)
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_ENEMY_AIR", getNameKey(), pInterceptor->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)), pInterceptor->getVisualCivAdjective(getTeam()));
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_DAMAGED", pInterceptor->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)));
			gDLL->getInterfaceIFace()->addMessage(pInterceptor->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
		}

		if (0 == kAirMission.getDamage(BATTLE_UNIT_ATTACKER) + kAirMission.getDamage(BATTLE_UNIT_DEFENDER))
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ABORTED_ENEMY_AIR", pInterceptor->getNameKey(), getNameKey(), getVisualCivAdjective(getTeam()));
			gDLL->getInterfaceIFace()->addMessage(pInterceptor->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_ABORTED", getNameKey(), pInterceptor->getNameKey());
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
		}
	}

	if (bFinish)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);
		pInterceptor->setCombatUnit(NULL);

		if (!isDead() && isSuicide())
		{
			kill(true);
		}
	}
}

void CvUnit::resolveCombat(CvUnit* pDefender, CvPlot* pPlot, CvBattleDefinition& kBattle)
{
	PROFILE_FUNC();

	CombatDetails cdAttackerDetails;
	CombatDetails cdDefenderDetails;

	//FfH: Modified by Kael 01/14/2009
	// Strength is vs defender strength, modified by health
	// Firepower is (average of strength and max strength) + (0.5 ???)
	int iAttackerStrength = currCombatStr(NULL, pDefender, &cdAttackerDetails);
	int iAttackerFirepower = currFirepower(NULL, pDefender);

	int iDefenderStrength;
	int iAttackerDamage;
	int iDefenderDamage;
	int iDefenderOdds;

	getDefenderCombatValues(*pDefender, pPlot, iAttackerStrength, iAttackerFirepower, iDefenderOdds, iDefenderStrength, iAttackerDamage, iDefenderDamage, &cdDefenderDetails);

	// Sends Combat Initiation Information to Python : UnitStatistics Written: Teg Navanis Imported: Xienwolf 07/18/08
	if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
	{
		ReportEventToPython(pDefender, getCombatOdds(this, pDefender), "combatBegin");
	}

	int iAttackerKillOdds = iDefenderOdds * (100 - combatWithdrawalProbability(pDefender)) / 100;

	//FfH: Modified by Kael 08/02/2008 (added check for getUSE_COMBAT_RESULT_CALLBACK)
	if(GC.getUSE_COMBAT_RESULT_CALLBACK())
	{
		if (isHuman() || pDefender->isHuman())
		{
			CyArgsList pyArgsCD;
			pyArgsCD.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
			pyArgsCD.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
			pyArgsCD.add(getCombatOdds(this, pDefender));
			CvEventReporter::getInstance().genericEvent("combatLogCalc", pyArgsCD.makeFunctionArgs());
		}
	}

	collateralCombat(pPlot, pDefender);

	// Immortal Respawn fix : Cyth 3/5/2010
	setImmortDeath(false);pDefender->setImmortDeath(false);

	// Blaze: Minor efficiency gain to do this before entering combat, for large FS numbers on attacker and defender both
	if (getCombatFirstStrikes() > 0 && pDefender->getCombatFirstStrikes() > 0)
	{
		changeCombatFirstStrikes(-std::min(getCombatFirstStrikes(), pDefender->getCombatFirstStrikes()));
		pDefender->changeCombatFirstStrikes(-std::min(getCombatFirstStrikes(), pDefender->getCombatFirstStrikes()));
	}

	// Combat!
	while (true)
	{
		// Defender wins this round
		if (GC.getGameINLINE().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Combat") < iDefenderOdds)
		{
			// Only do damage if attacker is out of first strikes
			if (getCombatFirstStrikes() <= 0)
			{
				// Defensive Withdrawal Ahwaric  24.09.09 && Higher hitpoints Snarko 01/02/11
				if (getDamageReal() + iAttackerDamage >= maxHitPoints()
				&& (GC.getGameINLINE().getSorenRandNum(100, "Withdrawal") < combatWithdrawalProbability(pDefender)))
				{
					flankingStrikeCombat(pPlot, iAttackerStrength, iAttackerFirepower, iAttackerKillOdds, iDefenderDamage, pDefender);

					// Grants both units involved in a Withdrawal some fractional XP, Promotion from withdrawal : DecimalXP && CommandingPresence Xienwolf 11/21/08, Ahwaric 28.05.09
					changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, pDefender->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pDefender->isBarbarian(), true);
					pDefender->changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, maxXPValue(), true, pPlot->getOwnerINLINE() == pDefender->getOwnerINLINE(), !isBarbarian(), true);
					setHasPromotion((PromotionTypes)GC.getDefineINT("WITHDRAW_PROMOTION"), true);

					//FfH Promotions: Added by Kael 08/12/2007
					setFleeWithdrawl(true);

					// Sends Combat Withdrawal Information to Python : UnitStatistics Written: Teg Navanis Imported: Xienwolf 07/18/08
					if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
					{
						ReportEventToPython(pDefender, "combatWithdrawal");
					}
					break;
				}

				// UnitStatistics, Higher hitpoints
				if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
				{
					ReportEventToPython(pDefender, 1, std::min((maxHitPoints() - getDamageReal()), iAttackerDamage), "combatHit");
				}
				changeDamageReal(iAttackerDamage, pDefender->getOwnerINLINE());

				// Defender won, attacker has no FS, *ranged* defender still has some: show that defender is dealing first strikes
				if (pDefender->getCombatFirstStrikes() > 0 && pDefender->isRanged())
				{
					kBattle.addFirstStrikes(BATTLE_UNIT_DEFENDER, 1);
					kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, iAttackerDamage);
				}

				cdAttackerDetails.iCurrHitPoints = currHitPoints();

				//FfH: Modified by Kael 08/02/2008 (added check for callback)
				if(GC.getUSE_COMBAT_RESULT_CALLBACK())
				{
					if (isHuman() || pDefender->isHuman())
					{
						CyArgsList pyArgs;
						pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
						pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
						pyArgs.add(1);
						pyArgs.add(iAttackerDamage);
						CvEventReporter::getInstance().genericEvent("combatLogHit", pyArgs.makeFunctionArgs());
					}
				}
			}
		}
		else // Attacker wins the round
		{
			// Only do damage if defender is out of first strikes
			if (pDefender->getCombatFirstStrikes() <= 0)
			{
				// Defender withdraws or dies, combat ends
				if (pDefender->getDamageReal() + iDefenderDamage >= pDefender->maxHitPoints())
				{
					// Allows Units to retreat while in cities, XP on defensive withdrawal, promotion from withdrawal, Python : UnitStatistics, Xienwolf Ahwaric Written: Teg Navanis 
					if (GC.getGameINLINE().getSorenRandNum(100, "Withdrawal") < (pDefender->getWithdrawlProbDefensive(this) + getExtraEnemyWithdrawal() + enemyWithdrawalProbability()))
					{
						changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, pDefender->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pDefender->isBarbarian(), true);
						pDefender->changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, maxXPValue(), true, pPlot->getOwnerINLINE() == pDefender->getOwnerINLINE(), !isBarbarian(), true);
						pDefender->setHasPromotion((PromotionTypes)GC.getDefineINT("WITHDRAW_PROMOTION"), true);
						pDefender->setFleeWithdrawl(true);
						if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
						{
							pDefender->ReportEventToPython(this, "combatWithdrawal");
						}
						break;
					}
				}
				// Defender "withdraws" due to attacker combat limit, combat ends
				if (std::min(GC.getMAX_HIT_POINTS(), pDefender->getDamageReal() + iDefenderDamage) > combatLimit())
				{
					if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
						{
							ReportEventToPython(pDefender, 2, std::min((combatLimit() - pDefender->getDamageReal()), iDefenderDamage), "combatHit");
							ReportEventToPython(pDefender, "combatWithdrawal");
						}
					// CommandingPresence, DecimalXP, UnitStatistics : Xienwolf
					changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, pDefender->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pDefender->isBarbarian(), true);
					pDefender->changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL")*100, maxXPValue(), true, pPlot->getOwnerINLINE() == pDefender->getOwnerINLINE(), !isBarbarian(), true);
					pDefender->setDamageReal(combatLimit(), getOwnerINLINE());

					if (pDefender->isAlive())
						changeDamage(-getCombatHealPercent(), NO_PLAYER);

					//FfH: Added by Kael 05/27/2008
					setMadeAttack(true);
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));

					break;
				}

				if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
				{
					ReportEventToPython(pDefender, 2, std::min((pDefender->maxHitPoints() - pDefender->getDamageReal()), iDefenderDamage), "combatHit");
				}

				// Apply damage to defender
				pDefender->changeDamageReal(iDefenderDamage, getOwnerINLINE());

				// Attacker won, defender has no first strikes, attacker is ranged: show that attacker is dealing first strikes
				if (getCombatFirstStrikes() > 0 && isRanged())
				{
					kBattle.addFirstStrikes(BATTLE_UNIT_ATTACKER, 1);
					kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, iDefenderDamage);
				}

				cdDefenderDetails.iCurrHitPoints=pDefender->currHitPoints();

				//FfH: Modified by Kael 08/02/2008 (added check for callback)
				if(GC.getUSE_COMBAT_RESULT_CALLBACK())
				{
					if (isHuman() || pDefender->isHuman())
					{
						CyArgsList pyArgs;
						pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
						pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
						pyArgs.add(0);
						pyArgs.add(iDefenderDamage);
						CvEventReporter::getInstance().genericEvent("combatLogHit", pyArgs.makeFunctionArgs());
					}
				}
			}
		}

		if (isDead() || pDefender->isDead())
		{
			if (isDead())
			{
				int iExperience = defenseXPValue();
				iExperience = ((iExperience * iAttackerStrength) / iDefenderStrength);

				// DecimalXP, CommandinGpresence : Xienwolf
				iExperience = range(iExperience, GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), GC.getDefineINT("MAX_EXPERIENCE_PER_COMBAT")*100);
				pDefender->changeExperience(iExperience, maxXPValue(), true, pPlot->getOwnerINLINE() == pDefender->getOwnerINLINE(), !isBarbarian(), true);
			}
			else
			{
				flankingStrikeCombat(pPlot, iAttackerStrength, iAttackerFirepower, iAttackerKillOdds, iDefenderDamage, pDefender);

				int iExperience = pDefender->attackXPValue();
				iExperience = ((iExperience * iDefenderStrength) / iAttackerStrength);

				// DecimalXP, CommandinGpresence : Xienwolf
				iExperience = range(iExperience, GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), GC.getDefineINT("MAX_EXPERIENCE_PER_COMBAT")*100);
				changeExperience(iExperience, pDefender->maxXPValue(), true, pPlot->getOwnerINLINE() == getOwnerINLINE(), !pDefender->isBarbarian(), true);
			}

			break;
		}

		// Round of combat complete; remove 1 FS if either combatant has any
		if (getCombatFirstStrikes() > 0)
		{
			changeCombatFirstStrikes(-1);
		}
		if (pDefender->getCombatFirstStrikes() > 0)
		{
			pDefender->changeCombatFirstStrikes(-1);
		}

		// Maybe one tier too high? Should be outside the combat while loop?? Blaze
		// Immortal Respawn fix : Cyth 3/5/2010
		if(isImmortDeath() || pDefender->isImmortDeath())
		{
			break;
		}

	}
}


void CvUnit::updateCombat(bool bQuick)
{
	PROFILE_FUNC();

	CvWString szBuffer;

	bool bFinish = false;
	bool bVisible = false;

	if (getCombatTimer() > 0)
	{
		changeCombatTimer(-1);

		if (getCombatTimer() > 0)
			return;
		else
			bFinish = true;
	}

	CvPlot* pPlot = getAttackPlot();

	if (pPlot == NULL)
		return;

	if (getDomainType() == DOMAIN_AIR)
	{
		updateAirStrike(pPlot, bQuick, bFinish);
		return;
	}

	CvUnit* pDefender = NULL;
	if (bFinish)
		pDefender = getCombatUnit();
	else
		pDefender = pPlot->getBestDefender(NO_PLAYER, getOwnerINLINE(), this, true);

	if (pDefender == NULL)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);

		getGroup()->groupMove(pPlot, true, ((canAdvance(pPlot, 0)) ? this : NULL));

		getGroup()->clearMissionQueue();

		return;
	}

	//check if quick combat
	if (!bQuick)
		bVisible = isCombatVisible(pDefender);

	// PyPreCombat  By BI 07/24/11
	if (!CvString(GC.getUnitInfo(getUnitType()).getPyPreCombat()).empty())
	{
		CyUnit* pyCaster = new CyUnit(this);
		CyUnit* pyOpponent = new CyUnit(pDefender);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));	// pass in unit class
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyOpponent));	// pass in unit class
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "preCombat", argsList.makeFunctionArgs()); //, &lResult
		delete pyCaster; // python fxn must not hold on to this pointer
		delete pyOpponent; // python fxn must not hold on to this pointer
	}
	if (!CvString(GC.getUnitInfo(pDefender->getUnitType()).getPyPreCombat()).empty())
	{
		CyUnit* pyCaster = new CyUnit(pDefender);
		CyUnit* pyOpponent = new CyUnit(this);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));	// pass in unit class
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyOpponent));	// pass in unit class
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "preCombat", argsList.makeFunctionArgs()); //, &lResult
		delete pyCaster; // python fxn must not hold on to this pointer
		delete pyOpponent; // python fxn must not hold on to this pointer
	}
	// PyPreCombat  By BI 07/24/11  END

	//FAssertMsg((pPlot == pDefender->plot()), "There is not expected to be a defender or the defender's plot is expected to be pPlot (the attack plot)");

	//FfH: Added by Kael 07/30/2007
	if (!isImmuneToDefensiveStrike())
		pDefender->doDefensiveStrike(this);

	if (pDefender->isFear() && !isImmuneToFear())
	{
		if (GC.getGameINLINE().getSorenRandNum(100, "Im afeared!") < pDefender->calcFearChance(this))
		{
			setMadeAttack(true);
			changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
			szBuffer = gDLL->getText("TXT_KEY_MESSAGE_IM_AFEARED", getNameKey());
			gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)getOwner()), false, GC.getDefineINT("EVENT_MESSAGE_TIME"), szBuffer, "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, "Art/Interface/Buttons/Promotions/Fear.dds", (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
			bFinish = true;
		}
	}

	//if not finished and not fighting yet, set up combat damage and mission
	if (!bFinish)
	{
		if (!isFighting())
		{
			if (plot()->isFighting() || pPlot->isFighting())
			{
				return;
			}

			setMadeAttack(true);

			//rotate to face plot
			DirectionTypes newDirection = estimateDirection(this->plot(), pDefender->plot());
			if (newDirection != NO_DIRECTION)
			{
				setFacingDirection(newDirection);
			}

			//rotate enemy to face us
			newDirection = estimateDirection(pDefender->plot(), this->plot());
			if (newDirection != NO_DIRECTION)
			{
				pDefender->setFacingDirection(newDirection);
			}

			setCombatUnit(pDefender, true);
			pDefender->setCombatUnit(this, false);

			pDefender->getGroup()->clearMissionQueue();

			bool bFocused = (bVisible && isCombatFocus() && gDLL->getInterfaceIFace()->isCombatFocus());

			if (bFocused)
			{
				DirectionTypes directionType = directionXY(plot(), pPlot);
				//								N			NE				E				SE					S				SW					W				NW
				NiPoint2 directions[8] = {NiPoint2(0, 1), NiPoint2(1, 1), NiPoint2(1, 0), NiPoint2(1, -1), NiPoint2(0, -1), NiPoint2(-1, -1), NiPoint2(-1, 0), NiPoint2(-1, 1)};
				NiPoint3 attackDirection = NiPoint3(directions[directionType].x, directions[directionType].y, 0);
				float plotSize = GC.getPLOT_SIZE();
				NiPoint3 lookAtPoint(plot()->getPoint().x + plotSize / 2 * attackDirection.x, plot()->getPoint().y + plotSize / 2 * attackDirection.y, (plot()->getPoint().z + pPlot->getPoint().z) / 2);
				attackDirection.Unitize();
				gDLL->getInterfaceIFace()->lookAt(lookAtPoint, (((getOwnerINLINE() != GC.getGameINLINE().getActivePlayer()) || gDLL->getGraphicOption(GRAPHICOPTION_NO_COMBAT_ZOOM)) ? CAMERALOOKAT_BATTLE : CAMERALOOKAT_BATTLE_ZOOM_IN), attackDirection);
			}
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**							This message is just plain annoying									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			else
			{
				PlayerTypes eAttacker = getVisualOwner(pDefender->getTeam());
				CvWString szMessage;
				if (BARBARIAN_PLAYER != eAttacker)
				{
					szMessage = gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK", GET_PLAYER(getOwnerINLINE()).getNameKey());
				}
				else
				{
					szMessage = gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK_UNKNOWN");
				}

				gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szMessage, "AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true);
			}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		}

		FAssertMsg(pDefender != NULL, "Defender is not assigned a valid value");

		FAssertMsg(plot()->isFighting(), "Current unit instance plot is not fighting as expected");
		FAssertMsg(pPlot->isFighting(), "pPlot is not fighting as expected");

		if (!pDefender->canDefend())
		{
			if (!bVisible)
			{
				bFinish = true;
			}
			else
			{
				CvMissionDefinition kMission;
				kMission.setMissionTime(getCombatTimer() * gDLL->getSecsPerTurn());
				kMission.setMissionType(MISSION_SURRENDER);
				kMission.setUnit(BATTLE_UNIT_ATTACKER, this);
				kMission.setUnit(BATTLE_UNIT_DEFENDER, pDefender);
				kMission.setPlot(pPlot);
				gDLL->getEntityIFace()->AddMission(&kMission);

				// Surrender mission
				setCombatTimer(GC.getMissionInfo(MISSION_SURRENDER).getTime());

				GC.getGameINLINE().incrementTurnTimer(getCombatTimer());
			}

/*************************************************************************************************/
/**	Higher hitpoints				11/04/11											Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			// Kill them!
			pDefender->setDamage(GC.getMAX_HIT_POINTS());
/**								----  End Original Code  ----									**/
			pDefender->setDamageReal(GC.getMAX_HIT_POINTS());
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
		}
		else
		{
			CvBattleDefinition kBattle;
			kBattle.setUnit(BATTLE_UNIT_ATTACKER, this);
			kBattle.setUnit(BATTLE_UNIT_DEFENDER, pDefender);
/*************************************************************************************************/
/**	Higher hitpoints				08/04/11											Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN, getDamage());
			kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN, pDefender->getDamage());
/**								----  End Original Code  ----									**/
			kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN, getDamageReal());
			kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN, pDefender->getDamageReal());
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/

			resolveCombat(pDefender, pPlot, kBattle);

			if (!bVisible)
			{
				bFinish = true;
			}
			else
			{
/*************************************************************************************************/
/**	Higher hitpoints				08/04/11											Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END, getDamage());
				kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END, pDefender->getDamage());
/**								----  End Original Code  ----									**/
				kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END, getDamageReal());
				kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END, pDefender->getDamageReal());
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
				kBattle.setAdvanceSquare(canAdvance(pPlot, 1));

				if (isRanged() && pDefender->isRanged())
				{
					kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END));
					kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END));
				}
				else
				{
					kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN));
					kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN));
				}

				int iTurns = planBattle( kBattle);
				kBattle.setMissionTime(iTurns * gDLL->getSecsPerTurn());
				setCombatTimer(iTurns);

				GC.getGameINLINE().incrementTurnTimer(getCombatTimer());

				if (pPlot->isActiveVisible(false))
				{
					ExecuteMove(0.5f, true);
					gDLL->getEntityIFace()->AddMission(&kBattle);
				}
			}
		}
	}

	if (bFinish)
	{
		if (bVisible)
		{
			if (isCombatFocus() && gDLL->getInterfaceIFace()->isCombatFocus())
			{
				if (getOwnerINLINE() == GC.getGameINLINE().getActivePlayer())
				{
					gDLL->getInterfaceIFace()->releaseLockedCamera();
				}
			}
		}

		//end the combat mission if this code executes first
		gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
		gDLL->getEntityIFace()->RemoveUnitFromBattle(pDefender);
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);
		pDefender->setCombatUnit(NULL);
		NotifyEntity(MISSION_DAMAGE);
		pDefender->NotifyEntity(MISSION_DAMAGE);

		if (isDead())
		{
			if (isBarbarian())
			{
				GET_PLAYER(pDefender->getOwnerINLINE()).changeWinsVsBarbs(1);
			}

/*************************************************************************************************/
/**	FoodFromAnimals						01/04/08		Written: DomPedroII	Imported: Xienwolf	**/
/**																								**/
/**					Initiates Salvaging Effect after Defensive Victory							**/
/*************************************************************************************************/
			if (!pDefender->isBarbarian())
			{
				pDefender->salvage(this);
			}
/*************************************************************************************************/
/**	FoodFromAnimals							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	NoWeary 								05/15/08								Xienwolf	**/
/**																								**/
/**						Stops Weariness Check if Attacker is Flagged & Killed					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
//FfH Hidden Nationality: Modified by Kael 08/27/2007
//			if (!m_pUnitInfo->isHiddenNationality() && !pDefender->getUnitInfo().isHiddenNationality())
			if (!isHiddenNationality() && !pDefender->isHiddenNationality() && getDuration() == 0 && !m_pUnitInfo->isNoWarWeariness())
/**								----  End Original Code  ----									**/
			if (!isHiddenNationality() && !pDefender->isHiddenNationality() && getDuration() == 0 && pDefender->getDuration() == 0 && !m_pUnitInfo->isNoWarWeariness() && !(isNonWarWeariness()) && getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL") && pDefender->getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL"))
/*************************************************************************************************/
/**	NoWeary 									END												**/
/*************************************************************************************************/
//FfH: End Modify

			{
				GET_TEAM(getTeam()).changeWarWeariness(pDefender->getTeam(), *pPlot, GC.getDefineINT("WW_UNIT_KILLED_ATTACKING"));
				GET_TEAM(pDefender->getTeam()).changeWarWeariness(getTeam(), *pPlot, GC.getDefineINT("WW_KILLED_UNIT_DEFENDING"));
				GET_TEAM(pDefender->getTeam()).AI_changeWarSuccess(getTeam(), GC.getDefineINT("WAR_SUCCESS_DEFENDING"));
			}

			if (isSuicide())// if suicide unit (mainly fireballs and meteors), do not produce defeatsound when it dies. Instead, fireball sound
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WEAKENED_ENEMY", getNameKey(), pDefender->getNameKey(), GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_SPELL_FIREBALL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
			}
			else
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", getNameKey(), pDefender->getNameKey(), GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
			}
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
			float fInfluenceRatio = 0.0;
			if(GET_PLAYER(getOwner()).isInfluenceAllowed())
			{
				if(canDeathInfluenceWar() && pDefender->canInfluenceWar())
				{
					if (pPlot->canBeInfluenced())
					{
						fInfluenceRatio = pDefender->doVictoryInfluence(this, pDefender, false, false);
						if (fInfluenceRatio != 0.0f)
						{
							CvWString szTempBuffer;
							szTempBuffer.Format(L" Influence: -%.1f%%", fInfluenceRatio);
							szBuffer += szTempBuffer;
						}
					}
				}
			}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(pDefender->getTeam()));
			gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

//FfH: Added by Kael 07/30/2007
			pDefender->combatWon(this, false);
//FfH: End Add

			// report event to Python, along with some other key state

//FfH: Modified by Kael 08/02/2008
//			CvEventReporter::getInstance().combatResult(pDefender, this);
			if(GC.getUSE_COMBAT_RESULT_CALLBACK())
			{
				CvEventReporter::getInstance().combatResult(pDefender, this);
			}
//FfH: End Modify

		}
		else if (pDefender->isDead())
		{
			if (pDefender->isBarbarian())
			{
				GET_PLAYER(getOwnerINLINE()).changeWinsVsBarbs(1);
			}

/*************************************************************************************************/
/**	FoodFromAnimals						01/04/08		Written: DomPedroII	Imported: Xienwolf	**/
/**																								**/
/**					Initiates Salvaging Effect after Offensive Victory							**/
/*************************************************************************************************/
			if (!isBarbarian())
			{
				salvage(pDefender);
			}
/*************************************************************************************************/
/**	FoodFromAnimals							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	NoWeary 								05/15/08								Xienwolf	**/
/**																								**/
/**						Stops Weariness Check if Defender is Flagged & Killed					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
//FfH Hidden Nationality: Modified by Kael 08/27/2007
//			if (!m_pUnitInfo->isHiddenNationality() && !pDefender->getUnitInfo().isHiddenNationality())
			if (!isHiddenNationality() && !pDefender->isHiddenNationality() && pDefender->getDuration() == 0 && !pDefender->getUnitInfo().isNoWarWeariness())
/**								----  End Original Code  ----									**/
			if (!isHiddenNationality() && !pDefender->isHiddenNationality() && getDuration() == 0 && pDefender->getDuration() == 0 && !pDefender->getUnitInfo().isNoWarWeariness() && !(pDefender->isNonWarWeariness()) && getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL") && pDefender->getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL"))
/*************************************************************************************************/
/**	NoWeary 									END												**/
/*************************************************************************************************/
//FfH: End Modify

			{
				GET_TEAM(pDefender->getTeam()).changeWarWeariness(getTeam(), *pPlot, GC.getDefineINT("WW_UNIT_KILLED_DEFENDING"));
				GET_TEAM(getTeam()).changeWarWeariness(pDefender->getTeam(), *pPlot, GC.getDefineINT("WW_KILLED_UNIT_ATTACKING"));
				GET_TEAM(getTeam()).AI_changeWarSuccess(pDefender->getTeam(), GC.getDefineINT("WAR_SUCCESS_ATTACKING"));
			}

/*************************************************************************************************/
/**	Xienwolf Tweak							02/14/09											**/
/**																								**/
/**						Displays identity of Opponent in a better fashion						**/
/*************************************************************************************************/
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY", getNameKey(), pDefender->getNameKey(), GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
			float fInfluenceRatio = 0.0;
			if(GET_PLAYER(getOwner()).isInfluenceAllowed())
			{
				if(pDefender->canDeathInfluenceWar() && canInfluenceWar())
				{
					if (pPlot->canBeInfluenced())
					{
						fInfluenceRatio = doVictoryInfluence(pDefender, this, true, false);
						if (fInfluenceRatio != 0.0f)
						{
							CvWString szTempBuffer;
							szTempBuffer.Format(L" Influence: +%.1f%%", fInfluenceRatio);
							szBuffer += szTempBuffer;
						}
					}
				}
			}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED", pDefender->getNameKey(), getNameKey(), GET_PLAYER(getVisualOwner(pDefender->getTeam())).getCivilizationAdjectiveKey());
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
			if (fInfluenceRatio != 0.0f)
			{
				CvWString szTempBuffer;
				szTempBuffer.Format(L" Influence: -%.1f%%", fInfluenceRatio);
				szBuffer += szTempBuffer;
			}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
			gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

//FfH: Added by Kael 05/15/2007
			combatWon(pDefender, true);
//FfH: End Add

			// report event to Python, along with some other key state

//FfH: Modified by Kael 08/02/2008
//			CvEventReporter::getInstance().combatResult(this, pDefender);
			if(GC.getUSE_COMBAT_RESULT_CALLBACK())
			{
				CvEventReporter::getInstance().combatResult(this, pDefender);
			}
//FfH: End Modify

			bool bAdvance = false;

			if (isSuicide())
			{
				kill(true);

				pDefender->kill(false);
				pDefender = NULL;
			}
			else
			{
				bAdvance = canAdvance(pPlot, ((pDefender->canDefend()) ? 1 : 0));

				if (bAdvance)
				{
					//FfH: Added by Kael 11/14/2007
					if (!isCannotCapture(true) || GC.getUnitInfo((UnitTypes)pDefender->getUnitType()).getEquipmentPromotion() != NO_PROMOTION)
					{
						pDefender->setCapturingPlayer(getOwnerINLINE());
						//pDefender->setCombatUnit(this);
					}
				}

				pDefender->kill(false);
				pDefender = NULL;

				//FfH Fear: Added by Kael 07/30/2007
				if (isFear() && !pPlot->isCity(true))
				{
					CvUnit* pLoopUnit;
					CLLNode<IDInfo>* pUnitNode;
					pUnitNode = pPlot->headUnitNode();
					while (pUnitNode != NULL)
					{
						pLoopUnit = ::getUnit(pUnitNode->m_data);
						pUnitNode = pPlot->nextUnitNode(pUnitNode);
						if (pLoopUnit->isEnemy(getTeam()) && !pLoopUnit->isImmuneToFear())
						{
							// Halved fear chance when checking against all units in stack
							if (GC.getGameINLINE().getSorenRandNum(100, "Im afeared!") < calcFearChance(pLoopUnit) / 2)
							{
								pLoopUnit->joinGroup(NULL);
								pLoopUnit->jumpToNearestValidPlot();
							}
						}
					}
				}
				bAdvance = canAdvance(pPlot, 0);

				if (!bAdvance)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
					checkRemoveSelectionAfterAttack();
				}
			}

			if (pPlot->getNumVisibleEnemyDefenders(this) == 0)
			{
				getGroup()->groupMove(pPlot, true, ((bAdvance) ? this : NULL));
			}

			// This is is put before the plot advancement, the unit will always try to walk back
			// to the square that they came from, before advancing.
			getGroup()->clearMissionQueue();
		}
		else
		{

//FfH Promotions: Modified by Kael 08/12/2007
//			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey());
//			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
//			szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey());
//			gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
//
//			changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
//			checkRemoveSelectionAfterAttack();
//
//			getGroup()->clearMissionQueue();
			if (pDefender->isFleeWithdrawl())
			{
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**					Removes "Lost after combat" Promotions when withdraw occurs					**/
/*************************************************************************************************/
				for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
				{
					if (isHasPromotion((PromotionTypes)iI))
					{
						if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedByCombat())
						{
							setHasPromotion(((PromotionTypes)iI), false);
						}
					}
					if (pDefender->isHasPromotion((PromotionTypes)iI))
					{
						if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedByCombat())
						{
							pDefender->setHasPromotion(((PromotionTypes)iI), false);
						}
					}
				}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
				pDefender->joinGroup(NULL);
				pDefender->setFleeWithdrawl(false);
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**					Keeps unit in the city when withdrawing if they own the city				**/
/*************************************************************************************************/
/*	Disabled by Vehem 04/16/09 - each unit with withdrawal chance requires multiple attacks in
/*  order to capture city if they remain in the city - exploitable, especially by mounted units
/*  e.g. 75% withdrawal chance means the unit will only be removed from the city on 1 in 4 attacks
/*  and the other 3 attacks are simply wasted.
/*************************************************************************************************/
/**								---- Start Original Code ----									**/
				pDefender->jumpToNearestValidPlot();
/**								----  End Original Code  ----									**
				if (pDefender->plot()->getPlotCity() == NULL || pDefender->plot()->getPlotCity()->getOwner() != pDefender->getOwner())
				{
					pDefender->jumpToNearestValidPlot();
				}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
				checkRemoveSelectionAfterAttack();
				if (pPlot->getNumVisibleEnemyDefenders(this) == 0)
				{
					getGroup()->groupMove(pPlot, true, ((canAdvance(pPlot, 0)) ? this : NULL));
				}
				getGroup()->clearMissionQueue();
/*************************************************************************************************/
/**	Xienwolf Tweak							02/14/09											**/
/**																								**/
/**						Displays identity of Opponent in a better fashion						**/
/*************************************************************************************************/
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_FLED", pDefender->getNameKey(), getNameKey(), GET_PLAYER(getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
				gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_FLED", pDefender->getNameKey(), getNameKey(), GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
			}
			if (isFleeWithdrawl())
			{
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**					Removes "Lost after combat" Promotions when withdraw occurs					**/
/*************************************************************************************************/
				for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
				{
					if (isHasPromotion((PromotionTypes)iI))
					{
						if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedByCombat())
						{
							setHasPromotion(((PromotionTypes)iI), false);
						}
					}
					if (pDefender->isHasPromotion((PromotionTypes)iI))
					{
						if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedByCombat())
						{
							pDefender->setHasPromotion(((PromotionTypes)iI), false);
						}
					}
				}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
				joinGroup(NULL);
				setFleeWithdrawl(false);
/*************************************************************************************************/
/**	Xienwolf Tweak							02/14/09											**/
/**																								**/
/**						Displays identity of Opponent in a better fashion						**/
/*************************************************************************************************/
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey(), GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey(), GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
				gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
				changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				checkRemoveSelectionAfterAttack();
				getGroup()->clearMissionQueue();
			}
//FfH: End Modify
		}
	}
}

// 10-75 range, baseline 50 to fear, modulated first by level/combat str, then multiplied by health percent of units
int CvUnit::calcFearChance(const CvUnit* pAfraidUnit) const
{
	int iFearChance = 50 + 2*(baseCombatStr() + getLevel()) - 2*(pAfraidUnit->baseCombatStr() + pAfraidUnit->getLevel());
	iFearChance = iFearChance * currHitPoints() * pAfraidUnit->maxHitPoints() / std::max(1, maxHitPoints() * pAfraidUnit->currHitPoints());

	return range(iFearChance, 10, 75);
}

void CvUnit::checkRemoveSelectionAfterAttack()
{
	if (!canMove() || !isBlitz())
	{
		if (IsSelected())
		{
			if (gDLL->getInterfaceIFace()->getLengthSelectionList() > 1)
			{
				gDLL->getInterfaceIFace()->removeFromSelectionList(this);
			}
		}
	}
}


bool CvUnit::isActionRecommended(int iAction)
{
	CvCity* pWorkingCity;
	CvPlot* pPlot;
	ImprovementTypes eImprovement;
	ImprovementTypes eFinalImprovement;
	BuildTypes eBuild;
	RouteTypes eRoute;
	BonusTypes eBonus;
	int iIndex;

	if (getOwnerINLINE() != GC.getGameINLINE().getActivePlayer())
	{
		return false;
	}

	if (GET_PLAYER(getOwnerINLINE()).isOption(PLAYEROPTION_NO_UNIT_RECOMMENDATIONS))
	{
		return false;
	}

	CyUnit* pyUnit = new CyUnit(this);
	CyArgsList argsList;
	argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
	argsList.add(iAction);
	long lResult=0;
	gDLL->getPythonIFace()->callFunction(PYGameModule, "isActionRecommended", argsList.makeFunctionArgs(), &lResult);
	delete pyUnit;	// python fxn must not hold on to this pointer
	if (lResult == 1)
	{
		return true;
	}

	pPlot = gDLL->getInterfaceIFace()->getGotoPlot();

	if (pPlot == NULL)
	{
		if (gDLL->shiftKey())
		{
			pPlot = getGroup()->lastMissionPlot();
		}
	}

	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	if (GC.getActionInfo(iAction).getMissionType() == MISSION_FORTIFY)
	{
		if (pPlot->isCity(true, getTeam()))
		{
			if (canDefend(pPlot))
			{
				if (pPlot->getNumDefenders(getOwnerINLINE()) < ((atPlot(pPlot)) ? 2 : 1))
				{
					return true;
				}
			}
		}
	}

	if (GC.getActionInfo(iAction).getMissionType() == MISSION_HEAL)
	{
		if (isHurt() && !isTurnHealBlocked())
		{
			if (GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()) || healTurns(pPlot) <= 4)
				return true;
		}
	}

	if (GC.getActionInfo(iAction).getMissionType() == MISSION_FOUND)
	{
		if (canFound(pPlot))
		{
			if (pPlot->isBestAdjacentFound(getOwnerINLINE()))
			{
				return true;
			}
		}
	}

	if (GC.getActionInfo(iAction).getMissionType() == MISSION_BUILD)
	{
		if (pPlot->getOwnerINLINE() == getOwnerINLINE())
		{
			eBuild = ((BuildTypes)(GC.getActionInfo(iAction).getMissionData()));
			FAssert(eBuild != NO_BUILD);
			FAssertMsg(eBuild < GC.getNumBuildInfos(), "Invalid Build");

			if (canBuild(pPlot, eBuild))
			{
				eImprovement = ((ImprovementTypes)(GC.getBuildInfo(eBuild).getImprovement()));
				eRoute = ((RouteTypes)(GC.getBuildInfo(eBuild).getRoute()));
				eBonus = pPlot->getBonusType(getTeam());
				pWorkingCity = pPlot->getWorkingCity();

				if (pPlot->getImprovementType() == NO_IMPROVEMENT)
				{
					if (pWorkingCity != NULL)
					{
						iIndex = pWorkingCity->getCityPlotIndex(pPlot);

						if (iIndex != -1)
						{
							if (pWorkingCity->AI_getBestBuild(iIndex) == eBuild)
							{
								return true;
							}
						}
					}

					if (eImprovement != NO_IMPROVEMENT)
					{
						if (eBonus != NO_BONUS)
						{
							if (GC.getImprovementInfo(eImprovement).isImprovementBonusTrade(eBonus))
							{
								return true;
							}
						}

						if (pPlot->getImprovementType() == NO_IMPROVEMENT)
						{
							if (!(pPlot->isIrrigated()) && pPlot->isIrrigationAvailable(true))
							{
								if (GC.getImprovementInfo(eImprovement).isCarriesIrrigation())
								{
									return true;
								}
							}

							if (pWorkingCity != NULL)
							{
								if (GC.getImprovementInfo(eImprovement).getYieldChange(YIELD_FOOD) > 0)
								{
									return true;
								}

								if (pPlot->isHills())
								{
									if (GC.getImprovementInfo(eImprovement).getYieldChange(YIELD_PRODUCTION) > 0)
									{
										return true;
									}
								}
								else
								{
									if (GC.getImprovementInfo(eImprovement).getYieldChange(YIELD_COMMERCE) > 0)
									{
										return true;
									}
								}
							}
						}
					}
				}

				if (eRoute != NO_ROUTE)
				{
					if (!(pPlot->isRoute()))
					{
						if (eBonus != NO_BONUS)
						{
							return true;
						}

						if (pWorkingCity != NULL)
						{
							if (pPlot->isRiver())
							{
								return true;
							}
						}
					}

					eFinalImprovement = eImprovement;

					if (eFinalImprovement == NO_IMPROVEMENT)
					{
						eFinalImprovement = pPlot->getImprovementType();
					}

					if (eFinalImprovement != NO_IMPROVEMENT)
					{
						if ((GC.getImprovementInfo(eFinalImprovement).getRouteYieldChanges(eRoute, YIELD_FOOD) > 0) ||
							(GC.getImprovementInfo(eFinalImprovement).getRouteYieldChanges(eRoute, YIELD_PRODUCTION) > 0) ||
							(GC.getImprovementInfo(eFinalImprovement).getRouteYieldChanges(eRoute, YIELD_COMMERCE) > 0))
						{
							return true;
						}
					}
				}
			}
		}
	}

	if (GC.getActionInfo(iAction).getCommandType() == COMMAND_PROMOTION)
	{
		return true;
	}

	return false;
}


/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      02/21/10                                jdog5000      */
/*                                                                                              */
/* Efficiency, Lead From Behind                                                                 */
/************************************************************************************************/
// From Lead From Behind by UncutDragon
// original
//bool CvUnit::isBetterDefenderThan(const CvUnit* pDefender, const CvUnit* pAttacker) const
// modified (with extra parameter)
bool CvUnit::isBetterDefenderThan(const CvUnit* pDefender, const CvUnit* pAttacker, int* pBestDefenderRank) const
{
	PROFILE("CvUnit::isBetterDefenderThan");
	int iOurDefense;
	int iTheirDefense;

	if (pDefender == NULL)
	{
		return true;
	}

	TeamTypes eAttackerTeam = NO_TEAM;
	if (NULL != pAttacker)
	{
		eAttackerTeam = pAttacker->getTeam();
	}

	if (canCoexistWithEnemyUnit(eAttackerTeam))
	{
		return false;
	}

	if (!canDefend())
	{
		return false;
	}

	if (canDefend() && !(pDefender->canDefend()))
	{
		return true;
	}

	if (pAttacker)
	{
		if (isTargetOf(*pAttacker) && !pDefender->isTargetOf(*pAttacker))
		{
			return true;
		}

		if (!isTargetOf(*pAttacker) && pDefender->isTargetOf(*pAttacker))
		{
			return false;
		}

		if (pAttacker->canAttack(*pDefender) && !pAttacker->canAttack(*this))
		{
			return false;
		}

		if (pAttacker->canAttack(*this) && !pAttacker->canAttack(*pDefender))
		{
			return true;
		}
	}

	// UncutDragon
	// To cut down on changes to existing code, we just short-circuit the method
	// and this point and call our own version instead
	if (GC.getLFBEnable())
		return LFBisBetterDefenderThan(pDefender, pAttacker, pBestDefenderRank);
	// /UncutDragon

	iOurDefense = currCombatStr(plot(), pAttacker);
	if (::isWorldUnitClass(getUnitClassType()))
	{
		iOurDefense /= 2;
	}

	if (NULL == pAttacker)
	{
		if (pDefender->collateralDamage() > 0)
		{
			iOurDefense *= (100 + pDefender->collateralDamage());
			iOurDefense /= 100;
		}

		if (pDefender->currInterceptionProbability() > 0)
		{
			iOurDefense *= (100 + pDefender->currInterceptionProbability());
			iOurDefense /= 100;
		}
	}
	else
	{
		if (!(pAttacker->immuneToFirstStrikes()))
		{
			iOurDefense *= ((((firstStrikes() * 2) + chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iOurDefense /= 100;
		}

		if (immuneToFirstStrikes())
		{
			iOurDefense *= ((((pAttacker->firstStrikes() * 2) + pAttacker->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iOurDefense /= 100;
		}
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							04/15/09											**/
/**																								**/
/**				AI will naturally value units with higher Asset values now						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	int iAssetValue = std::max(1, getUnitInfo().getAssetValue());
	int iCargoAssetValue = 0;
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
		iCargoAssetValue += aCargoUnits[i]->getUnitInfo().getAssetValue();
	}
/**								----  End Original Code  ----									**/
	int iAssetValue = std::max(1, getUnitInfo().getAssetValue() * (getAssetValue()/100));
	int iCargoAssetValue = 0;
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
		iCargoAssetValue += aCargoUnits[i]->getUnitInfo().getAssetValue() * (aCargoUnits[i]->getAssetValue()/100);
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	iOurDefense = iOurDefense * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);

	iTheirDefense = pDefender->currCombatStr(plot(), pAttacker);
	if (::isWorldUnitClass(pDefender->getUnitClassType()))
	{
		iTheirDefense /= 2;
	}

	if (NULL == pAttacker)
	{
		if (collateralDamage() > 0)
		{
			iTheirDefense *= (100 + collateralDamage());
			iTheirDefense /= 100;
		}

		if (currInterceptionProbability() > 0)
		{
			iTheirDefense *= (100 + currInterceptionProbability());
			iTheirDefense /= 100;
		}
	}
	else
	{
		if (!(pAttacker->immuneToFirstStrikes()))
		{
			iTheirDefense *= ((((pDefender->firstStrikes() * 2) + pDefender->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iTheirDefense /= 100;
		}

		if (pDefender->immuneToFirstStrikes())
		{
			iTheirDefense *= ((((pAttacker->firstStrikes() * 2) + pAttacker->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iTheirDefense /= 100;
		}
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							04/15/09											**/
/**																								**/
/**				AI will naturally value units with higher Asset values now						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	iAssetValue = std::max(1, pDefender->getUnitInfo().getAssetValue());
	iCargoAssetValue = 0;
	pDefender->getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
		iCargoAssetValue += aCargoUnits[i]->getUnitInfo().getAssetValue();
	}
/**								----  End Original Code  ----									**/
	iAssetValue = std::max(1, pDefender->getUnitInfo().getAssetValue() * (pDefender->getAssetValue()/100));
	iCargoAssetValue = 0;
	pDefender->getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
		iCargoAssetValue += aCargoUnits[i]->getUnitInfo().getAssetValue() * (aCargoUnits[i]->getAssetValue()/100);
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	iTheirDefense = iTheirDefense * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);

//FfH Promotions: Added by Kael 07/30/2007
	iOurDefense *= getBetterDefenderThanPercent();
	iOurDefense /= 100;
	iTheirDefense *= pDefender->getBetterDefenderThanPercent();
	iTheirDefense /= 100;
//FfH Promotions: End Add

	if (iOurDefense == iTheirDefense)
	{
		if (NO_UNIT == getLeaderUnitType() && NO_UNIT != pDefender->getLeaderUnitType())
		{
			++iOurDefense;
		}
		else if (NO_UNIT != getLeaderUnitType() && NO_UNIT == pDefender->getLeaderUnitType())
		{
			++iTheirDefense;
		}
		else if (isBeforeUnitCycle(this, pDefender))
		{
			++iOurDefense;
		}
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							07/17/09											**/
/**																								**/
/**								Commanders Less Likely to Defend								**/
/*************************************************************************************************/
	iOurDefense += ((getCommandLimit() - pDefender->getCommandLimit())*3 + (getCommandRange() - pDefender->getCommandRange()));
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	return (iOurDefense > iTheirDefense);
}
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/


bool CvUnit::canDoCommand(CommandTypes eCommand, int iData1, int iData2, bool bTestVisible, bool bTestBusy)
{
	CvUnit* pUnit;

	if (bTestBusy && getGroup()->isBusy())
	{
		return false;
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							05/12/09											**/
/**																								**/
/**			Places same restrictions on the AI as are placed on the Player for Blindness		**/
/*************************************************************************************************/
	if (isBlind() && (!plot()->isVisible(getTeam(), false) || !plot()->isRevealed(getTeam(), false)))
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	switch (eCommand)
	{
	case COMMAND_PROMOTION:
		if (canPromote((PromotionTypes)iData1, iData2))
		{
			return true;
		}
		break;

	case COMMAND_UPGRADE:
		if (canUpgrade(((UnitTypes)iData1), bTestVisible))
		{
			return true;
		}
		break;

	case COMMAND_AUTOMATE:
		if (canAutomate((AutomateTypes)iData1))
		{
			return true;
		}
		break;

	case COMMAND_WAKE:
		if (!isAutomated() && isWaiting())
		{
			return true;
		}
		break;

	case COMMAND_CANCEL:
	case COMMAND_CANCEL_ALL:
		if (!isAutomated() && (getGroup()->getLengthMissionQueue() > 0))
		{
			return true;
		}
		break;

	case COMMAND_STOP_AUTOMATION:
		if (isAutomated())
		{
			return true;
		}
/*************************************************************************************************/
/**	AutoCast								30/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
		else if (isAutoCast())
		{
			return true;
		}
/*************************************************************************************************/
/**	AutoCast								END													**/
/*************************************************************************************************/
		break;

	case COMMAND_DELETE:
		if (canScrap())
		{
			return true;
		}
		break;

	case COMMAND_GIFT:
		if (canGift(bTestVisible))
		{
			return true;
		}
		break;

	case COMMAND_LOAD:
		if (canLoad(plot()))
		{
			return true;
		}
		break;

	case COMMAND_LOAD_UNIT:
		pUnit = ::getUnit(IDInfo(((PlayerTypes)iData1), iData2));
		if (pUnit != NULL)
		{
			if (canLoadUnit(pUnit, plot()))
			{
				return true;
			}
		}
		break;

	case COMMAND_UNLOAD:
		if (canUnload())
		{
			return true;
		}
		break;

	case COMMAND_UNLOAD_ALL:
		if (canUnloadAll())
		{
			return true;
		}
		break;

	case COMMAND_HOTKEY:
		if (isGroupHead())
		{
			return true;
		}
		break;

//FfH Spell System: Added by Kael 07/23/2007
	case COMMAND_CAST:{
		if(canCastAnyPlot(iData1, bTestVisible))
		{
			return true;
		}
		break;
	}
//FfH: End Add

	default:
		FAssert(false);
		break;
	}

	return false;
}


void CvUnit::doCommand(CommandTypes eCommand, int iData1, int iData2)
{
	CvUnit* pUnit;
	bool bCycle;

	bCycle = false;

	FAssert(getOwnerINLINE() != NO_PLAYER);

	if (canDoCommand(eCommand, iData1, iData2))
	{
		switch (eCommand)
		{
		case COMMAND_PROMOTION:
			promote((PromotionTypes)iData1, iData2);
			break;

		case COMMAND_UPGRADE:
			upgrade((UnitTypes)iData1);
			bCycle = true;
			break;

		case COMMAND_AUTOMATE:
			automate((AutomateTypes)iData1);
			bCycle = true;
			break;

		case COMMAND_WAKE:
			getGroup()->setActivityType(ACTIVITY_AWAKE);
			break;

		case COMMAND_CANCEL:
			getGroup()->popMission();
			break;

		case COMMAND_CANCEL_ALL:
			getGroup()->clearMissionQueue();
			break;

		case COMMAND_STOP_AUTOMATION:
			getGroup()->setAutomateType(NO_AUTOMATE);
/*************************************************************************************************/
/**	AutoCast								30/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
			setAutoCast(NO_SPELL);
/*************************************************************************************************/
/**	AutoCast								END													**/
/*************************************************************************************************/
			break;

		case COMMAND_DELETE:
			scrap();
			bCycle = true;
			break;

		case COMMAND_GIFT:
			gift();
			bCycle = true;
			break;

		case COMMAND_LOAD:
			load();
			bCycle = true;
			break;

		case COMMAND_LOAD_UNIT:
			pUnit = ::getUnit(IDInfo(((PlayerTypes)iData1), iData2));
			if (pUnit != NULL)
			{
				loadUnit(pUnit);
				bCycle = true;
			}
			break;

		case COMMAND_UNLOAD:
			unload();
			bCycle = true;
			break;

		case COMMAND_UNLOAD_ALL:
			unloadAll();
			bCycle = true;
			break;

		case COMMAND_HOTKEY:
			setHotKeyNumber(iData1);
			break;

//FfH Spell System: Added by Kael 07/23/2007
		case COMMAND_CAST:{
		//TargetedSpell 0924 blackimp
			if (GC.getSpellInfo((SpellTypes)iData1).isTargeted())
			{
				setMissionSpell(iData1);
			}
			else
			{
				cast(iData1);
			}
/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
			if (gDLL->shiftKey() && IsSelected() && GC.getSpellInfo((SpellTypes)iData1).isAutoCast() && !(GC.getGameINLINE().isOption(GAMEOPTION_NO_AUTOCAST)))
			{
				setAutoCast((SpellTypes)iData1);
			}
			else if (gDLL->ctrlKey() && IsSelected() && GC.getSpellInfo((SpellTypes)iData1).isAutoCast() && !(GC.getGameINLINE().isOption(GAMEOPTION_NO_AUTOCAST)))
			{
				setAutoCast((SpellTypes)iData1, true);
			}
/*************************************************************************************************/
/**	AutoCast								END													**/
/*************************************************************************************************/
			break;
		}
//FfH: End Add

		default:
			FAssert(false);
			break;
		}
	}

	if (bCycle)
	{
		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setCycleSelectionCounter(1);
		}
	}

	getGroup()->doDelayedDeath();
}


FAStarNode* CvUnit::getPathLastNode() const
{
	return getGroup()->getPathLastNode();
}


CvPlot* CvUnit::getPathEndTurnPlot() const
{
	return getGroup()->getPathEndTurnPlot();
}

/*************************************************************************************************/
/**	K-mod merger								16/02/12								Snarko	**/
/**																								**/
/**					Merging in features of K-mod, most notably the pathfinder					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::generatePath(const CvPlot* pToPlot, int iFlags, bool bReuse, int* piPathTurns) const
{
	return getGroup()->generatePath(plot(), pToPlot, iFlags, bReuse, piPathTurns);
}
/**								----  End Original Code  ----									**/
bool CvUnit::generatePath(const CvPlot* pToPlot, int iFlags, bool bReuse, int* piPathTurns, int iMaxPath) const
{
	return getGroup()->generatePath(plot(), pToPlot, iFlags, bReuse, piPathTurns, iMaxPath);
}
/*************************************************************************************************/
/**	K-mod merger								END												**/
/*************************************************************************************************/

bool CvUnit::canEnterTerritory(TeamTypes eTeam, bool bIgnoreRightOfPassage) const
{
	if (GET_TEAM(getTeam()).isFriendlyTerritory(eTeam))
	{
		return true;
	}

	if (eTeam == NO_TEAM)
	{
		return true;
	}

/*************************************************************************************************/
/**	Rivals 									05/15/08								Xienwolf	**/
/**																								**/
/**	Keeps RivalBlocked Units out of any Territory except Team, since that is already checked	**/
/*************************************************************************************************/
	if (isRivalTerritoryBlock())
	{
		return false;
	}
/*************************************************************************************************/
/**	Rivals 										END												**/
/*************************************************************************************************/
	if (isEnemy(eTeam))
	{
		return true;
	}

	if (isRivalTerritory())
	{
		return true;
	}

	if (alwaysInvisible())
	{
		return true;
	}

	if (!bIgnoreRightOfPassage)
	{
		if (GET_TEAM(getTeam()).isOpenBorders(eTeam))
		{
			return true;
		}
	}

//FfH: Added by Kael 09/02/2007 (so hidden nationality units can enter all territories)
	if (isHiddenNationality())
	{
		return true;
	}
	if (GET_TEAM(eTeam).isBarbarian()) // (so barbarians can enter player areas they are at peace with an vice versa)
	{
		return true;
	}
	if (GET_TEAM(getTeam()).isBarbarian())
	{
		return true;
	}
	if (GET_PLAYER(getOwnerINLINE()).isDeclaringWar())
	{
		if (GET_PLAYER(getOwnerINLINE()).getStateReligion() != NO_RELIGION)
		{
			if (GC.getReligionInfo(GET_PLAYER(getOwnerINLINE()).getStateReligion()).isSneakAttack())
			{
				return true;
			}
		}
	}
//FfH: End Add

	return false;
}


bool CvUnit::canEnterArea(TeamTypes eTeam, const CvArea* pArea, bool bIgnoreRightOfPassage) const
{
/*************************************************************************************************/
/**	PeaceAndFlowers							05/31/09								Xienwolf	**/
/**																								**/
/**		Should prevent accidentaly bumping of never hostile units out of other territory		**/
/*************************************************************************************************/
	if (isNeverHostile())
	{
		return true;
	}
/*************************************************************************************************/
/**	PeaceAndFlowers							END													**/
/*************************************************************************************************/
	if (!canEnterTerritory(eTeam, bIgnoreRightOfPassage))
	{
		return false;
	}

	if (isBarbarian() && DOMAIN_LAND == getDomainType())
	{
		if (eTeam != NO_TEAM && eTeam != getTeam())
		{
			if (pArea && pArea->isBorderObstacle(eTeam))
			{
				return false;
			}
		}
	}

	return true;
}


// Returns the ID of the team to declare war against
TeamTypes CvUnit::getDeclareWarMove(const CvPlot* pPlot) const
{
	CvUnit* pUnit;
	TeamTypes eRevealedTeam;

	FAssert(isHuman());

/*************************************************************************************************/
/**	Rivals 									05/15/08								Xienwolf	**/
/**					Stops RivalBlocked Units from asking if you want to declare war				**/
/**								should you attempt to enter Territory							**/
/*************************************************************************************************/
	if (isRivalTerritoryBlock())
	{
		return NO_TEAM;
	}
/*************************************************************************************************/
/**	Rivals 										END												**/
/*************************************************************************************************/
	if (getDomainType() != DOMAIN_AIR)
	{
		eRevealedTeam = pPlot->getRevealedTeam(getTeam(), false);

		if (eRevealedTeam != NO_TEAM)
		{
			if (!canEnterArea(eRevealedTeam, pPlot->area()) || (getDomainType() == DOMAIN_SEA && !canCargoEnterArea(eRevealedTeam, pPlot->area(), false) && getGroup()->isAmphibPlot(pPlot)))
			{
/*************************************************************************************************/
/**	Xienwolf Tweak							03/27/09											**/
/**																								**/
/**						Allows Combat Odds to display properly when HN							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				if (GET_TEAM(getTeam()).canDeclareWar(pPlot->getTeam()))
/**								----  End Original Code  ----									**/
				if (isAlwaysHostile(pPlot) || GET_TEAM(getTeam()).canDeclareWar(pPlot->getTeam()))
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
				{
					return eRevealedTeam;
				}
			}
		}
		else
		{
			if (pPlot->isActiveVisible(false))
			{
				if (canMoveInto(pPlot, true, true, true))
				{
					pUnit = pPlot->plotCheck(PUF_canDeclareWar, getOwnerINLINE(), isAlwaysHostile(pPlot), NO_PLAYER, NO_TEAM, PUF_isVisible, getOwnerINLINE());

					if (pUnit != NULL)
					{
						return pUnit->getTeam();
					}
				}
			}
		}
	}

	return NO_TEAM;
}


bool CvUnit::willRevealByMove(const CvPlot* pPlot) const
{
	// Xienwolf - 03/27/09 - Blocks Movement of Marked Units
	if (isBlind())
		return false;

	int iRange = visibilityRange() + 1;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			CvPlot* pLoopPlot = ::plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), i, j);
			if (pLoopPlot == NULL)
				continue;

			// TODO: remove or fix this entire method; visibility range accounts for the unit's current tile, not pPlot
			if (!pLoopPlot->isRevealed(getTeam(), false) && pPlot->canSeePlot(pLoopPlot, getTeam(), visibilityRange()))
				return true;
		}
	}

	return false;
}


/*************************************************************************************************/
/**	AITweak							19/06/10								Snarko				**/
/**																								**/
/**		We need to ignore if the other unit has attacked. By the time it can move it hasn't		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::canMoveInto(const CvPlot* pPlot, bool bAttack, bool bDeclareWar, bool bIgnoreLoad) const
/**								----  End Original Code  ----									**/
bool CvUnit::canMoveInto(const CvPlot* pPlot, bool bAttack, bool bDeclareWar, bool bIgnoreLoad, bool bIgnoreHasAttacked, bool bIgnoreTileLimit) const
/*************************************************************************************************/
/**	AITweak									END													**/
/*************************************************************************************************/
{
	PROFILE_FUNC();

	FAssertMsg(pPlot != NULL, "Plot is not assigned a valid value");

	if (atPlot(pPlot))
	{
		return false;
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							03/27/09											**/
/**																								**/
/**									Blocks Movement of Marked Units								**/
/*************************************************************************************************/
	if ((!pPlot->isVisible(getTeam(), false) || !pPlot->isRevealed(getTeam(), false)) && isBlind())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (pPlot->isImpassable())
	{
		if (!canMoveImpassable())
		{
			return false;
		}
	}

/*************************************************************************************************/
/**	Mountain Mod 				expanded by Ahwaric	20.09.09		**/
/*************************************************************************************************/
	if (pPlot->isPeak())
	{
		if (!canClimbPeaks())
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Mountain Mod END									**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
//	if (pPlot->getPerceptionCost() > getPerception())
//	{
//		return false;
//	}
	if (pPlot->getPlotEffectType() != NO_PLOT_EFFECT && GC.getPlotEffectInfo((PlotEffectTypes)pPlot->getPlotEffectType()).getPerceptionCost() > getPerception())
	{
		if (!(pPlot->isOwned()) || pPlot->getOwner() != getOwner())
		{
			if (pPlot->getNumUnits() == 0 || pPlot->getUnitByIndex(0)->getTeam() != getTeam())
			{
				return false;
			}
		}
	}
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

	// Cannot move around in unrevealed land freely
/*************************************************************************************************/
/**	NoReveal 						05/15/08										Xienwolf	**/
/**																								**/
/**						Adds new Promotion Tag check to the old Unit Tag Check					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_pUnitInfo->isNoRevealMap() && willRevealByMove(pPlot))
/**								----  End Original Code  ----									**/
	if ((m_pUnitInfo->isNoRevealMap() || isNoMapReveal()) && willRevealByMove(pPlot))
/*************************************************************************************************/
/**	No Reveal 									END												**/
/*************************************************************************************************/
	{
		return false;
	}

	if (GC.getUSE_SPIES_NO_ENTER_BORDERS())
	{
		if (isSpy() && NO_PLAYER != pPlot->getOwnerINLINE())
		{
			if (!GET_PLAYER(getOwnerINLINE()).canSpiesEnterBorders(pPlot->getOwnerINLINE()))
			{
				return false;
			}
		}
	}

	CvArea *pPlotArea = pPlot->area();
	TeamTypes ePlotTeam = pPlot->getTeam();
	bool bCanEnterArea = canEnterArea(ePlotTeam, pPlotArea);
/*************************************************************************************************/
/** ImpassableTweak					Opera					26/10/09							**/
/**																								**/
/** --Start Original Code --																	**
	if (bCanEnterArea)
	{
		if (pPlot->getFeatureType() != NO_FEATURE)
		{
			if (m_pUnitInfo->getFeatureImpassable(pPlot->getFeatureType()))
			{
				TechTypes eTech = (TechTypes)m_pUnitInfo->getFeaturePassableTech(pPlot->getFeatureType());
				if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
				{
					if (DOMAIN_SEA != getDomainType() || pPlot->getTeam() != getTeam())  // sea units can enter impassable in own cultural borders
					{
						return false;
					}
				}
			}
		}
		else
		{
			if (m_pUnitInfo->getTerrainImpassable(pPlot->getTerrainType()))
			{
				TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
				if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
				{
					if (DOMAIN_SEA != getDomainType() || pPlot->getTeam() != getTeam())  // sea units can enter impassable in own cultural borders
					{
						if (bIgnoreLoad || !canLoad(pPlot))
						{
							return false;
						}
					}
				}
			}
		}
	}
/** -- End Original Code --																		**/
/*************************************************************************************************/
	bool bCanMoveIntoFeature = true;
	bool bCanMoveIntoTerrain = true;

	if (bCanEnterArea)
	{
		if (pPlot->getFeatureType() != NO_FEATURE)
		{
			if (m_pUnitInfo->getFeatureImpassable(pPlot->getFeatureType()))
			{
				TechTypes eTech = (TechTypes)m_pUnitInfo->getFeaturePassableTech(pPlot->getFeatureType());
				if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
				{
					if (DOMAIN_SEA != getDomainType() || pPlot->getTeam() != getTeam())  // sea units can enter impassable in own cultural borders
					{
						bCanMoveIntoFeature = false;
					}
				}
			}
		}

		if (m_pUnitInfo->getTerrainImpassable(pPlot->getTerrainType()))
		{
			TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
			if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
			{
				if (DOMAIN_SEA != getDomainType() || pPlot->getTeam() != getTeam())  // sea units can enter impassable in own cultural borders
				{
					if (bIgnoreLoad || !canLoad(pPlot))
					{
						bCanMoveIntoTerrain = false;
					}
				}
			}
		}

		if (!bCanMoveIntoFeature || !bCanMoveIntoTerrain)
		{
			return false;
		}
	}
/*************************************************************************************************/
/** ImpassableTweak					END															**/
/*************************************************************************************************/

	switch (getDomainType())
	{
	case DOMAIN_SEA:
		if (!pPlot->isWater() && !canMoveAllTerrain())
		{
			if (!pPlot->isFriendlyCity(*this, true) || !pPlot->isCoastalLand())
			{
				return false;
			}
		}
		break;

	case DOMAIN_AIR:
		if (!bAttack)
		{
			bool bValid = false;

			if (pPlot->isFriendlyCity(*this, true))
			{
				bValid = true;

				if (m_pUnitInfo->getAirUnitCap() > 0)
				{
					if (pPlot->airUnitSpaceAvailable(getTeam()) <= 0)
					{
						bValid = false;
					}
				}
			}

			if (!bValid)
			{
				if (bIgnoreLoad || !canLoad(pPlot))
				{
					return false;
				}
			}
		}

		break;

	case DOMAIN_LAND:
		if (pPlot->isWater()
		 && !canMoveAllTerrain()
		 && !(bAttack && isBoarding())
		 && !pPlot->isCity(true))
		{
			// Last two checks are... probably to avoid confusing AI? Boat-to-boat walking could be cool, enabled here if desired
			if (bIgnoreLoad || !canLoad(pPlot) || !isHuman() || plot()->isWater())
			{
				return false;
			}
		}
		break;

	case DOMAIN_IMMOBILE:
		return false;
		break;

	default:
		FAssert(false);
		break;
	}

/*************************************************************************************************/
/**	MultiBarb							01/01/09									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
//FfH: Modified by Kael 08/04/2007 (So owned animals dont have limited movement)
//	if (isAnimal())
	if (isAnimal() && isBarbarian())
//FfH: End Add

	{
		if (pPlot->isOwned())
		{
			return false;
		}
/**								----  End Original Code  ----									**/
	if (isBarbarian() && GC.getGameINLINE().getElapsedGameTurns() < (30 * GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent())/100)
	{
		if (pPlot->isCity() && atWar(pPlot->getTeam(), getTeam()))
		{
/*************************************************************************************************/
/**   Bugfix                           03/11/11                           Snarko   **/
/**                                                                        **/
/**   This was allowing barbs to move THROUGH enemy cities early in the game (capturing them)      **/
/**                        ---- Start Original Code ----                           **
			return (pPlot->getNumDefenders(pPlot->getOwner()) > 0);
/**                        ----  End Original Code  ----                           **/
			 if (pPlot->getNumDefenders(pPlot->getOwner()) > 0)
			 {
				return false;
			 }
/*************************************************************************************************/
/**   Bugfix End                                                                **/
/*************************************************************************************************/
		}
	}
	//This prevents Barbarians of mixed factions from sharing a tile.  Can be annoying if a large stack of peaceful orcs contains a hostile demon you didn't notice
	if (pPlot->isUnit())
	{
		if (isBarbarian())
		{
			if (!pPlot->plotCheck(PUF_isTeam, getTeam()))
			{
				if(pPlot->plotCheck(PUF_isTeam, ORC_TEAM))
				{
					return false;
				}
				if(pPlot->plotCheck(PUF_isTeam, ANIMAL_TEAM))
				{
					return false;
				}
				if(pPlot->plotCheck(PUF_isTeam, DEMON_TEAM))
				{
					return false;
				}
			}
		}
	}

	if (getTeam() == ANIMAL_TEAM)
	{
/*************************************************************************************************/
/** Feral Animal Tweak         				10/17/09								Valkrionn	**/
/**		Allows animals to enter cultural Borders if granted the RivalTerritoryExplore tag		**/
/*************************************************************************************************/
		if (pPlot->isCity() && atWar(pPlot->getTeam(), getTeam()))
		{
			if (GC.getGameINLINE().isOption(GAMEOPTION_TIMID_ANIMALS) || !isRivalTerritory())
			{
				return false;
			}
		}
		if (plot() != NULL)
		{
			if (!plot()->isOwned())
			{
				if (pPlot->isOwned() && atWar(pPlot->getTeam(), getTeam()))
				{
					if (GC.getGameINLINE().isOption(GAMEOPTION_TIMID_ANIMALS) || !isRivalTerritory())
					{
						return false;
					}
				}
			}
		}
/*************************************************************************************************/
/**	Tweak End																					**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Bugfix									23/01/12									Snarko	**/
/**																								**/
/**	This could cause a WoC if there were units on the plot, but not enemy units					**/
/**	bAttack is usually checked both on and off when deciding to move OR attack into a plot		**/
/**	Later in this function we make sure there are units on the plot if bAttack is on (roughly)	**/
/**	If bDeclareWar is set we only check for the existance of units that aren't our				**/
/**	Because we could potentially attack those units if we wanted to even if we aren't at war yet**/
/**	Since there are units on the plot we can attack into it so we return true in the end		**/
/**	When we finally try to move, we do just that - try to move. We don't want to declare war	**/
/**	But we can't move! Because there's a bonus or improvement there and no enemy units!			**/
/** So we leave our group (which has decided to move into the plot) and create a new one		**/
/** Later we'll try to give this new group some orders... guess what our new group will decide	**/
/** Sometimes it might decide to do something else and the code is just inefficient				**/
/** But sometimes it will try to move into the same plot again and again and again, thus WoC	**/
/**	This can't occur in BtS because nobody is at peace with barbs in BtS						**/
/**	So any not-our unit on the plot is guaranteed an enemy.										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (!bAttack)
		{
			if (pPlot->getBonusType() != NO_BONUS)
			{
				return false;
			}

			if (pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				return false;
			}
/*************************************************************************************************/
/**	Xienwolf Tweak							03/20/09											**/
/**																								**/
/**						Allows Animal Units to share tiles with friendly units					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			if (pPlot->getNumUnits() > 0)
/**								----  End Original Code  ----									**/
/**								---- Start Original Code ----									**
			if (pPlot->getNumVisibleEnemyDefenders(this) > 0)
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			{
				return false;
			}
		}
/**								----  End Original Code  ----									**/
		if ((pPlot->getBonusType() != NO_BONUS) || (pPlot->getImprovementType() != NO_IMPROVEMENT))
		{
			if (!bAttack || !pPlot->isVisibleEnemyUnit(this))
				return false;
		}
/*************************************************************************************************/
/**	Bugfix END																					**/
/*************************************************************************************************/
	}

	if (isCannotCapture(true))
	{
		if (!bAttack)
		{
			if (pPlot->isEnemyCity(*this))
			{
				return false;
			}
		}
	}

	if (bAttack)
	{
/*************************************************************************************************/
/**	AITweak							19/06/10								Snarko				**/
/**																								**/
/**		We need to ignore if the other unit has attacked. By the time it can move it hasn't		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (isMadeAttack() && !isBlitz())
/**								----  End Original Code  ----									**/
		if (!bIgnoreHasAttacked && isMadeAttack() && !isBlitz())
/*************************************************************************************************/
/**	AITweak									END													**/
/*************************************************************************************************/
		{
			return false;
		}
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		if (bAttack)
		{
			if (!canAirStrike(pPlot))
			{
				return false;
			}
		}
	}
	else
	{
		if (canAttack())
		{
			if (bAttack || !canCoexistWithEnemyUnit(NO_TEAM))
			{
				if (!isHuman() || (pPlot->isVisible(getTeam(), false)))
				{
					if (pPlot->isVisibleEnemyUnit(this) != bAttack)
					{
						//FAssertMsg(isHuman() || (!bDeclareWar || (pPlot->isVisibleOtherUnit(getOwnerINLINE()) != bAttack)), "hopefully not an issue, but tracking how often this is the case when we dont want to really declare war");
						if (!bDeclareWar || (pPlot->isVisibleOtherUnit(getOwnerINLINE()) != bAttack && !(bAttack && pPlot->getPlotCity() && !isCannotCapture(true))))
						{
							return false;
						}
					}
				}
			}

			if (bAttack)
			{
				CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwnerINLINE(), this, true);
				if (NULL != pDefender)
				{
					if (!canAttack(*pDefender))
					{
						return false;
					}
				}
			}
		}
		else
		{
			if (bAttack)
			{
				return false;
			}

			if (!canCoexistWithEnemyUnit(NO_TEAM))
			{
				if (!isHuman() || pPlot->isVisible(getTeam(), false))
				{
					if (pPlot->isEnemyCity(*this))
					{
						return false;
					}

					if (pPlot->isVisibleEnemyUnit(this))
					{
						return false;
					}
				}
			}
		}

		if (isHuman())
		{
			ePlotTeam = pPlot->getRevealedTeam(getTeam(), false);
			bCanEnterArea = canEnterArea(ePlotTeam, pPlotArea);
		}

		if (!bCanEnterArea)
		{
			FAssert(ePlotTeam != NO_TEAM);

			if (!(GET_TEAM(getTeam()).canDeclareWar(ePlotTeam)))
			{
				return false;
			}

			if (isHuman())
			{
				if (!bDeclareWar)
				{
					return false;
				}
			}
			else
			{
				if (GET_TEAM(getTeam()).AI_isSneakAttackReady(ePlotTeam))
				{
					if (!(getGroup()->AI_isDeclareWar(pPlot)))
					{
						return false;
					}
				}
				else
				{
					return false;
				}
			}
		}
	}

/*************************************************************************************************/
/**	JRouteNative by Jeckel		imported by Valkrionn	09.28.09                        		**/
/*************************************************************************************************/
	// If the Plot's RouteType is Route Impassable to the Unit
	if (pPlot->getRevealedRouteType(getTeam(), false) != NO_ROUTE)
	{
		if (GC.getUnitInfo(getUnitType()).getRouteImpassable(pPlot->getRevealedRouteType(getTeam(), false)))
		{
			return false;
		}
	}
	// If it has a Route Native then the Plot must have one of the Route Natives
	bool bHasRouteNative = false;
	int iI;
	for (iI = 0; iI < GC.getNumRouteInfos(); iI++)
	{
		if (GC.getUnitInfo(getUnitType()).getRouteNative(iI))
		{
			bHasRouteNative = true;
		}
	}
	if (bHasRouteNative)
	{
		if (pPlot->getRevealedRouteType(getTeam(), false) == NO_ROUTE)
		{
			return false;
		}
		if (!GC.getUnitInfo(getUnitType()).getRouteNative(pPlot->getRevealedRouteType(getTeam(), false)))
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	JRouteNative    END                                                                   		**/
/*************************************************************************************************/

//FfH: Added by Kael 09/02/2007
	if (pPlot->getFeatureType() != NO_FEATURE)
	{
		if (GC.getFeatureInfo((FeatureTypes)pPlot->getFeatureType()).getRequireResist() != NO_DAMAGE)
		{
			if (getDamageTypeResist((DamageTypes)GC.getFeatureInfo((FeatureTypes)pPlot->getFeatureType()).getRequireResist()) < GC.getDefineINT("FEATURE_REQUIRE_RESIST_AMOUNT"))
			{
				return false;
			}
		}
	}
	if (pPlot->isOwned())
	{
		if (pPlot->getTeam() != getTeam())
		{
			if (GET_PLAYER(pPlot->getOwnerINLINE()).getSanctuaryTimer() != 0)
			{
				return false;
			}
		}
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**			Allows Units to enter a City which has been locked down by Force Spells				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getLevel() < pPlot->getMinLevel())
/**								----  End Original Code  ----									**/
	if (getLevel() < pPlot->getMinLevel() && !(pPlot->isOwned() && pPlot->getTeam() == getTeam() && pPlot->isCity()))
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	{
		return false;
	}
	if (pPlot->isMoveDisabledHuman())
	{
		if (isHuman())
		{
			return false;
		}
	}
	if (pPlot->isMoveDisabledAI())
	{
		if (!isHuman())
		{
			return false;
		}
	}
//FfH: End Add
/*************************************************************************************************/
/**	MobileCage								 6/17/2009								Cyther		**/
/**	Expanded by Valkrionn					01/28/2010											**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	if (isLeashed())
	{
		if (getLeashRange() >= 0)
		{
			if (getLeashUnit() != NULL)
			{
				if ((getLeashUnit()->getX() != INVALID_PLOT_COORD) && (getLeashUnit()->getY() != INVALID_PLOT_COORD))
				{
					int iLeashRange = getLeashRange();
					int iX = getLeashUnit()->getX();
					int iY = getLeashUnit()->getY();
					int iNewPlotDistance = (plotDistance(iX, iY, pPlot->getX_INLINE(), pPlot->getY_INLINE()));
					int iPlotDistance = (plotDistance(iX, iY, getX(), getY()));
					if (iNewPlotDistance > iLeashRange)
					{
						if (iNewPlotDistance <= iPlotDistance)
						{
							return true;
						}
						else
						{
							return false;
						}
					}
				}
			}
			else if ((getLeashX() != INVALID_PLOT_COORD) && (getLeashY() != INVALID_PLOT_COORD))
			{
				int iLeashRange = getLeashRange();
				int iNewPlotDistance = (plotDistance(getLeashX(), getLeashY(), pPlot->getX_INLINE(), pPlot->getY_INLINE()));
				int iPlotDistance = (plotDistance(getLeashX(), getLeashY(), getX(), getY()));
				if (iNewPlotDistance > iLeashRange)
				{
					if (iNewPlotDistance <= iPlotDistance)
					{
						return true;
					}
					else
					{
						return false;
					}
				}
			}
		}
	}
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	xUPT								02/08/11									Afforess	**/
/**																								**/
/**						xUPT mechanic, ported and modified by Valkrionn							**/
/*************************************************************************************************/
	if (GC.getGameINLINE().getUPT() > 0)
	{
		if (!bIgnoreTileLimit)
		{
			if (!getUnitInfo().isOnlyDefensive() && baseCombatStr() > 0)
			{
				if (getDomainType() == DOMAIN_LAND && !pPlot->isWater() || getDomainType() == DOMAIN_SEA && pPlot->isWater() || getDomainType() == DOMAIN_AIR)
				{
					int iCount = pPlot->getUnitCount(this);
					if (GC.getGameINLINE().getUPT() <= iCount)
					{
						return false;
					}
				}
			}
		}
	}
/*************************************************************************************************/
/**	xUPT									END													**/
/*************************************************************************************************/


	if (GC.getUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK())
	{
		// Python Override
		CyArgsList argsList;
		argsList.add(getOwnerINLINE());	// Player ID
		argsList.add(getID());	// Unit ID
		argsList.add(pPlot->getX());	// Plot X
		argsList.add(pPlot->getY());	// Plot Y
		long lResult=0;
		gDLL->getPythonIFace()->callFunction(PYGameModule, "unitCannotMoveInto", argsList.makeFunctionArgs(), &lResult);

		if (lResult != 0)
		{
			return false;
		}
	}
	return true;
}

/*************************************************************************************************/
/**	AITweak							19/06/10								Snarko				**/
/**																								**/
/**		When checking for danger with workers we need to ignore if the other unit has attacked. **/
/**				By the time the enemy turn begin the unit has no longer attacked				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::canMoveOrAttackInto(const CvPlot* pPlot, bool bDeclareWar) const
{
	return (canMoveInto(pPlot, false, bDeclareWar) || canMoveInto(pPlot, true, bDeclareWar));
}
/**								----  End Original Code  ----									**/
bool CvUnit::canMoveOrAttackInto(const CvPlot* pPlot, bool bDeclareWar, bool bIgnoreHasAttacked) const
{
	return (canMoveInto(pPlot, false, bDeclareWar, false, bIgnoreHasAttacked) || canMoveInto(pPlot, true, bDeclareWar, false, bIgnoreHasAttacked));
}
/*************************************************************************************************/
/**	AITweak									END													**/
/*************************************************************************************************/

bool CvUnit::canMoveThrough(const CvPlot* pPlot) const
{
	return canMoveInto(pPlot, false, false, true);
}


void CvUnit::attack(CvPlot* pPlot, bool bQuick)
{
	PROFILE_FUNC();

	FAssert(canMoveInto(pPlot, true));
	FAssert(getCombatTimer() == 0);

	setAttackPlot(pPlot, false);

	updateCombat(bQuick);
}

void CvUnit::fightInterceptor(const CvPlot* pPlot, bool bQuick)
{
	FAssert(getCombatTimer() == 0);

	setAttackPlot(pPlot, true);

	updateAirCombat(bQuick);
}

void CvUnit::attackForDamage(CvUnit *pDefender, int attackerDamageChange, int defenderDamageChange)
{
	FAssert(getCombatTimer() == 0);
	FAssert(pDefender != NULL);
	FAssert(!isFighting());

	if(pDefender == NULL)
	{
		return;
	}

	setAttackPlot(pDefender->plot(), false);

	CvPlot* pPlot = getAttackPlot();
	if (pPlot == NULL)
	{
		return;
	}

	//rotate to face plot
	DirectionTypes newDirection = estimateDirection(this->plot(), pDefender->plot());
	if(newDirection != NO_DIRECTION)
	{
		setFacingDirection(newDirection);
	}

	//rotate enemy to face us
	newDirection = estimateDirection(pDefender->plot(), this->plot());
	if(newDirection != NO_DIRECTION)
	{
		pDefender->setFacingDirection(newDirection);
	}

	//check if quick combat
	bool bVisible = isCombatVisible(pDefender);

	//if not finished and not fighting yet, set up combat damage and mission
	if (!isFighting())
	{
		if (plot()->isFighting() || pPlot->isFighting())
		{
			return;
		}

		setCombatUnit(pDefender, true);
		pDefender->setCombatUnit(this, false);

		pDefender->getGroup()->clearMissionQueue();

		bool bFocused = (bVisible && isCombatFocus() && gDLL->getInterfaceIFace()->isCombatFocus());

		if (bFocused)
		{
			DirectionTypes directionType = directionXY(plot(), pPlot);
			//								N			NE				E				SE					S				SW					W				NW
			NiPoint2 directions[8] = {NiPoint2(0, 1), NiPoint2(1, 1), NiPoint2(1, 0), NiPoint2(1, -1), NiPoint2(0, -1), NiPoint2(-1, -1), NiPoint2(-1, 0), NiPoint2(-1, 1)};
			NiPoint3 attackDirection = NiPoint3(directions[directionType].x, directions[directionType].y, 0);
			float plotSize = GC.getPLOT_SIZE();
			NiPoint3 lookAtPoint(plot()->getPoint().x + plotSize / 2 * attackDirection.x, plot()->getPoint().y + plotSize / 2 * attackDirection.y, (plot()->getPoint().z + pPlot->getPoint().z) / 2);
			attackDirection.Unitize();
			gDLL->getInterfaceIFace()->lookAt(lookAtPoint, (((getOwnerINLINE() != GC.getGameINLINE().getActivePlayer()) || gDLL->getGraphicOption(GRAPHICOPTION_NO_COMBAT_ZOOM)) ? CAMERALOOKAT_BATTLE : CAMERALOOKAT_BATTLE_ZOOM_IN), attackDirection);
		}
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**							This message is just plain annoying									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		else
		{
			PlayerTypes eAttacker = getVisualOwner(pDefender->getTeam());
			CvWString szMessage;
			if (BARBARIAN_PLAYER != eAttacker)
			{
				szMessage = gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK", GET_PLAYER(getOwnerINLINE()).getNameKey());
			}
			else
			{
				szMessage = gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK_UNKNOWN");
			}

			gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szMessage, "AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true);
		}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	}

	FAssertMsg(plot()->isFighting(), "Current unit instance plot is not fighting as expected");
	FAssertMsg(pPlot->isFighting(), "pPlot is not fighting as expected");

	//setup battle object
	CvBattleDefinition kBattle;
	kBattle.setUnit(BATTLE_UNIT_ATTACKER, this);
	kBattle.setUnit(BATTLE_UNIT_DEFENDER, pDefender);
	kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN, getDamage());
	kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN, pDefender->getDamage());

	changeDamage(attackerDamageChange, pDefender->getOwnerINLINE());
	pDefender->changeDamage(defenderDamageChange, getOwnerINLINE());

	if (bVisible)
	{
		kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END, getDamage());
		kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END, pDefender->getDamage());
		kBattle.setAdvanceSquare(canAdvance(pPlot, 1));

		kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN));
		kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN));

		int iTurns = planBattle( kBattle);
		kBattle.setMissionTime(iTurns * gDLL->getSecsPerTurn());
		setCombatTimer(iTurns);

		GC.getGameINLINE().incrementTurnTimer(getCombatTimer());

		if (pPlot->isActiveVisible(false))
		{
			ExecuteMove(0.5f, true);
			gDLL->getEntityIFace()->AddMission(&kBattle);
		}
	}
	else
	{
		setCombatTimer(1);
	}
}


void CvUnit::move(CvPlot* pPlot, bool bShow)
{
	FAssert(canMoveOrAttackInto(pPlot) || isMadeAttack());
	if (this == NULL)
	{
		return;
	}
	CvPlot* pOldPlot = plot();

	changeMoves(pPlot->movementCost(this, plot()));

	setXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true, bShow && pPlot->isVisibleToWatchingHuman(), bShow);

	//change feature
	FeatureTypes featureType = pPlot->getFeatureType();
	if(featureType != NO_FEATURE)
	{
		CvString featureString(GC.getFeatureInfo(featureType).getOnUnitChangeTo());
		if(!featureString.IsEmpty())
		{
			FeatureTypes newFeatureType = (FeatureTypes) GC.getInfoTypeForString(featureString);
			pPlot->setFeatureType(newFeatureType);
		}
	}

	if (getOwnerINLINE() == GC.getGameINLINE().getActivePlayer())
	{
		if (!(pPlot->isOwned()))
		{
			//spawn birds if trees present - JW
			if (featureType != NO_FEATURE)
			{
				if (GC.getASyncRand().get(100) < GC.getFeatureInfo(featureType).getEffectProbability())
				{
					EffectTypes eEffect = (EffectTypes)GC.getInfoTypeForString(GC.getFeatureInfo(featureType).getEffectType());
					gDLL->getEngineIFace()->TriggerEffect(eEffect, pPlot->getPoint(), (float)(GC.getASyncRand().get(360)));
					gDLL->getInterfaceIFace()->playGeneralSound("AS3D_UN_BIRDS_SCATTER", pPlot->getPoint());
				}
			}
		}
	}

//FfH: Modified by Kael 08/02/2008
//	CvEventReporter::getInstance().unitMove(pPlot, this, pOldPlot);
	if(GC.getUSE_ON_UNIT_MOVE_CALLBACK())
	{
		CvEventReporter::getInstance().unitMove(pPlot, this, pOldPlot);
	}
//FfH: End Modify

}


// returns true if unit is relocated, false otherwise. AdjacentOnly defaults to false for e.g. sanctuary python effects
// If bKill is true, will immediately kill unit before returning false. bADJACENTONLY IS WIP
bool CvUnit::jumpToNearestValidPlot(bool bKill, bool bAdjacentOnly)
{
	PROFILE_FUNC();

	CvCity* pNearestCity;
	CvPlot* pLoopPlot;
	CvPlot* pBestPlot;
	int iValue;
	int iBestValue;
	int iI;

	FAssertMsg(!isAttacking(), "isAttacking did not return false as expected");
	FAssertMsg(!isFighting(), "isFighting did not return false as expected");

	pNearestCity = GC.getMapINLINE().findCity(getX_INLINE(), getY_INLINE(), getOwnerINLINE());

	iBestValue = MAX_INT;
	pBestPlot = NULL;

	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
	{
		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);

		if (!pLoopPlot->isValidDomainForLocation(*this))
			continue;

		if (!canMoveInto(pLoopPlot))
			continue;

		if (!canEnterArea(pLoopPlot->getTeam(), pLoopPlot->area()) || isEnemy(pLoopPlot->getTeam(), pLoopPlot))
			continue;

		FAssertMsg(!atPlot(pLoopPlot), "atPlot(pLoopPlot) did not return false as expected");

		if ((getDomainType() == DOMAIN_AIR) && !pLoopPlot->isFriendlyCity(*this, true))
			continue;

		if (!pLoopPlot->isRevealed(getTeam(), false))
			continue;

		iValue = (plotDistance(plot(), pLoopPlot) * 2);

		if (pNearestCity != NULL)
			iValue += plotDistance(pLoopPlot, pNearestCity->plot());

		if (getDomainType() == DOMAIN_SEA && !plot()->isWater())
		{
			if (!pLoopPlot->isWater() || !pLoopPlot->isAdjacentToArea(area()))
				iValue *= 3;
		}
		else if (pLoopPlot->area() != area())
			iValue *= 3;

		if (iValue < iBestValue)
		{
			iBestValue = iValue;
			pBestPlot = pLoopPlot;
		}
	}

	if (pBestPlot != NULL)
	{
		setXY(pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE());
		return true;
	}
	else if (bKill)
		kill(false);

	return false;
}


bool CvUnit::canAutomate(AutomateTypes eAutomate) const
{
	if (eAutomate == NO_AUTOMATE)
	{
		return false;
	}

	if (!isGroupHead())
	{
		return false;
	}

	switch (eAutomate)
	{
	case AUTOMATE_BUILD:
		if ((AI_getUnitAIType() != UNITAI_WORKER) && (AI_getUnitAIType() != UNITAI_WORKER_SEA))
		{
			return false;
		}
		break;

	case AUTOMATE_NETWORK:
		if ((AI_getUnitAIType() != UNITAI_WORKER) || !canBuildRoute())
		{
			return false;
		}
		break;

	case AUTOMATE_CITY:
		if (AI_getUnitAIType() != UNITAI_WORKER)
		{
			return false;
		}
		break;

	case AUTOMATE_EXPLORE:
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      04/25/10                                jdog5000      */
/*                                                                                              */
/* Player Interface                                                                             */
/************************************************************************************************/
		if ( !canFight() )
		{
			// Enable exploration for air units
			if((getDomainType() != DOMAIN_SEA) && (getDomainType() != DOMAIN_AIR))
			{
				if( !(alwaysInvisible()) || !(isSpy()) )
				{
					return false;
				}
			}
		}

		if( (getDomainType() == DOMAIN_IMMOBILE) )
		{
			return false;
		}

		if( getDomainType() == DOMAIN_AIR && !canRecon(NULL) )
		{
			return false;
		}
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/

		break;

	case AUTOMATE_RELIGION:
		if (AI_getUnitAIType() != UNITAI_MISSIONARY)
		{
			return false;
		}
		break;

	default:
		FAssert(false);
		break;
	}

	return true;
}


void CvUnit::automate(AutomateTypes eAutomate)
{
	if (!canAutomate(eAutomate))
	{
		return;
	}

	getGroup()->setAutomateType(eAutomate);
}


bool CvUnit::canScrap() const
{
	if (plot()->isFighting())
	{
		return false;
	}

//FfH: Added by Kael 11/06/2007
	if (GET_PLAYER(getOwnerINLINE()).getTempPlayerTimer() > 0)
	{
		return false;
	}
	if (m_pUnitInfo->getEquipmentPromotion() != NO_PROMOTION)
	{
		return false;
	}
/*************************************************************************************************/
/**	Upkeep									05/31/09								Xienwolf	**/
/**																								**/
/**		No good reason to scrap a unit that doesn't cost you a dime, so don't let them			**/
/*************************************************************************************************/
	if(getCommanderUnit() != NULL && getPreviousOwner() != NO_PLAYER)
	{
		return false;
	}

	if (!isHuman() && isFreeUnit())
	{
		return false;
	}
/*************************************************************************************************/
/**	Upkeep									END													**/
/*************************************************************************************************/
//FfH: End Add

	return true;
}


void CvUnit::scrap()
{
	if (!canScrap())
	{
		return;
	}

//FfH: Added by Kael 11/04/2007
	if (getBetrayalChance() > 0)
	{
/*************************************************************************************************/
/**	MultiBarb							12/23/08									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				betray(BARBARIAN_PLAYER);
/**								----  End Original Code  ----									**/
		betray(ORC_PLAYER);
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
	}
//FfH: End Add

	kill(true);
}


bool CvUnit::canGift(bool bTestVisible, bool bTestTransport)
{

//FfH: Added by Kael 04/22/2008 (to disable gifting)
	return false;
//FfH: End Add

	CvPlot* pPlot = plot();
	CvUnit* pTransport = getTransportUnit();

	if (!(pPlot->isOwned()))
	{
		return false;
	}

	if (pPlot->getOwnerINLINE() == getOwnerINLINE())
	{
		return false;
	}

	if (pPlot->isVisibleEnemyUnit(this))
	{
		return false;
	}

	if (pPlot->isVisibleEnemyUnit(pPlot->getOwnerINLINE()))
	{
		return false;
	}

	if (!pPlot->isValidDomainForLocation(*this) && NULL == pTransport)
	{
		return false;
	}

	for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
	{
		if (m_pUnitInfo->getCorporationSpreads(iCorp) > 0)
		{
			return false;
		}
	}

	if (bTestTransport)
	{
		if (pTransport && pTransport->getTeam() != pPlot->getTeam())
		{
			return false;
		}
	}

	if (!bTestVisible)
	{
		if (GET_TEAM(pPlot->getTeam()).isUnitClassMaxedOut(getUnitClassType(), GET_TEAM(pPlot->getTeam()).getUnitClassMaking(getUnitClassType())))
		{
			return false;
		}

		if (GET_PLAYER(pPlot->getOwnerINLINE()).isUnitClassMaxedOut(getUnitClassType(), GET_PLAYER(pPlot->getOwnerINLINE()).getUnitClassMaking(getUnitClassType())))
		{
			return false;
		}

		if (!(GET_PLAYER(pPlot->getOwnerINLINE()).AI_acceptUnit(this)))
		{
			return false;
		}
	}

//FfH: Added by Kael 11/06/2007
	if (GET_PLAYER(getOwnerINLINE()).getTempPlayerTimer() > 0)
	{
		return false;
	}
//FfH: End Add

	return !atWar(pPlot->getTeam(), getTeam());
}


void CvUnit::gift(bool bTestTransport)
{
	CvUnit* pGiftUnit;
	CvWString szBuffer;
	PlayerTypes eOwner;

	if (!canGift(false, bTestTransport))
	{
		return;
	}

	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
		aCargoUnits[i]->gift(false);
	}

	FAssertMsg(plot()->getOwnerINLINE() != NO_PLAYER, "plot()->getOwnerINLINE() is not expected to be equal with NO_PLAYER");
	pGiftUnit = GET_PLAYER(plot()->getOwnerINLINE()).initUnit(getUnitType(), getX_INLINE(), getY_INLINE(), AI_getUnitAIType());

	FAssertMsg(pGiftUnit != NULL, "GiftUnit is not assigned a valid value");

	eOwner = getOwnerINLINE();

	pGiftUnit->convert(this);

/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      10/03/09                                jdog5000      */
/*                                                                                              */
/* General AI                                                                                   */
/************************************************************************************************/
	//GET_PLAYER(pGiftUnit->getOwnerINLINE()).AI_changePeacetimeGrantValue(eOwner, (pGiftUnit->getUnitInfo().getProductionCost() / 5));
	if( pGiftUnit->isCombat() )
	{
		GET_PLAYER(pGiftUnit->getOwnerINLINE()).AI_changePeacetimeGrantValue(eOwner, (pGiftUnit->getUnitInfo().getProductionCost() * 3 * GC.getGameINLINE().AI_combatValue(pGiftUnit->getUnitType()))/100);
	}
	else
	{
		GET_PLAYER(pGiftUnit->getOwnerINLINE()).AI_changePeacetimeGrantValue(eOwner, (pGiftUnit->getUnitInfo().getProductionCost()));
	}
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/

	szBuffer = gDLL->getText("TXT_KEY_MISC_GIFTED_UNIT_TO_YOU", GET_PLAYER(eOwner).getNameKey(), pGiftUnit->getNameKey());
	gDLL->getInterfaceIFace()->addMessage(pGiftUnit->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, pGiftUnit->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pGiftUnit->getX_INLINE(), pGiftUnit->getY_INLINE(), true, true);

	// Python Event
	CvEventReporter::getInstance().unitGifted(pGiftUnit, getOwnerINLINE(), plot());
}


bool CvUnit::canLoadUnit(const CvUnit* pUnit, const CvPlot* pPlot) const
{
	FAssert(pUnit != NULL);
	FAssert(pPlot != NULL);

	if (pUnit == this)
	{
		return false;
	}

	if (pUnit->getTeam() != getTeam())
	{
		return false;
	}

	// From Mongoose SDK Bugfix : UNOFFICIAL_PATCH Mongoose & jdog5000 06/23/10
	if (isCargo() && getTransportUnit() == pUnit)
	{
		return false;
	}

	if (getCargo() > 0)
	{
		return false;
	}

	if (pUnit->isCargo())
	{
		return false;
	}

	// Flying ships can't load one another : Ahwaric 13.06.09
	if ((cargoSpace() > 0) && (specialCargo() == NO_SPECIALUNIT))
	{
		return false;
	}

	// No sneaky Archeon boating away!
	if (isHeld() || pUnit->isHeld() || isLeashed() || pUnit->isLeashed())
	{
		return false;
	}

	if (!(pUnit->cargoSpaceAvailable(getSpecialUnitType(), getDomainType())))
	{
		return false;
	}

	if (!(pUnit->atPlot(pPlot)))
	{
		return false;
	}

	//FfH Hidden Nationality: Modified by Kael 08/27/2007
	// if (!m_pUnitInfo->isHiddenNationality() && pUnit->getUnitInfo().isHiddenNationality())
	if (isHiddenNationality() != pUnit->isHiddenNationality())
	{
		return false;
	}

	// Prevents Grouping Combat Capables with non-Combat Capables : PeaceAndFlowers Xienwolf 03/27/09
	if (isNeverHostile() != pUnit->isNeverHostile())
	{
		return false;
	}

	if (NO_SPECIALUNIT != getSpecialUnitType())
	{
		if (GC.getSpecialUnitInfo(getSpecialUnitType()).isCityLoad())
		{
			if (!pPlot->isCity(true, getTeam()))
			{
				return false;
			}
		}
	}

	// No shipping fort commanders around! : Blazenclaw 2025
	if (getUnitClassType() == GC.getDefineINT("FORT_COMMANDER_UNITCLASS"))
	{
		return false;
	}

	return true;
}


void CvUnit::loadUnit(CvUnit* pUnit)
{
	if (!canLoadUnit(pUnit, plot()))
	{
		return;
	}

	setTransportUnit(pUnit);
}

bool CvUnit::shouldLoadOnMove(const CvPlot* pPlot) const
{
	if (isCargo())
	{
		return false;
	}

	switch (getDomainType())
	{
		case DOMAIN_LAND:
			// Units that can move on water shouldn't autoload on ships : Snarko 10/04/10
			if (pPlot->isWater() && !canMoveAllTerrain())
			{
				return true;
			}
			break;
		case DOMAIN_AIR:
			if (!pPlot->isFriendlyCity(*this, true))
			{
				return true;
			}

			if (m_pUnitInfo->getAirUnitCap() > 0)
			{
				if (pPlot->airUnitSpaceAvailable(getTeam()) <= 0)
				{
					return true;
				}
			}
			break;
		default:
			break;
	}

	if (m_pUnitInfo->getTerrainImpassable(pPlot->getTerrainType()))
	{
		TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
		if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
		{
			return true;
		}
	}

	return false;
}


bool CvUnit::canLoad(const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	FAssert(pPlot != NULL);

	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
	while (pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if (canLoadUnit(pLoopUnit, pPlot))
		{
			return true;
		}
	}

	return false;
}


void CvUnit::load()
{
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pPlot;
	int iPass;

	if (!canLoad(plot()))
	{
		return;
	}

	pPlot = plot();

	for (iPass = 0; iPass < 2; iPass++)
	{
		pUnitNode = pPlot->headUnitNode();

		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);

			if (canLoadUnit(pLoopUnit, pPlot))
			{
				if ((iPass == 0) ? (pLoopUnit->getOwnerINLINE() == getOwnerINLINE()) : (pLoopUnit->getTeam() == getTeam()))
				{
					setTransportUnit(pLoopUnit);
					break;
				}
			}
		}

		if (isCargo())
		{
			break;
		}
	}
}


bool CvUnit::canUnload() const
{
	CvPlot& kPlot = *(plot());

	if (getTransportUnit() == NULL)
	{
		return false;
	}

	if (!kPlot.isValidDomainForLocation(*this))
	{
		return false;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		if (kPlot.isFriendlyCity(*this, true))
		{
			int iNumAirUnits = kPlot.countNumAirUnits(getTeam());
			CvCity* pCity = kPlot.getPlotCity();
			if (NULL != pCity)
			{
				if (iNumAirUnits >= pCity->getAirUnitCapacity(getTeam()))
				{
					return false;
				}
			}
			else
			{
				if (iNumAirUnits >= GC.getDefineINT("CITY_AIR_UNIT_CAPACITY"))
				{
					return false;
				}
			}
		}
	}

	return true;
}


void CvUnit::unload()
{
	if (!canUnload())
	{
		return;
	}

	setTransportUnit(NULL);
}


bool CvUnit::canUnloadAll() const
{
	if (getCargo() == 0)
	{
		return false;
	}

	return true;
}


void CvUnit::unloadAll()
{
	if (!canUnloadAll())
	{
		return;
	}

	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
		CvUnit* pCargo = aCargoUnits[i];
		if (pCargo->canUnload())
		{
			pCargo->setTransportUnit(NULL);
		}
		else
		{
			FAssert(isHuman() || pCargo->getDomainType() == DOMAIN_AIR);
			pCargo->getGroup()->setActivityType(ACTIVITY_AWAKE);
		}
	}
}


bool CvUnit::canHold(const CvPlot* pPlot) const
{
	return true;
}


bool CvUnit::canSleep(const CvPlot* pPlot) const
{
	// Xienwolf - 01/19/09 - Prevents inappropriate Enraged Actions
	if (isEnraged())
		return false;

	if (isWaiting())
		return false;

	if (isCargo())
		return true;

	if (isFortifyable())
		return false;

	return true;
}


// Checks for AI control, unit-specific fortify, unit doing other actions, if is cargo, and water walkers trying to dig into water 
bool CvUnit::canFortify(const CvPlot* pPlot) const
{
	// Xienwolf - 01/19/09 - Prevents inappropriate Enraged Actions
	if (isEnraged())
		return false;

	if (!isFortifyable())
		return false;

	if (isWaiting())
		return false;

	if (isCargo())
		return false;

	// Land units can't fortify on water unless is water city, acts as city, or fort
	if (getDomainType() == DOMAIN_LAND && pPlot->isWater())
	{
		if (!pPlot->isCity(true, getTeam()) && (pPlot->getImprovementType() == NO_IMPROVEMENT || !GC.getImprovementInfo(pPlot->getImprovementType()).isFort()))
			return false;
	}

	return true;
}


bool CvUnit::canAirPatrol(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_AIR)
		return false;

	if (!canAirDefend(pPlot))
		return false;

	if (isWaiting())
		return false;

	return true;
}


bool CvUnit::canSeaPatrol(const CvPlot* pPlot) const
{
	if (!pPlot->isWater())
		return false;

	if (getDomainType() != DOMAIN_SEA)
		return false;

	if (!canFight() || isOnlyDefensive())
		return false;

	if (isWaiting())
		return false;

	// Bezeri pokeballs can't sea patrol while loaded up
	if (isCargo())
		return false;

	return true;
}


void CvUnit::airCircle(bool bStart)
{
	if (!GC.IsGraphicsInitialized())
		return;

	if ((getDomainType() != DOMAIN_AIR) || (maxInterceptionProbability() == 0))
		return;

	// cancel previous missions
	gDLL->getEntityIFace()->RemoveUnitFromBattle( this );

	if (bStart)
	{
		CvAirMissionDefinition kDefinition;
		kDefinition.setPlot(plot());
		kDefinition.setUnit(BATTLE_UNIT_ATTACKER, this);
		kDefinition.setUnit(BATTLE_UNIT_DEFENDER, NULL);
		kDefinition.setMissionType(MISSION_AIRPATROL);
		kDefinition.setMissionTime(1.0f); // patrol is indefinite - time is ignored

		gDLL->getEntityIFace()->AddMission( &kDefinition );
	}
}


// Used for checking whether the sentry mission is valid
bool CvUnit::canSentryMission(const CvPlot* pPlot) const
{
	// Xienwolf - 01/19/09 - Prevents inappropriate Enraged Actions
	if (isEnraged())
		return false;

	if (!canDefend(pPlot))
		return false;

	if (isWaiting())
		return false;

	return true;
}

// Used for checking whether the heal mission is valid
bool CvUnit::canHealMission(const CvPlot* pPlot) const
{
	// Xienwolf - 01/19/09 - Prevents inappropriate Enraged Actions
	if (isEnraged())
		return false;

	if (!isHurt())
		return false;

	if (isWaiting())
		return false;

	// LunarMongoose - 06/02/10 - UNOFFICIAL_PATCH FeatureDamageFix
	if (healTurns(pPlot) == MAX_INT)
		return false;

	return true;
}


// Returns the healrate provided by units on this and adjacent tiles
int CvUnit::getHealBonusFromUnits(const CvPlot* pPlot) const
{
	// XXX optimize this (save it?)
	// Blaze: Can make a cache in CvPlot that updates on turn start, but 
	// it will be invalidated during unit move, so you'd need an additional arg
	// to track if this method is being called during turn start, or for UI/other reasons

	int iHeal;
	int iBestHeal = 0;
	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;

	while (pUnitNode != NULL)
	{
		pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if (GET_TEAM(pLoopUnit->getTeam()).isMilitaryAlly(getTeam()))
		{
			iHeal = pLoopUnit->getSameTileHeal();

			if (iHeal > iBestHeal)
				iBestHeal = iHeal;
		}
	}
	// "Heal on adjacent tiles" literally means adjacent;
	// unit design should thus always pair adjacent heal with an equal or greater "heal on same tile" effect
	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), ((DirectionTypes)iI));

		if (pLoopPlot == NULL)
			continue;

		if (pLoopPlot->area() != pPlot->area())
			continue;

		pUnitNode = pLoopPlot->headUnitNode();

		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

			if (!GET_TEAM(pLoopUnit->getTeam()).isMilitaryAlly(getTeam()))
				continue;

			iHeal = pLoopUnit->getAdjacentTileHeal();

			if (iHeal > iBestHeal)
				iBestHeal = iHeal;
		}
	}

	return iBestHeal;
}

// Returns percentile healing per turn, for this unit on given pPlot.
// Accounts for this unit promos, other units, empire and location effects.
// Does NOT account for whether unit cannot heal due to e.g. movement.
// Does NOT account for damage from tile; use CvPlot::calcTurnDamage for that.
int CvUnit::healRate(const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	//FfH: Added by Kael 11/05/2008
	if (GC.getGameINLINE().isOption(GAMEOPTION_NO_HEALING_FOR_HUMANS) && isHuman() && isAlive())
		return 0;

	// Blaze: Shortcut for perf, since this is an expensive method to run in full on every unit:
	if (pPlot->calcTurnDamageReal(this, false) == 0 && !isHurt())
		return 0;

	CvCity* pCity = pPlot->getPlotCity();
	int iTotalHeal = 0;

	// City or tile heal rates. Includes impacts from promotions here
	if (pPlot->isCity(true, getTeam()))
	{
		iTotalHeal += GC.getDefineINT("CITY_HEAL_RATE") + (GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()) ? getExtraFriendlyHeal() : getExtraNeutralHeal());

		// Occupied cities don't get tile healing, instead relying on unit/faction-wide only
		if (pCity && !pCity->isOccupation())
			iTotalHeal += pCity->getHealRate();
	}
	else
	{
		if (!GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()))
		{
			if (isEnemy(pPlot->getTeam(), pPlot))
			{
				iTotalHeal += (GC.getDefineINT("ENEMY_HEAL_RATE") + getExtraEnemyHeal());

				//FfH Mana Effects: Added by Kael 08/21/2007
				if (pPlot->getOwnerINLINE() != NO_PLAYER)
					iTotalHeal += GET_PLAYER(pPlot->getOwnerINLINE()).getHealChangeEnemy();
			}
			else
				iTotalHeal += (GC.getDefineINT("NEUTRAL_HEAL_RATE") + getExtraNeutralHeal());
		}
		else
		{
			iTotalHeal += (GC.getDefineINT("FRIENDLY_HEAL_RATE") + getExtraFriendlyHeal());

			//FfH Mana Effects: Added by Kael 08/21/2007
			iTotalHeal += GET_PLAYER(getOwnerINLINE()).getHealChange();
		}
	}

	iTotalHeal += getHealBonusFromUnits(pPlot);

	//FfH: Added by Kael 10/29/2007 (improvement heal rates)
	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
		iTotalHeal += GC.getImprovementInfo((ImprovementTypes)pPlot->getImprovementType()).getHealRateChange();

	// Promotions cannot make heal rate negative... for now.
	return std::max(0, iTotalHeal);
}

// Returns MAX_INT if never heals, or will die to DoT before healing.
// Accounts for unit movement, including getting to a different tile.
// Doesn't account for edge cases such as teleport without using move... but oh well.
int CvUnit::healTurns(const CvPlot* pPlot) const
{
	if (!isHurt())
		return 0;

	int iHealReal = healRate(pPlot) * GC.getDefineINT("HIT_POINT_FACTOR");
	int iTurnDamageReal = pPlot->calcTurnDamageReal(this, false);

	// Quick check to see if damage outstrips healing
	if (iTurnDamageReal >= iHealReal)
		return MAX_INT;

	// Add 1 to turns if won't heal on this turn
	int iTurns = isTurnHealBlocked() || (pPlot != plot() && !(isAlwaysHeal() || isBarbarian() || isEnraged()));
	int iThisTurnDamageReal = pPlot->calcTurnDamageReal(this, true, (1 - iTurns) * iHealReal);

	// Unit might die before being able to heal!
	if (getDamageReal() + iThisTurnDamageReal >= maxHitPoints())
		return MAX_INT;

	int iEffectiveDamageReal = getDamageReal() + iThisTurnDamageReal;

	iTurns += iEffectiveDamageReal / (iHealReal - iTurnDamageReal);
	if (iEffectiveDamageReal % (iHealReal - iTurnDamageReal) != 0)
		++iTurns;

	return iTurns;
}

// Checks whether this can't heal due to move.
bool CvUnit::isTurnHealBlocked() const
{
	// Blaze 2025: Duplicated logic in healTurns, probably elsewhere... be aware if changing.

	// Xienwolf - 01/19/09 - Prevents inappropriate Enraged Actions
	if (hasMoved() && !(isAlwaysHeal() || isBarbarian() || isEnraged()))
		return true;

	return false;
}

// Given the current state of the unit, how much should the unit's health change (real damage) on turn start?
// Incorporates healing and feature/plot effect damage
int CvUnit::calcTurnHealthChangeReal() const
{
	int iHealReal = isTurnHealBlocked() ? 0 : healRate(plot()) * GC.getDefineINT("HIT_POINT_FACTOR");
	int iDamageRealIncoming = plot()->calcTurnDamageReal(this, true, iHealReal);

	// Can't report overhealing; cap the positive result to that which is our actual health lost
	return (std::min(getDamageReal(), iHealReal - iDamageRealIncoming));
}

bool CvUnit::canAirlift(const CvPlot* pPlot) const
{
	CvCity* pCity;

	if (getDomainType() != DOMAIN_LAND)
	{
		return false;
	}

	if (hasMoved())
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL  && pPlot->getMaxOutgoingAirlift()<=0 )
	{
		return false;
	}

	if (pCity!=NULL && pCity->getCurrAirlift() >= pCity->getMaxAirlift())
	{
		return false;
	}

	if (pCity != NULL && pCity->getTeam() != getTeam())
	{
		return false;
	}
	if (pCity == NULL && pPlot->getCurrentOutgoingAirlift() >= pPlot->getMaxOutgoingAirlift())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirliftAt(const CvPlot* pPlot, int iX, int iY) const
{
	CvPlot* pTargetPlot;
	CvCity* pTargetCity;

	if (!canAirlift(pPlot))
	{
		return false;
	}

	pTargetPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	if (!canMoveInto(pTargetPlot))
	{
		return false;
	}

	pTargetCity = pTargetPlot->getPlotCity();

	if (pTargetCity != NULL)
	{


		if (pTargetCity->isAirliftTargeted())
		{
			return false;
		}

		if (pTargetCity->getTeam() != getTeam() && !GET_TEAM(pTargetCity->getTeam()).isVassal(getTeam()))
		{
			return false;
		}
	}
	else
	{
		if (pTargetPlot->getCurrentIncomingAirlift() >= pTargetPlot->getMaxIncomingAirlift())
		{
			return false;
		}
		if (pTargetPlot->getTeam() != getTeam() && !GET_TEAM(pTargetPlot->getTeam()).isVassal(getTeam()))
		{
			return false;
		}

	}
	return true;
}


bool CvUnit::airlift(int iX, int iY)
{
	CvCity* pCity;
	CvCity* pTargetCity;
	CvPlot* pTargetPlot;

	if (!canAirliftAt(plot(), iX, iY))
	{
		return false;
	}

	pCity = plot()->getPlotCity();
	//FAssert(pCity != NULL);
	pTargetPlot = GC.getMapINLINE().plotINLINE(iX, iY);
	FAssert(pTargetPlot != NULL);
	pTargetCity = pTargetPlot->getPlotCity();
	//FAssert(pTargetCity != NULL);
	FAssert(pCity != pTargetCity);
	if (pCity != NULL)
	{
		pCity->changeCurrAirlift(1);
	}
	else
	{
		plot()->changeCurrentOutgoingAirlift(1);
	}
	if (pTargetCity != NULL)
	{
		
		if (pTargetCity->getMaxAirlift() == 0)
		{
			pTargetCity->setAirliftTargeted(true);
		}
	}
	else
	{
		pTargetPlot->changeCurrentIncomingAirlift(1);
	}
	finishMoves();

	setXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE());

	return true;
}


bool CvUnit::isNukeVictim(const CvPlot* pPlot, TeamTypes eTeam) const
{
	CvPlot* pLoopPlot;
	int iDX, iDY;

	if (!(GET_TEAM(eTeam).isAlive()))
	{
		return false;
	}

	if (eTeam == getTeam())
	{
		return false;
	}

	for (iDX = -(nukeRange()); iDX <= nukeRange(); iDX++)
	{
		for (iDY = -(nukeRange()); iDY <= nukeRange(); iDY++)
		{
			pLoopPlot	= plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);

			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->getTeam() == eTeam)
				{
					return true;
				}

				if (pLoopPlot->plotCheck(PUF_isCombatTeam, eTeam, getTeam()) != NULL)
				{
					return true;
				}
			}
		}
	}

	return false;
}


bool CvUnit::canNuke(const CvPlot* pPlot) const
{
	if (nukeRange() == -1)
	{
		return false;
	}

	return true;
}


bool CvUnit::canNukeAt(const CvPlot* pPlot, int iX, int iY) const
{
	CvPlot* pTargetPlot;
	int iI;

	if (!canNuke(pPlot))
	{
		return false;
	}

	int iDistance = plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
	if (iDistance <= nukeRange())
	{
		return false;
	}

	if (airRange() > 0 && iDistance > airRange())
	{
		return false;
	}

	pTargetPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (isNukeVictim(pTargetPlot, ((TeamTypes)iI)))
		{
			if (!isEnemy((TeamTypes)iI, pPlot))
			{
				return false;
			}
		}
	}

	return true;
}


bool CvUnit::nuke(int iX, int iY)
{
	CvPlot* pPlot;
	CvWString szBuffer;
	bool abTeamsAffected[MAX_TEAMS];
	TeamTypes eBestTeam;
	int iBestInterception;
	int iI, iJ, iK;

	if (!canNukeAt(plot(), iX, iY))
	{
		return false;
	}

	pPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		abTeamsAffected[iI] = isNukeVictim(pPlot, ((TeamTypes)iI));
	}

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (abTeamsAffected[iI])
		{
			if (!isEnemy((TeamTypes)iI))
			{
				GET_TEAM(getTeam()).declareWar(((TeamTypes)iI), false, WARPLAN_LIMITED);
			}
		}
	}

	iBestInterception = 0;
	eBestTeam = NO_TEAM;

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (abTeamsAffected[iI])
		{
			if (GET_TEAM((TeamTypes)iI).getNukeInterception() > iBestInterception)
			{
				iBestInterception = GET_TEAM((TeamTypes)iI).getNukeInterception();
				eBestTeam = ((TeamTypes)iI);
			}
		}
	}

	iBestInterception *= (100 - m_pUnitInfo->getEvasionProbability());
	iBestInterception /= 100;

	setReconPlot(pPlot);

	if (GC.getGameINLINE().getSorenRandNum(100, "Nuke") < iBestInterception)
	{
		for (iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if (GET_PLAYER((PlayerTypes)iI).isAlive())
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_NUKE_INTERCEPTED", GET_PLAYER(getOwnerINLINE()).getNameKey(), getNameKey(), GET_TEAM(eBestTeam).getName().GetCString());
				gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)iI), (((PlayerTypes)iI) == getOwnerINLINE()), GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_NUKE_INTERCEPTED", MESSAGE_TYPE_MAJOR_EVENT, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);
			}
		}

		if (pPlot->isActiveVisible(false))
		{
			// Nuke entity mission
			CvMissionDefinition kDefiniton;
			kDefiniton.setMissionTime(GC.getMissionInfo(MISSION_NUKE).getTime() * gDLL->getSecsPerTurn());
			kDefiniton.setMissionType(MISSION_NUKE);
			kDefiniton.setPlot(pPlot);
			kDefiniton.setUnit(BATTLE_UNIT_ATTACKER, this);
			kDefiniton.setUnit(BATTLE_UNIT_DEFENDER, this);

			// Add the intercepted mission (defender is not NULL)
			gDLL->getEntityIFace()->AddMission(&kDefiniton);
		}

		kill(true);
		return true; // Intercepted!!! (XXX need special event for this...)
	}

	if (pPlot->isActiveVisible(false))
	{
		// Nuke entity mission
		CvMissionDefinition kDefiniton;
		kDefiniton.setMissionTime(GC.getMissionInfo(MISSION_NUKE).getTime() * gDLL->getSecsPerTurn());
		kDefiniton.setMissionType(MISSION_NUKE);
		kDefiniton.setPlot(pPlot);
		kDefiniton.setUnit(BATTLE_UNIT_ATTACKER, this);
		kDefiniton.setUnit(BATTLE_UNIT_DEFENDER, NULL);

		// Add the non-intercepted mission (defender is NULL)
		gDLL->getEntityIFace()->AddMission(&kDefiniton);
	}

	setMadeAttack(true);
	setAttackPlot(pPlot, false);

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (abTeamsAffected[iI])
		{
			GET_TEAM((TeamTypes)iI).changeWarWeariness(getTeam(), 100 * GC.getDefineINT("WW_HIT_BY_NUKE"));
			GET_TEAM(getTeam()).changeWarWeariness(((TeamTypes)iI), 100 * GC.getDefineINT("WW_ATTACKED_WITH_NUKE"));
			GET_TEAM(getTeam()).AI_changeWarSuccess(((TeamTypes)iI), GC.getDefineINT("WAR_SUCCESS_NUKE"));
		}
	}

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (GET_TEAM((TeamTypes)iI).isAlive())
		{
			if (iI != getTeam())
			{
				if (abTeamsAffected[iI])
				{
					for (iJ = 0; iJ < MAX_PLAYERS; iJ++)
					{
						if (GET_PLAYER((PlayerTypes)iJ).isAlive())
						{
							if (GET_PLAYER((PlayerTypes)iJ).getTeam() == ((TeamTypes)iI))
							{
								GET_PLAYER((PlayerTypes)iJ).AI_changeMemoryCount(getOwnerINLINE(), MEMORY_NUKED_US, 1);
							}
						}
					}
				}
				else
				{
					for (iJ = 0; iJ < MAX_TEAMS; iJ++)
					{
						if (GET_TEAM((TeamTypes)iJ).isAlive())
						{
							if (abTeamsAffected[iJ])
							{
								if (GET_TEAM((TeamTypes)iI).isHasMet((TeamTypes)iJ))
								{
									if (GET_TEAM((TeamTypes)iI).AI_getAttitude((TeamTypes)iJ) >= ATTITUDE_CAUTIOUS)
									{
										for (iK = 0; iK < MAX_PLAYERS; iK++)
										{
											if (GET_PLAYER((PlayerTypes)iK).isAlive())
											{
												if (GET_PLAYER((PlayerTypes)iK).getTeam() == ((TeamTypes)iI))
												{
													GET_PLAYER((PlayerTypes)iK).AI_changeMemoryCount(getOwnerINLINE(), MEMORY_NUKED_FRIEND, 1);
												}
											}
										}
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// XXX some AI should declare war here...

	for (iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_NUKE_LAUNCHED", GET_PLAYER(getOwnerINLINE()).getNameKey(), getNameKey());
			gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)iI), (((PlayerTypes)iI) == getOwnerINLINE()), GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_NUKE_EXPLODES", MESSAGE_TYPE_MAJOR_EVENT, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);
		}
	}

	if (isSuicide())
	{
		kill(true);
	}

	return true;
}


bool CvUnit::canRecon(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (airRange() == 0)
	{
		return false;
	}

	if (m_pUnitInfo->isSuicide())
	{
		return false;
	}

	return true;
}



bool CvUnit::canReconAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canRecon(pPlot))
	{
		return false;
	}

	int iDistance = plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
	if (iDistance > airRange() || 0 == iDistance)
	{
		return false;
	}

	return true;
}


bool CvUnit::recon(int iX, int iY)
{
	CvPlot* pPlot;

	if (!canReconAt(plot(), iX, iY))
	{
		return false;
	}

	pPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	setReconPlot(pPlot);

	finishMoves();

	if (pPlot->isActiveVisible(false))
	{
		CvAirMissionDefinition kAirMission;
		kAirMission.setMissionType(MISSION_RECON);
		kAirMission.setUnit(BATTLE_UNIT_ATTACKER, this);
		kAirMission.setUnit(BATTLE_UNIT_DEFENDER, NULL);
		kAirMission.setDamage(BATTLE_UNIT_DEFENDER, 0);
		kAirMission.setDamage(BATTLE_UNIT_ATTACKER, 0);
		kAirMission.setPlot(pPlot);
		kAirMission.setMissionTime(GC.getMissionInfo((MissionTypes)MISSION_RECON).getTime() * gDLL->getSecsPerTurn());
		gDLL->getEntityIFace()->AddMission(&kAirMission);
	}

	return true;
}


bool CvUnit::canParadrop(const CvPlot* pPlot) const
{
	if (getDropRange() <= 0)
	{
		return false;
	}

	if (hasMoved())
	{
		return false;
	}

/*************************************************************************************************/
/**	Vehem Tweak								07/18/08											**/
/**																								**/
/**					Teleporting doesn't have to Originate in a City								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!pPlot->isFriendlyCity(*this, true))
	{
		return false;
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Vehem Tweak									END												**/
/*************************************************************************************************/

	return true;
}



bool CvUnit::canParadropAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canParadrop(pPlot))
	{
		return false;
	}

	CvPlot* pTargetPlot = GC.getMapINLINE().plotINLINE(iX, iY);
	if (NULL == pTargetPlot || pTargetPlot == pPlot)
	{
		return false;
	}

	if (!pTargetPlot->isVisible(getTeam(), false))
	{
		return false;
	}

	if (!canMoveInto(pTargetPlot, false, false, true))
	{
		return false;
	}

	if (plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY) > getDropRange())
	{
		return false;
	}

	if (!canCoexistWithEnemyUnit(NO_TEAM))
	{
		if (pTargetPlot->isEnemyCity(*this))
		{
			return false;
		}

		if (pTargetPlot->isVisibleEnemyUnit(this))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::paradrop(int iX, int iY)
{
	if (!canParadropAt(plot(), iX, iY))
	{
		return false;
	}

	CvPlot* pPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	changeMoves(GC.getMOVE_DENOMINATOR() / 2);
	setMadeAttack(true);

	setXY(pPlot->getX_INLINE(), pPlot->getY_INLINE());

	//check if intercepted
	if(interceptTest(pPlot))
	{
		return true;
	}

	//play paradrop animation by itself
	if (pPlot->isActiveVisible(false))
	{
		CvAirMissionDefinition kAirMission;
		kAirMission.setMissionType(MISSION_PARADROP);
		kAirMission.setUnit(BATTLE_UNIT_ATTACKER, this);
		kAirMission.setUnit(BATTLE_UNIT_DEFENDER, NULL);
		kAirMission.setDamage(BATTLE_UNIT_DEFENDER, 0);
		kAirMission.setDamage(BATTLE_UNIT_ATTACKER, 0);
		kAirMission.setPlot(pPlot);
		kAirMission.setMissionTime(GC.getMissionInfo((MissionTypes)MISSION_PARADROP).getTime() * gDLL->getSecsPerTurn());
		gDLL->getEntityIFace()->AddMission(&kAirMission);
	}

	return true;
}


bool CvUnit::canAirBomb(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (airBombBaseRate() == 0)
	{
		return false;
	}

	if (isMadeAttack())
	{
		return false;
	}

	return true;
}


bool CvUnit::canAirBombAt(const CvPlot* pPlot, int iX, int iY) const
{
	CvCity* pCity;
	CvPlot* pTargetPlot;

	if (!canAirBomb(pPlot))
	{
		return false;
	}

	pTargetPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	if (plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE()) > airRange())
	{
		return false;
	}

	if (pTargetPlot->isOwned())
	{
		if (!potentialWarAction(pTargetPlot))
		{
			return false;
		}
	}

	pCity = pTargetPlot->getPlotCity();

	if (pCity != NULL)
	{
		if (!(pCity->isBombardable(this)))
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Route Pillage 	 Orbis from Route Pillage Mod by the Lopez	19/02/09	Ahwaric	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	else
	{
		if (pTargetPlot->getImprovementType() == NO_IMPROVEMENT)
		{
			return false;
		}
		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).isPermanent())
		{
			return false;
		}

		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).getAirBombDefense() == -1)
		{
			return false;
		}
	}

/**								----  End Original Code  ----									**/
	else if(pTargetPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).isPermanent())
		{
			return false;
		}

		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).getAirBombDefense() == -1)
		{
			return false;
		}
	}
	else
	{
		if(pTargetPlot->getRouteType() == NO_ROUTE)
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Route Pillage							END			**/
/*************************************************************************************************/

	return true;
}


bool CvUnit::airBomb(int iX, int iY)
{
	CvCity* pCity;
	CvPlot* pPlot;
	CvWString szBuffer;

	if (!canAirBombAt(plot(), iX, iY))
	{
		return false;
	}

	pPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	if (!isEnemy(pPlot->getTeam()))
	{
		getGroup()->groupDeclareWar(pPlot, true);
	}

	if (!isEnemy(pPlot->getTeam()))
	{
		return false;
	}

	if (interceptTest(pPlot))
	{
		return true;
	}

	pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeDefenseModifier(-airBombCurrRate());

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DEFENSES_REDUCED_TO", pCity->getNameKey(), pCity->getDefenseModifier(false), getNameKey());
		gDLL->getInterfaceIFace()->addMessage(pCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_DEFENSES_REDUCED_TO", getNameKey(), pCity->getNameKey(), pCity->getDefenseModifier(false));
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE());
	}
	else
	{
		if (pPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (GC.getGameINLINE().getSorenRandNum(airBombCurrRate(), "Air Bomb - Offense") >=
					GC.getGameINLINE().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getAirBombDefense(), "Air Bomb - Defense"))
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

				if (pPlot->isOwned())
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), getVisualCivAdjective(pPlot->getTeam()));
					gDLL->getInterfaceIFace()->addMessage(pPlot->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);
				}

				pPlot->setImprovementType((ImprovementTypes)(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage()));
/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
				if (pPlot->getImprovementOwner() != NO_PLAYER)
				{
					pPlot->addCultureControl(pPlot->getImprovementOwner(), pPlot->getImprovementType(), true);
				}
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/
			}
			else
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_FAIL_DESTROY_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMB_FAILS", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
			}
		}
/*************************************************************************************************/
/**	Route Pillage 	 Orbis from Route Pillage Mod by the Lopez	19/02/09	Ahwaric	**/
/*************************************************************************************************/
		else if(pPlot->getRouteType() != NO_ROUTE)
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP", getNameKey(), GC.getRouteInfo(pPlot->getRouteType()).getTextKeyWide());

			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, GC.getUnitInfo(getUnitType()).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

			if (pPlot->isOwned())
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED", GC.getRouteInfo(pPlot->getRouteType()).getTextKeyWide(), getNameKey(), GET_PLAYER(getOwnerINLINE()).getCivilizationAdjectiveKey());
				gDLL->getInterfaceIFace()->addMessage(pPlot->getOwnerINLINE(), false, GC.getDefineINT("EVENT_MESSAGE_TIME"), szBuffer, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, GC.getUnitInfo(getUnitType()).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);
			}

			pPlot->setRouteType(NO_ROUTE, true);
		}
/*************************************************************************************************/
/**	Route Pillage							END			**/
/*************************************************************************************************/
	}

	setReconPlot(pPlot);

	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	if (pPlot->isActiveVisible(false))
	{
		CvAirMissionDefinition kAirMission;
		kAirMission.setMissionType(MISSION_AIRBOMB);
		kAirMission.setUnit(BATTLE_UNIT_ATTACKER, this);
		kAirMission.setUnit(BATTLE_UNIT_DEFENDER, NULL);
		kAirMission.setDamage(BATTLE_UNIT_DEFENDER, 0);
		kAirMission.setDamage(BATTLE_UNIT_ATTACKER, 0);
		kAirMission.setPlot(pPlot);
		kAirMission.setMissionTime(GC.getMissionInfo((MissionTypes)MISSION_AIRBOMB).getTime() * gDLL->getSecsPerTurn());

		gDLL->getEntityIFace()->AddMission(&kAirMission);
	}

	if (isSuicide())
	{
		kill(true);
	}

	return true;
}


CvCity* CvUnit::bombardTarget(const CvPlot* pPlot) const
{
	int iBestValue = MAX_INT;
	CvCity* pBestCity = NULL;

	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		CvPlot* pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), ((DirectionTypes)iI));

		if (pLoopPlot != NULL)
		{
			CvCity* pLoopCity = pLoopPlot->getPlotCity();

			if (pLoopCity != NULL)
			{
				if (pLoopCity->isBombardable(this))
				{
					int iValue = pLoopCity->getDefenseDamage();

					// always prefer cities we are at war with
					if (isEnemy(pLoopCity->getTeam(), pPlot))
					{
						iValue *= 128;
					}

					if (iValue < iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
				}
			}
		}
	}

	return pBestCity;
}


bool CvUnit::canBombard(const CvPlot* pPlot) const
{
	if (bombardRate() <= 0)
	{
		return false;
	}

	if (isMadeAttack())
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	if (bombardTarget(pPlot) == NULL)
	{
		return false;
	}

	return true;
}


bool CvUnit::bombard()
{
	CvPlot* pPlot = plot();
	if (!canBombard(pPlot))
	{
		return false;
	}

	CvCity* pBombardCity = bombardTarget(pPlot);
	FAssertMsg(pBombardCity != NULL, "BombardCity is not assigned a valid value");

	CvPlot* pTargetPlot = pBombardCity->plot();
	if (!isEnemy(pTargetPlot->getTeam()))
	{
		getGroup()->groupDeclareWar(pTargetPlot, true);
	}

	if (!isEnemy(pTargetPlot->getTeam()))
	{
		return false;
	}

	int iBombardModifier = 0;
/*************************************************************************************************/
/**	Orbis So defense from bombardment is ignored by most of the bombarding units? No chance	Ahwaric 20.05.2009										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!ignoreBuildingDefense())
	{
		iBombardModifier -= pBombardCity->getBuildingBombardDefense();
	}
/**								----  End Original Code  ----									**/
	iBombardModifier -= pBombardCity->getBuildingBombardDefense();
/*************************************************************************************************/
/**	Orbis Warlords			END							**/
/*************************************************************************************************/
	pBombardCity->changeDefenseModifier(-(bombardRate() * std::max(0, 100 + iBombardModifier)) / 100);

	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
	CvWString szBuffer;
	if (!isHiddenNationality())
	{
		szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", pBombardCity->getNameKey(), pBombardCity->getDefenseModifier(false), GET_PLAYER(getOwnerINLINE()).getNameKey());
	}
	else
	{
		szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", pBombardCity->getNameKey(), pBombardCity->getDefenseModifier(false), GET_PLAYER((PlayerTypes)GC.getORC_PLAYER()).getNameKey());
	}
	gDLL->getInterfaceIFace()->addMessage(pBombardCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pBombardCity->getX_INLINE(), pBombardCity->getY_INLINE(), true, true);

	szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_REDUCE_CITY_DEFENSES", getNameKey(), pBombardCity->getNameKey(), pBombardCity->getDefenseModifier(false));
	gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pBombardCity->getX_INLINE(), pBombardCity->getY_INLINE());
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI) && GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply() != NO_PROMOTION)
		{
			PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply();
			//pPlot = pLoser->plot();
			pUnitNode = pTargetPlot->headUnitNode();
			while (pUnitNode != NULL)
			{
				pLoopUnit = ::getUnit(pUnitNode->m_data);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);
				if (pLoopUnit->isHasPromotion(ePromotion) == false)
				{
					if (pLoopUnit->isAlive() || !GC.getPromotionInfo(ePromotion).isPrereqAlive())
					{
						if (isEnemy(pLoopUnit->getTeam()))
						{
							if (GC.getGameINLINE().getSorenRandNum(100, "Combat Apply") <= GC.getDefineINT("COMBAT_APPLY_CHANCE") / 3)
							{
								// reimplemented; was commented out because...?
								if (pLoopUnit->canAcquirePromotion(ePromotion))
								{
									pLoopUnit->setHasPromotion(ePromotion, true);
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoopUnit->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
								}
							}
						}
					}
				}
			}
		}
	}
	if (pPlot->isActiveVisible(false))
	{
		CvUnit *pDefender = pBombardCity->plot()->getBestDefender(NO_PLAYER, getOwnerINLINE(), this, true);

		// Bombard entity mission
		CvMissionDefinition kDefiniton;
		kDefiniton.setMissionTime(GC.getMissionInfo(MISSION_BOMBARD).getTime() * gDLL->getSecsPerTurn());
		kDefiniton.setMissionType(MISSION_BOMBARD);
		kDefiniton.setPlot(pBombardCity->plot());
		kDefiniton.setUnit(BATTLE_UNIT_ATTACKER, this);
		kDefiniton.setUnit(BATTLE_UNIT_DEFENDER, pDefender);
		gDLL->getEntityIFace()->AddMission(&kDefiniton);
	}

//FfH: Added by Kael 08/30/2007
	if (isSuicide())
	{
		kill(true);
	}
//FfH: End Add

	return true;
}


bool CvUnit::canPillage(const CvPlot* pPlot) const
{
/*************************************************************************************************/
/**	PillageToggle 							05/15/08								Xienwolf	**/
/**																								**/
/**							Blocks or Simulates the UnitInfo Flag								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!(m_pUnitInfo->isPillage()))
/**								----  End Original Code  ----									**/
	if (isCannotPillage())
	{
		return false;
	}
	if (!(m_pUnitInfo->isPillage() || isCanPillage()))
/*************************************************************************************************/
/**	PillageToggle 								END												**/
/*************************************************************************************************/
	{
		return false;
	}

	if (pPlot->isCity())
	{
		return false;
	}

/************************************************************************************************/
/* UNOFFICIAL_PATCH                       06/23/10                     Mongoose & jdog5000      */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
	// From Mongoose SDK
	if (isCargo())
	{
		return false;
	}
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/

	if (pPlot->getImprovementType() == NO_IMPROVEMENT)
	{
		if (!(pPlot->isRoute()))
		{
			return false;
		}
/*************************************************************************************************/
/**	Route Pillage 	 Orbis from Route Pillage Mod by the Lopez	19/02/09	Ahwaric	**/
/*************************************************************************************************/
		if ((pPlot->isRoute()) && (isHuman()))
		{
			return false;
		}
/*************************************************************************************************/
/**	Route Pillage							END			**/
/*************************************************************************************************/

	}
	else
	{
		if (GC.getImprovementInfo(pPlot->getImprovementType()).isPermanent())
		{
			return false;
		}
	}

	if (pPlot->isOwned())
	{
		if (!potentialWarAction(pPlot))
		{
			if ((pPlot->getImprovementType() == NO_IMPROVEMENT) || (pPlot->getOwnerINLINE() != getOwnerINLINE()))
			{
				return false;
			}
		}
	}

	if (!(pPlot->isValidDomainForAction(*this)))
	{
		return false;
	}

//FfH: Added by Kael 03/24/2009
	if (isBarbarian())
	{
		if (pPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (GC.getImprovementInfo(pPlot->getImprovementType()).getSpawnUnitType() != NO_UNIT)
			{
/*************************************************************************************************/
/**	Xienwolf Tweak							03/27/09											**/
/**																								**/
/**						Allows Barbarians to pillage non-Barbarian Lairs						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				return false;
/**								----  End Original Code  ----									**/
				if (!pPlot->isOwned() || GC.getImprovementInfo(pPlot->getImprovementType()).getSpawnUnitCiv() != GET_PLAYER(pPlot->getOwner()).getCivilizationType())
				{
					return false;
				}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
			}
		}
	}
//FfH: End Add

	return true;
}

/*************************************************************************************************/
/**	Route Pillage 	 Orbis from Route Pillage Mod by the Lopez	19/02/09	Ahwaric	**/
/*************************************************************************************************/
bool CvUnit::canPillageRoute(const CvPlot* pPlot) const
{
	if (!(GC.getUnitInfo(getUnitType()).isPillage()))
	{
		return false;
	}

	if (pPlot->isCity())
	{
		return false;
	}

	if (!(pPlot->isRoute()))
	{
		return false;
	}

	if (pPlot->isOwned())
	{
		if (!atWar(pPlot->getTeam(), getTeam()))
		{
			if (pPlot->getOwnerINLINE() != getOwnerINLINE())
			{
				return false;
			}
		}
	}

	if (!(pPlot->isValidDomainForAction(*this)))
	{
		return false;
	}

	return true;
}
/*************************************************************************************************/
/**	Route Pillage							END			**/
/*************************************************************************************************/

bool CvUnit::pillage()
{
	CvWString szBuffer;
	int iPillageGold;
	long lPillageGold;
	ImprovementTypes eTempImprovement = NO_IMPROVEMENT;
	RouteTypes eTempRoute = NO_ROUTE;

	CvPlot* pPlot = plot();

	if (!canPillage(pPlot))
	{
		return false;
	}

	if (pPlot->isOwned())
	{
		// we should not be calling this without declaring war first, so do not declare war here
		if (!isEnemy(pPlot->getTeam(), pPlot))
		{
			if ((pPlot->getImprovementType() == NO_IMPROVEMENT) || (pPlot->getOwnerINLINE() != getOwnerINLINE()))
			{
				return false;
			}
		}
	}

	if (pPlot->isWater())
	{
		// UncutDragon
		// original
		//CvUnit* pInterceptor = bestSeaPillageInterceptor(this, GC.getDefineINT("COMBAT_DIE_SIDES") / 2);
		// modified
		CvUnit* pInterceptor = bestSeaPillageInterceptor(this, GC.getCOMBAT_DIE_SIDES() / 2);
		// /UncutDragon
		if (NULL != pInterceptor)
		{
			setMadeAttack(false);

			int iWithdrawal = withdrawalProbability();
			changeExtraWithdrawal(-iWithdrawal); // no withdrawal since we are really the defender
			attack(pInterceptor->plot(), false);
			changeExtraWithdrawal(iWithdrawal);

			return false;
		}
	}

	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		eTempImprovement = pPlot->getImprovementType();

		if (pPlot->getTeam() != getTeam())
		{
			// Use python to determine pillage amounts...
			lPillageGold = 0;

			CyPlot* pyPlot = new CyPlot(pPlot);
			CyUnit* pyUnit = new CyUnit(this);

			CyArgsList argsList;
			argsList.add(gDLL->getPythonIFace()->makePythonObject(pyPlot));	// pass in plot class
			argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class

			gDLL->getPythonIFace()->callFunction(PYGameModule, "doPillageGold", argsList.makeFunctionArgs(),&lPillageGold);

			delete pyPlot;	// python fxn must not hold on to this pointer
			delete pyUnit;	// python fxn must not hold on to this pointer

			iPillageGold = (int)lPillageGold;

			if (iPillageGold > 0)
			{
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
				float fInfluenceRatio = 0.0f;
				if (atWar(pPlot->getTeam(), getTeam()))
				{
					if (pPlot->canBeInfluenced())
					{
						fInfluenceRatio = doPillageInfluence();
					}
				}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

//FfH Traits: Added by Kale 08/02/2007
				iPillageGold += (iPillageGold * GET_PLAYER(getOwnerINLINE()).getPillagingGold()) / 100;
//FfH: End Add

				GET_PLAYER(getOwnerINLINE()).changeGold(iPillageGold);

				szBuffer = gDLL->getText("TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP", iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
				if (fInfluenceRatio > 0.0f)
				{
					szBuffer += gDLL->getText("TXT_KEY_MISC_TILE_INFLUENCE", fInfluenceRatio);
				}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

				if (pPlot->isOwned())
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_IMP_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), getVisualCivAdjective(pPlot->getTeam()));

/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
					if (fInfluenceRatio > 0.0f)
					{
						CvWString szInfluence;
						szInfluence.Format(L" Tile influence: -%.1f%%", fInfluenceRatio);
						szBuffer += szInfluence;
					}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
					gDLL->getInterfaceIFace()->addMessage(pPlot->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);
				}
			}
		}

		pPlot->setImprovementType((ImprovementTypes)(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage()));
/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
		if (pPlot->getImprovementOwner() != NO_PLAYER)
		{
			pPlot->addCultureControl(pPlot->getImprovementOwner(), pPlot->getImprovementType(), true);
		}
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/

	}
	else if (pPlot->isRoute())
	{
		eTempRoute = pPlot->getRouteType();
		pPlot->setRouteType(NO_ROUTE, true); // XXX downgrade rail???
	}

	changeMoves(GC.getMOVE_DENOMINATOR());

	if (pPlot->isActiveVisible(false))
	{
		// Pillage entity mission
		CvMissionDefinition kDefiniton;
		kDefiniton.setMissionTime(GC.getMissionInfo(MISSION_PILLAGE).getTime() * gDLL->getSecsPerTurn());
		kDefiniton.setMissionType(MISSION_PILLAGE);
		kDefiniton.setPlot(pPlot);
		kDefiniton.setUnit(BATTLE_UNIT_ATTACKER, this);
		kDefiniton.setUnit(BATTLE_UNIT_DEFENDER, NULL);
		gDLL->getEntityIFace()->AddMission(&kDefiniton);
	}

	if (eTempImprovement != NO_IMPROVEMENT || eTempRoute != NO_ROUTE)
	{
		TraitTriggeredData kData;
		kData.m_iImprovement = eTempImprovement;
		kData.m_iRoute = eTempRoute;
		GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_PILLAGE, &kData);
		if (pPlot->getOwner() != NO_PLAYER)
		{
			GET_PLAYER(pPlot->getOwner()).doTraitTriggers(TRAITHOOK_IMPROVEMENT_PILLAGED, &kData);

		}
		CvEventReporter::getInstance().unitPillage(this, eTempImprovement, eTempRoute, getOwnerINLINE());
	}

//FfH: Added by Kael 03/02/2009
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedByCombat())
			{
				setHasPromotion(((PromotionTypes)iI), false);
			}
		}
	}
//FfH: End Add

	return true;
}


bool CvUnit::canPlunder(const CvPlot* pPlot, bool bTestVisible) const
{
	if (getDomainType() != DOMAIN_SEA)
	{
		return false;
	}

	if (!(m_pUnitInfo->isPillage()))
	{
		return false;
	}

	if (!pPlot->isWater())
	{
		return false;
	}

	if (pPlot->isFreshWater())
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (pPlot->getTeam() == getTeam())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::plunder()
{
	CvPlot* pPlot = plot();

	if (!canPlunder(pPlot))
	{
		return false;
	}

	setBlockading(true);

	finishMoves();

	return true;
}


void CvUnit::updatePlunder(int iChange, bool bUpdatePlotGroups)
{
	int iBlockadeRange = GC.getDefineINT("SHIP_BLOCKADE_RANGE");

	bool bOldTradeNet=false;
	bool bChanged = false;

/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      06/01/09                                jdog5000      */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
	//gDLL->getFAStarIFace()->ForceReset(&GC.getStepFinder());
	bool bValid = false;
	for (int i = -iBlockadeRange; i <= iBlockadeRange; ++i)
	{
		for (int j = -iBlockadeRange; j <= iBlockadeRange; ++j)
		{
			CvPlot* pLoopPlot = ::plotXY(getX_INLINE(), getY_INLINE(), i, j);

			if (NULL != pLoopPlot && pLoopPlot->isWater() && pLoopPlot->area() == area())
			{

				int iPathDist = GC.getMapINLINE().calculatePathDistance(plot(),pLoopPlot);

				// BBAI NOTES:  There are rare issues where the path finder will return incorrect results
				// for unknown reasons.  Seems to find a suboptimal path sometimes in partially repeatable
				// circumstances.  The fix below is a hack to address the permanent one or two tile blockades which
				// would appear randomly, it should cause extra blockade clearing only very rarely.
				/*
				if( iPathDist > iBlockadeRange )
				{
					// No blockading on other side of an isthmus
					continue;
				}
				*/

				if( (iPathDist >= 0) && (iPathDist <= iBlockadeRange + 2) )
				{
					for (int iTeam = 0; iTeam < MAX_TEAMS; ++iTeam)
					{
						if (isEnemy((TeamTypes)iTeam))
						{
							bValid = (iPathDist <= iBlockadeRange);
							if( !bValid && (iChange == -1 && pLoopPlot->getBlockadedCount((TeamTypes)iTeam) > 0) )
							{
								bValid = true;
							}

							if( bValid )
							{
								if (!bChanged)
								{
									bOldTradeNet = pLoopPlot->isTradeNetwork((TeamTypes)iTeam);
								}

								pLoopPlot->changeBlockadedCount((TeamTypes)iTeam, iChange);

								if (!bChanged)
								{
									bChanged = (bOldTradeNet != pLoopPlot->isTradeNetwork((TeamTypes)iTeam));
								}
							}
						}
					}
				}
			}
		}
	}

	if (bChanged)
	{
		gDLL->getInterfaceIFace()->setDirty(BlockadedPlots_DIRTY_BIT, true);

		if (bUpdatePlotGroups)
		{
			GC.getGameINLINE().updatePlotGroups();
		}
	}
}
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/
/*************************************************************************************************/
/**	Route Pillage 	 Orbis from Route Pillage Mod by the Lopez	19/02/09	Ahwaric	**/
/*************************************************************************************************/
bool CvUnit::pillageRoute()
{
	CvPlot* pPlot;
	CvWString szBuffer;


	if (!canPillageRoute(plot()))
	{
		return false;
	}

	pPlot = plot();

	if (pPlot->isRoute())
	{
		pPlot->setRouteType(NO_ROUTE, true); // XXX downgrade rail???
	}

	changeMoves(GC.getMOVE_DENOMINATOR());

	if (pPlot->isActiveVisible(false))
	{
		// Pillage entity mission
		CvMissionDefinition kDefiniton;
		kDefiniton.setMissionTime(GC.getMissionInfo(MISSION_PILLAGE_ROUTE).getTime() * gDLL->getSecsPerTurn());
		kDefiniton.setMissionType(MISSION_PILLAGE_ROUTE);
		kDefiniton.setPlot(pPlot);
		kDefiniton.setUnit(BATTLE_UNIT_ATTACKER, this);
		kDefiniton.setUnit(BATTLE_UNIT_DEFENDER, NULL);
		gDLL->getEntityIFace()->AddMission(&kDefiniton);
	}

	return true;
}
/*************************************************************************************************/
/**	Route Pillage							END			**/
/*************************************************************************************************/

int CvUnit::sabotageCost(const CvPlot* pPlot) const
{
	return GC.getDefineINT("BASE_SPY_SABOTAGE_COST");
}


// XXX compare with destroy prob...
int CvUnit::sabotageProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	CvPlot* pLoopPlot;
	int iDefenseCount;
	int iCounterSpyCount;
	int iProb;
	int iI;

	iProb = 0; // XXX

	if (pPlot->isOwned())
	{
		iDefenseCount = pPlot->plotCount(PUF_canDefend, -1, -1, NO_PLAYER, pPlot->getTeam());
		iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NO_PLAYER, pPlot->getTeam());

		for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
		{
			pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), ((DirectionTypes)iI));

			if (pLoopPlot != NULL)
			{
				iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NO_PLAYER, pPlot->getTeam());
			}
		}
	}
	else
	{
		iDefenseCount = 0;
		iCounterSpyCount = 0;
	}

	if (eProbStyle == PROBABILITY_HIGH)
	{
		iCounterSpyCount = 0;
	}

	iProb += (40 / (iDefenseCount + 1)); // XXX

	if (eProbStyle != PROBABILITY_LOW)
	{
		iProb += (50 / (iCounterSpyCount + 1)); // XXX
	}

	return iProb;
}


bool CvUnit::canSabotage(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!(m_pUnitInfo->isSabotage()))
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam())
	{
		return false;
	}

	if (pPlot->isCity())
	{
		return false;
	}

	if (pPlot->getImprovementType() == NO_IMPROVEMENT)
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(getOwnerINLINE()).getGold() < sabotageCost(pPlot))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::sabotage()
{
	CvCity* pNearestCity;
	CvPlot* pPlot;
	CvWString szBuffer;
	bool bCaught;

	if (!canSabotage(plot()))
	{
		return false;
	}

	pPlot = plot();

	bCaught = (GC.getGameINLINE().getSorenRandNum(100, "Spy: Sabotage") > sabotageProb(pPlot));

	GET_PLAYER(getOwnerINLINE()).changeGold(-(sabotageCost(pPlot)));

	if (!bCaught)
	{
		pPlot->setImprovementType((ImprovementTypes)(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage()));
/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
		if (pPlot->getImprovementOwner() != NO_PLAYER)
		{
			pPlot->addCultureControl(pPlot->getImprovementOwner(), (ImprovementTypes) GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage(), true);
		}
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/

		finishMoves();

		pNearestCity = GC.getMapINLINE().findCity(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pPlot->getOwnerINLINE(), NO_TEAM, false);

		if (pNearestCity != NULL)
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_SABOTAGED", getNameKey(), pNearestCity->getNameKey());
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_SABOTAGE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

			if (pPlot->isOwned())
			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_SABOTAGE_NEAR", pNearestCity->getNameKey());
				gDLL->getInterfaceIFace()->addMessage(pPlot->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_SABOTAGE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);
			}
		}

		if (pPlot->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SABOTAGE);
		}
	}
	else
	{
		if (pPlot->isOwned())
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED", GET_PLAYER(getOwnerINLINE()).getCivilizationAdjective(), getNameKey());
			gDLL->getInterfaceIFace()->addMessage(pPlot->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);
		}

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey());
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SURRENDER);
		}

		if (pPlot->isOwned())
		{
			if (!isEnemy(pPlot->getTeam(), pPlot))
			{
				GET_PLAYER(pPlot->getOwnerINLINE()).AI_changeMemoryCount(getOwnerINLINE(), MEMORY_SPY_CAUGHT, 1);
			}
		}

		kill(true, pPlot->getOwnerINLINE());
	}

	return true;
}


int CvUnit::destroyCost(const CvPlot* pPlot) const
{
	CvCity* pCity;
	bool bLimited;

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	bLimited = false;

	if (pCity->isProductionUnit())
	{
		bLimited = isLimitedUnitClass((UnitClassTypes)(GC.getUnitInfo(pCity->getProductionUnit()).getUnitClassType()));
	}
	else if (pCity->isProductionBuilding())
	{
		bLimited = isLimitedWonderClass((BuildingClassTypes)(GC.getBuildingInfo(pCity->getProductionBuilding()).getBuildingClassType()));
	}
	else if (pCity->isProductionProject())
	{
		bLimited = isLimitedProject(pCity->getProductionProject());
	}

	return (GC.getDefineINT("BASE_SPY_DESTROY_COST") + (pCity->getProduction() * ((bLimited) ? GC.getDefineINT("SPY_DESTROY_COST_MULTIPLIER_LIMITED") : GC.getDefineINT("SPY_DESTROY_COST_MULTIPLIER"))));
}


int CvUnit::destroyProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	CvCity* pCity;
	CvPlot* pLoopPlot;
	int iDefenseCount;
	int iCounterSpyCount;
	int iProb;
	int iI;

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	iProb = 0; // XXX

	iDefenseCount = pPlot->plotCount(PUF_canDefend, -1, -1, NO_PLAYER, pPlot->getTeam());

	iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NO_PLAYER, pPlot->getTeam());

	for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), ((DirectionTypes)iI));

		if (pLoopPlot != NULL)
		{
			iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NO_PLAYER, pPlot->getTeam());
		}
	}

	if (eProbStyle == PROBABILITY_HIGH)
	{
		iCounterSpyCount = 0;
	}

	iProb += (25 / (iDefenseCount + 1)); // XXX

	if (eProbStyle != PROBABILITY_LOW)
	{
		iProb += (50 / (iCounterSpyCount + 1)); // XXX
	}

	iProb += std::min(25, pCity->getProductionTurnsLeft()); // XXX

	return iProb;
}


bool CvUnit::canDestroy(const CvPlot* pPlot, bool bTestVisible) const
{
	CvCity* pCity;

	if (!(m_pUnitInfo->isDestroy()))
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam())
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (pCity->getProduction() == 0)
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(getOwnerINLINE()).getGold() < destroyCost(pPlot))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::destroy()
{
	CvCity* pCity;
	CvWString szBuffer;
	bool bCaught;

	if (!canDestroy(plot()))
	{
		return false;
	}

	bCaught = (GC.getGameINLINE().getSorenRandNum(100, "Spy: Destroy") > destroyProb(plot()));

	pCity = plot()->getPlotCity();
	FAssertMsg(pCity != NULL, "City is not assigned a valid value");

	GET_PLAYER(getOwnerINLINE()).changeGold(-(destroyCost(plot())));

	if (!bCaught)
	{
		pCity->setProduction(pCity->getProduction() / 2);

		finishMoves();

		szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_DESTROYED_PRODUCTION", getNameKey(), pCity->getProductionNameKey(), pCity->getNameKey());
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_DESTROY", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE());

		szBuffer = gDLL->getText("TXT_KEY_MISC_CITY_PRODUCTION_DESTROYED", pCity->getProductionNameKey(), pCity->getNameKey());
		gDLL->getInterfaceIFace()->addMessage(pCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_DESTROY", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE(), true, true);

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_DESTROY);
		}
	}
	else
	{
		szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED", GET_PLAYER(getOwnerINLINE()).getCivilizationAdjective(), getNameKey());
		gDLL->getInterfaceIFace()->addMessage(pCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey());
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SURRENDER);
		}

		if (!isEnemy(pCity->getTeam()))
		{
			GET_PLAYER(pCity->getOwnerINLINE()).AI_changeMemoryCount(getOwnerINLINE(), MEMORY_SPY_CAUGHT, 1);
		}

		kill(true, pCity->getOwnerINLINE());
	}

	return true;
}


int CvUnit::stealPlansCost(const CvPlot* pPlot) const
{
	CvCity* pCity;

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	return (GC.getDefineINT("BASE_SPY_STEAL_PLANS_COST") + ((GET_TEAM(pCity->getTeam()).getTotalLand() + GET_TEAM(pCity->getTeam()).getTotalPopulation()) * GC.getDefineINT("SPY_STEAL_PLANS_COST_MULTIPLIER")));
}


// XXX compare with destroy prob...
int CvUnit::stealPlansProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	CvCity* pCity;
	CvPlot* pLoopPlot;
	int iDefenseCount;
	int iCounterSpyCount;
	int iProb;
	int iI;

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	iProb = ((pCity->isGovernmentCenter()) ? 20 : 0); // XXX

	iDefenseCount = pPlot->plotCount(PUF_canDefend, -1, -1, NO_PLAYER, pPlot->getTeam());

	iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NO_PLAYER, pPlot->getTeam());

	for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), ((DirectionTypes)iI));

		if (pLoopPlot != NULL)
		{
			iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NO_PLAYER, pPlot->getTeam());
		}
	}

	if (eProbStyle == PROBABILITY_HIGH)
	{
		iCounterSpyCount = 0;
	}

	iProb += (20 / (iDefenseCount + 1)); // XXX

	if (eProbStyle != PROBABILITY_LOW)
	{
		iProb += (50 / (iCounterSpyCount + 1)); // XXX
	}

	return iProb;
}


bool CvUnit::canStealPlans(const CvPlot* pPlot, bool bTestVisible) const
{
	CvCity* pCity;

	if (!(m_pUnitInfo->isStealPlans()))
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam())
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(getOwnerINLINE()).getGold() < stealPlansCost(pPlot))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::stealPlans()
{
	CvCity* pCity;
	CvWString szBuffer;
	bool bCaught;

	if (!canStealPlans(plot()))
	{
		return false;
	}

	bCaught = (GC.getGameINLINE().getSorenRandNum(100, "Spy: Steal Plans") > stealPlansProb(plot()));

	pCity = plot()->getPlotCity();
	FAssertMsg(pCity != NULL, "City is not assigned a valid value");

	GET_PLAYER(getOwnerINLINE()).changeGold(-(stealPlansCost(plot())));

	if (!bCaught)
	{
		GET_TEAM(getTeam()).changeStolenVisibilityTimer(pCity->getTeam(), 2);

		finishMoves();

		szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_STOLE_PLANS", getNameKey(), pCity->getNameKey());
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_STEALPLANS", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE());

		szBuffer = gDLL->getText("TXT_KEY_MISC_PLANS_STOLEN", pCity->getNameKey());
		gDLL->getInterfaceIFace()->addMessage(pCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_STEALPLANS", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE(), true, true);

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_STEAL_PLANS);
		}
	}
	else
	{
		szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED", GET_PLAYER(getOwnerINLINE()).getCivilizationAdjective(), getNameKey());
		gDLL->getInterfaceIFace()->addMessage(pCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey());
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SURRENDER);
		}

		if (!isEnemy(pCity->getTeam()))
		{
			GET_PLAYER(pCity->getOwnerINLINE()).AI_changeMemoryCount(getOwnerINLINE(), MEMORY_SPY_CAUGHT, 1);
		}

		kill(true, pCity->getOwnerINLINE());
	}

	return true;
}


bool CvUnit::canFound(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!isFound())
	{
		return false;
	}

	if (!(GET_PLAYER(getOwnerINLINE()).canFound(pPlot->getX_INLINE(), pPlot->getY_INLINE(), bTestVisible)))
	{
		return false;
	}

//FfH: Added by Kael 11/10/2008
	if (pPlot->isFoundDisabled())
	{
		return false;
	}
	if (isHasCasted())
	{
		return false;
	}
	if (GC.getDefineINT("BONUS_MANA") != -1)
	{
		if (pPlot->getBonusType() == GC.getDefineINT("BONUS_MANA"))
		{
			return false;
		}
	}
//FfH: End Add

	return true;
}


bool CvUnit::found()
{
	if (!canFound(plot()))
	{
		return false;
	}

	if (GC.getGameINLINE().getActivePlayer() == getOwnerINLINE())
	{
		gDLL->getInterfaceIFace()->lookAt(plot()->getPoint(), CAMERALOOKAT_NORMAL);
	}

	GET_PLAYER(getOwnerINLINE()).found(getX_INLINE(), getY_INLINE());

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_FOUND);
	}

	kill(true);

	return true;
}


bool CvUnit::canSpread(const CvPlot* pPlot, ReligionTypes eReligion, bool bTestVisible) const
{
	CvCity* pCity;

/************************************************************************************************/
/* UNOFFICIAL_PATCH                       08/19/09                                jdog5000      */
/*                                                                                              */
/* Efficiency                                                                                   */
/************************************************************************************************/
/* orginal bts code
	if (GC.getUSE_USE_CANNOT_SPREAD_RELIGION_CALLBACK())
	{
		CyArgsList argsList;
		argsList.add(getOwnerINLINE());
		argsList.add(getID());
		argsList.add((int) eReligion);
		argsList.add(pPlot->getX());
		argsList.add(pPlot->getY());
		long lResult=0;
		gDLL->getPythonIFace()->callFunction(PYGameModule, "cannotSpreadReligion", argsList.makeFunctionArgs(), &lResult);
		if (lResult > 0)
		{
			return false;
		}
	}
*/
				// UP efficiency: Moved below faster calls
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/

	if (eReligion == NO_RELIGION)
	{
		return false;
	}

	if (m_pUnitInfo->getReligionSpreads(eReligion) <= 0)
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (pCity->isHasReligion(eReligion))
	{
		return false;
	}

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (pCity->getTeam() != getTeam())
		{
			if (GET_PLAYER(pCity->getOwnerINLINE()).isNoNonStateReligionSpread())
			{
				if (eReligion != GET_PLAYER(pCity->getOwnerINLINE()).getStateReligion())
				{
					return false;
				}
			}
		}
	}

/************************************************************************************************/
/* UNOFFICIAL_PATCH                       08/19/09                                jdog5000      */
/*                                                                                              */
/* Efficiency                                                                                   */
/************************************************************************************************/
	if (GC.getUSE_USE_CANNOT_SPREAD_RELIGION_CALLBACK())
	{
		CyArgsList argsList;
		argsList.add(getOwnerINLINE());
		argsList.add(getID());
		argsList.add((int) eReligion);
		argsList.add(pPlot->getX());
		argsList.add(pPlot->getY());
		long lResult=0;
		gDLL->getPythonIFace()->callFunction(PYGameModule, "cannotSpreadReligion", argsList.makeFunctionArgs(), &lResult);
		if (lResult > 0)
		{
			return false;
		}
	}
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/

	return true;
}


bool CvUnit::spread(ReligionTypes eReligion)
{
	CvCity* pCity;
	CvWString szBuffer;
	int iSpreadProb;

	if (!canSpread(plot(), eReligion))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		iSpreadProb = m_pUnitInfo->getReligionSpreads(eReligion);

		if (pCity->getTeam() != getTeam())
		{
			iSpreadProb /= 2;
		}

		bool bSuccess;

		iSpreadProb += (((GC.getNumReligionInfos() - pCity->getReligionCount()) * (100 - iSpreadProb)) / GC.getNumReligionInfos());

		if (GC.getGameINLINE().getSorenRandNum(100, "Unit Spread Religion") < iSpreadProb)
		{

//FfH: Modified by Kael 10/04/2008
//			pCity->setHasReligion(eReligion, true, true, false);
			if (GC.getGameINLINE().isReligionFounded(eReligion))
			{
				pCity->setHasReligion(eReligion, true, true, false);
			}
			else
			{
				pCity->setHasReligion(eReligion, true, true, false);
				GC.getGameINLINE().setHolyCity(eReligion, pCity, true);
				GC.getGameINLINE().setReligionSlotTaken(eReligion, true);
			}
//FfH: End Modify

			bSuccess = true;
		}
		else
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_RELIGION_FAILED_TO_SPREAD", getNameKey(), GC.getReligionInfo(eReligion).getChar(), pCity->getNameKey());
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_NOSPREAD", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE());
			bSuccess = false;
		}

		// Python Event
		CvEventReporter::getInstance().unitSpreadReligionAttempt(this, eReligion, bSuccess);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SPREAD);
	}

	kill(true);

	return true;
}


bool CvUnit::canSpreadCorporation(const CvPlot* pPlot, CorporationTypes eCorporation, bool bTestVisible) const
{
	if (NO_CORPORATION == eCorporation)
	{
		return false;
	}

	if (!GET_PLAYER(getOwnerINLINE()).isActiveCorporation(eCorporation))
	{
		return false;
	}

	if (m_pUnitInfo->getCorporationSpreads(eCorporation) <= 0)
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (NULL == pCity)
	{
		return false;
	}

	if (pCity->isHasCorporation(eCorporation))
	{
		return false;
	}

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (!GET_PLAYER(pCity->getOwnerINLINE()).isActiveCorporation(eCorporation))
		{
			return false;
		}

		for (int iCorporation = 0; iCorporation < GC.getNumCorporationInfos(); ++iCorporation)
		{
			if (pCity->isHeadquarters((CorporationTypes)iCorporation))
			{
				if (GC.getGameINLINE().isCompetingCorporation((CorporationTypes)iCorporation, eCorporation))
				{
					return false;
				}
			}
		}

		bool bValid = false;

//FfH: Added by Kael 10/21/2007 (So that corporations can be made to not require bonuses)
		if (GC.getCorporationInfo(eCorporation).getPrereqBonus(0) == NO_BONUS)
		{
			bValid = true;
		}
//FfH: End Add

		for (int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++i)
		{
			BonusTypes eBonus = (BonusTypes)GC.getCorporationInfo(eCorporation).getPrereqBonus(i);
			if (NO_BONUS != eBonus)
			{
				if (pCity->hasBonus(eBonus))
				{
					bValid = true;
					break;
				}
			}
		}

		if (!bValid)
		{
			return false;
		}

		if (GET_PLAYER(getOwnerINLINE()).getGold() < spreadCorporationCost(eCorporation, pCity))
		{
			return false;
		}
	}

	return true;
}

int CvUnit::spreadCorporationCost(CorporationTypes eCorporation, CvCity* pCity) const
{
	int iCost = std::max(0, GC.getCorporationInfo(eCorporation).getSpreadCost() * (100 + GET_PLAYER(getOwnerINLINE()).calculateInflationRate()));
	iCost /= 100;

	if (NULL != pCity)
	{
		if (getTeam() != pCity->getTeam() && !GET_TEAM(pCity->getTeam()).isVassal(getTeam()))
		{
			iCost *= GC.getDefineINT("CORPORATION_FOREIGN_SPREAD_COST_PERCENT");
			iCost /= 100;
		}

		for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
		{
			if (iCorp != eCorporation)
			{
				if (pCity->isActiveCorporation((CorporationTypes)iCorp))
				{
					if (GC.getGameINLINE().isCompetingCorporation(eCorporation, (CorporationTypes)iCorp))
					{
						iCost *= 100 + GC.getCorporationInfo((CorporationTypes)iCorp).getSpreadFactor();
						iCost /= 100;
					}
				}
			}
		}
	}

	return iCost;
}

bool CvUnit::spreadCorporation(CorporationTypes eCorporation)
{
	int iSpreadProb;

	if (!canSpreadCorporation(plot(), eCorporation))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (NULL != pCity)
	{
		GET_PLAYER(getOwnerINLINE()).changeGold(-spreadCorporationCost(eCorporation, pCity));

		iSpreadProb = m_pUnitInfo->getCorporationSpreads(eCorporation);

		if (pCity->getTeam() != getTeam())
		{
			iSpreadProb /= 2;
		}

		iSpreadProb += (((GC.getNumCorporationInfos() - pCity->getCorporationCount()) * (100 - iSpreadProb)) / GC.getNumCorporationInfos());

		if (GC.getGameINLINE().getSorenRandNum(100, "Unit Spread Corporation") < iSpreadProb)
		{
			pCity->setHasCorporation(eCorporation, true, true, false);
		}
		else
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_CORPORATION_FAILED_TO_SPREAD", getNameKey(), GC.getCorporationInfo(eCorporation).getChar(), pCity->getNameKey());
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_NOSPREAD", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE());
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SPREAD_CORPORATION);
	}

	kill(true);

	return true;
}


bool CvUnit::canJoin(const CvPlot* pPlot, SpecialistTypes eSpecialist) const
{
	CvCity* pCity;

	if (eSpecialist == NO_SPECIALIST)
	{
		return false;
	}

	if (!(m_pUnitInfo->getGreatPeoples(eSpecialist)))
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (!(pCity->canJoin()))
	{
		return false;
	}

	if (pCity->getTeam() != getTeam())
	{
		return false;
	}

	if (isDelayedDeath())
	{
		return false;
	}

//FfH: Added by Kael 08/18/2008
	if (isHasCasted())
	{
		return false;
	}
//FfH: End Add

	return true;
}


bool CvUnit::join(SpecialistTypes eSpecialist)
{
	CvCity* pCity;

	if (!canJoin(plot(), eSpecialist))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeFreeSpecialistCount(eSpecialist, 1);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_JOIN);
	}

	kill(true);

	return true;
}


bool CvUnit::canConstruct(const CvPlot* pPlot, BuildingTypes eBuilding, bool bTestVisible) const
{
	// Xienwolf - 01/19/09 - Prevents inappropriate Enraged Actions
	if (isEnraged())
		return false;

	CvCity* pCity;

	if (eBuilding == NO_BUILDING)
		return false;

	//FfH: Added by Kael 08/18/2008
	if (isHasCasted())
		return false;

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
		return false;

	if (getTeam() != pCity->getTeam())
		return false;

	if (pCity->getNumRealBuilding(eBuilding) > 0)
		return false;

	if (!(m_pUnitInfo->getBuildings(eBuilding)))
		return false;

	if (!(pCity->canConstruct(eBuilding, false, bTestVisible, true)))
		return false;

	if (isDelayedDeath())
		return false;

	return true;
}


bool CvUnit::construct(BuildingTypes eBuilding)
{
	CvCity* pCity;

	if (!canConstruct(plot(), eBuilding))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->setNumRealBuilding(eBuilding, pCity->getNumRealBuilding(eBuilding) + 1);

		CvEventReporter::getInstance().buildingBuilt(pCity, eBuilding);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_CONSTRUCT);
	}

	kill(true);

	return true;
}


TechTypes CvUnit::getDiscoveryTech() const
{
	return ::getDiscoveryTech(getUnitType(), getOwnerINLINE());
}


int CvUnit::getDiscoverResearch(TechTypes eTech) const
{
	int iResearch;

	iResearch = (m_pUnitInfo->getBaseDiscover() + (m_pUnitInfo->getDiscoverMultiplier() * GET_TEAM(getTeam()).getTotalPopulation()));

	iResearch *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getUnitDiscoverPercent();
	iResearch /= 100;

	if (eTech != NO_TECH)
	{
		iResearch = std::min(GET_TEAM(getTeam()).getResearchLeft(eTech), iResearch);
	}

//FfH: Added by Kael 08/18/2008
	if (isHasCasted())
	{
		return 0;
	}
//FfH: End Add

	return std::max(0, iResearch);
}


bool CvUnit::canDiscover(const CvPlot* pPlot) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	TechTypes eTech;

	eTech = getDiscoveryTech();

	if (eTech == NO_TECH)
	{
		return false;
	}

	if (getDiscoverResearch(eTech) == 0)
	{
		return false;
	}

	if (isDelayedDeath())
	{
		return false;
	}

	return true;
}


bool CvUnit::discover()
{
	TechTypes eDiscoveryTech;

	if (!canDiscover(plot()))
	{
		return false;
	}

	eDiscoveryTech = getDiscoveryTech();
	FAssertMsg(eDiscoveryTech != NO_TECH, "DiscoveryTech is not assigned a valid value");

	GET_TEAM(getTeam()).changeResearchProgress(eDiscoveryTech, getDiscoverResearch(eDiscoveryTech), getOwnerINLINE());

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_DISCOVER);
	}

	kill(true);

	return true;
}


int CvUnit::getMaxHurryProduction(CvCity* pCity) const
{
	int iProduction;

	iProduction = (m_pUnitInfo->getBaseHurry() + (m_pUnitInfo->getHurryMultiplier() * pCity->getPopulation()));

	iProduction *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getUnitHurryPercent();
	iProduction /= 100;

//FfH: Added by Kael 08/18/2008
	if (isHasCasted())
	{
		return 0;
	}
//FfH: End Add

	return std::max(0, iProduction);
}


int CvUnit::getHurryProduction(const CvPlot* pPlot) const
{
	CvCity* pCity;
	int iProduction;

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	iProduction = getMaxHurryProduction(pCity);

	iProduction = std::min(pCity->productionLeft(), iProduction);

	return std::max(0, iProduction);
}


bool CvUnit::canHurry(const CvPlot* pPlot, bool bTestVisible) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (isDelayedDeath())
	{
		return false;
	}

	CvCity* pCity;

	if (getHurryProduction(pPlot) == 0)
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (pCity->getProductionTurnsLeft() == 1)
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (!(pCity->isProductionBuilding()))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::hurry()
{
	CvCity* pCity;

	if (!canHurry(plot()))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeProduction(getHurryProduction(plot()));
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_HURRY);
	}

	kill(true);

	return true;
}


int CvUnit::getTradeGold(const CvPlot* pPlot) const
{
	CvCity* pCapitalCity;
	CvCity* pCity;
/*************************************************************************************************/
/**	Merchandizing						11/21/08									Xienwolf	**/
/**																								**/
/**				Makes TradeMission rewards more vairable and predictable in FfH					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	int iGold;

	pCity = pPlot->getPlotCity();
	pCapitalCity = GET_PLAYER(getOwnerINLINE()).getCapitalCity();

	if (pCity == NULL)
	{
		return 0;
	}

	iGold = (m_pUnitInfo->getBaseTrade() + (m_pUnitInfo->getTradeMultiplier() * ((pCapitalCity != NULL) ? pCity->calculateTradeProfit(pCapitalCity) : 0)));
/**								----  End Original Code  ----									**/
	int iGold, iDist;

	pCity = pPlot->getPlotCity();
	pCapitalCity = GET_PLAYER(getOwnerINLINE()).getCapitalCity();

	if (pCity == NULL || pCapitalCity == NULL || isHasCasted())
	{
		return 0;
	}

	iDist = plotDistance(pCapitalCity->getX(), pCapitalCity->getY(), pCity->getX(), pCity->getY());

	iGold = m_pUnitInfo->getBaseTrade();
	iGold += m_pUnitInfo->getTradeMultiplier() * ((pCapitalCity->getPopulation()/5) + (pCity->getPopulation()/3) + (iDist/8));
/*************************************************************************************************/
/**	Merchandizing								END												**/
/*************************************************************************************************/

	iGold *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getUnitTradePercent();
	iGold /= 100;

//FfH: Added by Kael 08/18/2008
	if (isHasCasted())
	{
		return 0;
	}
//FfH: End Add

	return std::max(0, iGold);
}


bool CvUnit::canTrade(const CvPlot* pPlot, bool bTestVisible) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (isDelayedDeath())
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (getTradeGold(pPlot) == 0)
	{
		return false;
	}

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (pCity->getTeam() == getTeam())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::trade()
{
	if (!canTrade(plot()))
	{
		return false;
	}

	GET_PLAYER(getOwnerINLINE()).changeGold(getTradeGold(plot()));

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_TRADE);
	}

	kill(true);

	return true;
}


int CvUnit::getGreatWorkCulture(const CvPlot* pPlot) const
{
	int iCulture;

	iCulture = m_pUnitInfo->getGreatWorkCulture();

	iCulture *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getUnitGreatWorkPercent();
	iCulture /= 100;

//FfH: Added by Kael 08/18/2008
	if (isHasCasted())
	{
		return 0;
	}
//FfH: End Add

	return std::max(0, iCulture);
}


bool CvUnit::canGreatWork(const CvPlot* pPlot) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (isDelayedDeath())
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (pCity->getOwnerINLINE() != getOwnerINLINE())
	{
		return false;
	}

	if (getGreatWorkCulture(pPlot) == 0)
	{
		return false;
	}

	return true;
}


bool CvUnit::greatWork()
{
	if (!canGreatWork(plot()))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->setCultureUpdateTimer(0);
		pCity->setOccupationTimer(0);

		int iCultureToAdd = 100 * getGreatWorkCulture(plot());
		int iNumTurnsApplied = (GC.getDefineINT("GREAT_WORKS_CULTURE_TURNS") * GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getUnitGreatWorkPercent()) / 100;

		for (int i = 0; i < iNumTurnsApplied; ++i)
		{
			pCity->changeCultureTimes100(getOwnerINLINE(), iCultureToAdd / iNumTurnsApplied, true, true);
		}

		if (iNumTurnsApplied > 0)
		{
			pCity->changeCultureTimes100(getOwnerINLINE(), iCultureToAdd % iNumTurnsApplied, false, true);
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_GREAT_WORK);
	}

	kill(true);

	return true;
}


int CvUnit::getEspionagePoints(const CvPlot* pPlot) const
{
	int iEspionagePoints;

	iEspionagePoints = m_pUnitInfo->getEspionagePoints();

	iEspionagePoints *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getUnitGreatWorkPercent();
	iEspionagePoints /= 100;

	return std::max(0, iEspionagePoints);
}

bool CvUnit::canInfiltrate(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (GC.getGameINLINE().isOption(GAMEOPTION_NO_ESPIONAGE))
	{
		return false;
	}

	if (getEspionagePoints(NULL) == 0)
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();
	if (pCity == NULL || pCity->isBarbarian())
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (NULL != pCity && pCity->getTeam() == getTeam())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::infiltrate()
{
	if (!canInfiltrate(plot()))
	{
		return false;
	}

	int iPoints = getEspionagePoints(NULL);
	GET_TEAM(getTeam()).changeEspionagePointsAgainstTeam(GET_PLAYER(plot()->getOwnerINLINE()).getTeam(), iPoints);
	GET_TEAM(getTeam()).changeEspionagePointsEver(iPoints);

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_INFILTRATE);
	}

	kill(true);

	return true;
}


bool CvUnit::canEspionage(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (!isSpy())
	{
		return false;
	}

	if (GC.getGameINLINE().isOption(GAMEOPTION_NO_ESPIONAGE))
	{
		return false;
	}

	PlayerTypes ePlotOwner = pPlot->getOwnerINLINE();
	if (NO_PLAYER == ePlotOwner)
	{
		return false;
	}

	CvPlayer& kTarget = GET_PLAYER(ePlotOwner);

	if (kTarget.isBarbarian())
	{
		return false;
	}

	if (kTarget.getTeam() == getTeam())
	{
		return false;
	}

	if (GET_TEAM(getTeam()).isVassal(kTarget.getTeam()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (isMadeAttack())
		{
			return false;
		}

		if (hasMoved())
		{
			return false;
		}

		if (kTarget.getTeam() != getTeam() && !isInvisible(kTarget.getTeam(), false))
		{
			return false;
		}
	}

	return true;
}

bool CvUnit::espionage(EspionageMissionTypes eMission, int iData)
{
	if (!canEspionage(plot()))
	{
		return false;
	}

	PlayerTypes eTargetPlayer = plot()->getOwnerINLINE();

	if (NO_ESPIONAGEMISSION == eMission)
	{
		FAssert(GET_PLAYER(getOwnerINLINE()).isHuman());
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_DOESPIONAGE);
		if (NULL != pInfo)
		{
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwnerINLINE(), true);
		}
	}
	else if (GC.getEspionageMissionInfo(eMission).isTwoPhases() && -1 == iData)
	{
		FAssert(GET_PLAYER(getOwnerINLINE()).isHuman());
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_DOESPIONAGE_TARGET);
		if (NULL != pInfo)
		{
			pInfo->setData1(eMission);
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwnerINLINE(), true);
		}
	}
	else
	{
		if (testSpyIntercepted(eTargetPlayer, GC.getEspionageMissionInfo(eMission).getDifficultyMod()))
		{
			return false;
		}

		if (GET_PLAYER(getOwnerINLINE()).doEspionageMission(eMission, eTargetPlayer, plot(), iData, this))
		{
			if (plot()->isActiveVisible(false))
			{
				NotifyEntity(MISSION_ESPIONAGE);
			}

			if (!testSpyIntercepted(eTargetPlayer, GC.getDefineINT("ESPIONAGE_SPY_MISSION_ESCAPE_MOD")))
			{
				setFortifyTurns(0);
				setMadeAttack(true);
				finishMoves();

				CvCity* pCapital = GET_PLAYER(getOwnerINLINE()).getCapitalCity();
				if (NULL != pCapital)
				{
					setXY(pCapital->getX_INLINE(), pCapital->getY_INLINE(), false, false, false);

					CvWString szBuffer = gDLL->getText("TXT_KEY_ESPIONAGE_SPY_SUCCESS", getNameKey(), pCapital->getNameKey());
					gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pCapital->getX_INLINE(), pCapital->getY_INLINE(), true, true);
				}
			}

			return true;
		}
	}

	return false;
}

bool CvUnit::testSpyIntercepted(PlayerTypes eTargetPlayer, int iModifier)
{
	CvPlayer& kTargetPlayer = GET_PLAYER(eTargetPlayer);

	if (kTargetPlayer.isBarbarian())
	{
		return false;
	}

	if (GC.getGameINLINE().getSorenRandNum(10000, "Spy Interception") >= getSpyInterceptPercent(kTargetPlayer.getTeam()) * (100 + iModifier))
	{
		return false;
	}

	CvString szFormatNoReveal;
	CvString szFormatReveal;

	if (GET_TEAM(kTargetPlayer.getTeam()).getCounterespionageModAgainstTeam(getTeam()) > 0)
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED_MISSION";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_MISSION_REVEAL";
	}
	else if (plot()->isEspionageCounterSpy(kTargetPlayer.getTeam()))
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED_SPY";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_SPY_REVEAL";
	}
	else
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_REVEAL";
	}

	CvWString szCityName = kTargetPlayer.getCivilizationShortDescription();
	CvCity* pClosestCity = GC.getMapINLINE().findCity(getX_INLINE(), getY_INLINE(), eTargetPlayer, kTargetPlayer.getTeam(), true, false);
	if (pClosestCity != NULL)
	{
		szCityName = pClosestCity->getName();
	}

	CvWString szBuffer = gDLL->getText(szFormatReveal.GetCString(), GET_PLAYER(getOwnerINLINE()).getCivilizationAdjectiveKey(), getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString());
	gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);

	if (GC.getGameINLINE().getSorenRandNum(100, "Spy Reveal identity") < GC.getDefineINT("ESPIONAGE_SPY_REVEAL_IDENTITY_PERCENT"))
	{
		if (!isEnemy(kTargetPlayer.getTeam()))
		{
			GET_PLAYER(eTargetPlayer).AI_changeMemoryCount(getOwnerINLINE(), MEMORY_SPY_CAUGHT, 1);
		}

		gDLL->getInterfaceIFace()->addMessage(eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
	}
	else
	{
		szBuffer = gDLL->getText(szFormatNoReveal.GetCString(), getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString());
		gDLL->getInterfaceIFace()->addMessage(eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SURRENDER);
	}

	kill(true);

	return true;
}

int CvUnit::getSpyInterceptPercent(TeamTypes eTargetTeam) const
{
	FAssert(isSpy());
	FAssert(getTeam() != eTargetTeam);

	int iSuccess = 0;

	int iTargetPoints = GET_TEAM(eTargetTeam).getEspionagePointsEver();
	int iOurPoints = GET_TEAM(getTeam()).getEspionagePointsEver();
	iSuccess += (GC.getDefineINT("ESPIONAGE_INTERCEPT_SPENDING_MAX") * iTargetPoints) / std::max(1, iTargetPoints + iOurPoints);

	if (plot()->isEspionageCounterSpy(eTargetTeam))
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_COUNTERSPY");
	}

	if (GET_TEAM(eTargetTeam).getCounterespionageModAgainstTeam(getTeam()) > 0)
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_COUNTERESPIONAGE_MISSION");
	}

	if (0 == getFortifyTurns() || plot()->plotCount(PUF_isSpy, -1, -1, NO_PLAYER, getTeam()) > 1)
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_RECENT_MISSION");
	}

	return std::min(100, std::max(0, iSuccess));
}

bool CvUnit::isIntruding() const
{
	TeamTypes eLocalTeam = plot()->getTeam();

	if (NO_TEAM == eLocalTeam || eLocalTeam == getTeam())
	{
		return false;
	}

	// UNOFFICIAL_PATCH Start
	// * Vassal's spies no longer caught in master's territory
	//if (GET_TEAM(eLocalTeam).isVassal(getTeam()))
	if (GET_TEAM(eLocalTeam).isVassal(getTeam()) || GET_TEAM(getTeam()).isVassal(eLocalTeam))
	// UNOFFICIAL_PATCH End
	{
		return false;
	}

	return true;
}

bool CvUnit::canGoldenAge(const CvPlot* pPlot, bool bTestVisible) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (!isGoldenAge())
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(getOwnerINLINE()).unitsRequiredForGoldenAge() > GET_PLAYER(getOwnerINLINE()).unitsGoldenAgeReady())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::goldenAge()
{
	if (!canGoldenAge(plot()))
	{
		return false;
	}

	GET_PLAYER(getOwnerINLINE()).killGoldenAgeUnits(this);

	GET_PLAYER(getOwnerINLINE()).changeGoldenAgeTurns(GET_PLAYER(getOwnerINLINE()).getGoldenAgeLength());
	GET_PLAYER(getOwnerINLINE()).changeNumUnitGoldenAges(1);

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_GOLDEN_AGE);
	}

	kill(true);

	return true;
}

/*************************************************************************************************/
/**	Tweak									14/08/10									Snarko	**/
/**						Don't build linked builds if we maintain that feature					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestVisible) const
/**								----  End Original Code  ----									**/
bool CvUnit::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestVisible, bool bIsLink) const
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	FAssertMsg(eBuild < GC.getNumBuildInfos(), "Index out of bounds");

//FfH: Modified by Kael 08/31/2007 (so AI workers can upgrade mana nodes)
//	if (!(m_pUnitInfo->getBuilds(eBuild)))
//	{
//		return false;
//	}
//
//	if (!(GET_PLAYER(getOwnerINLINE()).canBuild(pPlot, eBuild, false, bTestVisible)))
//	{
//		return false;
//	}
//
//	if (!pPlot->isValidDomainForAction(*this))
//	{
//		return false;
//	}
	if (!(GET_PLAYER(getOwnerINLINE()).canBuild(pPlot, eBuild, false, bTestVisible)))
	{
		return false;
	}
	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									14/08/10									Snarko	**/
/**						Don't build linked builds if we maintain that feature					**/
/*************************************************************************************************/
	if (bIsLink)
	{
		if (pPlot->getOwner() != NO_PLAYER)
		{
			if (pPlot->getFeatureType() != NO_FEATURE)
			{
				if (GC.getBuildInfo(eBuild).isFeatureRemove(pPlot->getFeatureType()))
				{
					if (GC.getCivilizationInfo(GET_PLAYER(pPlot->getOwnerINLINE()).getCivilizationType()).isMaintainFeatures(pPlot->getFeatureType()))
					{
						if (GC.getBuildInfo(eBuild).getImprovement() == NO_IMPROVEMENT)
							return false;
					}
				}
			}
		}
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (!(GET_PLAYER(getOwnerINLINE()).isHuman()))
	{
		if (GC.getDefineINT("BONUS_MANA") != -1)
		{
			if (pPlot->getBonusType(getTeam()) == GC.getDefineINT("BONUS_MANA"))
			{
				if (GC.getBuildInfo(eBuild).getImprovement() != NO_IMPROVEMENT && GC.getImprovementInfo((ImprovementTypes)GC.getBuildInfo(eBuild).getImprovement()).isImprovementBonusMakesValid(GC.getDefineINT("BONUS_MANA")))
				{
					if (getUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WORKER"))
					{
						return true;
					}
				}
			}
		}
	}
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	bool bValid = true;
	if (!(m_pUnitInfo->getBuilds(eBuild)))
	{
		bValid = false;
	}
	if (isPromotionBuild())
	{
		for (int iJ=0;iJ<GC.getNumPromotionInfos();iJ++)
		{
			if (isHasPromotion((PromotionTypes)iJ))
			{
				int iNumPromotionBuilds = GC.getPromotionInfo((PromotionTypes)iJ).getNumPromotionBuilds();
				if (iNumPromotionBuilds > 0)
				{
					for (int iI=0; iI< iNumPromotionBuilds; iI++)
					{
						if (GC.getPromotionInfo((PromotionTypes)iJ).getPromotionBuilds(iI) == eBuild)
						{
							bValid = true;
						}
					}
				}
				int iNumPromotionCannotBuilds = GC.getPromotionInfo((PromotionTypes)iJ).getNumPromotionCannotBuilds();
				if (iNumPromotionCannotBuilds > 0)
				{
					for (int iI=0; iI< iNumPromotionCannotBuilds; iI++)
					{
						if (GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCannotBuilds(iI) == eBuild)
						{
							bValid = false;
						}
					}
				}
			}
		}
	}
	if (!bValid)
	{
		return false;
	}
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/

//FfH: End Modify

	return true;
}

// Returns true if build finished...
bool CvUnit::build(BuildTypes eBuild)
{
	bool bFinished;
	bool bLinkedBuild = false;
	int iJ, iNumLinkedBuilds;
	int iWorkRate = workRate(false, eBuild, plot()->getFeatureType());

	FAssertMsg(eBuild < GC.getNumBuildInfos(), "Invalid Build");

	if (!canBuild(plot(), eBuild))
	{
		return false;
	}

	// Note: notify entity must come before changeBuildProgress - because once the unit is done building,
	// that function will notify the entity to stop building.
	NotifyEntity((MissionTypes)GC.getBuildInfo(eBuild).getMissionType());

/*************************************************************************************************/
/**	LinkedBuilds							7/18/10									Valkrionn	**/
/**																								**/
/**		Creates a list of Builds, which are executed before the main build if reqs are met		**/
/*************************************************************************************************/
	if (GC.getBuildInfo(eBuild).getNumLinkedBuilds() > 0)
	{
		iNumLinkedBuilds = GC.getBuildInfo(eBuild).getNumLinkedBuilds();
		for (iJ=0; iJ < iNumLinkedBuilds; iJ++)
		{
			BuildTypes eLinkedBuild = (BuildTypes)GC.getBuildInfo(eBuild).getLinkedBuilds(iJ);

			if (canBuild(plot(), eLinkedBuild, false, true))
			{
				build(eLinkedBuild);
				bLinkedBuild = true;
			}
		}
	}

	if (!bLinkedBuild)
	{

		GET_PLAYER(getOwnerINLINE()).changeGold(-(GET_PLAYER(getOwnerINLINE()).getBuildCost(plot(), eBuild)));

/*************************************************************************************************/
/**	BuildXP									7/17/10									Valkrionn	**/
/**																								**/
/**									Allows Builds to grant XP									**/
/*************************************************************************************************/
		if (!GC.getGameINLINE().isOption(GAMEOPTION_NO_WORKER_XP))
			changeExperience((GC.getBuildInfo(eBuild).getXPValue() * (iWorkRate / 100)), -1, false, false, false, true);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
	ImprovementTypes eOldImprovement = plot()->getImprovementType();
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**					Need to know build order and features to get workrate now					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	bFinished = plot()->changeBuildProgress(eBuild, workRate(false), getTeam());
/**								----  End Original Code  ----									**/
	bFinished = plot()->changeBuildProgress(eBuild, iWorkRate, getTeam(), bLinkedBuild);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	finishMoves(); // needs to be at bottom because movesLeft() can affect workRate()...

	if (bFinished)
	{
/*************************************************************************************************/
/**	Improvements Mods by Jeckel		imported by Ahwaric	20.09.09 | Valkrionn	09.24.09		**/
/*************************************************************************************************/
		if ((ImprovementTypes) GC.getBuildInfo(eBuild).getImprovement() != NO_IMPROVEMENT && (ImprovementTypes) GC.getBuildInfo(eBuild).getImprovement() != eOldImprovement)
		{
			if (GC.getImprovementInfo((ImprovementTypes) GC.getBuildInfo(eBuild).getImprovement()).getCultureControlStrength() > 0)
			{
				if (GC.getImprovementInfo((ImprovementTypes) GC.getBuildInfo(eBuild).getImprovement()).isFort())
				{
					claimFort(true);
				}
				else
				{
					plot()->setImprovementOwner(getOwner());
					plot()->addCultureControl(getOwner(), (ImprovementTypes) GC.getBuildInfo(eBuild).getImprovement(), true);
				}
			}
		}
		// DynTraits Start
		if (GC.getBuildInfo(eBuild).getRoute() != NO_ROUTE)
		{
			TraitTriggeredData kTrigger;
			kTrigger.m_iRoute = (RouteTypes)GC.getBuildInfo(eBuild).getRoute();
			GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_BUILD_ROUTE, &kTrigger);
		}
		if (GC.getBuildInfo(eBuild).getImprovement() != NO_IMPROVEMENT)
		{
			TraitTriggeredData kTrigger;
			kTrigger.m_iUnitClass = getUnitClassType();
			kTrigger.m_iImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild).getImprovement();
			GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_BUILD_IMPROVEMENT, &kTrigger);
			if ((plot()->getBonusType(getTeam())) != NO_BONUS)
			{
				if (GC.getImprovementInfo((ImprovementTypes)GC.getBuildInfo(eBuild).getImprovement()).isImprovementBonusTrade(plot()->getBonusType(getTeam())))
				{
					CvString szError;
					//		szError.Format("getting inside the test for resource");
					//		gDLL->logMsg("trait2.log", szError);

					TraitTriggeredData kTrigger;
					kTrigger.m_iBonus = plot()->getBonusType(getTeam());
					kTrigger.m_bHealth = GC.getBonusInfo(plot()->getBonusType(getTeam())).getHealth() > 0;
					kTrigger.m_bHappy = GC.getBonusInfo(plot()->getBonusType(getTeam())).getHappiness() > 0;
					GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_CONNECT_RESOURCE, &kTrigger);
				}
			}

		}

		// DynTraits End
/*************************************************************************************************/
/**	Improvements Mods	END								**/
/*************************************************************************************************/
		if (GC.getBuildInfo(eBuild).isKill())
		{
			kill(true);
		}
	}

	// Python Event
	CvEventReporter::getInstance().unitBuildImprovement(this, eBuild, bFinished);

	return bFinished;
}


bool CvUnit::canPromote(PromotionTypes ePromotion, int iLeaderUnitId) const
{
	PROFILE("CvUnit::canPromote");
/*************************************************************************************************/
/**	Xienwolf Tweak							05/12/09											**/
/**																								**/
/**			Places same restrictions on the AI as are placed on the Player for Blindness		**/
/*************************************************************************************************/
	if (isBlind() && (!plot()->isVisible(getTeam(), false) || !plot()->isRevealed(getTeam(), false)))
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (iLeaderUnitId >= 0)
	{
		if (iLeaderUnitId == getID())
		{
			return false;
		}

		// The command is always possible if it's coming from a Warlord unit that gives just experience points
		CvUnit* pWarlord = GET_PLAYER(getOwnerINLINE()).getUnit(iLeaderUnitId);
		if (pWarlord &&
			NO_UNIT != pWarlord->getUnitType() &&
			pWarlord->getUnitInfo().getLeaderExperience() > 0 &&
			NO_PROMOTION == pWarlord->getUnitInfo().getLeaderPromotion() &&
			canAcquirePromotionAny())
		{
			return true;
		}
	}

	if (ePromotion == NO_PROMOTION)
	{
		return false;
	}

/*************************************************************************************************/
/**	Tweak								29/01/12										Snarko	**/
/**																								**/
/**		With so many promotions we don't want to check them all if we can avoid it.				**/
/**		I have not kept the original code because... well this is the original code.			**/
/**		I just changed the order of the calls to put canAcquirePromotion as late as possible	**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	AutoBots								07/16/08								Xienwolf	**/
/**																								**/
/**	Prevents a Unit from Purchasing a Must Maintain Promotion Multiple Times unless StackEffect	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!canAcquirePromotion(ePromotion))
/**								----  End Original Code  ----									**/
	if (isHasPromotion(ePromotion) && GC.getPromotionInfo(ePromotion).isMustMaintain() && !GC.getPromotionInfo(ePromotion).isStackEffect()) //canAcquirePromotion check was here
/*************************************************************************************************/
/**	AutoBots									END												**/
/*************************************************************************************************/
	{
		return false;
	}
/*************************************************************************************************/
/**	Existential								07/16/08								Xienwolf	**/
/**																								**/
/**						Allows a Unit to gain Promotions without spending XP					**/
/*************************************************************************************************/
	//NoXP check was here
/*************************************************************************************************/
/**	Existential									END												**/
/*************************************************************************************************/

//FfH Units: Added by Kael 08/04/2007
	//FreePromotionPick check was here
//FfH: End Add

	if (GC.getPromotionInfo(ePromotion).isLeader())
	{
		if (iLeaderUnitId >= 0)
		{
			CvUnit* pWarlord = GET_PLAYER(getOwnerINLINE()).getUnit(iLeaderUnitId);
			if (pWarlord && NO_UNIT != pWarlord->getUnitType())
			{
				return (pWarlord->getUnitInfo().getLeaderPromotion() == ePromotion);
			}
		}
		return false;
	}
	else
	{
		if (!isPromotionReady() && !GC.getPromotionInfo(ePromotion).isNoXP() && !(getFreePromotionPick() > 0))
		{
			return false;
		}
		if (!canAcquirePromotion(ePromotion))
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	return true;
}

void CvUnit::promote(PromotionTypes ePromotion, int iLeaderUnitId)
{
	if (!canPromote(ePromotion, iLeaderUnitId))
	{
		return;
	}

	if (iLeaderUnitId >= 0)
	{
		CvUnit* pWarlord = GET_PLAYER(getOwnerINLINE()).getUnit(iLeaderUnitId);
		if (pWarlord)
		{
			pWarlord->giveExperience();
			if (!pWarlord->getNameNoDesc().empty())
			{
				setName(pWarlord->getNameKey());
			}

			//update graphics models
			m_eLeaderUnitType = pWarlord->getUnitType();
			reloadEntity();
		}
	}

/*************************************************************************************************/
/**	Existential								07/16/08								Xienwolf	**/
/**																								**/
/**							Allows for Specific Free Promotions									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
//FfH Units: Modified by Kael 08/04/2007
//	if (!GC.getPromotionInfo(ePromotion).isLeader())
	if ((!GC.getPromotionInfo(ePromotion).isLeader()) && getFreePromotionPick() == 0)
//FfH: End Modify

/**								----  End Original Code  ----									**/
	if ((!GC.getPromotionInfo(ePromotion).isLeader()) && getFreePromotionPick() == 0 && !GC.getPromotionInfo(ePromotion).isNoXP())
/*************************************************************************************************/
/**	Existential									END												**/
/*************************************************************************************************/
	{
		changeLevel(1);

		TraitTriggeredData kTrigger;
		//kTrigger.eLevel = getLevel();
		kTrigger.m_iUnitClass = getUnitClassType();
		kTrigger.m_iUnitCombat = getUnitCombatType();
		kTrigger.m_bHero = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_HERO"));
		kTrigger.m_bWerewolf = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_WEREWOLF"));
		kTrigger.m_bUndead = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_UNDEAD"));
		kTrigger.m_iRace = (PromotionTypes)getRace();
		//kTrigger.eReligion = GET_PLAYER(getOwner()).getStateReligion();
		//kTrigger.eAlignment = GET_PLAYER(getOwner()).getAlignment();
		//kTrigger.eEthicalAlignment = GET_PLAYER(getOwner()).getEthicalAlignment();
		GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_UNIT_LEVEL_UP, &kTrigger);

		changeDamageReal(-(getDamageReal() / 2));
	}

//FfH: Added by Kael 01/09/2008
/*************************************************************************************************/
/**	Existential								07/16/08								Xienwolf	**/
/**																								**/
/**				Prevents loss of Free Promotion points if Promotion was Free Anyway				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getFreePromotionPick() > 0)
/**								----  End Original Code  ----									**/
	if (getFreePromotionPick() > 0 && !GC.getPromotionInfo(ePromotion).isNoXP())
/*************************************************************************************************/
/**	Existential									END												**/
/*************************************************************************************************/
	{
		changeFreePromotionPick(-1);
	}
//FfH: End Add

	setHasPromotion(ePromotion, true);

/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**			Enables a Unit to spend XP on health & Level after Promotions are exhausted			**/
/*************************************************************************************************/
	if (GC.getPromotionInfo(ePromotion).getGoldCost() != 0)
	{
		GET_PLAYER(getOwnerINLINE()).changeGold(-GC.getPromotionInfo(ePromotion).getGoldCost());
	}
/*************************************************************************************************/
/**	Tweak								29/01/12										Snarko	**/
/**																								**/
/**		With so many promotions we don't want to check them all if we can avoid it.				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!canAcquirePromotionAny())
	{
		setNullPromoteAvailable(getUnitCombatType() != NO_UNITCOMBAT);
	}
/**								----  End Original Code  ----									**/
	//setNullPromoteAvailable(getUnitCombatType() != NO_UNITCOMBAT);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	testPromotionReady();

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->playGeneralSound(GC.getPromotionInfo(ePromotion).getSound());

		gDLL->getInterfaceIFace()->setDirty(UnitInfo_DIRTY_BIT, true);
	}
	else
	{
		setInfoBarDirty(true);
	}

	CvEventReporter::getInstance().unitPromoted(this, ePromotion);
}

bool CvUnit::lead(int iUnitId)
{
	if (!canLead(plot(), iUnitId))
	{
		return false;
	}

	PromotionTypes eLeaderPromotion = (PromotionTypes)m_pUnitInfo->getLeaderPromotion();

	if (-1 == iUnitId)
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_LEADUNIT, eLeaderPromotion, getID());
		if (pInfo)
		{
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwnerINLINE(), true);
		}
		return false;
	}
	else
	{
		CvUnit* pUnit = GET_PLAYER(getOwnerINLINE()).getUnit(iUnitId);

		if (!pUnit || !pUnit->canPromote(eLeaderPromotion, getID()))
		{
			return false;
		}

		pUnit->joinGroup(NULL, true, true);

		pUnit->promote(eLeaderPromotion, getID());

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_LEAD);
		}

		kill(true);

		return true;
	}
}


int CvUnit::canLead(const CvPlot* pPlot, int iUnitId) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	PROFILE_FUNC();

	if (isDelayedDeath())
	{
		return 0;
	}

	if (NO_UNIT == getUnitType())
	{
		return 0;
	}

	int iNumUnits = 0;
	CvUnitInfo& kUnitInfo = getUnitInfo();

	if (-1 == iUnitId)
	{
		CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
		while(pUnitNode != NULL)
		{
			CvUnit* pUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);

			if (pUnit && pUnit != this && pUnit->getOwnerINLINE() == getOwnerINLINE() && pUnit->canPromote((PromotionTypes)kUnitInfo.getLeaderPromotion(), getID()))
			{
				++iNumUnits;
			}
		}
	}
	else
	{
		CvUnit* pUnit = GET_PLAYER(getOwnerINLINE()).getUnit(iUnitId);
		if (pUnit && pUnit != this && pUnit->canPromote((PromotionTypes)kUnitInfo.getLeaderPromotion(), getID()))
		{
			iNumUnits = 1;
		}
	}
	return iNumUnits;
}


int CvUnit::canGiveExperience(const CvPlot* pPlot) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	int iNumUnits = 0;

	if (NO_UNIT != getUnitType() && m_pUnitInfo->getLeaderExperience() > 0)
	{
		CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
		while(pUnitNode != NULL)
		{
			CvUnit* pUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);

			if (pUnit && pUnit != this && pUnit->getOwnerINLINE() == getOwnerINLINE() && pUnit->canAcquirePromotionAny())
			{
				++iNumUnits;
			}
		}
	}

	return iNumUnits;
}

bool CvUnit::giveExperience()
{
	CvPlot* pPlot = plot();

	if (pPlot)
	{
		int iNumUnits = canGiveExperience(pPlot);
		if (iNumUnits > 0)
		{
			int iTotalExperience = getStackExperienceToGive(iNumUnits);

			int iMinExperiencePerUnit = iTotalExperience / iNumUnits;
			int iRemainder = iTotalExperience % iNumUnits;

			CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
			int i = 0;
			while(pUnitNode != NULL)
			{
				CvUnit* pUnit = ::getUnit(pUnitNode->m_data);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);

				if (pUnit && pUnit != this && pUnit->getOwnerINLINE() == getOwnerINLINE() && pUnit->canAcquirePromotionAny())
				{
					pUnit->changeExperience(i < iRemainder ? iMinExperiencePerUnit+1 : iMinExperiencePerUnit);
					pUnit->testPromotionReady();
				}

				i++;
			}

			return true;
		}
	}

	return false;
}

int CvUnit::getStackExperienceToGive(int iNumUnits) const
{
/*************************************************************************************************/
/**	DecimalXP							11/21/08									Xienwolf	**/
/**																								**/
/**					XP Values carried as Floats now in XML, 100x value in DLL					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return (m_pUnitInfo->getLeaderExperience() * (100 + std::min(50, (iNumUnits - 1) * GC.getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT")))) / 100;
/**								----  End Original Code  ----									**/
	return (m_pUnitInfo->getLeaderExperience() * (100 + std::min(50, (iNumUnits - 1) * GC.getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT"))));
/*************************************************************************************************/
/**	DecimalXP									END												**/
/*************************************************************************************************/
}

int CvUnit::upgradePrice(UnitTypes eUnit) const
{
	PROFILE("CvUnit::upgradePrice");
	int iPrice;

/*************************************************************************************************/
/**	Speedup								10/02/12										Snarko	**/
/**																								**/
/**	This function is called a lot of times late game, so don't call python unless needed.		**/
/*************************************************************************************************/
	if(GC.getUSE_UPGRADE_PRICE_CALLBACK())
	{
		CyArgsList argsList;
		argsList.add(getOwnerINLINE());
		argsList.add(getID());
		argsList.add((int) eUnit);
		long lResult=0;
		gDLL->getPythonIFace()->callFunction(PYGameModule, "getUpgradePriceOverride", argsList.makeFunctionArgs(), &lResult);
		if (lResult >= 0)
		{
			return lResult;
		}
	}
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/

	if (isBarbarian())
	{
		return 0;
	}

	iPrice = GC.getDefineINT("BASE_UNIT_UPGRADE_COST");

	iPrice += (std::max(0, (GET_PLAYER(getOwnerINLINE()).getProductionNeeded(eUnit) - GET_PLAYER(getOwnerINLINE()).getProductionNeeded(getUnitType()))) * GC.getDefineINT("UNIT_UPGRADE_COST_PER_PRODUCTION"));

	if (!isHuman() && !isBarbarian())
	{
		iPrice *= GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIUnitUpgradePercent();
		iPrice /= 100;

		iPrice *= std::max(0, ((GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIPerEraModifier() * GET_PLAYER(getOwnerINLINE()).getCurrentEra()) + 100));
		iPrice /= 100;
	}

	iPrice -= (iPrice * getUpgradeDiscount()) / 100;

//FfH Traits: Added by Kael 08/02/2007
	iPrice += (iPrice * GET_PLAYER(getOwnerINLINE()).getUpgradeCostModifier()) / 100;
//FfH: End Add

	return iPrice;
}

/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::upgradeAvailable(UnitTypes eFromUnit, UnitClassTypes eToUnitClass, int iCount) const
{
	PROFILE("CvUnit::upgradeAvailable");
	UnitTypes eLoopUnit;
	int iI;
	int numUnitClassInfos = GC.getNumUnitClassInfos();

	if (iCount > numUnitClassInfos)
	{
		return false;
	}

	CvUnitInfo &fromUnitInfo = GC.getUnitInfo(eFromUnit);

	if (fromUnitInfo.getUpgradeUnitClass(eToUnitClass))
	{
		return true;
	}

	for (iI = 0; iI < numUnitClassInfos; iI++)
	{
		if (fromUnitInfo.getUpgradeUnitClass(iI))
		{
			//This is possibly the location we need to edit so that Warriors cannot upgrade into Centaur Chargers
			//Currently they are blocked from upgrading to Centaurs, but they are able to upgrade to anything which a centaur can upgrade to
			//The same happens in a few other locations.
			eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));

			if (eLoopUnit != NO_UNIT)
			{
				if (upgradeAvailable(eLoopUnit, eToUnitClass, (iCount + 1)))
				{
					return true;
				}
			}
		}
	}

	return false;
}
/**								----  End Original Code  ----									**/
bool CvUnit::upgradeAvailable(UnitTypes eFromUnit, UnitClassTypes eToUnitClass, int iCount) const
{
	PROFILE("CvUnit::upgradeAvailable");
	UnitTypes eLoopUnit;
	UnitClassTypes eUpgradeClass;
	int iI;

	if (GC.getUnitInfo(eFromUnit).getNumUpgradeUnitClass() == 0)
	{
		return false;
	}

	CvUnitInfo &fromUnitInfo = GC.getUnitInfo(eFromUnit);


	for (iI = 0; iI < fromUnitInfo.getNumUpgradeUnitClass(); iI++)
	{
		eUpgradeClass = (UnitClassTypes)GC.getUnitInfo(eFromUnit).getUpgradeUnitClass(iI);
		if (eUpgradeClass == eToUnitClass)
		{
			return true;
		}

		eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits((int)eUpgradeClass)));
		if (eLoopUnit != NO_UNIT)
		{
			if (upgradeAvailable(eLoopUnit, eToUnitClass))
			{
				return true;
			}
		}
	}

	return false;
}
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/


bool CvUnit::canUpgrade(UnitTypes eUnit, bool bTestVisible) const
{
	PROFILE("CvUnit::canUpgrade");

	if (eUnit == NO_UNIT)
	{
		return false;
	}

	if(!isReadyForUpgrade())
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(getOwnerINLINE()).getGold() < upgradePrice(eUnit))
		{
			return false;
		}
	}

//FfH Units: Added by Kael 05/24/2008
	if (getLevel() < GC.getUnitInfo(eUnit).getMinLevel())
	{
		if (isHuman() || !GC.getGameINLINE().isOption(GAMEOPTION_AI_NO_MINIMUM_LEVEL))
		{
			return false;
		}
	}

	if (GC.getUnitInfo(eUnit).isDisableUpgradeTo())
	{
		return false;
	}

	if (GET_PLAYER(getOwnerINLINE()).isUnitClassMaxedOut((UnitClassTypes)(GC.getUnitInfo(eUnit).getUnitClassType())))
	{
		return false;
	}
	if (!isHuman()) //added so the AI wont spam UNTIAI_MISSIONARY priests by upgrading disciples
	{
		if (AI_getUnitAIType() == UNITAI_MISSIONARY && getLevel() < 2)
		{
			return false;
		}
	}
//FfH: End Add

	if (hasUpgrade(eUnit))
	{
		return true;
	}

	return false;
}

bool CvUnit::isReadyForUpgrade() const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							11/30/08											**/
/**																								**/
/**					Allows units which can NEVER move to be able to upgrade						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!canMove())
/**								----  End Original Code  ----									**/
	if (!canMove() && maxMoves() > 0)
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	{
		return false;
	}

	if (plot()->getTeam() != getTeam())
	{
		return false;
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	return true;
}

// has upgrade is used to determine if an upgrade is possible,
// it specifically does not check whether the unit can move, whether the current plot is owned, enough gold
// those are checked in canUpgrade()
// does not search all cities, only checks the closest one
bool CvUnit::hasUpgrade(bool bSearch) const
{
	return (getUpgradeCity(bSearch) != NULL);
}

// has upgrade is used to determine if an upgrade is possible,
// it specifically does not check whether the unit can move, whether the current plot is owned, enough gold
// those are checked in canUpgrade()
// does not search all cities, only checks the closest one
bool CvUnit::hasUpgrade(UnitTypes eUnit, bool bSearch) const
{
	return (getUpgradeCity(eUnit, bSearch) != NULL);
}

// finds the 'best' city which has a valid upgrade for the unit,
// it specifically does not check whether the unit can move, or if the player has enough gold to upgrade
// those are checked in canUpgrade()
// if bSearch is true, it will check every city, if not, it will only check the closest valid city
// NULL result means the upgrade is not possible
CvCity* CvUnit::getUpgradeCity(bool bSearch) const
{
	CvPlayerAI& kPlayer = GET_PLAYER(getOwnerINLINE());
	UnitAITypes eUnitAI = AI_getUnitAIType();
	CvArea* pArea = area();

	int iCurrentValue = kPlayer.AI_unitValue(getUnitType(), eUnitAI, pArea);

	int iBestSearchValue = MAX_INT;
	CvCity* pBestUpgradeCity = NULL;

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
/*************************************************************************************************/
/**	Xienwolf Tweak							07/05/09											**/
/**																								**/
/**		Why check for absolutely every unit who is better than this one for the AI type?		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		int iNewValue = kPlayer.AI_unitValue(((UnitTypes)iI), eUnitAI, pArea);
		if (iNewValue > iCurrentValue)
		{
			int iSearchValue;
			CvCity* pUpgradeCity = getUpgradeCity((UnitTypes)iI, bSearch, &iSearchValue);
			if (pUpgradeCity != NULL)
			{
				// if not searching or close enough, then this match will do
				if (!bSearch || iSearchValue < 16)
				{
					return pUpgradeCity;
				}

				if (iSearchValue < iBestSearchValue)
				{
					iBestSearchValue = iSearchValue;
					pBestUpgradeCity = pUpgradeCity;
				}
			}
		}
/**								----  End Original Code  ----									**/
		if (upgradeAvailable(getUnitType(), (UnitClassTypes)GC.getUnitInfo((UnitTypes)iI).getUnitClassType()))	//Unfortunately this still isn't perfect, doesn't account for Assimilation, UpgradeCiv, DisableUpgradeTo and a few other tags added by FfH
		{
			int iNewValue = kPlayer.AI_unitValue(((UnitTypes)iI), eUnitAI, pArea);
			if (iNewValue > iCurrentValue)
			{
				int iSearchValue;
				CvCity* pUpgradeCity = getUpgradeCity((UnitTypes)iI, bSearch, &iSearchValue);
				if (pUpgradeCity != NULL)
				{
					// if not searching or close enough, then this match will do
					if (!bSearch || iSearchValue < 16)
					{
						return pUpgradeCity;
					}

					if (iSearchValue < iBestSearchValue)
					{
						iBestSearchValue = iSearchValue;
						pBestUpgradeCity = pUpgradeCity;
					}
				}
			}
		}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	}

	return pBestUpgradeCity;
}

// finds the 'best' city which has a valid upgrade for the unit, to eUnit type
// it specifically does not check whether the unit can move, or if the player has enough gold to upgrade
// those are checked in canUpgrade()
// if bSearch is true, it will check every city, if not, it will only check the closest valid city
// if iSearchValue non NULL, then on return it will be the city's proximity value, lower is better
// NULL result means the upgrade is not possible
CvCity* CvUnit::getUpgradeCity(UnitTypes eUnit, bool bSearch, int* iSearchValue) const
{
	PROFILE("CvUnit::getUpgradeCity");
	if (eUnit == NO_UNIT)
	{
		return false;
	}

	CvPlayerAI& kPlayer = GET_PLAYER(getOwnerINLINE());
	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);

//FfH: Modified by Kael 05/09/2008
//	if (GC.getCivilizationInfo(kPlayer.getCivilizationType()).getCivilizationUnits(kUnitInfo.getUnitClassType()) != eUnit)
//	{
//		return false;
//	}
//	if (m_pUnitInfo->getUpgradeCiv() == NO_CIVILIZATION)
//	{
//		if (!kPlayer.isAssimilation())
//		{
//			if (GC.getCivilizationInfo(kPlayer.getCivilizationType()).getCivilizationUnits(kUnitInfo.getUnitClassType()) != eUnit)
//			{
//				return false;
//			}
//		}
//	}
//	else
//	{
//		if (GC.getCivilizationInfo((CivilizationTypes)m_pUnitInfo->getUpgradeCiv()).getCivilizationUnits(kUnitInfo.getUnitClassType()) != eUnit)
//		{
//			return false;
//		}
//	}
//FfH: End Modify

	if (!upgradeAvailable(getUnitType(), ((UnitClassTypes)(kUnitInfo.getUnitClassType()))))
	{
		return false;
	}

	if (kUnitInfo.getCargoSpace() < getCargo())
	{
		return false;
	}

	CLLNode<IDInfo>* pUnitNode = plot()->headUnitNode();
	while (pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = plot()->nextUnitNode(pUnitNode);

		if (pLoopUnit->getTransportUnit() == this)
		{
			if (kUnitInfo.getSpecialCargo() != NO_SPECIALUNIT)
			{
				if (kUnitInfo.getSpecialCargo() != pLoopUnit->getSpecialUnitType())
				{
					return false;
				}
			}

			if (kUnitInfo.getDomainCargo() != NO_DOMAIN)
			{
				if (kUnitInfo.getDomainCargo() != pLoopUnit->getDomainType())
				{
					return false;
				}
			}
		}
	}

	// sea units must be built on the coast
	bool bCoastalOnly = (getDomainType() == DOMAIN_SEA);

	// results
	int iBestValue = MAX_INT;
	CvCity* pBestCity = NULL;

	// if search is true, check every city for our team
	if (bSearch)
	{
		// air units can travel any distance
		bool bIgnoreDistance = (getDomainType() == DOMAIN_AIR);
/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		TeamTypes eTeam = getTeam();
		int iArea = getArea();
		int iX = getX_INLINE(), iY = getY_INLINE();


		// check every player on our team's cities
		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			// is this player on our team?
			CvPlayerAI& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
			if (kLoopPlayer.isAlive() && kLoopPlayer.getTeam() == eTeam)
			{
				int iLoop;
				for (CvCity* pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))
				{
					// if coastal only, then make sure we are coast
					CvArea* pWaterArea = NULL;
					if (!bCoastalOnly || ((pWaterArea = pLoopCity->waterArea()) != NULL && !pWaterArea->isLake()))
					{
						// can this city tran this unit?

//FfH Units: Modified by Kael 05/24/2008
//						if (pLoopCity->canTrain(eUnit, false, false, true))
						if (pLoopCity->canUpgrade(eUnit, false, false, true))
//FfH: End Modify

						{
							// if we do not care about distance, then the first match will do
							if (bIgnoreDistance)
							{
								// if we do not care about distance, then return 1 for value
								if (iSearchValue != NULL)
								{
									*iSearchValue = 1;
								}

								return pLoopCity;
							}

							int iValue = plotDistance(iX, iY, pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE());

							// if not same area, not as good (lower numbers are better)
							if (iArea != pLoopCity->getArea() && (!bCoastalOnly || iArea != pWaterArea->getID()))
							{
								iValue *= 16;
							}

							// if we cannot path there, not as good (lower numbers are better)
							if (!generatePath(pLoopCity->plot(), 0, true))
							{
								iValue *= 16;
							}

							if (iValue < iBestValue)
							{
								iBestValue = iValue;
								pBestCity = pLoopCity;
							}
						}
					}
				}
			}
		}
/**								----  End Original Code  ----									**/
		int iArea = getArea();
		int iX = getX_INLINE(), iY = getY_INLINE();

		int iLoop;
		for (CvCity* pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
		{
			// if coastal only, then make sure we are coast
			CvArea* pWaterArea = NULL;
			if (!bCoastalOnly || ((pWaterArea = pLoopCity->waterArea()) != NULL && !pWaterArea->isLake()))
			{
				// can this city tran this unit?

//FfH Units: Modified by Kael 05/24/2008
//				if (pLoopCity->canTrain(eUnit, false, false, true))
				if (pLoopCity->getCityUnits(kUnitInfo.getUnitClassType())==eUnit && pLoopCity->canUpgrade(eUnit, false, false, true))
//FfH: End Modify

				{
					// if we do not care about distance, then the first match will do
					if (bIgnoreDistance)
					{
						// if we do not care about distance, then return 1 for value
						if (iSearchValue != NULL)
						{
							*iSearchValue = 1;
						}

						return pLoopCity;
					}

					int iValue = plotDistance(iX, iY, pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE());

					// if not same area, not as good (lower numbers are better)
					if (iArea != pLoopCity->getArea() && (!bCoastalOnly || iArea != pWaterArea->getID()))
					{
						iValue *= 16;
					}

					// if we cannot path there, not as good (lower numbers are better)
					if (!generatePath(pLoopCity->plot(), 0, true))
					{
						iValue *= 16;
					}

					if (iValue < iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
				}
			}
		}
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/
	}
	else
	{
		// find the closest city
/*************************************************************************************************/
/**	Tweak								14/02/12										Snarko	**/
/**																								**/
/**		Can only upgrade to units from our own cities, to prevent abuse/weird situations		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		CvCity* pClosestCity = GC.getMapINLINE().findCity(getX_INLINE(), getY_INLINE(), NO_PLAYER, getTeam(), true, bCoastalOnly);
/**								----  End Original Code  ----									**/
		CvCity* pClosestCity = GC.getMapINLINE().findCity(getX_INLINE(), getY_INLINE(), getOwnerINLINE(), NO_TEAM, true, bCoastalOnly);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		if (pClosestCity != NULL)
		{
			// if we can train, then return this city (otherwise it will return NULL)

//FfH Units: Modified by Kael 08/07/2007
//			if (pClosestCity->canTrain(eUnit, false, false, true))
		//	if (kPlayer.isAssimilation() && (m_pUnitInfo->getUpgradeCiv() == NO_CIVILIZATION))
		//	{
		//		if (GC.getCivilizationInfo(pClosestCity->getCivilizationType()).getCivilizationUnits(kUnitInfo.getUnitClassType()) != eUnit && GC.getCivilizationInfo(kPlayer.getCivilizationType()).getCivilizationUnits(kUnitInfo.getUnitClassType()) != eUnit)
		//		{
		//			return false;
		//		}
		//	}
			if (pClosestCity->getCityUnits(kUnitInfo.getUnitClassType()) != eUnit)
			{
				return false;
			}
			if (pClosestCity->canUpgrade(eUnit, false, false, true))
//FfH: End Add

			{
				// did not search, always return 1 for search value
				iBestValue = 1;

				pBestCity = pClosestCity;
			}
		}
	}

	// return the best value, if non-NULL
	if (iSearchValue != NULL)
	{
		*iSearchValue = iBestValue;
	}

	return pBestCity;
}

void CvUnit::upgrade(UnitTypes eUnit)
{
	CvUnit* pUpgradeUnit;

	if (!canUpgrade(eUnit))
	{
		return;
	}
	TraitTriggeredData kTriggerData;
	kTriggerData.m_iUnitClass = (UnitClassTypes)GC.getUnitInfo(eUnit).getUnitClassType();
	kTriggerData.m_iUnitCombat = (UnitCombatTypes)GC.getUnitInfo(eUnit).getUnitCombatType();
	kTriggerData.m_iRace = (PromotionTypes)getRace();
	//	kTriggerData.eReligion = GET_PLAYER(getOwner()).getStateReligion();
	//	kTriggerData.eAlignment = GET_PLAYER(getOwner()).getAlignment();
	//	kTriggerData.eEthicalAlignment = GET_PLAYER(getOwner()).getEthicalAlignment();
	GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_UPGRADE_UNIT, &kTriggerData);
	// DynTraits End


	GET_PLAYER(getOwnerINLINE()).changeGold(-(upgradePrice(eUnit)));

//FfH: Modified by Kael 04/18/2009
//	pUpgradeUnit = GET_PLAYER(getOwnerINLINE()).initUnit(eUnit, getX_INLINE(), getY_INLINE(), AI_getUnitAIType());
	UnitAITypes eUnitAI = AI_getUnitAIType();
	if (eUnitAI == UNITAI_MISSIONARY)
	{
		ReligionTypes eReligion = GET_PLAYER(getOwnerINLINE()).getStateReligion();
		if (eReligion == NO_RELIGION || GC.getUnitInfo(eUnit).getReligionSpreads(eReligion) == 0)
		{
			eUnitAI = UNITAI_RESERVE;
		}
	}
	pUpgradeUnit = GET_PLAYER(getOwnerINLINE()).initUnit(eUnit, getX_INLINE(), getY_INLINE(), eUnitAI);
//FfH: End Modify

	FAssertMsg(pUpgradeUnit != NULL, "UpgradeUnit is not assigned a valid value");

	pUpgradeUnit->joinGroup(getGroup());

	pUpgradeUnit->convert(this);

	pUpgradeUnit->finishMoves();

/*************************************************************************************************/
/**	Xienwolf Tweak							07/23/08											**/
/**																								**/
/**							No point in losing XP for an Upgrade in FfH							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (pUpgradeUnit->getLeaderUnitType() == NO_UNIT)
	{
		if (pUpgradeUnit->getExperience() > GC.getDefineINT("MAX_EXPERIENCE_AFTER_UPGRADE"))
		{
			pUpgradeUnit->setExperience(GC.getDefineINT("MAX_EXPERIENCE_AFTER_UPGRADE"));
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	UnitStatistics							07/18/08	Written: Teg Navanis Imported: Xienwolf	**/
/**																								**/
/**							Sends Unit Upgrade Information to Python							**/
/*************************************************************************************************/
	if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
	{
		ReportEventToPython(pUpgradeUnit, "unitUpgraded");
	}
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/
}


HandicapTypes CvUnit::getHandicapType() const
{
	return GET_PLAYER(getOwnerINLINE()).getHandicapType();
}


CivilizationTypes CvUnit::getCivilizationType() const
{
	return GET_PLAYER(getOwnerINLINE()).getCivilizationType();
}

const wchar* CvUnit::getVisualCivAdjective(TeamTypes eForTeam) const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							02/14/09											**/
/**																								**/
/**						Displays identity of Opponent in a better fashion						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getVisualOwner(eForTeam) == getOwnerINLINE())
	{
		return GC.getCivilizationInfo(getCivilizationType()).getAdjectiveKey();
	}

	return L"";
/**								----  End Original Code  ----									**/
	return GET_PLAYER(getVisualOwner(eForTeam)).getCivilizationAdjectiveKey();
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

SpecialUnitTypes CvUnit::getSpecialUnitType() const
{
	return ((SpecialUnitTypes)(m_pUnitInfo->getSpecialUnitType()));
}


UnitTypes CvUnit::getCaptureUnitType(CivilizationTypes eCivilization) const
{
	FAssert(eCivilization != NO_CIVILIZATION);
	return ((m_pUnitInfo->getUnitCaptureClassType() == NO_UNITCLASS) ? NO_UNIT : (UnitTypes)GC.getCivilizationInfo(eCivilization).getCivilizationUnits(m_pUnitInfo->getUnitCaptureClassType()));
}


UnitCombatTypes CvUnit::getUnitCombatType() const
{
/*************************************************************************************************/
/**	TempCombat							11/21/08									Xienwolf	**/
/**				Allows a Promotion to change Unitcombat.  Written "dumb" right now				**/
/**					Will be rewritten eventually to allow multiple Unitcombats					**/
/*************************************************************************************************/
	if (getTempUnitCombat() != -1)
	{
		return ((UnitCombatTypes)(getTempUnitCombat()));
	}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
	return ((UnitCombatTypes)(m_pUnitInfo->getUnitCombatType()));
}


DomainTypes CvUnit::getDomainType() const
{
	return ((DomainTypes)(m_pUnitInfo->getDomainType()));
}


/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
InvisibleTypes CvUnit::getInvisibleType() const
{

//FfH: Modified by Kael 11/11/2008
//	return ((InvisibleTypes)(m_pUnitInfo->getInvisibleType()));
	if (m_iInvisibleType == NO_INVISIBLE)
	{
		if (plot()->isOwned())
		{
			if (GET_PLAYER(plot()->getOwnerINLINE()).isHideUnits() && !isIgnoreHide())
			{
				if (plot()->getTeam() == getTeam())
				{
					if (!plot()->isCity())
					{
						return ((InvisibleTypes)GC.getDefineINT("INVISIBLE_TYPE"));
					}
				}
			}
		}
	}
	if (isInvisibleFromPromotion())
	{
		if (m_pUnitInfo->getEquipmentPromotion() != NO_PROMOTION)
		{
			return ((InvisibleTypes)2);
		}
		else
		{
			return ((InvisibleTypes)GC.getDefineINT("INVISIBLE_TYPE"));
		}
	}
	return ((InvisibleTypes)m_iInvisibleType);
//FfH: End Modify

}

int CvUnit::getNumSeeInvisibleTypes() const
{

//FfH: Added by Kael 12/07/2008
	if (isSeeInvisible())
	{
		return 1;
	}
//FfH: End Add

	return m_pUnitInfo->getNumSeeInvisibleTypes();
}

InvisibleTypes CvUnit::getSeeInvisibleType(int i) const
{

//FfH: Added by Kael 12/07/2008
	if (isSeeInvisible())
	{
		return ((InvisibleTypes)GC.getDefineINT("INVISIBLE_TYPE"));
	}
//FfH: End Add

	return (InvisibleTypes)(m_pUnitInfo->getSeeInvisibleType(i));
}
/**								----  End Original Code  ----									**/
int CvUnit::getNumInvisibleTypes() const
{
	return m_aiInvisibleTypes.size();
}

InvisibleTypes CvUnit::getInvisibleType(int i) const
{
	return (InvisibleTypes)(m_aiInvisibleTypes[i]);
}

InvisibleTypes CvUnit::getInvisibleLevel() const
{
	if (getNumInvisibleTypes() == 0)
	{
		return NO_INVISIBLE;
	}
	return (InvisibleTypes)m_aiInvisibleTypes[0];
}
int CvUnit::getNumSeeInvisibleTypes() const
{
	return m_aiSeeInvisibleTypes.size();
}

InvisibleTypes CvUnit::getSeeInvisibleType(int i) const
{
	return (InvisibleTypes)(m_aiSeeInvisibleTypes[i]);
}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/


int CvUnit::flavorValue(FlavorTypes eFlavor) const
{
	return m_pUnitInfo->getFlavorValue(eFlavor);
}


bool CvUnit::isBarbarian() const
{
	return GET_PLAYER(getOwnerINLINE()).isBarbarian();
}


bool CvUnit::isHuman() const
{
	return GET_PLAYER(getOwnerINLINE()).isHuman();
}
//Invisibility Rework
bool CvUnit::isRevealed() const
{
	if (getNumInvisibleTypes() <= 0)
	{
		return false;
	}
	bool temp = false;
	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if (GET_PLAYER((PlayerTypes)iI).getTeam() != getTeam())
			{
				for (int iJ = 0; iJ < getNumInvisibleTypes(); iJ++)
				{
					temp = temp || plot()->isInvisibleVisible(GET_PLAYER((PlayerTypes)iI).getTeam(), getInvisibleType(iJ));
				}
			}
		}
	}
	return temp;

}
bool CvUnit::isRevealed(const CvPlot* pPlot) const
{
	if (getNumInvisibleTypes() <= 0)
	{
		return false;
	}
	bool temp = false;
	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if (GET_PLAYER((PlayerTypes)iI).getTeam() != getTeam())
			{
				for (int iJ = 0; iJ < getNumInvisibleTypes(); iJ++)
				{
					temp = temp || pPlot->isInvisibleVisible(GET_PLAYER((PlayerTypes)iI).getTeam(), getInvisibleType(iJ));
				}
			}
		}
	}
	return temp;

}
bool CvUnit::isHidden() const
{
	return ((getNumInvisibleTypes() > 0) && !(isRevealed()));

}


// accounts for plot improvements boosting units vision range. Flying and air domain get less benefit from improvements
int CvUnit::visibilityRange() const
{
	// Needed to ensure no vision on blinded units
	if (isBlind())
		return -99;

	int iRange = GC.getDefineINT("UNIT_VISIBILITY_RANGE") + getExtraVisibilityRange();

	if (plot() == NULL)
		return iRange;

	ImprovementTypes eImprovement = plot()->getImprovementType();

	if (eImprovement == NO_IMPROVEMENT)
		return iRange;

	int iImprovementMod = GC.getImprovementInfo(eImprovement).getVisibilityChange();

	// Guess an improvement could give a negative range value?
	if (iImprovementMod <= 0)
		return (iRange + iImprovementMod);

	// Blaze 2025: Flying units (and domain air units) have a built-in +1 (or fixed) range,
	// and should get less bonus from e.g. a tall tower helping them see further.
	// Something like mirror of heaven or tower of eyes though still should give a buff.
	if (isFlying() || getDomainType() == DOMAIN_AIR)
		iImprovementMod = std::max(0, iImprovementMod - 2);
	
	return (iRange + iImprovementMod);
}


int CvUnit::baseMoves() const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**									Prevents negative Move Value								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return (m_pUnitInfo->getMoves() + getExtraMoves() + GET_TEAM(getTeam()).getExtraMoves(getDomainType()));
/**								----  End Original Code  ----									**/
	return std::max(0, (m_pUnitInfo->getMoves() + getExtraMoves() + GET_TEAM(getTeam()).getExtraMoves(getDomainType())));
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}


int CvUnit::maxMoves() const
{
	return (baseMoves() * GC.getMOVE_DENOMINATOR());
}


int CvUnit::movesLeft() const
{
	return std::max(0, (maxMoves() - getMoves()));
}


bool CvUnit::canMove() const
{
	// Xienwolf - 03/27/09 - Blocks Movement of Marked Units
	if (plot() == NULL)
		return false;

	if (isBlind() && (!plot()->isVisible(getTeam(), false) || !plot()->isRevealed(getTeam(), false)))
		return false;

	if (isDead())
		return false;

	if (getMoves() >= maxMoves())
		return false;

	if (getImmobileTimer() > 0)
		return false;

	return true;
}


bool CvUnit::hasMoved()	const
{
	return (getMoves() > 0);
}


int CvUnit::airRange() const
{
	return (m_pUnitInfo->getAirRange() + getExtraAirRange());
}


int CvUnit::nukeRange() const
{
	return m_pUnitInfo->getNukeRange();
}


// XXX should this test for coal?
bool CvUnit::canBuildRoute() const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**							Prevents inappropriate Enraged Actions							**/
/*************************************************************************************************/
	if (isEnraged())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	int iI;

	for (iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		if (GC.getBuildInfo((BuildTypes)iI).getRoute() != NO_ROUTE)
		{
			if (m_pUnitInfo->getBuilds(iI))
			{
				if (GET_TEAM(getTeam()).isHasTech((TechTypes)(GC.getBuildInfo((BuildTypes)iI).getTechPrereq())))
				{
					return true;
				}
			}
		}
	}

	return false;
}

BuildTypes CvUnit::getBuildType() const
{
	BuildTypes eBuild;

	if (getGroup()->headMissionQueueNode() != NULL)
	{
		switch (getGroup()->headMissionQueueNode()->m_data.eMissionType)
		{
		case MISSION_MOVE_TO:
			break;

		case MISSION_ROUTE_TO:
			if (getGroup()->getBestBuildRoute(plot(), &eBuild) != NO_ROUTE)
			{
				return eBuild;
			}
			break;

		case MISSION_MOVE_TO_UNIT:
		case MISSION_SKIP:
		case MISSION_SLEEP:
		case MISSION_FORTIFY:
		case MISSION_PLUNDER:
		case MISSION_AIRPATROL:
		case MISSION_SEAPATROL:
		case MISSION_HEAL:
		case MISSION_SENTRY:
		case MISSION_AIRLIFT:
		case MISSION_NUKE:
		case MISSION_RECON:
		case MISSION_PARADROP:
		case MISSION_AIRBOMB:
		case MISSION_BOMBARD:
		case MISSION_RANGE_ATTACK:
		case MISSION_PILLAGE:
		case MISSION_SABOTAGE:
		case MISSION_DESTROY:
		case MISSION_STEAL_PLANS:
		case MISSION_FOUND:
		case MISSION_SPREAD:
		case MISSION_SPREAD_CORPORATION:
		case MISSION_JOIN:
		case MISSION_CONSTRUCT:
		case MISSION_DISCOVER:
		case MISSION_HURRY:
		case MISSION_TRADE:
		case MISSION_GREAT_WORK:
		case MISSION_INFILTRATE:
		case MISSION_GOLDEN_AGE:
		case MISSION_LEAD:
		case MISSION_ESPIONAGE:
		case MISSION_DIE_ANIMATION:
/*************************************************************************************************/
/**	MISSION_CLAIM_FORT/MISSION_EXPLORE_LAIR	19/06/10									Snarko	**/
/**																								**/
/**						Adding a mission for the claim_fort action...							**/
/**							and one for the explore_lair action									**/
/*************************************************************************************************/
		case MISSION_CLAIM_FORT:
		case MISSION_EXPLORE_LAIR:
/*************************************************************************************************/
/**	MISSION_CLAIM_FORT/MISSION_EXPLORE_LAIR	END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
		case MISSION_INQUISITION:
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
		//TargetedSpell 0924 blackimp
		case MISSION_TARGETED_SPELL:
			break;

		case MISSION_BUILD:
			return (BuildTypes)getGroup()->headMissionQueueNode()->m_data.iData1;
			break;

		default:
			FAssert(false);
			break;
		}
	}

	return NO_BUILD;
}


/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**					Need to know build order and features to get workrate now					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvUnit::workRate(bool bMax) const
/**								----  End Original Code  ----									**/
int CvUnit::workRate(bool bMax, BuildTypes eBuild, FeatureTypes eFeature) const
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
{
	int iRate;

	if (!bMax)
	{
		if (!canMove())
		{
			return 0;
		}
	}

	iRate = m_pUnitInfo->getWorkRate();

//FfH: Added by Kael 08/13/2008
	iRate += getWorkRateModify();
//FfH: End Add
/*************************************************************************************************/
/**	Choppers							12/07/08									Xienwolf	**/
/**																								**/
/**					Allows Discounting of Build Times based on known Technologies				**/
/*************************************************************************************************/
	if (eBuild != NO_BUILD)
	{
		int iTechDiscount = 0;
		for (int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
		{
			if (GET_TEAM(getTeam()).isHasTech((TechTypes) iTechLoop))
			{
				if (GC.getBuildInfo(eBuild).getTechDiscount(iTechLoop) != 0)
				{
					iTechDiscount += GC.getBuildInfo(eBuild).getTechDiscount(iTechLoop);
				}
			}
		}
		int iTime = GC.getBuildInfo(eBuild).getTime() + (eFeature != NO_FEATURE ? GC.getBuildInfo(eBuild).getFeatureTime(eFeature) : 0);
		if (iTime > 0)
		{
			iRate *= iTime;
			iRate /= std::max(1, (iTime - iTechDiscount));
		}
	}
/*************************************************************************************************/
/**	Choppers								END													**/
/*************************************************************************************************/

	iRate *= std::max(0, (GET_PLAYER(getOwnerINLINE()).getWorkerSpeedModifier() + 100));
	iRate /= 100;

	if (!isHuman() && !isBarbarian())
	{
		iRate *= std::max(0, (GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIWorkRateModifier() + 100));
		iRate /= 100;
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**						Prevents negative Workrates due to Racial adjustments					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return iRate;
/**								----  End Original Code  ----									**/
	return std::max(0, iRate);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}


bool CvUnit::isAnimal() const
{
/*************************************************************************************************/
/**	MultiBarb							01/07/09									Xienwolf	**/
/**																								**/
/**								Adds extra Barbarian Civilizations								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_pUnitInfo->isAnimal();
/**								----  End Original Code  ----									**/
	return (m_pUnitInfo->isAnimal() || getTeam() == ANIMAL_TEAM);
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
}


bool CvUnit::isNoBadGoodies() const
{
	return m_pUnitInfo->isNoBadGoodies();
}


bool CvUnit::isOnlyDefensive() const
{

//FfH Promotions: Added by Kael 08/14/2007
	if (m_iOnlyDefensive > 0)
	{
		return true;
	}
//FfH: End Add
/*************************************************************************************************/
/**	AttackEnable 							05/15/08								Xienwolf	**/
/**																								**/
/**									Blocks the UnitInfo Flag									**/
/*************************************************************************************************/
	if (isAllowAttacks())
	{
		return false;
	}
/*************************************************************************************************/
/**	AttackEnable 								END												**/
/*************************************************************************************************/

	return m_pUnitInfo->isOnlyDefensive();
}

int CvUnit::getBetrayalChance() const
{
	return m_iBetrayalChance;
}

void CvUnit::changeBetrayalChance(int iChange)
{
	m_iBetrayalChance += iChange;
}


bool CvUnit::isRivalTerritory() const
{
/*************************************************************************************************/
/**	Rivals 									05/15/08								Xienwolf	**/
/**																								**/
/**							Blocks or Simulates the UnitInfo Flag								**/
/*************************************************************************************************/
	if (isRivalTerritoryBlock())
	{
		return false;
	}
	if (isRivalTerritoryExplore())
	{
		return true;
	}
/*************************************************************************************************/
/**	Rivals 										END												**/
/*************************************************************************************************/
	return m_pUnitInfo->isRivalTerritory();
}


bool CvUnit::isMilitaryHappiness() const
{
/*************************************************************************************************/
/**	MilHappy 								05/15/08								Xienwolf	**/
/**																								**/
/**							Blocks or Simulates the UnitInfo Flag								**/
/*************************************************************************************************/
	if (isCityNoHappy())
	{
		return false;
	}
	if (isCityHappy())
	{
		return true;
	}
/*************************************************************************************************/
/**	MilHappy 									END												**/
/*************************************************************************************************/
	return m_pUnitInfo->isMilitaryHappiness();
}


bool CvUnit::isInvestigate() const
{
/*************************************************************************************************/
/**	CitySpy 								05/15/08								Xienwolf	**/
/**																								**/
/**									Simulates the UnitInfo Flag									**/
/*************************************************************************************************/
	if (isCitySpy())
	{
		return true;
	}
/*************************************************************************************************/
/**	CitySpy 									END												**/
/*************************************************************************************************/
	return m_pUnitInfo->isInvestigate();
}


bool CvUnit::isCounterSpy() const
{
	return m_pUnitInfo->isCounterSpy();
}


bool CvUnit::isSpy() const
{
	return m_pUnitInfo->isSpy();
}


bool CvUnit::isFound() const
{
	return m_pUnitInfo->isFound();
}


bool CvUnit::isGoldenAge() const
{
	if (isDelayedDeath())
	{
		return false;
	}

/*************************************************************************************************/
/**	Goldie 									05/15/08								Xienwolf	**/
/**									Simulates the UnitInfo Flag									**/
/**		AI Doesn't seem to realize Unit is capable of this.  Or doesn't think it worthwhile		**/
/*************************************************************************************************/
	if (getDuration() > 0)
	{
		return false;
	}
	if (isStartGoldenAge())
	{
		return true;
	}
/*************************************************************************************************/
/**	Goldie 										END												**/
/*************************************************************************************************/
	return m_pUnitInfo->isGoldenAge();
}

bool CvUnit::canCoexistWithEnemyUnit(TeamTypes eTeam) const
{
/*************************************************************************************************/
/**	PeaceAndFlowers							03/27/09								Xienwolf	**/
/**																								**/
/**					Makes all Combat Actions impossible for this type of Unit					**/
/*************************************************************************************************/
	if (isNeverHostile())
	{
		return true;
	}
/*************************************************************************************************/
/**	PeaceAndFlowers							END													**/
/*************************************************************************************************/
	if (NO_TEAM == eTeam)
	{
		if(alwaysInvisible())
		{
			return true;
		}

		return false;
	}

	if(isInvisible(eTeam, false))
	{
		return true;
	}

	return false;
}

bool CvUnit::isFighting() const
{
	return (getCombatUnit() != NULL);
}


bool CvUnit::isAttacking() const
{
	return (getAttackPlot() != NULL && !isDelayedDeath());
}


bool CvUnit::isDefending() const
{
	return (isFighting() && !isAttacking());
}


bool CvUnit::isCombat() const
{
	return (isFighting() || isAttacking());
}


int CvUnit::maxHitPoints() const
{
	return GC.getMAX_HIT_POINTS();
}


// Returns actual hit points (default 1000 hp scale)
int CvUnit::currHitPoints()	const
{
	// Snarko - Higher hitpoints - 07/04/11 - Makes higher values than 100 HP possible.
	return (maxHitPoints() - getDamageReal());
}


// Checks actual hp instead of rounding to a percent
bool CvUnit::isHurt() const
{
	return (getDamageReal() > 0);
}


bool CvUnit::isDead() const
{
	// Snarko - Higher hitpoints - 07/04/11 - Makes higher values than 100 HP possible.
	return (getDamageReal() >= maxHitPoints());
}


void CvUnit::setBaseCombatStr(int iCombat)
{
	m_iBaseCombat = iCombat;
}

int CvUnit::baseCombatStr() const
{

//FfH Damage Types: Modified by Kael 10/26/2007
//    return m_iBaseCombat;
	int iStr = m_iBaseCombat + m_iTotalDamageTypeCombat;
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**						Allows Animal Escalation to carry over on convert						**/
/*************************************************************************************************/
	iStr += getStrBoost();
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (iStr < 0)
	{
		iStr = 0;
	}
	return iStr;
//FfH: End Add

}

//FfH Defense Str: Added by Kael 10/26/2007
void CvUnit::setBaseCombatStrDefense(int iCombat)
{
	m_iBaseCombatDefense = iCombat;
}

int CvUnit::baseCombatStrDefense() const
{
	int iStr = m_iBaseCombatDefense + m_iTotalDamageTypeCombat;
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**						Allows Animal Escalation to carry over on convert						**/
/*************************************************************************************************/
	iStr += getStrBoost();
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (iStr < 0)
	{
		iStr = 0;
	}
	return iStr;
}
//FfH: End Add

// maxCombatStr can be called in four different configurations
//		pPlot == NULL, pAttacker == NULL for combat when this is the attacker
//		pPlot valid, pAttacker valid for combat when this is the defender
//		pPlot valid, pAttacker == NULL (new case), when this is the defender, attacker unknown
//		pPlot valid, pAttacker == this (new case), when the defender is unknown, but we want to calc approx str
//			note, in this last case, it is expected pCombatDetails == NULL, it does not have to be, but some
//			values may be unexpectedly reversed in this case (iModifierTotal will be the negative sum)
int CvUnit::maxCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails) const
{
	int iCombat;

//FfH Damage Types: Added by Kael 09/02/2007
	const CvUnit* pDefender = NULL;
	if (pPlot == NULL)
	{
		if (pAttacker != NULL)
		{
			pDefender = pAttacker;
			pAttacker = NULL;
		}
	}
//FfH: End Add

	FAssertMsg((pPlot == NULL) || (pPlot->getTerrainType() != NO_TERRAIN), "(pPlot == NULL) || (pPlot->getTerrainType() is not expected to be equal with NO_TERRAIN)");

	// handle our new special case
	const	CvPlot*	pAttackedPlot = NULL;
	bool	bAttackingUnknownDefender = false;
	if (pAttacker == this)
	{
		bAttackingUnknownDefender = true;
		pAttackedPlot = pPlot;

		// reset these values, we will fiddle with them below
		pPlot = NULL;
		pAttacker = NULL;
	}
	// otherwise, attack plot is the plot of us (the defender)
	else if (pAttacker != NULL)
	{
		pAttackedPlot = plot();
	}

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iExtraCombatPercent = 0;
		pCombatDetails->iAnimalCombatModifierTA = 0;
		pCombatDetails->iAIAnimalCombatModifierTA = 0;
		pCombatDetails->iAnimalCombatModifierAA = 0;
		pCombatDetails->iAIAnimalCombatModifierAA = 0;
		pCombatDetails->iBarbarianCombatModifierTB = 0;
		pCombatDetails->iAIBarbarianCombatModifierTB = 0;
		pCombatDetails->iBarbarianCombatModifierAB = 0;
		pCombatDetails->iAIBarbarianCombatModifierAB = 0;
		pCombatDetails->iPlotDefenseModifier = 0;
		pCombatDetails->iFortifyModifier = 0;
		pCombatDetails->iCityDefenseModifier = 0;
		pCombatDetails->iHillsAttackModifier = 0;
		pCombatDetails->iHillsDefenseModifier = 0;
		pCombatDetails->iFeatureAttackModifier = 0;
		pCombatDetails->iFeatureDefenseModifier = 0;
		pCombatDetails->iPlotEffectAttackModifier = 0;
		pCombatDetails->iPlotEffectDefenseModifier = 0;
		pCombatDetails->iTerrainAttackModifier = 0;
		pCombatDetails->iTerrainDefenseModifier = 0;
		pCombatDetails->iCityAttackModifier = 0;
		pCombatDetails->iDomainDefenseModifier = 0;
		pCombatDetails->iCityBarbarianDefenseModifier = 0;
		pCombatDetails->iClassDefenseModifier = 0;
		pCombatDetails->iClassAttackModifier = 0;
		pCombatDetails->iCombatModifierA = 0;
		pCombatDetails->iCombatModifierT = 0;
		pCombatDetails->iDomainModifierA = 0;
		pCombatDetails->iDomainModifierT = 0;
		pCombatDetails->iAnimalCombatModifierA = 0;
		pCombatDetails->iAnimalCombatModifierT = 0;
		pCombatDetails->iRiverAttackModifier = 0;
		pCombatDetails->iAmphibAttackModifier = 0;
		pCombatDetails->iKamikazeModifier = 0;
		pCombatDetails->iModifierTotal = 0;
		pCombatDetails->iBaseCombatStr = 0;
		pCombatDetails->iCombat = 0;
		pCombatDetails->iMaxCombatStr = 0;
		pCombatDetails->iCurrHitPoints = 0;
		pCombatDetails->iMaxHitPoints = 0;
		pCombatDetails->iCurrCombatStr = 0;
		pCombatDetails->eOwner = getOwnerINLINE();
		pCombatDetails->eVisualOwner = getVisualOwner();
		pCombatDetails->sUnitName = getName().GetCString();
	}

//FfH Defense Str: Modified by Kael 08/18/2007
//	if (baseCombatStr() == 0)
//	{
//		return 0;
//	}
	int iStr;
	if ((pAttacker == NULL && pPlot == NULL) || pAttacker == this)
	{
		iStr = baseCombatStr();
	}
	else
	{
		iStr = baseCombatStrDefense();
	}

	if (iStr == 0)
	{
		return 0;
	}
//FfH: End Modify

	int iModifier = 0;
	int iExtraModifier;

	iExtraModifier = getExtraCombatPercent();
	iModifier += iExtraModifier;
	if (pCombatDetails != NULL)
	{
		pCombatDetails->iExtraCombatPercent = iExtraModifier;
	}

	if (!((pAttacker == NULL && pPlot == NULL) || pAttacker == this))
	{
		iExtraModifier = getExtraCombatPercentDefense();
		iModifier += iExtraModifier;
		if (pCombatDetails != NULL)
		{
			pCombatDetails->iExtraCombatPercent += iExtraModifier;
		}

	}

	// do modifiers for animals and barbarians (leaving these out for bAttackingUnknownDefender case)
	if (pAttacker != NULL)
	{
/*************************************************************************************************/
/**	MultiBarb							01/01/09									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (isAnimal())
/**								----  End Original Code  ----									**/
		if (getCivilizationType() == (CivilizationTypes)GC.getDefineINT("ANIMAL_CIVILIZATION"))
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
		{
			if (pAttacker->isHuman())
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierTA = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIAnimalCombatModifierTA = iExtraModifier;
				}
			}
		}

/*************************************************************************************************/
/**	MultiBarb							01/01/09									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (pAttacker->isAnimal())
/**								----  End Original Code  ----									**/
		if (pAttacker->getCivilizationType() == (CivilizationTypes)GC.getDefineINT("ANIMAL_CIVILIZATION"))
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
		{
			if (isHuman())
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierAA = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIAnimalCombatModifierAA = iExtraModifier;
				}
			}
		}

/*************************************************************************************************/
/**	MultiBarb							01/01/09									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (isBarbarian())
/**								----  End Original Code  ----									**/
		if (getCivilizationType() == (CivilizationTypes)GC.getDefineINT("ORC_CIVILIZATION"))
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
		{
			if (pAttacker->isHuman())
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getBarbarianCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierTB = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIBarbarianCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIBarbarianCombatModifierTB = iExtraModifier;
				}
			}
		}

/*************************************************************************************************/
/**	MultiBarb							01/01/09									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (pAttacker->isBarbarian())
/**								----  End Original Code  ----									**/
		if (pAttacker->getCivilizationType() == (CivilizationTypes)GC.getDefineINT("ORC_CIVILIZATION"))
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
		{
			if (isHuman())
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getBarbarianCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierAB = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIBarbarianCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{

//FfH: Modified by Kael 07/31/2008
//					pCombatDetails->iAIBarbarianCombatModifierTB = iExtraModifier;
					pCombatDetails->iAIBarbarianCombatModifierAB = iExtraModifier;
//FfH: End Modify

				}
			}
		}
/*************************************************************************************************/
/**	MultiBarb							01/01/09									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
		if (getCivilizationType() == (CivilizationTypes)GC.getDefineINT("DEMON_CIVILIZATION"))
		{
			if (pAttacker->isHuman())
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getDemonBonus();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierTB = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIDemonBonus();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIBarbarianCombatModifierTB = iExtraModifier;
				}
			}
		}

		if (pAttacker->getCivilizationType() == (CivilizationTypes)GC.getDefineINT("DEMON_CIVILIZATION"))
		{
			if (isHuman())
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getDemonBonus();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierAB = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIDemonBonus();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{

					pCombatDetails->iAIBarbarianCombatModifierAB = iExtraModifier;

				}
			}
		}
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
	}

	// add defensive bonuses (leaving these out for bAttackingUnknownDefender case)
	if (pPlot != NULL)
	{
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
		if (pPlot->getOwnerINLINE() == getOwnerINLINE())
		{
			iExtraModifier = getCombatPercentInBorders();
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
		if (!noDefensiveBonus())
		{
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      03/30/10                                jdog5000      */
/*                                                                                              */
/* General AI                                                                                   */
/************************************************************************************************/
			// When pAttacker is NULL but pPlot is not, this is a computation for this units defensive value
			// against an unknown attacker.  Always ignoring building defense in this case is a conservative estimate,
			// but causes AI to suicide against castle walls of low culture cities in early game.  Using this units
			// ignoreBuildingDefense does a little better ... in early game it corrects undervalue of castles.  One
			// downside is when medieval unit is defending a walled city against gunpowder.  Here, the over value
			// makes attacker a little more cautious, but with their tech lead it shouldn't matter too much.  Also
			// makes vulnerable units (ships, etc) feel safer in this case and potentially not leave, but ships
			// leave when ratio is pretty low anyway.

			//iExtraModifier = pPlot->defenseModifier(getTeam(), (pAttacker != NULL) ? pAttacker->ignoreBuildingDefense() : true);
			iExtraModifier = pPlot->defenseModifier(getTeam(), (pAttacker != NULL) ? pAttacker->ignoreBuildingDefense() : ignoreBuildingDefense());
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iPlotDefenseModifier = iExtraModifier;
			}
		}

		iExtraModifier = fortifyModifier();
		iModifier += iExtraModifier;
		if (pCombatDetails != NULL)
		{
			pCombatDetails->iFortifyModifier = iExtraModifier;
		}

		if (pPlot->isCity(true, getTeam()))
		{
			iExtraModifier = cityDefenseModifier();
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCityDefenseModifier = iExtraModifier;
			}
		}

		if (pPlot->isHills())
		{
			iExtraModifier = hillsDefenseModifier();
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iHillsDefenseModifier = iExtraModifier;
			}
		}

		if (pPlot->getFeatureType() != NO_FEATURE)
		{
			iExtraModifier = featureDefenseModifier(pPlot->getFeatureType());
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iFeatureDefenseModifier = iExtraModifier;
			}
		}
		if (pPlot->getPlotEffectType() != NO_PLOT_EFFECT)
		{
			iExtraModifier = getExtraPlotEffectDefensePercent(pPlot->getPlotEffectType());
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iPlotEffectDefenseModifier = iExtraModifier;
			}
		}
		//	else
		{
			iExtraModifier = terrainDefenseModifier(pPlot->getTerrainType());
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iTerrainDefenseModifier = iExtraModifier;
			}
		}
	}

	// if we are attacking to an plot with an unknown defender, the calc the modifier in reverse
	if (bAttackingUnknownDefender)
	{
		pAttacker = this;
	}

	// calc attacker bonueses
/************************************************************************************************/
/* UNOFFICIAL_PATCH                       09/20/09                                jdog5000      */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
/* original code
	if (pAttacker != NULL)
*/
	if (pAttacker != NULL && pAttackedPlot != NULL)
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/
	{
		int iTempModifier = 0;

/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
		if (pAttackedPlot->getOwnerINLINE() == pAttacker->getOwnerINLINE())
		{
			iExtraModifier = -pAttacker->getCombatPercentInBorders();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/

		if (pAttackedPlot->isCity(true, getTeam()))
		{
			iExtraModifier = -pAttacker->cityAttackModifier();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCityAttackModifier = iExtraModifier;
			}

			if (pAttacker->isBarbarian())
			{
				iExtraModifier = GC.getDefineINT("CITY_BARBARIAN_DEFENSE_MODIFIER");
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iCityBarbarianDefenseModifier = iExtraModifier;
				}
			}
		}

		if (pAttackedPlot->isHills())
		{
			iExtraModifier = -pAttacker->hillsAttackModifier();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iHillsAttackModifier = iExtraModifier;
			}
		}

		if (pAttackedPlot->getFeatureType() != NO_FEATURE)
		{
			iExtraModifier = -pAttacker->featureAttackModifier(pAttackedPlot->getFeatureType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iFeatureAttackModifier = iExtraModifier;
			}
		}
		if (pAttackedPlot->getPlotEffectType() != NO_PLOT_EFFECT)
		{
			iExtraModifier = -pAttacker->getExtraPlotEffectAttackPercent(pAttackedPlot->getPlotEffectType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iPlotEffectAttackModifier = iExtraModifier;
			}
		}
		//else
		{
			iExtraModifier = -pAttacker->terrainAttackModifier(pAttackedPlot->getTerrainType());
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iTerrainAttackModifier = iExtraModifier;
			}
		}

		// only compute comparisions if we are the defender with a known attacker
		if (!bAttackingUnknownDefender)
		{
			FAssertMsg(pAttacker != this, "pAttacker is not expected to be equal with this");

//FfH Promotions: Added by Kael 08/13/2007
			for (int iJ=0;iJ<GC.getNumPromotionInfos();iJ++)
			{
				if ((isHasPromotion((PromotionTypes)iJ)) && (GC.getPromotionInfo((PromotionTypes)iJ).getNumPromotionCombatMods() > 0))
				{
					for (int iK = 0; iK < GC.getPromotionInfo((PromotionTypes)iJ).getNumPromotionCombatMods() > 0; iK++)
					{
						if (pAttacker->isHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMods(iK,false)))
							{
								iModifier += GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMods(iK,true)*countHasPromotion((PromotionTypes)iJ);
							}

					}
				}
				if ((pAttacker->isHasPromotion((PromotionTypes)iJ)) && (GC.getPromotionInfo((PromotionTypes)iJ).getNumPromotionCombatMods() > 0))
				{
					for (int iK = 0; iK < GC.getPromotionInfo((PromotionTypes)iJ).getNumPromotionCombatMods() > 0; iK++)
					{
						if (isHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMods(iK, false)))
						{
							iModifier -= GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMods(iK, true)*pAttacker->countHasPromotion((PromotionTypes)iJ);
						}

					}

				}
				//if ((isHasPromotion((PromotionTypes)iJ)) && (GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMod()!=0))
				//{
				//	if (pAttacker->isHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatType()))
				//	{
				//		iModifier += GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMod();
				//	}
				//}
				//if ((pAttacker->isHasPromotion((PromotionTypes)iJ)) && (GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMod() != 0))
				//{
				//	if (isHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatType()))
				//	{
				//		iModifier -= GC.getPromotionInfo((PromotionTypes)iJ).getPromotionCombatMod();
				//	}
				//}
				//ReligionCombatBonus by BI 07/25/11

				if ((isHasPromotion((PromotionTypes)iJ)) && (GC.getPromotionInfo((PromotionTypes)iJ).getReligionCombatMod()>0))
				{
					if (pAttacker->getReligion() ==(GC.getPromotionInfo((PromotionTypes)iJ).getReligionCombatType()))
					{
						iModifier += GC.getPromotionInfo((PromotionTypes)iJ).getReligionCombatMod();
					}
				}
				if ((pAttacker->isHasPromotion((PromotionTypes)iJ)) && (GC.getPromotionInfo((PromotionTypes)iJ).getReligionCombatMod() > 0))
				{
					if (getReligion() == (GC.getPromotionInfo((PromotionTypes)iJ).getReligionCombatType()))
					{
						iModifier -= GC.getPromotionInfo((PromotionTypes)iJ).getReligionCombatMod();
					}
				}

			}
			if (GC.getGameINLINE().getGlobalCounter() * getCombatPercentGlobalCounter() / 100 != 0)
			{
				iModifier += GC.getGameINLINE().getGlobalCounter() * getCombatPercentGlobalCounter() / 100;
			}
			if (GC.getGameINLINE().getGlobalCounter() * pAttacker->getCombatPercentGlobalCounter() / 100 != 0)
			{
				iModifier -= GC.getGameINLINE().getGlobalCounter() * pAttacker->getCombatPercentGlobalCounter() / 100;
			}
//FfH: End Add

			iExtraModifier = unitClassDefenseModifier(pAttacker->getUnitClassType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iClassDefenseModifier = iExtraModifier;
			}

			iExtraModifier = -pAttacker->unitClassAttackModifier(getUnitClassType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iClassAttackModifier = iExtraModifier;
			}

			if (pAttacker->getUnitCombatType() != NO_UNITCOMBAT)
			{
				iExtraModifier = unitCombatModifier(pAttacker->getUnitCombatType());
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iCombatModifierA = iExtraModifier;
				}
			}
			if (getUnitCombatType() != NO_UNITCOMBAT)
			{
				iExtraModifier = -pAttacker->unitCombatModifier(getUnitCombatType());
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iCombatModifierT = iExtraModifier;
				}
			}

			iExtraModifier = domainModifier(pAttacker->getDomainType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDomainModifierA = iExtraModifier;
			}

			iExtraModifier = -pAttacker->domainModifier(getDomainType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDomainModifierT = iExtraModifier;
			}

			if (pAttacker->isAnimal())
			{
				iExtraModifier = animalCombatModifier();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierA = iExtraModifier;
				}
			}

			if (isAnimal())
			{
				iExtraModifier = -pAttacker->animalCombatModifier();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierT = iExtraModifier;
				}
			}
		}

		if (!(pAttacker->isRiver()))
		{
			if (pAttacker->plot()->isRiverCrossing(directionXY(pAttacker->plot(), pAttackedPlot)))
			{
				iExtraModifier = -GC.getRIVER_ATTACK_MODIFIER();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iRiverAttackModifier = iExtraModifier;
				}
			}
		}

		if (!(pAttacker->isAmphib()))
		{
			if (!(pAttackedPlot->isWater()) && pAttacker->plot()->isWater())
			{
				iExtraModifier = -GC.getAMPHIB_ATTACK_MODIFIER();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAmphibAttackModifier = iExtraModifier;
				}
			}
		}

		if (pAttacker->getKamikazePercent() != 0)
		{
			iExtraModifier = pAttacker->getKamikazePercent();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iKamikazeModifier = iExtraModifier;
			}
		}

		// if we are attacking an unknown defender, then use the reverse of the modifier
		if (bAttackingUnknownDefender)
		{
			iModifier -= iTempModifier;
		}
		else
		{
			iModifier += iTempModifier;
		}
	}

//FfH Defense Str: Modified by Kael 08/18/2007
//	if (pCombatDetails != NULL)
//	{
//		pCombatDetails->iModifierTotal = iModifier;
//		pCombatDetails->iBaseCombatStr = baseCombatStr();
//	}
//
//	if (iModifier > 0)
//	{
//		iCombat = (baseCombatStr() * (iModifier + 100));
//	}
//	else
//	{
//		iCombat = ((baseCombatStr() * 10000) / (100 - iModifier));
//  }
	if (pCombatDetails != NULL)
	{
		pCombatDetails->iModifierTotal = iModifier;
		pCombatDetails->iBaseCombatStr = iStr;
	}

	iStr *= 100;
	if (pAttacker != NULL)
	{
		for (int iI = 0; iI < GC.getNumDamageTypeInfos(); iI++)
		{
			if (getDamageTypeCombat((DamageTypes) iI) != 0)
			{
				if (pAttacker->getDamageTypeResist((DamageTypes) iI) != 0)
				{
					iStr -= getDamageTypeCombat((DamageTypes) iI) * 100;
					iStr += getDamageTypeCombat((DamageTypes) iI) * (100 - pAttacker->getDamageTypeResist((DamageTypes) iI));
				}
			}
		}
	}
	if (pDefender != NULL)
	{
		for (int iI = 0; iI < GC.getNumDamageTypeInfos(); iI++)
		{
			if (getDamageTypeCombat((DamageTypes) iI) != 0)
			{
				if (pDefender->getDamageTypeResist((DamageTypes) iI) != 0)
				{
					iStr -= getDamageTypeCombat((DamageTypes) iI) * 100;
					iStr += getDamageTypeCombat((DamageTypes) iI) * (100 - pDefender->getDamageTypeResist((DamageTypes) iI));
				}
			}
		}
	}

	if (iModifier > 0)
	{
		iCombat = (iStr * (iModifier + 100)) / 100;
	}
	else
	{
		iCombat = ((iStr * 100) / (100 - iModifier));
	}
//FfH: End Modify

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iCombat = iCombat;
		pCombatDetails->iMaxCombatStr = std::max(1, iCombat);
		pCombatDetails->iCurrHitPoints = currHitPoints();
		pCombatDetails->iMaxHitPoints = maxHitPoints();
		pCombatDetails->iCurrCombatStr = ((pCombatDetails->iMaxCombatStr * pCombatDetails->iCurrHitPoints) / pCombatDetails->iMaxHitPoints);
	}

	return std::max(1, iCombat);
}


int CvUnit::currCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails) const
{
	return ((maxCombatStr(pPlot, pAttacker, pCombatDetails) * currHitPoints()) / maxHitPoints());
}


int CvUnit::currFirepower(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return ((maxCombatStr(pPlot, pAttacker) + currCombatStr(pPlot, pAttacker) + 1) / 2);
}

// this nomalizes str by firepower, useful for quick odds calcs
// the effect is that a damaged unit will have an effective str lowered by firepower/maxFirepower
// doing the algebra, this means we mulitply by 1/2(1 + currHP)/maxHP = (maxHP + currHP) / (2 * maxHP)
int CvUnit::currEffectiveStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails) const
{
	int currStr = currCombatStr(pPlot, pAttacker, pCombatDetails);

	currStr *= (maxHitPoints() + currHitPoints());
	currStr /= (2 * maxHitPoints());

	return currStr;
}

float CvUnit::maxCombatStrFloat(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return (((float)(maxCombatStr(pPlot, pAttacker))) / 100.0f);
}


float CvUnit::currCombatStrFloat(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return (((float)(currCombatStr(pPlot, pAttacker))) / 100.0f);
}


bool CvUnit::canFight() const
{

/*************************************************************************************************/
/**	PeaceAndFlowers							03/27/09								Xienwolf	**/
/**																								**/
/**					Makes all Combat Actions impossible for this type of Unit					**/
/*************************************************************************************************/
	if (isNeverHostile())
	{
		return false;
	}
/*************************************************************************************************/
/**	PeaceAndFlowers							END													**/
/*************************************************************************************************/
//FfH: Modified by Kael 10/31/2007
//	return (baseCombatStr() > 0);
	if (baseCombatStr() == 0 && baseCombatStrDefense() == 0)
	{
		return false;
	}
	return true;
//FfH: End Modify

}


bool CvUnit::canAttack() const
{
	if (!canFight())
	{
		return false;
	}

	if (isOnlyDefensive())
	{
		return false;
	}

//FfH: Added by Kael 10/31/2007
	if (baseCombatStr() == 0)
	{
		return false;
	}
//FfH: End Add

	return true;
}
bool CvUnit::canAttack(const CvUnit& defender) const
{
	if (!canAttack())
	{
		return false;
	}

/*************************************************************************************************/
/**	Higher hitpoints				01/02/11											Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (defender.getDamage() >= combatLimit())
/**								----  End Original Code  ----									**/
	if (defender.getDamageReal() >= combatLimit())
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
	{
		return false;
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							02/14/09											**/
/**																								**/
/**				Useless field/workaround which would cause complications later					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	// Artillery can't amphibious attack
	if (plot()->isWater() && !defender.plot()->isWater())
	{
		if (combatLimit() < 100)
		{
			return false;
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	return true;
}

bool CvUnit::canDefend(const CvPlot* pPlot) const
{
	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	if (!canFight())
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

//FfH: Added by Kael 10/31/2007
	if (baseCombatStrDefense() == 0)
	{
		return false;
	}
//FfH: End Add

	return true;
}


bool CvUnit::canSiege(TeamTypes eTeam) const
{
	if (!canDefend())
	{
		return false;
	}

	if (!isEnemy(eTeam))
	{
		return false;
	}

	if (!isNeverInvisible())
	{
		return false;
	}

	return true;
}


int CvUnit::airBaseCombatStr() const
{
/*************************************************************************************************/
/**	SkyRocket							09/19/08									Xienwolf	**/
/**																								**/
/**						Includes Promotion Field with the UnitInfo								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_pUnitInfo->getAirCombat();
/**								----  End Original Code  ----									**/
	return m_pUnitInfo->getAirCombat() + getAirCombat();
/*************************************************************************************************/
/**	SkyRocket									END												**/
/*************************************************************************************************/
}


int CvUnit::airMaxCombatStr(const CvUnit* pOther) const
{
	int iModifier;
	int iCombat;

	if (airBaseCombatStr() == 0)
	{
		return 0;
	}

/*************************************************************************************************/
/**	Ranged Promos						02/16/09									Vehem		**/
/**																								**/
/**			Remove double benefit of Combat Promotions, Halves overall %modifier.				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**


	iModifier = getExtraCombatPercent();

	if (getKamikazePercent() != 0)
	{
		iModifier += getKamikazePercent();
	}

	if (NULL != pOther)
	{
		if (pOther->getUnitCombatType() != NO_UNITCOMBAT)
		{
			iModifier += unitCombatModifier(pOther->getUnitCombatType());
		}

		iModifier += domainModifier(pOther->getDomainType());

		if (pOther->isAnimal())
		{
			iModifier += animalCombatModifier();
		}
	}

	if (iModifier > 0)
	{
		iCombat = (airBaseCombatStr() * (iModifier + 100));
	}
	else
	{
		iCombat = ((airBaseCombatStr() * 10000) / (100 - iModifier));
	}


/**								----  End Original Code  ----									**/
	iModifier = getExtraRangedCombatPercent();

	if (NULL != pOther)
	{
		if (pOther->getUnitCombatType() != NO_UNITCOMBAT)
		{
			iModifier += unitCombatModifier(pOther->getUnitCombatType());
		}

		iModifier += domainModifier(pOther->getDomainType());

		if (pOther->isAnimal())
		{
			iModifier += animalCombatModifier();
		}
	}

	if (GC.getGameINLINE().getGlobalCounter() * getRangedCombatPercentGlobalCounter() / 100 != 0)
	{
		iModifier += GC.getGameINLINE().getGlobalCounter() * getRangedCombatPercentGlobalCounter() / 100;
	}

	if (getKamikazePercent() != 0)
	{
		iModifier += getKamikazePercent();
	}


	if (iModifier > 0)
	{
		iCombat = (airBaseCombatStr() * (iModifier + 100));
	}
	else
	{
		iCombat = ((airBaseCombatStr() * 10000) / (100 - iModifier));
	}

/*************************************************************************************************/
/**	Ranged Promos								END												**/
/*************************************************************************************************/

	return std::max(1, iCombat);
}


int CvUnit::airCurrCombatStr(const CvUnit* pOther) const
{
	return ((airMaxCombatStr(pOther) * currHitPoints()) / maxHitPoints());
}


float CvUnit::airMaxCombatStrFloat(const CvUnit* pOther) const
{
	return (((float)(airMaxCombatStr(pOther))) / 100.0f);
}


float CvUnit::airCurrCombatStrFloat(const CvUnit* pOther) const
{
	return (((float)(airCurrCombatStr(pOther))) / 100.0f);
}


int CvUnit::combatLimit() const
{

//FfH: Modified by Kael 04/26/2008
//	return m_pUnitInfo->getCombatLimit();
	return m_iCombatLimit;
//FfH: End Modify

}


int CvUnit::airCombatLimit() const
{
/*************************************************************************************************/
/**	SkyRocket							09/19/08									Xienwolf	**/
/**																								**/
/**						Includes Promotion Field with the UnitInfo								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_pUnitInfo->getAirCombatLimit();
/**								----  End Original Code  ----									**/
	return range(m_pUnitInfo->getAirCombatLimit() + getAirCombatLimitBoost(), 0, 100);
/*************************************************************************************************/
/**	SkyRocket									END												**/
/*************************************************************************************************/
}


bool CvUnit::canAirAttack() const
{
	return (airBaseCombatStr() > 0);
}


bool CvUnit::canAirDefend(const CvPlot* pPlot) const
{
	if (pPlot == NULL)
		pPlot = plot();

	if (maxInterceptionProbability() == 0)
		return false;

	// UNOFFICIAL_PATCH - Mongoose & jdog5000 - 10/30/09 - Land units which are cargo cannot intercept
	if (getDomainType() != DOMAIN_AIR && (!pPlot->isValidDomainForLocation(*this) || isCargo()))
		return false;

	return true;
}


int CvUnit::airCombatDamage(const CvUnit* pDefender) const
{
	CvCity* pCity;
	CvPlot* pPlot;
	int iOurStrength;
	int iTheirStrength;
	int iStrengthFactor;
	int iDamage;

	pPlot = pDefender->plot();

	iOurStrength = airCurrCombatStr(pDefender);
	FAssertMsg(iOurStrength > 0, "Air combat strength is expected to be greater than zero");
	iTheirStrength = pDefender->maxCombatStr(pPlot, this);

	iStrengthFactor = ((iOurStrength + iTheirStrength + 1) / 2);

	iDamage = std::max(1, ((GC.getDefineINT("AIR_COMBAT_DAMAGE") * (iOurStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor)));

	pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		iDamage *= std::max(0, (pCity->getAirModifier() + 100));
		iDamage /= 100;
	}

	return iDamage;
}


int CvUnit::rangeCombatDamage(const CvUnit* pDefender) const
{
	CvPlot* pPlot;
	int iOurStrength;
	int iTheirStrength;
	int iDamage;

	pPlot = pDefender->plot();

	iOurStrength = airCurrCombatStr(pDefender);
	FAssertMsg(iOurStrength > 0, "Combat strength is expected to be greater than zero");
	iTheirStrength = pDefender->maxCombatStr(pPlot, this);

/*************************************************************************************************/
/**	Vehem Tweak							02/05/09	 											**/
/**																								**/
/**		Ranged attack damage more dependant on unit strength and has random element				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	iStrengthFactor = ((iOurStrength + iTheirStrength + 1) / 2);

	iDamage = std::max(1, ((GC.getDefineINT("RANGE_COMBAT_DAMAGE") * (iOurStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor)));
/**								----  End Original Code  ----									**/

	int rangeCombatDamage = GC.getDefineINT("RANGE_COMBAT_DAMAGE");
	int randomRangedCombatDamage = GC.getGameINLINE().getSorenRandNum(rangeCombatDamage, "RangedDamage1") + GC.getGameINLINE().getSorenRandNum(rangeCombatDamage, "RangedDamage2") + 1;
	iDamage = std::max(1, ( randomRangedCombatDamage * (iOurStrength) / (iTheirStrength) ));

/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	return iDamage;
}


CvUnit* CvUnit::bestInterceptor(const CvPlot* pPlot) const
{
	CvUnit* pLoopUnit;
	CvUnit* pBestUnit;
	int iValue;
	int iBestValue;
	int iLoop;
	int iI;

	iBestValue = 0;
	pBestUnit = NULL;

	for (iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if (isEnemy(GET_PLAYER((PlayerTypes)iI).getTeam()) && !isInvisible(GET_PLAYER((PlayerTypes)iI).getTeam(), false, false))
			{
				for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))
				{
					if (pLoopUnit->canAirDefend())
					{
						if (!pLoopUnit->isMadeInterception())
						{
							if ((pLoopUnit->getDomainType() != DOMAIN_AIR) || !(pLoopUnit->hasMoved()))
							{
								if ((pLoopUnit->getDomainType() != DOMAIN_AIR) || (pLoopUnit->getGroup()->getActivityType() == ACTIVITY_INTERCEPT))
								{
									if (plotDistance(pLoopUnit->getX_INLINE(), pLoopUnit->getY_INLINE(), pPlot->getX_INLINE(), pPlot->getY_INLINE()) <= pLoopUnit->airRange())
									{
										iValue = pLoopUnit->currInterceptionProbability();

										if (iValue > iBestValue)
										{
											iBestValue = iValue;
											pBestUnit = pLoopUnit;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return pBestUnit;
}


CvUnit* CvUnit::bestSeaPillageInterceptor(CvUnit* pPillager, int iMinOdds) const
{
	CvUnit* pBestUnit = NULL;
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      02/21/10                                jdog5000      */
/*                                                                                              */
/* Lead From Behind                                                                             */
/************************************************************************************************/
	// From Lead From Behind by UncutDragon
	int pBestUnitRank = -1;

	for (int iDX = -1; iDX <= 1; ++iDX)
	{
		for (int iDY = -1; iDY <= 1; ++iDY)
		{
			CvPlot* pLoopPlot = plotXY(pPillager->getX_INLINE(), pPillager->getY_INLINE(), iDX, iDY);

			if (NULL != pLoopPlot)
			{
				CLLNode<IDInfo>* pUnitNode = pLoopPlot->headUnitNode();

				while (NULL != pUnitNode)
				{
					CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

					if (NULL != pLoopUnit)
					{
						if (pLoopUnit->area() == pPillager->plot()->area())
						{
							if (!pLoopUnit->isInvisible(getTeam(), false))
							{
								if (isEnemy(pLoopUnit->getTeam()))
								{
									if (DOMAIN_SEA == pLoopUnit->getDomainType())
									{
										if (ACTIVITY_PATROL == pLoopUnit->getGroup()->getActivityType())
										{
											// UncutDragon
											// orignal
											//if (NULL == pBestUnit || pLoopUnit->isBetterDefenderThan(pBestUnit, this))
											// modified (added extra parameter)
											if (NULL == pBestUnit || pLoopUnit->isBetterDefenderThan(pBestUnit, this, &pBestUnitRank))
											// /UncutDragon
											{
												if (getCombatOdds(pPillager, pLoopUnit) < iMinOdds)
												{
													pBestUnit = pLoopUnit;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/

	return pBestUnit;
}


bool CvUnit::isAutomated() const
{
	return getGroup()->isAutomated();
}


bool CvUnit::isWaiting() const
{
	return getGroup()->isWaiting();
}


bool CvUnit::isFortifyable() const
{
	if (!canFight() || noDefensiveBonus() || ((getDomainType() != DOMAIN_LAND) && (getDomainType() != DOMAIN_IMMOBILE)))
	{
		return false;
	}

	return true;
}


int CvUnit::fortifyModifier() const
{
	if (!isFortifyable())
	{
		return 0;
	}

//FfH: Modified by Kael 10/26/2007
//	return (getFortifyTurns() * GC.getFORTIFY_MODIFIER_PER_TURN());
	int i = getFortifyTurns() * GC.getFORTIFY_MODIFIER_PER_TURN();
	if (isDoubleFortifyBonus())
	{
		i *= 2;
	}
	return i;
//FfH: End Modify

}


int CvUnit::experienceNeeded() const
{
	// Use python to determine pillage amounts...
	int iExperienceNeeded;
	long lExperienceNeeded;

	lExperienceNeeded = 0;
	iExperienceNeeded = 0;

	CyArgsList argsList;
	argsList.add(getLevel());	// pass in the units level
	argsList.add(getOwnerINLINE());	// pass in the units

	gDLL->getPythonIFace()->callFunction(PYGameModule, "getExperienceNeeded", argsList.makeFunctionArgs(),&lExperienceNeeded);

	iExperienceNeeded = (int)lExperienceNeeded;

	return iExperienceNeeded;
}


int CvUnit::attackXPValue() const
{

//FfH: Modified by Kael 02/12/2009
//	return m_pUnitInfo->getXPValueAttack();
	int iXP = m_pUnitInfo->getXPValueAttack();
	if (isAnimal() || isBarbarian())
	{
		iXP = iXP * GC.getDefineINT("BARBARIAN_EXPERIENCE_MODIFIER") / 100;
	}
	return iXP;
//FfH: End Modify

}


int CvUnit::defenseXPValue() const
{

//FfH: Modified by Kael 02/12/2009
//	return m_pUnitInfo->getXPValueDefense();
	int iXP = m_pUnitInfo->getXPValueDefense();
	if (isAnimal() || isBarbarian())
	{
		iXP = iXP * GC.getDefineINT("BARBARIAN_EXPERIENCE_MODIFIER") / 100;
	}
	return iXP;
//FfH: End Modify

}


int CvUnit::maxXPValue() const
{
	int iMaxValue;

	iMaxValue = MAX_INT;
	if (getMaxExpReward() != -1)
	{
		iMaxValue = std::min(iMaxValue, getMaxExpReward());
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							11/21/08											**/
/**																								**/
/**		Removes XP caps from the game, Decimal XP should cause a natural limitation to emerge	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
//FfH: Modified by Kael 02/12/2009
//	if (isAnimal())
//	{
//		iMaxValue = std::min(iMaxValue, GC.getDefineINT("ANIMAL_MAX_XP_VALUE"));
//	}
//	if (isBarbarian())
//	{
//		iMaxValue = std::min(iMaxValue, GC.getDefineINT("BARBARIAN_MAX_XP_VALUE"));
//	}
	if (!::isWorldUnitClass(getUnitClassType()))
	{
		if (isAnimal())
		{
			iMaxValue = std::min(iMaxValue, GC.getDefineINT("ANIMAL_MAX_XP_VALUE"));
		}
		if (isBarbarian())
		{
			iMaxValue = std::min(iMaxValue, GC.getDefineINT("BARBARIAN_MAX_XP_VALUE"));
		}
	}
//FfH: End Modify
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	return iMaxValue;
}


int CvUnit::firstStrikes() const
{
	return std::max(0, (m_pUnitInfo->getFirstStrikes() + getExtraFirstStrikes()));
}


int CvUnit::chanceFirstStrikes() const
{
	return std::max(0, (m_pUnitInfo->getChanceFirstStrikes() + getExtraChanceFirstStrikes()));
}


int CvUnit::maxFirstStrikes() const
{
	return (firstStrikes() + chanceFirstStrikes());
}


bool CvUnit::isRanged() const
{
	int i;
	CvUnitInfo * pkUnitInfo = &getUnitInfo();
	for ( i = 0; i < pkUnitInfo->getGroupDefinitions(); i++ )
	{
		if ( !getArtInfo(i, GET_PLAYER(getOwnerINLINE()).getCurrentEra())->getActAsRanged() )
		{
			return false;
		}
	}
	return true;
}


bool CvUnit::alwaysInvisible() const
{
	return m_pUnitInfo->isInvisible();
}


bool CvUnit::immuneToFirstStrikes() const
{
/*************************************************************************************************/
/**	FirstStrikeable 						05/15/08								Xienwolf	**/
/**																								**/
/**									Simulates the UnitInfo Flag									**/
/*************************************************************************************************/
	if (isFirstStrikeVulnerable())
	{
		return false;
	}
/*************************************************************************************************/
/**	FirstStrikeable 							END												**/
/*************************************************************************************************/
	return (m_pUnitInfo->isFirstStrikeImmune() || (getImmuneToFirstStrikesCount() > 0));
}


bool CvUnit::noDefensiveBonus() const
{
/*************************************************************************************************/
/**	DefenseBlock 							05/15/08								Xienwolf	**/
/**	DefenseEnable 							05/15/08								Xienwolf	**/
/**									Simulates or  the UnitInfo Flag								**/
/*************************************************************************************************/
	if (isNoDefenseBonus())
	{
		return true;
	}
	if (isAllowDefenseBonuses())
	{
		return false;
	}
/*************************************************************************************************/
/**	DefenseBlock 									END												**/
/**	DefenseEnable 									END												**/
/*************************************************************************************************/
	return m_pUnitInfo->isNoDefensiveBonus();
}


bool CvUnit::ignoreBuildingDefense() const
{

//FfH: Modifed by Kael 11/17/2007
//	return m_pUnitInfo->isIgnoreBuildingDefense();
	if (m_pUnitInfo->isIgnoreBuildingDefense())
	{
		return true;
	}
	return m_iIgnoreBuildingDefense == 0 ? false : true;
//FfH: End Modify

}


bool CvUnit::canMoveImpassable() const
{

//FfH Flying: Added by Kael 07/30/2007
	if (isFlying())
	{
		return true;
	}
//FfH: End Add
/*************************************************************************************************/
/**	ImpassMove 								05/15/08								Xienwolf	**/
/**																								**/
/**									Simulates the UnitInfo Flag									**/
/*************************************************************************************************/
	if (isMoveImpassable())
	{
		return true;
	}
/*************************************************************************************************/
/**	ImpassMove 									END												**/
/*************************************************************************************************/

	return m_pUnitInfo->isCanMoveImpassable();
}

/*************************************************************************************************/
/**	Mountain Mod		 		expanded by Ahwaric	20.09.09		**/
/*************************************************************************************************/
bool CvUnit::canClimbPeaks() const
{
	if (isFlying())
	{
		return true;
	}
	if (isClimbPeaks())
	{
		return true;
	}

	return m_pUnitInfo->isCanClimbPeaks();
}
/*************************************************************************************************/
/**	Mountain Mod END									**/
/*************************************************************************************************/

bool CvUnit::canMoveAllTerrain() const
{

//FfH Flying: Added by Kael 07/30/2007
	if (isFlying() || isWaterWalking())
	{
		return true;
	}
//FfH: End Add

	return m_pUnitInfo->isCanMoveAllTerrain();
}

bool CvUnit::flatMovementCost() const
{

//FfH Flying: Added by Kael 07/30/2007
	if (isFlying())
	{
		return true;
	}
//FfH: End Add
/*************************************************************************************************/
/**	MoveConst 								05/15/08								Xienwolf	**/
/**																								**/
/**									Simulates the UnitInfo Flag									**/
/*************************************************************************************************/
	if (isFlatMoveCost())
	{
		return true;
	}
/*************************************************************************************************/
/**	MoveConst 									END												**/
/*************************************************************************************************/

	return m_pUnitInfo->isFlatMovementCost();
}


bool CvUnit::ignoreTerrainCost() const
{
	//FfH Flying: Added by Kael 07/30/2007
	if (isFlying())
		return true;

	// MoveBetter - Xienwolf - 05/15/08 - Simulates the UnitInfo Flag
	if (isIgnoreTerrainCosts())
		return true;

	return m_pUnitInfo->isIgnoreTerrainCost();
}


// Xienwolf - 09/27/08 - Checks against all kinds of invisibility
bool CvUnit::isNeverInvisible() const
{
	return (!alwaysInvisible() && (getNumInvisibleTypes() == 0));
}


// Checks if a unit is invisible to a given team while on its own tile
bool CvUnit::isInvisible(TeamTypes eTeam, bool bDebug, bool bCheckCargo) const
{
	if (bDebug && GC.getGameINLINE().isDebugMode())
		return false;

	if (getTeam() == eTeam)
		return false;

	//FfH: Added by Kael 04/11/2008
	if (plot() != NULL)
	{
		if (plot()->isCity() && getTeam() == plot()->getTeam())
			return false;

		if (plot()->isOwned() && plot()->getTeam() != getTeam()
		 && GET_PLAYER(plot()->getOwnerINLINE()).isSeeInvisible())
		{
			return false;
		}
	}

	if (alwaysInvisible())
		return true;

	if (bCheckCargo && isCargo())
		return true;

	if (getNumInvisibleTypes() == 0)
		return false;

	if (plot() == NULL)
		return false;

	bool bHidden = false;
	for (int iI = 0; iI < getNumInvisibleTypes(); iI++)
	{
		if (!plot()->isInvisibleVisible(eTeam, getInvisibleType(iI)))
			bHidden = true;
	}

	return bHidden;
}

// Snarko - Checks if a unit will be invisible to a given team on a target plot (for purpose of moving onto that plot)
bool CvUnit::isInvisible(TeamTypes eTeam, const CvPlot* pPlot) const
{

	if (getTeam() == eTeam)
		return false;

	//FfH: Added by Kael 04/11/2008
	if (pPlot->isCity() && getTeam() == pPlot->getTeam())
		return false;

	if (pPlot->isOwned() && pPlot->getTeam() != getTeam()
	 && GET_PLAYER(pPlot->getOwnerINLINE()).isSeeInvisible())
	{
		return false;
	}

	if (alwaysInvisible())
		return true;

	if (isCargo())
		return true;

	if (getNumInvisibleTypes() == 0)
		return false;

	bool bHidden = false;
	for (int iI = 0; iI < getNumInvisibleTypes(); iI++)
	{
		if (!pPlot->isInvisibleVisible(eTeam, getInvisibleType(iI)))
			bHidden = true;
	}

	return bHidden;
}

bool CvUnit::isNukeImmune() const
{
	return m_pUnitInfo->isNukeImmune();
}


int CvUnit::maxInterceptionProbability() const
{
	return std::max(0, m_pUnitInfo->getInterceptionProbability() + getExtraIntercept());
}


int CvUnit::currInterceptionProbability() const
{
	if (getDomainType() != DOMAIN_AIR)
	{
		return maxInterceptionProbability();
	}
	else
	{
		return ((maxInterceptionProbability() * currHitPoints()) / maxHitPoints());
	}
}


int CvUnit::evasionProbability() const
{
	return std::max(0, m_pUnitInfo->getEvasionProbability() + getExtraEvasion());
}

// Base chance to withdraw when losing an attack, NOT accounting for the defending unit
int CvUnit::withdrawalProbability() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater() && !canMoveAllTerrain())
		return 0;

	//FfH: Added by Kael 04/06/2009
	if (getImmobileTimer() > 0)
		return 0;

	// Xienwolf - 02/06/09 - Allows units to purchase withdraw beyond the cap but enforces the cap still
	return range(m_pUnitInfo->getWithdrawalProbability() + getExtraWithdrawal(), 0, GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"));
}

// Modifier to enemy withdrawal chance when fighting this unit
int CvUnit::enemyWithdrawalProbability() const
{
	return m_pUnitInfo->getEnemyWithdrawalProbability();
}

// When attacking against Defender, what's the chance of successfully withdrawing
int CvUnit::combatWithdrawalProbability(CvUnit* Defender)
{
	return range(withdrawalProbability() + Defender->enemyWithdrawalProbability() + Defender->getExtraEnemyWithdrawal(), 0, GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"));
}
// When attacking against Defender, what's the chance of successfully withdrawing (duplicate of above but const overload so CvUnitAI can use it)
int CvUnit::combatWithdrawalProbability(CvUnit* Defender) const
{
	return range(withdrawalProbability() + Defender->enemyWithdrawalProbability() + Defender->getExtraEnemyWithdrawal(), 0, GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"));
}

// When defending against pAttacker, what's the chance of us successfully withdrawing instead of dying
int CvUnit::getWithdrawlProbDefensive(CvUnit* pAttacker) const
{
	if (getImmobileTimer() > 0)
		return 0;

	return range(m_pUnitInfo->getWithdrawlProbDefensive() + getExtraWithdrawal() + pAttacker->getExtraEnemyWithdrawal() + pAttacker->enemyWithdrawalProbability(), 0, GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"));
}

int CvUnit::collateralDamage() const
{
	return std::max(0, (m_pUnitInfo->getCollateralDamage() + getExtraCollateralDamage()));
}


int CvUnit::collateralDamageLimit() const
{
/*************************************************************************************************/
/**	Higher hitpoints				01/02/11											Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return std::max(0, (m_pUnitInfo->getCollateralDamageLimit()+ getCollateralLimitBoost()) * GC.getMAX_HIT_POINTS() / 100);
/**								----  End Original Code  ----									**/
	return std::max(0, m_pUnitInfo->getCollateralDamageLimit()+ getCollateralLimitBoost());
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
}


int CvUnit::collateralDamageMaxUnits() const
{
	return std::max(0, (m_pUnitInfo->getCollateralDamageMaxUnits()  + getCollateralExtraTargets()));
}

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
int CvUnit::flankingDamage() const
{
	return std::max(0, (m_pUnitInfo->getFlankingDamage() + getExtraFlankingDamage()));
}

int CvUnit::flankingDamageLimit() const
{
	return std::max(0, m_pUnitInfo->getFlankingDamageLimit()+ getFlankingLimitBoost());
}

int CvUnit::flankingDamageMaxUnits() const
{
	return std::max(0, (m_pUnitInfo->getFlankingDamageMaxUnits()  + getFlankingExtraTargets()));
}

int CvUnit::getExtraFlankingDamage() const
{
	return m_iExtraFlankingDamage;
}

void CvUnit::changeExtraFlankingDamage(int iChange)
{
	m_iExtraFlankingDamage += iChange;
	FAssert(getExtraFlankingDamage() >= 0);
}

/*************************************************************************************************/
/**	Updated Flanking							END												**/
/*************************************************************************************************/

int CvUnit::cityAttackModifier() const
{
	return (m_pUnitInfo->getCityAttackModifier() + getExtraCityAttackPercent());
}


int CvUnit::cityDefenseModifier() const
{
	return (m_pUnitInfo->getCityDefenseModifier() + getExtraCityDefensePercent());
}


int CvUnit::animalCombatModifier() const
{
	return m_pUnitInfo->getAnimalCombatModifier();
}


int CvUnit::hillsAttackModifier() const
{
	return (m_pUnitInfo->getHillsAttackModifier() + getExtraHillsAttackPercent());
}


int CvUnit::hillsDefenseModifier() const
{
	return (m_pUnitInfo->getHillsDefenseModifier() + getExtraHillsDefensePercent());
}


int CvUnit::terrainAttackModifier(TerrainTypes eTerrain) const
{
	FAssertMsg(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	FAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getTerrainAttackModifier(eTerrain) + getExtraTerrainAttackPercent(eTerrain));
}


int CvUnit::terrainDefenseModifier(TerrainTypes eTerrain) const
{
	FAssertMsg(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	FAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getTerrainDefenseModifier(eTerrain) + getExtraTerrainDefensePercent(eTerrain));
}


int CvUnit::featureAttackModifier(FeatureTypes eFeature) const
{
	FAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	FAssertMsg(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getFeatureAttackModifier(eFeature) + getExtraFeatureAttackPercent(eFeature));
}

int CvUnit::featureDefenseModifier(FeatureTypes eFeature) const
{
	FAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	FAssertMsg(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getFeatureDefenseModifier(eFeature) + getExtraFeatureDefensePercent(eFeature));
}

int CvUnit::unitClassAttackModifier(UnitClassTypes eUnitClass) const
{
	FAssertMsg(eUnitClass >= 0, "eUnitClass is expected to be non-negative (invalid Index)");
	FAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass is expected to be within maximum bounds (invalid Index)");
	return m_pUnitInfo->getUnitClassAttackModifier(eUnitClass);
}


int CvUnit::unitClassDefenseModifier(UnitClassTypes eUnitClass) const
{
	FAssertMsg(eUnitClass >= 0, "eUnitClass is expected to be non-negative (invalid Index)");
	FAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass is expected to be within maximum bounds (invalid Index)");
	return m_pUnitInfo->getUnitClassDefenseModifier(eUnitClass);
}


int CvUnit::unitCombatModifier(UnitCombatTypes eUnitCombat) const
{
	FAssertMsg(eUnitCombat >= 0, "eUnitCombat is expected to be non-negative (invalid Index)");
	FAssertMsg(eUnitCombat < GC.getNumUnitCombatInfos(), "eUnitCombat is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getUnitCombatModifier(eUnitCombat) + getExtraUnitCombatModifier(eUnitCombat));
}


int CvUnit::domainModifier(DomainTypes eDomain) const
{
	FAssertMsg(eDomain >= 0, "eDomain is expected to be non-negative (invalid Index)");
	FAssertMsg(eDomain < NUM_DOMAIN_TYPES, "eDomain is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getDomainModifier(eDomain) + getExtraDomainModifier(eDomain));
}


int CvUnit::bombardRate() const
{
	return (m_pUnitInfo->getBombardRate() + getExtraBombardRate());
}


int CvUnit::airBombBaseRate() const
{
	return m_pUnitInfo->getBombRate();
}


int CvUnit::airBombCurrRate() const
{
	return ((airBombBaseRate() * currHitPoints()) / maxHitPoints());
}

int CvUnit::getSpecialCargo() const
{
	if (m_pUnitInfo->getSpecialCargo() != NO_SPECIALUNIT)
	{
		return m_pUnitInfo->getSpecialCargo();
	}
	return m_iSpecialCargo;
}
void CvUnit::setSpecialCargo(int iNewValue)
{
	m_iSpecialCargo = iNewValue;
}

int CvUnit::getExtraDomainCargo() const
{
	return m_iDomainCargo;
}
void CvUnit::setExtraDomainCargo(int iNewValue)
{
	m_iDomainCargo = iNewValue;
}

SpecialUnitTypes CvUnit::specialCargo() const
{
	return ((SpecialUnitTypes)(getSpecialCargo()));
}


DomainTypes CvUnit::domainCargo() const
{
	return ((DomainTypes)(m_pUnitInfo->getDomainCargo()));
}


int CvUnit::cargoSpace() const
{
	return m_iCargoCapacity;
}

void CvUnit::changeCargoSpace(int iChange)
{
	if (iChange != 0)
	{
		m_iCargoCapacity += iChange;
		FAssert(m_iCargoCapacity >= 0);
		setInfoBarDirty(true);
	}
}
int CvUnit::getMaxExpReward() const
{
	return m_iMaxExpReward;
}

void CvUnit::changeMaxExpReward(int iChange)
{
	if (iChange != 0)
	{
		m_iMaxExpReward += iChange;
	}
}
bool CvUnit::isFull() const
{
	return (getCargo() >= cargoSpace());
}


int CvUnit::cargoSpaceAvailable(SpecialUnitTypes eSpecialCargo, DomainTypes eDomainCargo) const
{
	if (specialCargo() != NO_SPECIALUNIT)
	{
		if (specialCargo() != eSpecialCargo)
		{
			return 0;
		}
	}

	if (domainCargo() != NO_DOMAIN)
	{
		if (domainCargo() != eDomainCargo &&( getExtraDomainCargo()==NO_DOMAIN || getExtraDomainCargo() != eDomainCargo))
		{
			return 0;
		}
	}

	return std::max(0, (cargoSpace() - getCargo()));
}


bool CvUnit::hasCargo() const
{
	return (getCargo() > 0);
}


bool CvUnit::canCargoAllMove() const
{
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pPlot;

	pPlot = plot();

	pUnitNode = pPlot->headUnitNode();

	while (pUnitNode != NULL)
	{
		pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if (pLoopUnit->getTransportUnit() == this)
		{
			if (pLoopUnit->getDomainType() == DOMAIN_LAND)
			{
				if (!(pLoopUnit->canMove()))
				{
					return false;
				}
			}
		}
	}

	return true;
}

bool CvUnit::canCargoEnterArea(TeamTypes eTeam, const CvArea* pArea, bool bIgnoreRightOfPassage) const
{
	CvPlot* pPlot = plot();

	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();

	while (pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if (pLoopUnit->getTransportUnit() == this)
		{
			if (!pLoopUnit->canEnterArea(eTeam, pArea, bIgnoreRightOfPassage))
			{
				return false;
			}
		}
	}

	return true;
}

int CvUnit::getUnitAICargo(UnitAITypes eUnitAI) const
{
	int iCount = 0;

	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	for (uint i = 0; i < aCargoUnits.size(); ++i)
	{
		if (aCargoUnits[i]->AI_getUnitAIType() == eUnitAI)
		{
			++iCount;
		}
	}

	return iCount;
}


int CvUnit::getID() const
{
	return m_iID;
}


int CvUnit::getIndex() const
{
	return (getID() & FLTA_INDEX_MASK);
}


IDInfo CvUnit::getIDInfo() const
{
	IDInfo unit(getOwnerINLINE(), getID());
	return unit;
}


void CvUnit::setID(int iID)
{
	m_iID = iID;
}


int CvUnit::getGroupID() const
{
	return m_iGroupID;
}


bool CvUnit::isInGroup() const
{
	return(getGroupID() != FFreeList::INVALID_INDEX);
}


bool CvUnit::isGroupHead() const // XXX is this used???
{
	return (getGroup()->getHeadUnit() == this);
}


CvSelectionGroup* CvUnit::getGroup() const
{
	return GET_PLAYER(getOwnerINLINE()).getSelectionGroup(getGroupID());
}


bool CvUnit::canJoinGroup(const CvPlot* pPlot, CvSelectionGroup* pSelectionGroup) const
{
	CvUnit* pHeadUnit;

	// do not allow someone to join a group that is about to be split apart
	// this prevents a case of a never-ending turn
	if (pSelectionGroup->AI_isForceSeparate())
	{
		return false;
	}

	if (pSelectionGroup->getOwnerINLINE() == NO_PLAYER)
	{
		pHeadUnit = pSelectionGroup->getHeadUnit();

		if (pHeadUnit != NULL)
		{
			if (pHeadUnit->getOwnerINLINE() != getOwnerINLINE())
			{
				return false;
			}
		}
	}
	else
	{
		if (pSelectionGroup->getOwnerINLINE() != getOwnerINLINE())
		{
			return false;
		}
	}

	// Horrible, terrible hack to prevent AI from only moving starting settler one tile at a time : Blazenclaw AI_SpeedySettle
	if (!isHuman())
	{
		if (isHasPromotion((PromotionTypes)GC.getDefineINT("STARTING_SETTLER_PROMOTION")))
			return false;
		if (pSelectionGroup->getHeadUnit() != NULL && pSelectionGroup->getHeadUnit()->isHasPromotion((PromotionTypes)GC.getDefineINT("STARTING_SETTLER_PROMOTION")))
			return false;
	}

	if (pSelectionGroup->getNumUnits() > 0)
	{
		if (!(pSelectionGroup->atPlot(pPlot)))
		{
			return false;
		}

		if (pSelectionGroup->getDomainType() != getDomainType())
		{
			return false;
		}

		/*************************************************************************************************/
		/**	Xienwolf Tweak							01/04/09											**/
		/**																								**/
		/**							Allows HN units to group with each other							**/
		/*************************************************************************************************/
		/**								---- Start Original Code ----									**
		//FfH: Added by Kael 11/14/2007
		if (isEnraged())
		{
			return false;
		}
		if (isHiddenNationality())
		{
			return false;
		}
		pHeadUnit = pSelectionGroup->getHeadUnit();
		if (pHeadUnit != NULL)
		{
			if (pHeadUnit->isHiddenNationality())
			{
				return false;
			}
			if (pHeadUnit->isEnraged())
			{
				return false;
			}
		}
		//FfH: End Add
		/**								----  End Original Code  ----									**/
		pHeadUnit = pSelectionGroup->getHeadUnit();
		if (pHeadUnit != NULL)
		{
			if (pHeadUnit->isHiddenNationality() != isHiddenNationality())
			{
				return false;
			}
			if (pHeadUnit->isEnraged() != isEnraged())
			{
				return false;
			}
			if (pHeadUnit->isNeverHostile() != isNeverHostile())
			{
				return false;
			}
		}
		/*************************************************************************************************/
		/**	Tweak									END													**/
		/*************************************************************************************************/
	}

	return true;
}


void CvUnit::joinGroup(CvSelectionGroup* pSelectionGroup, bool bRemoveSelected, bool bRejoin)
{
	CvSelectionGroup* pOldSelectionGroup;
	CvSelectionGroup* pNewSelectionGroup;
	CvPlot* pPlot;

	pOldSelectionGroup = GET_PLAYER(getOwnerINLINE()).getSelectionGroup(getGroupID());

	if ((pSelectionGroup != pOldSelectionGroup) || (pOldSelectionGroup == NULL))
	{
		pPlot = plot();

		if (pSelectionGroup != NULL)
		{
			pNewSelectionGroup = pSelectionGroup;
		}
		else
		{
			if (bRejoin)
			{
				pNewSelectionGroup = GET_PLAYER(getOwnerINLINE()).addSelectionGroup();
				pNewSelectionGroup->init(pNewSelectionGroup->getID(), getOwnerINLINE());
			}
			else
			{
				pNewSelectionGroup = NULL;
			}
		}

		if ((pNewSelectionGroup == NULL) || canJoinGroup(pPlot, pNewSelectionGroup))
		{
			if (pOldSelectionGroup != NULL)
			{
				bool bWasHead = false;
				if (!isHuman())
				{
					if (pOldSelectionGroup->getNumUnits() > 1)
					{
						if (pOldSelectionGroup->getHeadUnit() == this)
						{
							bWasHead = true;
						}
					}
				}

				pOldSelectionGroup->removeUnit(this);

				// if we were the head, if the head unitAI changed, then force the group to separate (non-humans)
				if (bWasHead)
				{
					FAssert(pOldSelectionGroup->getHeadUnit() != NULL);
					if (pOldSelectionGroup->getHeadUnit()->AI_getUnitAIType() != AI_getUnitAIType())
					{
						pOldSelectionGroup->AI_makeForceSeparate();
					}
				}
			}

			if ((pNewSelectionGroup != NULL) && pNewSelectionGroup->addUnit(this, false))
			{
				m_iGroupID = pNewSelectionGroup->getID();
			}
			else
			{
				m_iGroupID = FFreeList::INVALID_INDEX;
			}

			if (getGroup() != NULL)
			{
				if (getGroup()->getNumUnits() > 1)
				{
					getGroup()->setActivityType(ACTIVITY_AWAKE);
				}
				else
				{
					GET_PLAYER(getOwnerINLINE()).updateGroupCycle(this);
				}
			}

			if (getTeam() == GC.getGameINLINE().getActiveTeam())
			{
				if (pPlot != NULL)
				{
					pPlot->setFlagDirty(true);
				}
			}

			if (pPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
			{
				gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
			}
		}

		if (bRemoveSelected)
		{
			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->removeFromSelectionList(this);
			}
		}
	}
}


int CvUnit::getHotKeyNumber()
{
	return m_iHotKeyNumber;
}


void CvUnit::setHotKeyNumber(int iNewValue)
{
	CvUnit* pLoopUnit;
	int iLoop;

	FAssert(getOwnerINLINE() != NO_PLAYER);

	if (getHotKeyNumber() != iNewValue)
	{
		if (iNewValue != -1)
		{
			for(pLoopUnit = GET_PLAYER(getOwnerINLINE()).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(getOwnerINLINE()).nextUnit(&iLoop))
			{
				if (pLoopUnit->getHotKeyNumber() == iNewValue)
				{
					pLoopUnit->setHotKeyNumber(-1);
				}
			}
		}

		m_iHotKeyNumber = iNewValue;

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}


int CvUnit::getX() const
{
	return m_iX;
}


int CvUnit::getY() const
{
	return m_iY;
}


void CvUnit::setXY(int iX, int iY, bool bGroup, bool bUpdate, bool bShow, bool bCheckPlotVisible)
{
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**			Profiling allows us to track which functions are taking up too much time			**/
/*************************************************************************************************/
	PROFILE("CvUnit::setXY");
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvCity* pOldCity;
	CvCity* pNewCity;
	CvCity* pWorkingCity;
	CvUnit* pTransportUnit;
	CvUnit* pLoopUnit;
	CvPlot* pOldPlot;
	CvPlot* pNewPlot;
	CvPlot* pLoopPlot;
	CLinkList<IDInfo> oldUnits;
	ActivityTypes eOldActivityType;
	int iI;

	// OOS!! Temporary for Out-of-Sync madness debugging...
	if (GC.getLogging())
	{
		if (gDLL->getChtLvl() > 0)
		{
			char szOut[1024];
			sprintf(szOut, "Player %d Unit %d (%S's %S) moving from %d:%d to %d:%d\n", getOwnerINLINE(), getID(), GET_PLAYER(getOwnerINLINE()).getNameKey(), getName().GetCString(), getX_INLINE(), getY_INLINE(), iX, iY);
			gDLL->messageControlLog(szOut);
		}
	}

//	FAssert(!at(iX, iY));
	if (at(iX, iY))
	{
		jumpToNearestValidPlot();
		return;
	}
//	FAssert(!isFighting());
	FAssert((iX == INVALID_PLOT_COORD) || (GC.getMapINLINE().plotINLINE(iX, iY)->getX_INLINE() == iX));
	FAssert((iY == INVALID_PLOT_COORD) || (GC.getMapINLINE().plotINLINE(iX, iY)->getY_INLINE() == iY));

	if (getGroup() != NULL)
	{
		eOldActivityType = getGroup()->getActivityType();
	}
	else
	{
		eOldActivityType = NO_ACTIVITY;
	}

	setBlockading(false);

	if (!bGroup || isCargo())
	{
		joinGroup(NULL, true);
		bShow = false;
	}

	pNewPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	if (pNewPlot != NULL)
	{
		pTransportUnit = getTransportUnit();

		if (pTransportUnit != NULL)
		{
			if (!(pTransportUnit->atPlot(pNewPlot)))
			{
				setTransportUnit(NULL);
			}
		}

		if (canFight())
		{
			oldUnits.clear();

			pUnitNode = pNewPlot->headUnitNode();

			while (pUnitNode != NULL)
			{
				oldUnits.insertAtEnd(pUnitNode->m_data);
				pUnitNode = pNewPlot->nextUnitNode(pUnitNode);
			}

			pUnitNode = oldUnits.head();

			while (pUnitNode != NULL)
			{
				pLoopUnit = ::getUnit(pUnitNode->m_data);
				pUnitNode = oldUnits.next(pUnitNode);

				if (pLoopUnit != NULL)
				{
					if (isEnemy(pLoopUnit->getTeam(), pNewPlot) || pLoopUnit->isEnemy(getTeam()))
					{
						if (!pLoopUnit->canCoexistWithEnemyUnit(getTeam()))
						{
							if (NO_UNITCLASS == pLoopUnit->getUnitInfo().getUnitCaptureClassType() && pLoopUnit->canDefend(pNewPlot))
							{

//FfH: Modified by Kael 12/30/2008
//								pLoopUnit->jumpToNearestValidPlot(); // can kill unit
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**			Clears a glitch with moving onto a tile you couldn't see before the move			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
								if (!isInvisible(pLoopUnit->getTeam(), false))
								{
									pLoopUnit->jumpToNearestValidPlot(); // can kill unit
								}
/**								----  End Original Code  ----									**/
								pNewPlot->changeAdjacentSight(getTeam(), visibilityRange(), true, this, true);

/*************************************************************************************************/
/**	Tweak					 	   10/04/10									Snarko				**/
/**																								**/
/**				This should check the plot we're moving into, not the plot we're on				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
								if (!isInvisible(pLoopUnit->getTeam(), false))
/**								----  End Original Code  ----									**/
								if (!isInvisible(pLoopUnit->getTeam(), pNewPlot))
/*************************************************************************************************/
/**	Tweak								END														**/
/*************************************************************************************************/
								{
									pLoopUnit->jumpToNearestValidPlot(); // can kill unit
								}
								pNewPlot->changeAdjacentSight(getTeam(), visibilityRange(), false, this, true);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
//FfH: End Modify

							}
							else
							{

//FfH Hidden Nationality: Modified by Kael 08/27/2007
//								if (!m_pUnitInfo->isHiddenNationality() && !pLoopUnit->getUnitInfo().isHiddenNationality())
								if (!isHiddenNationality() && !pLoopUnit->isHiddenNationality())
//FfH: End Modify

								{
/*************************************************************************************************/
/**	Xienwolf Tweak							03/27/09											**/
/**																								**/
/**							War Weariness from Fireballs makes no sense							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
									GET_TEAM(pLoopUnit->getTeam()).changeWarWeariness(getTeam(), *pNewPlot, GC.getDefineINT("WW_UNIT_CAPTURED"));
									GET_TEAM(getTeam()).changeWarWeariness(pLoopUnit->getTeam(), *pNewPlot, GC.getDefineINT("WW_CAPTURED_UNIT"));
									GET_TEAM(getTeam()).AI_changeWarSuccess(pLoopUnit->getTeam(), GC.getDefineINT("WAR_SUCCESS_UNIT_CAPTURING"));
/**								----  End Original Code  ----									**/
									if (getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL") && pLoopUnit->getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL"))
									{
										GET_TEAM(pLoopUnit->getTeam()).changeWarWeariness(getTeam(), *pNewPlot, GC.getDefineINT("WW_UNIT_CAPTURED"));
										GET_TEAM(getTeam()).changeWarWeariness(pLoopUnit->getTeam(), *pNewPlot, GC.getDefineINT("WW_CAPTURED_UNIT"));
										GET_TEAM(getTeam()).AI_changeWarSuccess(pLoopUnit->getTeam(), GC.getDefineINT("WAR_SUCCESS_UNIT_CAPTURING"));
									}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
								}

//FfH: Modified by Kael 12/30/2207
//								if (!isNoCapture())
//								{
//									pLoopUnit->setCapturingPlayer(getOwnerINLINE());
//								}
								if (!isCannotCapture(true) || GC.getUnitInfo((UnitTypes)pLoopUnit->getUnitType()).getEquipmentPromotion() != NO_PROMOTION)
								{
									if (!pLoopUnit->isHiddenNationality())
									{
										pLoopUnit->setCapturingPlayer(getOwnerINLINE());
									}
								}
//FfH: End Modify
								if (pLoopUnit->getUnitType() != GC.getDefineINT("EQUIPMENT_HOLDER"))
								{
									pLoopUnit->kill(false, getOwnerINLINE());
								}
							}
						}
					}
				}
			}
		}

		if (pNewPlot->isGoody(getTeam()))
		{
			GET_PLAYER(getOwnerINLINE()).doGoody(pNewPlot, this);
		}
	}

	pOldPlot = plot();

	if (pOldPlot != NULL)
	{
		pOldPlot->removeUnit(this, bUpdate && !hasCargo());

		pOldPlot->changeAdjacentSight(getTeam(), visibilityRange(), false, this, true);

		pOldPlot->area()->changeUnitsPerPlayer(getOwnerINLINE(), -1);
/*************************************************************************************************/
/**	PromotionPower						12/13/08									Xienwolf	**/
/**				Adjusts Player Military Might by promotions to reflect true strength			**/
/**						Tracks presence of Units & Promotions on Tiles							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		pOldPlot->area()->changePower(getOwnerINLINE(), -(m_pUnitInfo->getPowerValue()));
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		pOldPlot->area()->changePower(getOwnerINLINE(), -(m_pUnitInfo->getPowerValue() * (getPowerValue()/100)));
/**								----  End Original Code  ----									**/
		pOldPlot->area()->changePower(getOwnerINLINE(), -(getPower()));
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	PromotionPower							END													**/
/*************************************************************************************************/

		if (AI_getUnitAIType() != NO_UNITAI)
		{
			pOldPlot->area()->changeNumAIUnits(getOwnerINLINE(), AI_getUnitAIType(), -1);
		}

		if (isAnimal())
		{
			pOldPlot->area()->changeAnimalsPerPlayer(getOwnerINLINE(), -1);
		}

/*************************************************************************************************/
/**	MilSupport							12/13/08									Xienwolf	**/
/**																								**/
/**				Prevents charging of Supply Costs for non-supported units out of borders		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (pOldPlot->getTeam() != getTeam() && (pOldPlot->getTeam() == NO_TEAM || !GET_TEAM(pOldPlot->getTeam()).isVassal(getTeam())))
/**								----  End Original Code  ----									**/
		if (pOldPlot->getTeam() != getTeam() && !isNoSupply() && (pOldPlot->getTeam() == NO_TEAM || !GET_TEAM(pOldPlot->getTeam()).isVassal(getTeam())))
/*************************************************************************************************/
/**	MilSupport								END													**/
/*************************************************************************************************/
		{
			GET_PLAYER(getOwnerINLINE()).changeNumOutsideUnits(-1);
		}

		setLastMoveTurn(GC.getGameINLINE().getTurnSlice());

		pOldCity = pOldPlot->getPlotCity();

		if (pOldCity != NULL)
		{
			if (isMilitaryHappiness())
			{
				pOldCity->changeMilitaryHappinessUnits(-1);
			}
		}

/*************************************************************************************************/
/**	People's Choice							07/23/08								Xienwolf	**/
/**																								**/
/**								Clears Modifiers from Previous Turn								**/
/*************************************************************************************************/
		applyCityBonusEffects(false, false);
/*************************************************************************************************/
/**	People's Choice							END													**/
/*************************************************************************************************/
		pWorkingCity = pOldPlot->getWorkingCity();

		if (pWorkingCity != NULL)
		{
			if (canSiege(pWorkingCity->getTeam()))
			{
				pWorkingCity->AI_setAssignWorkDirty(true);
			}
		}

		if (pOldPlot->isWater())
		{
			for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
			{
				pLoopPlot = plotDirection(pOldPlot->getX_INLINE(), pOldPlot->getY_INLINE(), ((DirectionTypes)iI));

				if (pLoopPlot != NULL)
				{
					if (pLoopPlot->isWater())
					{
						pWorkingCity = pLoopPlot->getWorkingCity();

						if (pWorkingCity != NULL)
						{
							if (canSiege(pWorkingCity->getTeam()))
							{
								pWorkingCity->AI_setAssignWorkDirty(true);
							}
						}
					}
				}
			}
		}

		if (pOldPlot->isActiveVisible(true))
		{
			pOldPlot->updateMinimapColor();
		}

		if (pOldPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->verifyPlotListColumn();

			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}

	if (pNewPlot != NULL)
	{
		m_iX = pNewPlot->getX_INLINE();
		m_iY = pNewPlot->getY_INLINE();
	}
	else
	{
		m_iX = INVALID_PLOT_COORD;
		m_iY = INVALID_PLOT_COORD;
	}

	FAssertMsg(plot() == pNewPlot, "plot is expected to equal pNewPlot");

/*************************************************************************************************/
/**	CommandingPresence						06/30/09								Xienwolf	**/
/**				Needs to run AFTER assigning new plot for Cascade Effect of Promotions			**/
/**					Enforces Range restriction of Command Promotions							**/
/*************************************************************************************************/
	validateCommandPromotions(pOldPlot, pNewPlot);
/*************************************************************************************************/
/**	CommandingPresence						END													**/
/*************************************************************************************************/
	if (pNewPlot != NULL)
	{
		pNewCity = pNewPlot->getPlotCity();

		if (pNewCity != NULL)
		{
/*************************************************************************************************/
/**	InvisAlign								04/04/09								Xienwolf	**/
/**																								**/
/**					Invisible Units and other oddities can take undefended cities				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			if (isEnemy(pNewCity->getTeam()) && !canCoexistWithEnemyUnit(pNewCity->getTeam()) && canFight())
/**								----  End Original Code  ----									**/
			if (isEnemy(pNewCity->getTeam()) && pNewPlot->getNumVisibleEnemyDefenders(this) == 0 && canFight())
/*************************************************************************************************/
/**	InvisAlign								END													**/
/*************************************************************************************************/
			{
				GET_TEAM(getTeam()).changeWarWeariness(pNewCity->getTeam(), *pNewPlot, GC.getDefineINT("WW_CAPTURED_CITY"));
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      06/14/09                                jdog5000      */
/*                                                                                              */
/* General AI                                                                                   */
/************************************************************************************************/
/* original bts code
				GET_TEAM(getTeam()).AI_changeWarSuccess(pNewCity->getTeam(), GC.getDefineINT("WAR_SUCCESS_CITY_CAPTURING"));
*/
				// Double war success if capturing capital city, always a significant blow to enemy
				// pNewCity still points to old city here, hasn't been acquired yet
				GET_TEAM(getTeam()).AI_changeWarSuccess(pNewCity->getTeam(), (pNewCity->isCapital() ? 2 : 1)*GC.getWAR_SUCCESS_CITY_CAPTURING());
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/

				PlayerTypes eNewOwner = GET_PLAYER(getOwnerINLINE()).pickConqueredCityOwner(*pNewCity);

				if (NO_PLAYER != eNewOwner)
				{
					GET_PLAYER(eNewOwner).acquireCity(pNewCity, true, false, true); // will delete the pointer
					pNewCity = NULL;
				}
			}
		}

		//update facing direction
		if(pOldPlot != NULL)
		{
			DirectionTypes newDirection = estimateDirection(pOldPlot, pNewPlot);
			if(newDirection != NO_DIRECTION)
				m_eFacingDirection = newDirection;
		}

		//update cargo mission animations
		if (isCargo())
		{
			if (eOldActivityType != ACTIVITY_MISSION)
			{
				getGroup()->setActivityType(eOldActivityType);
			}
		}

		setFortifyTurns(0);

		pNewPlot->changeAdjacentSight(getTeam(), visibilityRange(), true, this, true); // needs to be here so that the square is considered visible when we move into it...
		pNewPlot->addUnit(this, bUpdate && !hasCargo());

		pNewPlot->area()->changeUnitsPerPlayer(getOwnerINLINE(), 1);
/*************************************************************************************************/
/**	PromotionPower						12/13/08									Xienwolf	**/
/**																								**/
/**				Adjusts Player Military Might by promotions to reflect true strength			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		pNewPlot->area()->changePower(getOwnerINLINE(), m_pUnitInfo->getPowerValue());
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		pNewPlot->area()->changePower(getOwnerINLINE(), m_pUnitInfo->getPowerValue() * (getPowerValue()/100));
/**								----  End Original Code  ----									**/
		pNewPlot->area()->changePower(getOwnerINLINE(), getPower());
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	PromotionPower							END													**/
/*************************************************************************************************/

		if (AI_getUnitAIType() != NO_UNITAI)
		{
			pNewPlot->area()->changeNumAIUnits(getOwnerINLINE(), AI_getUnitAIType(), 1);
		}

		if (isAnimal())
		{
			pNewPlot->area()->changeAnimalsPerPlayer(getOwnerINLINE(), 1);
		}

/*************************************************************************************************/
/**	MilSupport							12/13/08									Xienwolf	**/
/**																								**/
/**				Prevents charging of Supply Costs for non-supported units out of borders		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (pNewPlot->getTeam() != getTeam() && (pNewPlot->getTeam() == NO_TEAM || !GET_TEAM(pNewPlot->getTeam()).isVassal(getTeam())))
/**								----  End Original Code  ----									**/
		if (pNewPlot->getTeam() != getTeam() && !isNoSupply() && (pNewPlot->getTeam() == NO_TEAM || !GET_TEAM(pNewPlot->getTeam()).isVassal(getTeam())))
/*************************************************************************************************/
/**	MilSupport								END													**/
/*************************************************************************************************/
		{

//FfH: Modified by Kael 04/19/2009
//			GET_PLAYER(getOwnerINLINE()).changeNumOutsideUnits(1);
			if (getDuration() == 0)
			{
				GET_PLAYER(getOwnerINLINE()).changeNumOutsideUnits(1);
			}
//FfH: End Modify

		}

		if (shouldLoadOnMove(pNewPlot))
		{
			load();
		}

		for (iI = 0; iI < MAX_CIV_TEAMS; iI++)
		{
			if (GET_TEAM((TeamTypes)iI).isAlive())
			{
/*************************************************************************************************/
/**	Xienwolf Tweak							12/13/08											**/
/**																								**/
/**					Prevents Civ contact with HN units, only effective one-way however			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				if (!isInvisible(((TeamTypes)iI), false))
/**								----  End Original Code  ----									**/
				if (!isInvisible(((TeamTypes)iI), false) && !isHiddenNationality())
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
				{
					if (pNewPlot->isVisible((TeamTypes)iI, false))
					{
						GET_TEAM((TeamTypes)iI).meet(getTeam(), true);
					}
				}
			}
		}

		pNewCity = pNewPlot->getPlotCity();

		if (pNewCity != NULL)
		{
			if (isMilitaryHappiness())
			{
				pNewCity->changeMilitaryHappinessUnits(1);
			}
		}
/*************************************************************************************************/
/**	People's Choice							07/23/08								Xienwolf	**/
/**																								**/
/**						Modifies City Status upon Flagged Unit Entry							**/
/*************************************************************************************************/
		applyCityBonusEffects(true, false);
/*************************************************************************************************/
/**	People's Choice							END													**/
/*************************************************************************************************/

		pWorkingCity = pNewPlot->getWorkingCity();

		if (pWorkingCity != NULL)
		{
			if (canSiege(pWorkingCity->getTeam()))
			{
				pWorkingCity->verifyWorkingPlot(pWorkingCity->getCityPlotIndex(pNewPlot));
			}
		}

		if (pNewPlot->isWater())
		{
			for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
			{
				pLoopPlot = plotDirection(pNewPlot->getX_INLINE(), pNewPlot->getY_INLINE(), ((DirectionTypes)iI));

				if (pLoopPlot != NULL)
				{
					if (pLoopPlot->isWater())
					{
						pWorkingCity = pLoopPlot->getWorkingCity();

						if (pWorkingCity != NULL)
						{
							if (canSiege(pWorkingCity->getTeam()))
							{
								pWorkingCity->verifyWorkingPlot(pWorkingCity->getCityPlotIndex(pLoopPlot));
							}
						}
					}
				}
			}
		}

		if (pNewPlot->isActiveVisible(true))
		{
			pNewPlot->updateMinimapColor();
		}

		if (GC.IsGraphicsInitialized())
		{
			//override bShow if check plot visible
			if(bCheckPlotVisible && pNewPlot->isVisibleToWatchingHuman())
				bShow = true;

			if (bShow)
			{
				QueueMove(pNewPlot);
			}
			else
			{
				SetPosition(pNewPlot);
			}
		}

		if (pNewPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->verifyPlotListColumn();

			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}

	if (pOldPlot != NULL)
	{
		if (hasCargo())
		{
			pUnitNode = pOldPlot->headUnitNode();

			while (pUnitNode != NULL)
			{
				pLoopUnit = ::getUnit(pUnitNode->m_data);
				pUnitNode = pOldPlot->nextUnitNode(pUnitNode);

				if (pLoopUnit->getTransportUnit() == this)
				{
					pLoopUnit->setXY(iX, iY, bGroup, false);
				}
			}
		}
	}

	if (bUpdate && hasCargo())
	{
		if (pOldPlot != NULL)
		{
			pOldPlot->updateCenterUnit();
			pOldPlot->setFlagDirty(true);
		}

		if (pNewPlot != NULL)
		{
			pNewPlot->updateCenterUnit();
			pNewPlot->setFlagDirty(true);
		}
	}
//FfH Units: Added by Kael 11/10/2008
	if (pNewPlot != NULL)
	{
		int iImprovement = pNewPlot->getImprovementType();
		if (iImprovement != NO_IMPROVEMENT)
		{
			if (GC.getImprovementInfo((ImprovementTypes)iImprovement).getSpawnUnitType() != NO_UNIT)
			{
/*************************************************************************************************/
/**	MultiBarb							12/23/08									Xienwolf	**/
/**					Do not want the AI to Autodestroy Permanent Lairs							**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				if (!isHuman() || GC.getImprovementInfo((ImprovementTypes)iImprovement).isPermanent() == false)
				{
					if (atWar(getTeam(), GET_PLAYER(BARBARIAN_PLAYER).getTeam()))
/**								----  End Original Code  ----									**/
				if (!GC.getImprovementInfo((ImprovementTypes)iImprovement).isPermanent())
				{
					bool bValid = false;
					if (GC.getImprovementInfo((ImprovementTypes)iImprovement).getSpawnUnitCiv() == GC.getDefineINT("ANIMAL_CIVILIZATION") && atWar(getTeam(), GET_PLAYER(ANIMAL_PLAYER).getTeam()))
					{
						bValid = true;
					}
					else if (GC.getImprovementInfo((ImprovementTypes)iImprovement).getSpawnUnitCiv() == GC.getDefineINT("DEMON_CIVILIZATION") && atWar(getTeam(), GET_PLAYER(DEMON_PLAYER).getTeam()))
					{
						bValid = true;
					}
					else if (GC.getImprovementInfo((ImprovementTypes)iImprovement).getSpawnUnitCiv() == GC.getDefineINT("ORC_CIVILIZATION") && atWar(getTeam(), GET_PLAYER(ORC_PLAYER).getTeam()))
					{
						bValid = true;
					}
					if (bValid)
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
					{
						if (isHuman())
						{
							gDLL->getInterfaceIFace()->addMessage(getOwner(), false, GC.getDefineINT("EVENT_MESSAGE_TIME"), gDLL->getText("TXT_KEY_MESSAGE_LAIR_DESTROYED"), "AS2D_CITYRAZE", MESSAGE_TYPE_MAJOR_EVENT, GC.getImprovementInfo((ImprovementTypes)iImprovement).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pNewPlot->getX(), pNewPlot->getY(), true, true);
						}
						pNewPlot->setImprovementType(NO_IMPROVEMENT);
					}
				}
			}
		}
		iImprovement = pNewPlot->getImprovementType(); // rechecking because the previous function may have deleted the improvement
		if (iImprovement != NO_IMPROVEMENT)
		{
			if (!CvString(GC.getImprovementInfo((ImprovementTypes)iImprovement).getPythonOnMove()).empty())
			{
				if (pNewPlot->isPythonActive())
				{
					CyUnit* pyUnit = new CyUnit(this);
					CyPlot* pyPlot = new CyPlot(pNewPlot);
					CyArgsList argsList;
					argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
					argsList.add(gDLL->getPythonIFace()->makePythonObject(pyPlot));	// pass in plot class
					argsList.add(iImprovement);//the promotion #
					gDLL->getPythonIFace()->callFunction(PYSpellModule, "onMove", argsList.makeFunctionArgs()); //, &lResult
					delete pyUnit; // python fxn must not hold on to this pointer
					delete pyPlot;	// python fxn must not hold on to this pointer
				}
			}
		}
		for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
		{
			pLoopPlot = plotDirection(pNewPlot->getX_INLINE(), pNewPlot->getY_INLINE(), ((DirectionTypes)iI));
			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
				{
					if (!CvString(GC.getImprovementInfo((ImprovementTypes)pLoopPlot->getImprovementType()).getPythonAtRange()).empty())
					{
						if (pLoopPlot->isPythonActive())
						{
							CyUnit* pyUnit = new CyUnit(this);
							CyPlot* pyPlot = new CyPlot(pLoopPlot);
							CyArgsList argsList;
							argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
							argsList.add(gDLL->getPythonIFace()->makePythonObject(pyPlot));	// pass in plot class
							argsList.add(pLoopPlot->getImprovementType());
							gDLL->getPythonIFace()->callFunction(PYSpellModule, "atRange", argsList.makeFunctionArgs()); //, &lResult
							delete pyUnit; // python fxn must not hold on to this pointer
							delete pyPlot;	// python fxn must not hold on to this pointer
						}
					}
				}
			}
		}
		if (pNewPlot->getFeatureType() != NO_FEATURE)
		{
			if (!CvString(GC.getFeatureInfo((FeatureTypes)pNewPlot->getFeatureType()).getPythonOnMove()).empty())
			{
				CyUnit* pyUnit = new CyUnit(this);
				CyPlot* pyPlot = new CyPlot(pNewPlot);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyPlot));	// pass in plot class
				argsList.add(pNewPlot->getFeatureType());
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "onMoveFeature", argsList.makeFunctionArgs()); //, &lResult
				delete pyUnit; // python fxn must not hold on to this pointer
				delete pyPlot;	// python fxn must not hold on to this pointer
			}
		}
		if (pNewPlot->getPlotEffectType() != NO_PLOT_EFFECT)
		{
			if (!CvString(GC.getPlotEffectInfo((PlotEffectTypes)pNewPlot->getPlotEffectType()).getPythonOnMove()).empty())
			{
				CyUnit* pyUnit = new CyUnit(this);
				CyPlot* pyPlot = new CyPlot(pNewPlot);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyPlot));	// pass in plot class
				argsList.add(pNewPlot->getFeatureType());
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "onMovePlotEffect", argsList.makeFunctionArgs()); //, &lResult
				delete pyUnit; // python fxn must not hold on to this pointer
				delete pyPlot;	// python fxn must not hold on to this pointer
			}
		}
		if (isMustDie())
		{
			return;
		}
/*************************************************************************************************/
/**	Xienwolf Tweak							10/03/08											**/
/**																								**/
/**						No longer need the DLL to directly handle Weapon upgrades				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (pNewPlot->isCity() && m_pUnitInfo->getWeaponTier() > 0)
		{
			if (getOwner() == pNewPlot->getOwner())
			{
				setWeapons();
			}
		}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	SelfPillage 							05/15/08								Xienwolf	**/
/**				Makes a Unit automatically Pillage in Team controlled or Neutral Territory		**/
/**					Demotes Improvements along Pillage Tree, then Takes out Routes				**/
/*************************************************************************************************/
		if (isSelfPillage())
		{
			if (!(pNewPlot->isOwned()) || getTeam() == pNewPlot->getTeam())
			{
				CvWString szBuffer;
				ImprovementTypes eTempImprovement = NO_IMPROVEMENT;
				RouteTypes eTempRoute = NO_ROUTE;

				if (pNewPlot->getImprovementType() != NO_IMPROVEMENT)
				{
					if (!GC.getImprovementInfo((ImprovementTypes)pNewPlot->getImprovementType()).isPermanent())
					{
						eTempImprovement = pNewPlot->getImprovementType();
						szBuffer = gDLL->getText("TXT_KEY_MISC_IMP_DESTROYED", GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide(), getNameKey(), getVisualCivAdjective(pNewPlot->getTeam()));
						gDLL->getInterfaceIFace()->addMessage(pNewPlot->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pNewPlot->getX_INLINE(), pNewPlot->getY_INLINE(), true, true);
						pNewPlot->setImprovementType((ImprovementTypes)(GC.getImprovementInfo(pNewPlot->getImprovementType()).getImprovementPillage()));
					}
				}
				else if (pNewPlot->isRoute())
				{
					eTempRoute = pNewPlot->getRouteType();
					pNewPlot->setRouteType(NO_ROUTE, true);
				}
				if (eTempImprovement != NO_IMPROVEMENT || eTempRoute != NO_ROUTE)
				{
					CvEventReporter::getInstance().unitPillage(this, eTempImprovement, eTempRoute, getOwnerINLINE());
				}
			}
		}
/*************************************************************************************************/
/**	SelfPillage 								END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	AutoPillage 							05/15/08								Xienwolf	**/
/**																								**/
/**						Adds new Promotion Tag check to the old Unit Tag Check					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (m_pUnitInfo->isAutoRaze())
/**								----  End Original Code  ----									**/
		if (m_pUnitInfo->isAutoRaze() || isPillageOnMove())
/*************************************************************************************************/
/**	AutoPillage 								END												**/
/*************************************************************************************************/
		{
			if (pNewPlot->isOwned())
			{
				if (pNewPlot->getImprovementType() != NO_IMPROVEMENT)
				{
					if (!GC.getImprovementInfo((ImprovementTypes)pNewPlot->getImprovementType()).isPermanent())
					{
						if (atWar(getTeam(), GET_PLAYER(pNewPlot->getOwner()).getTeam()))
						{
/*************************************************************************************************/
/**	AutoPillage 							05/15/08								Xienwolf	**/
/**					Lots of Code here to change from the Old "No Cash, Full Destroy"			**/
/**					to the new "Pillage without Spending Movement or getting a choice"			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
							pNewPlot->setImprovementType(NO_IMPROVEMENT);
/**								----  End Original Code  ----									**/
							CvWString szBuffer;
							int iPillageGold;
							long lPillageGold;
							lPillageGold = 0;

							CyPlot* pyPlot = new CyPlot(pNewPlot);
							CyUnit* pyUnit = new CyUnit(this);

							CyArgsList argsList;
							argsList.add(gDLL->getPythonIFace()->makePythonObject(pyPlot));	// pass in plot class
							argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class

							gDLL->getPythonIFace()->callFunction(PYGameModule, "doPillageGold", argsList.makeFunctionArgs(),&lPillageGold);

							delete pyPlot;	// python fxn must not hold on to this pointer
							delete pyUnit;	// python fxn must not hold on to this pointer

							iPillageGold = (int)lPillageGold;

							if (iPillageGold > 0)
							{
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
								float fInfluenceRatio = 0.0f;
								if (atWar(pNewPlot->getTeam(), getTeam()))
								{
									if (pNewPlot->canBeInfluenced())
									{
										fInfluenceRatio = doPillageInfluence();
									}
								}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

								iPillageGold += (iPillageGold * GET_PLAYER(getOwnerINLINE()).getPillagingGold()) / 100;

								GET_PLAYER(getOwnerINLINE()).changeGold(iPillageGold);

								szBuffer = gDLL->getText("TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP", iPillageGold, GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide());
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
								if (fInfluenceRatio > 0.0f)
								{
									CvWString szInfluence;
									szInfluence.Format(L" Tile influence: +%.1f%%", fInfluenceRatio);
									szBuffer += szInfluence;
								}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
								gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pNewPlot->getX_INLINE(), pNewPlot->getY_INLINE());

								if (pNewPlot->isOwned())
								{
									szBuffer = gDLL->getText("TXT_KEY_MISC_IMP_DESTROYED", GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide(), getNameKey(), getVisualCivAdjective(pNewPlot->getTeam()));
/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
									if (fInfluenceRatio > 0.0f)
									{
										CvWString szInfluence;
										szInfluence.Format(L" Tile influence: -%.1f%%", fInfluenceRatio);
										szBuffer += szInfluence;
									}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
									gDLL->getInterfaceIFace()->addMessage(pNewPlot->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pNewPlot->getX_INLINE(), pNewPlot->getY_INLINE(), true, true);
								}
								CvEventReporter::getInstance().unitPillage(this, pNewPlot->getImprovementType(), NO_ROUTE, getOwnerINLINE());
								pNewPlot->setImprovementType((ImprovementTypes)(GC.getImprovementInfo(pNewPlot->getImprovementType()).getImprovementPillage()));
							}
/*************************************************************************************************/
/**	AutoPillage 								END												**/
/*************************************************************************************************/
						}
					}
				}
			}
/*************************************************************************************************/
/**	AutoPillage 							05/15/08								Xienwolf	**/
/**																								**/
/**					Allows Unit Tag to destroy Features as well as Pillage Improvements			**/
/*************************************************************************************************/
		}
		if (m_pUnitInfo->isAutoRaze())
		{
/*************************************************************************************************/
/**	AutoPillage 								END												**/
/*************************************************************************************************/
			pNewPlot->setFeatureType(NO_FEATURE, -1);
		}
	}
//FfH: End Add

/*************************************************************************************************/
/**	AutoBots								07/16/08								Xienwolf	**/
/**		Automatically applies/removes a Promotion when Unit meets conditions after moving		**/
/**					Wakes exploring units when they move onto an explorable tile				**/
/*************************************************************************************************/
	if (pNewPlot != NULL)
	{
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (isHasPromotion((PromotionTypes)iI))
			{
				if (isHasPromotion((PromotionTypes)iI) && GC.getPromotionInfo((PromotionTypes)iI).isMustMaintain() && !canAcquirePromotion((PromotionTypes)iI,true) && !m_pUnitInfo->getFreePromotions(iI))
				{
					for(int k=0;k<countHasPromotion((PromotionTypes)iI);++k)
					{
						setHasPromotion(((PromotionTypes)iI), false);
					}
				}
			}

			if (GC.getPromotionInfo((PromotionTypes)iI).isAutoAcquire() && canPromote((PromotionTypes)iI, -1))
			{
				promote(((PromotionTypes)iI), -1);
			}
		}
		if (pNewPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (GC.getImprovementInfo((ImprovementTypes)pNewPlot->getImprovementType()).isExplorable())
			{
				if (getGroup() != NULL && getGroup()->getAutomateType() == AUTOMATE_EXPLORE)
				{
					getGroup()->setAutomateType(NO_AUTOMATE);
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR				26/10/12								Snarko			**/
/**																								**/
/**						No longer needed with exploring lairs now being a mission.				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
					if (!isHuman())
					{
						chooseSpell();
					}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	MISSION_EXPLORE_LAIR					END													**/
/*************************************************************************************************/
				}
			}
		}
	}
/*************************************************************************************************/
/**	AutoBots									END												**/
/*************************************************************************************************/
	FAssert(pOldPlot != pNewPlot);
	GET_PLAYER(getOwnerINLINE()).updateGroupCycle(this);

	setInfoBarDirty(true);

	if (IsSelected())
	{
		if (isFound())
		{
			gDLL->getInterfaceIFace()->setDirty(GlobeLayer_DIRTY_BIT, true);
			gDLL->getEngineIFace()->updateFoundingBorder();
		}

		gDLL->getInterfaceIFace()->setDirty(ColoredPlots_DIRTY_BIT, true);
	}

	//update glow
	if (pNewPlot != NULL)
	{
		gDLL->getEntityIFace()->updateEnemyGlow(getUnitEntity());
	}

	// report event to Python, along with some other key state

//FfH: Modified by Kael 10/15/2008
//	CvEventReporter::getInstance().unitSetXY(pNewPlot, this);
	if(GC.getUSE_ON_UNIT_MOVE_CALLBACK())
	{
		CvEventReporter::getInstance().unitSetXY(pNewPlot, this);
	}
//FfH: End Modify

}


bool CvUnit::at(int iX, int iY) const
{
	return((getX_INLINE() == iX) && (getY_INLINE() == iY));
}


bool CvUnit::atPlot(const CvPlot* pPlot) const
{
	return (plot() == pPlot);
}


CvPlot* CvUnit::plot() const
{
	return GC.getMapINLINE().plotSorenINLINE(getX_INLINE(), getY_INLINE());
}


int CvUnit::getArea() const
{
	return plot()->getArea();
}


CvArea* CvUnit::area() const
{
	return plot()->area();
}


bool CvUnit::onMap() const
{
	return (plot() != NULL);
}


int CvUnit::getLastMoveTurn() const
{
	return m_iLastMoveTurn;
}


void CvUnit::setLastMoveTurn(int iNewValue)
{
	m_iLastMoveTurn = iNewValue;
	FAssert(getLastMoveTurn() >= 0);
}


CvPlot* CvUnit::getReconPlot() const
{
	return GC.getMapINLINE().plotSorenINLINE(m_iReconX, m_iReconY);
}


void CvUnit::setReconPlot(CvPlot* pNewValue)
{
	CvPlot* pOldPlot = getReconPlot();

	if (pOldPlot == pNewValue)
		return;

	if (pOldPlot != NULL)
	{
		pOldPlot->changeAdjacentSight(getTeam(), GC.getDefineINT("RECON_VISIBILITY_RANGE"), false, this, true);
	}

	if (pNewValue == NULL)
	{
		m_iReconX = INVALID_PLOT_COORD;
		m_iReconY = INVALID_PLOT_COORD;
	}
	else
	{
		m_iReconX = pNewValue->getX_INLINE();
		m_iReconY = pNewValue->getY_INLINE();

		pNewValue->changeAdjacentSight(getTeam(), GC.getDefineINT("RECON_VISIBILITY_RANGE"), true, this, true);
	}
}


int CvUnit::getGameTurnCreated() const
{
	return m_iGameTurnCreated;
}


void CvUnit::setGameTurnCreated(int iNewValue)
{
	m_iGameTurnCreated = iNewValue;
	FAssert(getGameTurnCreated() >= 0);
}

// Returns true damage (default 1000 hp scale)
int CvUnit::getDamageReal() const
{
	return m_iDamage;
}

// Set true damage (default 1000 hp scale), kills if damage > max_hp
void CvUnit::setDamageReal(int iNewValue, PlayerTypes ePlayer, bool bNotifyEntity)
{
	int iOldValue;

	iOldValue = getDamageReal();

	m_iDamage = range(iNewValue, 0, maxHitPoints());

	FAssertMsg(currHitPoints() >= 0, "currHitPoints() is expected to be non-negative (invalid Index)");

	if (iOldValue != getDamageReal())
	{
		if (GC.getGameINLINE().isFinalInitialized() && bNotifyEntity)
			NotifyEntity(MISSION_DAMAGE);

		setInfoBarDirty(true);

		if (IsSelected())
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);

		if (plot() == gDLL->getInterfaceIFace()->getSelectionPlot())
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
	}

	if (isDead())
		kill(true, ePlayer);
}

// change HP by true damage (default 1000 hp scale). Will kill(true) if damage > max hp
void CvUnit::changeDamageReal(int iChange, PlayerTypes ePlayer)
{
	setDamageReal((getDamageReal() + iChange), ePlayer);
}

// Returns damage rounded down to nearest whole percent
int CvUnit::getDamage() const
{
	return getDamageReal() / GC.getDefineINT("HIT_POINT_FACTOR");
}

// Set damage to flat 1-100 percent
void CvUnit::setDamage(int iNewValue, PlayerTypes ePlayer, bool bNotifyEntity)
{
	iNewValue *= GC.getDefineINT("HIT_POINT_FACTOR");
	setDamageReal(iNewValue, ePlayer, bNotifyEntity);
}

// Change hp by a flat 1-100 percent. Will kill(true) if damage > max hp
void CvUnit::changeDamage(int iChange, PlayerTypes ePlayer)
{
	setDamageReal((getDamageReal() + iChange * GC.getDefineINT("HIT_POINT_FACTOR")), ePlayer);
}


int CvUnit::getMoves() const
{
	return m_iMoves;
}


void CvUnit::setMoves(int iNewValue)
{
	CvPlot* pPlot;

	if (getMoves() != iNewValue)
	{
		pPlot = plot();

		m_iMoves = iNewValue;

		FAssert(getMoves() >= 0);

		if (getTeam() == GC.getGameINLINE().getActiveTeam())
		{
			if (pPlot != NULL)
			{
				pPlot->setFlagDirty(true);
			}
		}

		if (IsSelected())
		{
			gDLL->getFAStarIFace()->ForceReset(&GC.getInterfacePathFinder());

			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}

		if (pPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}
}


void CvUnit::changeMoves(int iChange)
{
	setMoves(getMoves() + iChange);
}


void CvUnit::finishMoves()
{
	setMoves(maxMoves());
}


int CvUnit::getExperience() const
{
	return m_iExperience;
}

void CvUnit::setExperience(int iNewValue, int iMax)
{
	if ((getExperience() != iNewValue) && (getExperience() < ((iMax == -1) ? MAX_INT : iMax)))
	{
		m_iExperience = std::max(0, std::min(((iMax == -1) ? MAX_INT : iMax), iNewValue));
		FAssert(getExperience() >= 0);

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}

/*************************************************************************************************/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**																								**/
/**				Allows Commanders to gain XP when their Minions take part in battle				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
void CvUnit::changeExperience(int iChange, int iMax, bool bFromCombat, bool bInBorders, bool bUpdateGlobal)
/**								----  End Original Code  ----									**/
void CvUnit::changeExperience(int iChange, int iMax, bool bFromCombat, bool bInBorders, bool bUpdateGlobal, bool bUpdateCommander)
/*************************************************************************************************/
/**	CommandingPresence						END													**/
/*************************************************************************************************/
{
	int iUnitExperience = iChange;

	if (bFromCombat)
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwnerINLINE());

		int iCombatExperienceMod = 100 + kPlayer.getGreatGeneralRateModifier();

		if (bInBorders)
		{
			iCombatExperienceMod += kPlayer.getDomesticGreatGeneralRateModifier() + kPlayer.getExpInBorderModifier();
			iUnitExperience += (iChange * kPlayer.getExpInBorderModifier()) / 100;
		}

		if (bUpdateGlobal)
		{
			kPlayer.changeCombatExperience((iChange * iCombatExperienceMod) / 100);
		}

		if (getExperiencePercent() != 0)
		{
			iUnitExperience *= std::max(0, 100 + getExperiencePercent());
			iUnitExperience /= 100;
		}

//FfH: Added by Kael 05/17/2008
		if (GC.getGameINLINE().isOption(GAMEOPTION_SLOWER_XP))
		{
			iUnitExperience += 1;
			iUnitExperience /= 2;
		}
//FfH: End Add

	}
/*************************************************************************************************/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**																								**/
/**				Allows Commanders to gain XP when their Minions take part in battle				**/
/*************************************************************************************************/
	if (bUpdateCommander)
	{
		if(getCommanderUnit() != NULL)
		{
			int iCommanderXP = (iUnitExperience*getCommanderUnit()->getCommandXPShareRate()) / (abs(getExperience() - getCommanderUnit()->getExperience())/1000 + 1) /100;
			getCommanderUnit()->changeExperience(iCommanderXP, -1, false, false, false, true);
		}
	}
/*************************************************************************************************/
/**	CommandingPresence						END													**/
/*************************************************************************************************/

	setExperience((getExperience() + iUnitExperience), iMax);
}

int CvUnit::getLevel() const
{
	return m_iLevel;
}

void CvUnit::setLevel(int iNewValue)
{
	if (getLevel() != iNewValue)
	{
		m_iLevel = iNewValue;
		FAssert(getLevel() >= 0);

		if (getLevel() > GET_PLAYER(getOwnerINLINE()).getHighestUnitLevel())
		{
			GET_PLAYER(getOwnerINLINE()).setHighestUnitLevel(getLevel());
		}

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}

void CvUnit::changeLevel(int iChange)
{
	setLevel(getLevel() + iChange);
}

int CvUnit::getCargo() const
{
	return m_iCargo;
}

void CvUnit::changeCargo(int iChange)
{
	m_iCargo += iChange;
	FAssert(getCargo() >= 0);
}

void CvUnit::getCargoUnits(std::vector<CvUnit*>& aUnits) const
{
	aUnits.clear();

	if (hasCargo())
	{
		CvPlot* pPlot = plot();
		CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->getTransportUnit() == this)
			{
				aUnits.push_back(pLoopUnit);
			}
		}
	}

	FAssert(getCargo() == aUnits.size());
}

CvPlot* CvUnit::getAttackPlot() const
{
	return GC.getMapINLINE().plotSorenINLINE(m_iAttackPlotX, m_iAttackPlotY);
}


void CvUnit::setAttackPlot(const CvPlot* pNewValue, bool bAirCombat)
{
	if (getAttackPlot() != pNewValue)
	{
		if (pNewValue != NULL)
		{
			m_iAttackPlotX = pNewValue->getX_INLINE();
			m_iAttackPlotY = pNewValue->getY_INLINE();
		}
		else
		{
			m_iAttackPlotX = INVALID_PLOT_COORD;
			m_iAttackPlotY = INVALID_PLOT_COORD;
		}
	}

	m_bAirCombat = bAirCombat;
}

bool CvUnit::isAirCombat() const
{
	return m_bAirCombat;
}

int CvUnit::getCombatTimer() const
{
	return m_iCombatTimer;
}

void CvUnit::setCombatTimer(int iNewValue)
{
	m_iCombatTimer = iNewValue;
	FAssert(getCombatTimer() >= 0);
}

void CvUnit::changeCombatTimer(int iChange)
{
	setCombatTimer(getCombatTimer() + iChange);
}

int CvUnit::getCombatFirstStrikes() const
{
	return m_iCombatFirstStrikes;
}

void CvUnit::setCombatFirstStrikes(int iNewValue)
{
	m_iCombatFirstStrikes = iNewValue;
	FAssert(getCombatFirstStrikes() >= 0);
}

void CvUnit::changeCombatFirstStrikes(int iChange)
{
	setCombatFirstStrikes(getCombatFirstStrikes() + iChange);
}

int CvUnit::getFortifyTurns() const
{
	return m_iFortifyTurns;
}

void CvUnit::setFortifyTurns(int iNewValue)
{
	iNewValue = range(iNewValue, 0, GC.getDefineINT("MAX_FORTIFY_TURNS"));

	if (iNewValue != getFortifyTurns())
	{
		m_iFortifyTurns = iNewValue;
		setInfoBarDirty(true);
	}
}

void CvUnit::changeFortifyTurns(int iChange)
{
	setFortifyTurns(getFortifyTurns() + iChange);
}

int CvUnit::getBlitzCount() const
{
	return m_iBlitzCount;
}

bool CvUnit::isBlitz() const
{
	return (getBlitzCount() > 0);
}

void CvUnit::changeBlitzCount(int iChange)
{
	m_iBlitzCount += iChange;
	FAssert(getBlitzCount() >= 0);
}
int CvUnit::getTradeDefenderCount() const
{
	return m_iTradeDefenderCount;
}

bool CvUnit::isTradeDefender() const
{
	return (getTradeDefenderCount() > 0);
}

void CvUnit::changeTradeDefenderCount(int iChange)
{
	m_iTradeDefenderCount += iChange;
	FAssert(getTradeDefenderCount() >= 0);
}

int CvUnit::getAmphibCount() const
{
	return m_iAmphibCount;
}

bool CvUnit::isAmphib() const
{
	return (getAmphibCount() > 0);
}

void CvUnit::changeAmphibCount(int iChange)
{
	m_iAmphibCount += iChange;
	FAssert(getAmphibCount() >= 0);
}

int CvUnit::getRiverCount() const
{
	return m_iRiverCount;
}

bool CvUnit::isRiver() const
{
	return (getRiverCount() > 0);
}

void CvUnit::changeRiverCount(int iChange)
{
	m_iRiverCount += iChange;
	FAssert(getRiverCount() >= 0);
}

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**	New Tag Defs	(UnitInfos)				05/15/08											**/
/**						Loads & Tracks all Promotion Information for the Unit					**/
/*************************************************************************************************/
bool CvUnit::isRealPromotion(PromotionTypes ePromotion) const
{
	return m_pabRealPromotion[ePromotion];
}
void CvUnit::setRealPromotion(PromotionTypes ePromotion, bool bNewValue)
{
	m_pabRealPromotion[ePromotion] = bNewValue;
}
void CvUnit::validateCommandPromotions(CvPlot* pOldPlot, CvPlot* pNewPlot, int iChange)
{
	CvUnit* pCommander = getCommanderUnit();
	if (pCommander == NULL && getNumMinions() == 0)
	{
		return;
	}
	int iLoop = 0;
	if(pCommander != NULL)
	{
		bool bInRangePre = (pOldPlot == NULL) ? (false) : (plotDistance(pOldPlot->getX_INLINE(), pOldPlot->getY_INLINE(), pCommander->getX_INLINE(), pCommander->getY_INLINE()) <= pCommander->getCommandRange());
		bool bInRangePost = (pNewPlot == NULL) ? (false) : (plotDistance(pNewPlot->getX_INLINE(), pNewPlot->getY_INLINE(), pCommander->getX_INLINE(), pCommander->getY_INLINE()) <= (pCommander->getCommandRange() + iChange));
		if (bInRangePre != bInRangePost)
		{
			for(int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
			{
				CvPromotionInfo &kLoopPromotion = GC.getPromotionInfo((PromotionTypes)iI);
				iLoop = pCommander->countHasPromotion((PromotionTypes)iI);
				for (int iK = 0; iK < iLoop; ++iK)
				{
					for (int iJ = 0; iJ < kLoopPromotion.getNumMinionPromotions(); ++iJ)
					{
						if(isPromotionValid(kLoopPromotion.getMinionPromotion(iJ)))
						{
							changeSupplementalPromotions(kLoopPromotion.getMinionPromotion(iJ), bInRangePost);
						}
					}
				}
				iLoop = countHasPromotion((PromotionTypes)iI);
				for (int iK = 0; iK < iLoop; ++iK)
				{
					for (int iJ = 0; iJ < kLoopPromotion.getNumCommanderPromotions(); ++iJ)
					{
						pCommander->changeSupplementalPromotions(kLoopPromotion.getCommanderPromotion(iJ), bInRangePost);
					}
				}
			}
		}
	}
	for(int iK = 0; iK < getNumMinions(); ++iK)
	{
		CvUnit* pMinion = getMinionUnit(iK);
		bool bInRangePre = (pOldPlot == NULL) ? (false) : (plotDistance(pOldPlot->getX_INLINE(), pOldPlot->getY_INLINE(), pMinion->getX_INLINE(), pMinion->getY_INLINE()) <= getCommandRange());
		bool bInRangePost = (pNewPlot == NULL) ? (false) : (plotDistance(pNewPlot->getX_INLINE(), pNewPlot->getY_INLINE(), pMinion->getX_INLINE(), pMinion->getY_INLINE()) <= (getCommandRange() + iChange));
		if (bInRangePre != bInRangePost)
		{
			for(int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
			{
				CvPromotionInfo &kLoopPromotion = GC.getPromotionInfo((PromotionTypes)iI);
				for (int iK = 0; iK < countHasPromotion((PromotionTypes)iI); ++iK)
				{
					for (int iJ = 0; iJ < kLoopPromotion.getNumMinionPromotions(); ++iJ)
					{
						if(pMinion->isPromotionValid(kLoopPromotion.getMinionPromotion(iJ)))
						{
							pMinion->changeSupplementalPromotions(kLoopPromotion.getMinionPromotion(iJ), bInRangePost);
						}
					}
				}
				for (int iK = 0; iK < pMinion->countHasPromotion((PromotionTypes)iI); ++iK)
				{
					for (int iJ = 0; iJ < kLoopPromotion.getNumCommanderPromotions(); ++iJ)
					{
						changeSupplementalPromotions(kLoopPromotion.getCommanderPromotion(iJ), bInRangePost);
					}
				}
			}
		}
	}
}
int CvUnit::getSupplementalPromotionQuantity(PromotionTypes ePromotion) const
{
	return m_aiSupplementalPromotions[ePromotion];
}
void CvUnit::changeSupplementalPromotions(PromotionTypes ePromotion, bool bNewValue)
{
	int iPre = m_aiSupplementalPromotions[ePromotion];
	m_aiSupplementalPromotions[ePromotion] = std::max(0, m_aiSupplementalPromotions[ePromotion] + (bNewValue ? 1 : -1));
	if( ((m_aiSupplementalPromotions[ePromotion] > 0) != (iPre > 0)) || (GC.getPromotionInfo(ePromotion).isStackEffect() && iPre != m_aiSupplementalPromotions[ePromotion]))
	{
		setHasPromotion(ePromotion, bNewValue);
	}
}

/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	bool CvUnit::isNonInfluence() const
	{
		return m_bNonInfluence;
	}

	bool CvUnit::isInfluence() const
	{
		return m_bInfluence;
	}

	void CvUnit::setNonInfluence(bool bNewValue)
	{
		m_bNonInfluence = bNewValue;
	}

	void CvUnit::setInfluence(bool bNewValue)
	{
		m_bInfluence = bNewValue;
	}

	int CvUnit::getVictoryInfluenceModifier() const
	{
		return m_iVictoryInfluenceModifier;
	}

	void CvUnit::changeVictoryInfluenceModifier(int iChange)
	{
		m_iVictoryInfluenceModifier += iChange;
	}

	int CvUnit::getDefeatInfluenceModifier() const
	{
		return m_iDefeatInfluenceModifier;
	}

	void CvUnit::changeDefeatInfluenceModifier(int iChange)
	{
		m_iDefeatInfluenceModifier += iChange;
	}

	int CvUnit::getPillageInfluenceModifier() const
	{
		return m_iPillageInfluenceModifier;
	}

	void CvUnit::changePillageInfluenceModifier(int iChange)
	{
		m_iPillageInfluenceModifier += iChange;
	}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

int CvUnit::getCommandLimit() const
{
	return m_pUnitInfo->getCommandLimit() + m_iCommandLimit;
}
void CvUnit::changeCommandLimit(int iChange)		//Probably ought to include a function to remove Minions if your Limit is reduced below your current capacity
{
	m_iCommandLimit += iChange;
}
int CvUnit::getCommandRange() const
{
	return m_pUnitInfo->getCommandRange() + m_iCommandRange;
}
void CvUnit::changeCommandRange(int iChange)
{
	if(iChange != 0)
	{
		validateCommandPromotions(plot(), plot(), iChange);
		m_iCommandRange += iChange;
	}
}
int CvUnit::getCommandXPShareRate() const
{
	return GC.getDefineINT("BASE_COMMANDER_XP_SHARE") + m_iCommandXPShareRate;
}
void CvUnit::changeCommandXPShareRate(int iChange)
{
	m_iCommandXPShareRate += iChange;
}
PlayerTypes CvUnit::getPreviousOwner() const
{
	return m_ePreviousOwner;
}
void CvUnit::setPreviousOwner(PlayerTypes eNewValue)
{
	m_ePreviousOwner = eNewValue;
}
int CvUnit::getNumPromotions() const
{
	return m_iNumPromotions;
}
void CvUnit::changeNumPromotions(int iChange)
{
	m_iNumPromotions += iChange;
}
bool CvUnit::isCommunalProperty() const
{
	return (m_pUnitInfo->isCommunalProperty() || m_iCommunalProperty > 0);
}
void CvUnit::changeCommunalProperty(int iChange)
{
	m_iCommunalProperty += iChange;
}
bool CvUnit::isNeverHostile() const
{
	return (m_pUnitInfo->isNeverHostile() || m_iNeverHostile > 0);
}
void CvUnit::changeNeverHostile(int iChange)
{
	m_iNeverHostile += iChange;
}
bool CvUnit::isBlind() const
{
	return (m_pUnitInfo->isBlind() || m_iBlind > 0);
}
void CvUnit::changeBlind(int iChange)
{
	if (iChange != 0)
	{
		plot()->changeAdjacentSight(getTeam(), visibilityRange(), false, this, true);

		m_iBlind += iChange;

		plot()->changeAdjacentSight(getTeam(), visibilityRange(), true, this, true);
	}
}
int CvUnit::getStrBoost() const
{
	return m_iStrBoost;
}
void CvUnit::changeStrBoost(int iChange)
{
	m_iStrBoost += iChange;
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
	calculatePower();
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/

}
bool CvUnit::isFreeUnit() const
{
	return m_pUnitInfo->isFreeUnit() || m_iFreeUnit > 0;
}
void CvUnit::changeFreeUnit(int iChange)
{
	bool bFree = isFreeUnit();
	m_iFreeUnit = (m_iFreeUnit + iChange);
	if (bFree != isFreeUnit())
	{
		GET_PLAYER(getOwner()).changeBaseFreeUnits((bFree ? -1 : 1));
	}
}
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
bool CvUnit::isPromotionBuild() const
{
	return m_pUnitInfo->isPromotionBuild() || m_iPromotionBuild > 0;
}
void CvUnit::setPromotionBuild(int iNewValue)
{
	m_iPromotionBuild = iNewValue;
}
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
bool CvUnit::isNoSupply() const
{
	return m_pUnitInfo->isNoSupply() || m_iNoSupply > 0;
}
void CvUnit::changeNoSupply(int iChange)
{
	bool bFree = isNoSupply();
	m_iNoSupply = (m_iNoSupply + iChange);
	if (bFree != isNoSupply())
	{
		if (plot()->getTeam() != getTeam() && (plot()->getTeam() == NO_TEAM || !GET_TEAM(plot()->getTeam()).isVassal(getTeam())))
		{
			GET_PLAYER(getOwnerINLINE()).changeNumOutsideUnits((bFree ? 1 : -1));
		}
	}
}
bool CvUnit::isCannotCast() const
{
	return m_iCannotCast > 0;
}
void CvUnit::changeCannotCast(int iChange)
{
	m_iCannotCast = (m_iCannotCast + iChange);
}
bool CvUnit::isTerritorial() const
{
	return m_iTerritorial > 0;
}
void CvUnit::changeTerritorial(int iChange)
{
	m_iTerritorial = (m_iTerritorial + iChange);
}
bool CvUnit::isRivalTerritoryExplore() const
{
	return m_iRivalTerritoryExplore > 0;
}
void CvUnit::changeRivalTerritoryExplore(int iChange)
{
	m_iRivalTerritoryExplore = (m_iRivalTerritoryExplore + iChange);
}
bool CvUnit::isRivalTerritoryBlock() const
{
	return m_iRivalTerritoryBlock > 0;
}
void CvUnit::changeRivalTerritoryBlock(int iChange)
{
	m_iRivalTerritoryBlock = (m_iRivalTerritoryBlock + iChange);
}
bool CvUnit::isPillageOnMove() const
{
	return m_iPillageOnMove > 0;
}
void CvUnit::changePillageOnMove(int iChange)
{
	m_iPillageOnMove = (m_iPillageOnMove + iChange);
}
bool CvUnit::isSelfPillage() const
{
	return m_iSelfPillage > 0;
}
void CvUnit::changeSelfPillage(int iChange)
{
	m_iSelfPillage = (m_iSelfPillage + iChange);
}
bool CvUnit::isGetCasterXP() const
{
	return m_iGetCasterXP > 0;
}
void CvUnit::changeGetCasterXP(int iChange)
{
	m_iGetCasterXP = (m_iGetCasterXP + iChange);
}
bool CvUnit::isNonWarWeariness() const
{
	return m_iNonWarWeariness > 0;
}
void CvUnit::changeNonWarWeariness(int iChange)
{
	m_iNonWarWeariness = (m_iNonWarWeariness + iChange);
}
bool CvUnit::isNoMapReveal() const
{
	return m_iNoMapReveal > 0;
}
void CvUnit::changeNoMapReveal(int iChange)
{
	m_iNoMapReveal = (m_iNoMapReveal + iChange);
}
bool CvUnit::isCannotCapture(bool bHidden) const
{
	return m_iCannotCapture > 0 || (bHidden && isHiddenNationality());
}
void CvUnit::changeCannotCapture(int iChange)
{
	m_iCannotCapture = (m_iCannotCapture + iChange);
}
bool CvUnit::isCityHappy() const
{
	return m_iCityHappy > 0;
}
void CvUnit::changeCityHappy(int iChange)
{
	bool bHappyPre = false;
	bool bHappyPost = false;
	if ((isCityHappy() || m_pUnitInfo->isMilitaryHappiness()) && !isCityNoHappy())
	{
		bHappyPre = true;
	}
	m_iCityHappy = (m_iCityHappy + iChange);
	if ((isCityHappy() || m_pUnitInfo->isMilitaryHappiness()) && !isCityNoHappy())
	{
		bHappyPost = true;
	}
	if (bHappyPre != bHappyPost)
	{
		if (plot()->isCity())
		{
			plot()->getPlotCity()->changeMilitaryHappinessUnits(bHappyPost ? 1 : -1);
		}
	}
}
bool CvUnit::isCityNoHappy() const
{
	return m_iCityNoHappy > 0;
}
void CvUnit::changeCityNoHappy(int iChange)
{
	bool bHappyPre = false;
	bool bHappyPost = false;
	if ((isCityHappy() || m_pUnitInfo->isMilitaryHappiness()) && !isCityNoHappy())
	{
		bHappyPre = true;
	}
	m_iCityNoHappy = (m_iCityNoHappy + iChange);
	if ((isCityHappy() || m_pUnitInfo->isMilitaryHappiness()) && !isCityNoHappy())
	{
		bHappyPost = true;
	}
	if (bHappyPre != bHappyPost)
	{
		if (plot()->isCity())
		{
			plot()->getPlotCity()->changeMilitaryHappinessUnits(bHappyPost ? 1 : -1);
		}
	}
}
bool CvUnit::isNoSupport() const
{
	return m_iNoSupport > 0;
}
void CvUnit::changeNoSupport(int iChange)
{
	bool bSupportPre = false;
	bool bSupportPost = false;
	if (!isNoSupport() && m_pUnitInfo->isMilitarySupport())
	{
		bSupportPre = true;
	}
	m_iNoSupport = (m_iNoSupport + iChange);
	if (!isNoSupport() && m_pUnitInfo->isMilitarySupport())
	{
		bSupportPost = true;
	}
	if (bSupportPre != bSupportPost)
	{
		GET_PLAYER(getOwnerINLINE()).changeNumMilitaryUnits(bSupportPost ? 1 : -1);
	}
}
bool CvUnit::isCanPillage() const
{
	return m_iCanPillage > 0;
}
void CvUnit::changeCanPillage(int iChange)
{
	m_iCanPillage = (m_iCanPillage + iChange);
}
bool CvUnit::isCannotPillage() const
{
	return m_iCannotPillage > 0;
}
void CvUnit::changeCannotPillage(int iChange)
{
	m_iCannotPillage = (m_iCannotPillage + iChange);
}
bool CvUnit::isCitySpy() const
{
	return m_iCitySpy > 0;
}
void CvUnit::changeCitySpy(int iChange)
{
	m_iCitySpy = (m_iCitySpy + iChange);
}
bool CvUnit::isStartGoldenAge() const
{
	return m_iStartGoldenAge > 0;
}
void CvUnit::changeStartGoldenAge(int iChange)
{
	m_iStartGoldenAge = (m_iStartGoldenAge + iChange);
}
bool CvUnit::isNoDefenseBonus() const
{
	return m_iNoDefenseBonus > 0;
}
void CvUnit::changeNoDefenseBonus(int iChange)
{
	m_iNoDefenseBonus = (m_iNoDefenseBonus + iChange);
}
bool CvUnit::isMoveImpassable() const
{
	return m_iMoveImpassable > 0;
}
/*************************************************************************************************/
/**	Mountain Mod		 		expanded by Ahwaric	20.09.09		**/
/*************************************************************************************************/
bool CvUnit::isClimbPeaks() const
{
	return m_iClimbPeaks > 0;
}
void CvUnit::changeClimbPeaks(int iChange)
{
	m_iClimbPeaks = (m_iClimbPeaks + iChange);
}
/*************************************************************************************************/
/**	Mountain Mod END									**/
/*************************************************************************************************/
void CvUnit::changeMoveImpassable(int iChange)
{
	m_iMoveImpassable = (m_iMoveImpassable + iChange);
}
bool CvUnit::isFlatMoveCost() const
{
	return m_iFlatMoveCost > 0;
}
void CvUnit::changeFlatMoveCost(int iChange)
{
	m_iFlatMoveCost = (m_iFlatMoveCost + iChange);
}
bool CvUnit::isIgnoreTerrainCosts() const
{
	return m_iIgnoreTerrainCosts > 0;
}
void CvUnit::changeIgnoreTerrainCosts(int iChange)
{
	m_iIgnoreTerrainCosts = (m_iIgnoreTerrainCosts + iChange);
}
bool CvUnit::isAttackNoWar() const
{
	return m_iAttackNoWar > 0;
}
void CvUnit::changeAttackNoWar(int iChange)
{
	m_iAttackNoWar = (m_iAttackNoWar + iChange);
}
bool CvUnit::isAllowAttacks() const
{
	return m_iAllowAttacks > 0;
}
void CvUnit::changeAllowAttacks(int iChange)
{
	m_iAllowAttacks = (m_iAllowAttacks + iChange);
}
bool CvUnit::isFirstStrikeVulnerable() const
{
	return m_iFirstStrikeVulnerable > 0;
}
void CvUnit::changeFirstStrikeVulnerable(int iChange)
{
	m_iFirstStrikeVulnerable = (m_iFirstStrikeVulnerable + iChange);
}
bool CvUnit::isAllowDefenseBonuses() const
{
	return m_iAllowDefenseBonuses > 0;
}
void CvUnit::changeAllowDefenseBonuses(int iChange)
{
	m_iAllowDefenseBonuses = (m_iAllowDefenseBonuses + iChange);
}
bool CvUnit::isNonAbandon() const
{
	return m_iNonAbandon > 0;
}
void CvUnit::changeNonAbandon(int iChange)
{
	m_iNonAbandon = (m_iNonAbandon + iChange);
}
bool CvUnit::isIndependant() const
{
	return m_iIndependant > 0;
}

//ReligiousCommander by BI 07/24/11
bool CvUnit::isReligiousCommander() const
{
	for (int iJ=0;iJ<GC.getNumPromotionInfos();iJ++)
			{
				if ((isHasPromotion((PromotionTypes)iJ)) && (GC.getPromotionInfo((PromotionTypes)iJ).isReligiousCommanderPromo()))
				{
					return true;
				}
			}
	if (getUnitInfo().isReligiousCommander())
	{
		return true;
	}

	return false;

}
void CvUnit::changeIndependant(int iChange)
{
	bool bPre = isIndependant();
	m_iIndependant = (m_iIndependant + iChange);
	if (bPre != isIndependant())
	{
		GET_TEAM(getTeam()).changeUnitClassCount((UnitClassTypes)m_pUnitInfo->getUnitClassType(), (isIndependant() ? -1 : 1));
		GET_PLAYER(getOwnerINLINE()).changeUnitClassCount((UnitClassTypes)m_pUnitInfo->getUnitClassType(), (isIndependant() ? -1 : 1));
	}
}
int CvUnit::getTempUnitCombat() const
{
	return m_iTempUnitCombat;
}
void CvUnit::setTempUnitCombat(int iNewValue)
{
	m_iTempUnitCombat = iNewValue;
}
int CvUnit::getAssetValue() const
{
	return std::max(1, m_iAssetValue);
}
void CvUnit::changeAssetValue(int iChange)
{
	if (iChange != 0)
	{
		GET_PLAYER(getOwnerINLINE()).changeAssets(-m_pUnitInfo->getAssetValue()*(getAssetValue()/100));
		m_iAssetValue += iChange;
		GET_PLAYER(getOwnerINLINE()).changeAssets(m_pUnitInfo->getAssetValue()*(getAssetValue()/100));
	}
}
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvUnit::getPowerValue() const
{
	return std::max(1, m_iPowerValue);
}
void CvUnit::changePowerValue(int iChange)
{
	if (iChange != 0)
	{
		int iPowerPre = m_pUnitInfo->getPowerValue()*(getPowerValue()/100);
		m_iPowerValue += iChange;
		int iPowerPost = m_pUnitInfo->getPowerValue()*(getPowerValue()/100);
		area()->changePower(getOwnerINLINE(), iPowerPost-iPowerPre);
		GET_PLAYER(getOwnerINLINE()).changePower(iPowerPost-iPowerPre);
	}
}
/**								----  End Original Code  ----									**/
int CvUnit::getPowerMult() const
{
	return m_iPowerMult;
}
void CvUnit::changePowerMult(int iChange)
{
	m_iPowerMult += iChange;
	calculatePower();
}

int CvUnit::getPowerAdd() const
{
	return m_iPowerAdd;
}
void CvUnit::changePowerAdd(int iChange)
{
	m_iPowerAdd += iChange;
	calculatePower();
}

int CvUnit::getPower() const
{
	return m_iPower;
}

void CvUnit::calculatePower()
{
	int iNewPower = (baseCombatStr() + baseCombatStrDefense());
	iNewPower *= 100; //To avoid any rounding issues
	iNewPower *= (100 + getExtraCombatPercent());
	iNewPower /= 100;
	iNewPower *= (100 + getPowerMult());
	iNewPower /= 100;
	iNewPower += getPowerAdd();
	if (onMap())
		area()->changePower(getOwnerINLINE(), iNewPower - m_iPower);
	GET_PLAYER(getOwnerINLINE()).changePower(iNewPower - m_iPower);

	m_iPower = iNewPower;
}

/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
int CvUnit::getFreeXPCap() const
{
	return m_iFreeXPCap;
}
void CvUnit::setFreeXPCap(int iNewValue)
{
	m_iFreeXPCap = iNewValue;
}
void CvUnit::changeFreeXPCap(int iChange)
{
	setFreeXPCap(getFreeXPCap() + iChange);
}
float CvUnit::getCasterXPRate() const
{
	float fXPRate = m_fCasterXPRate;
	CvPlot* pPlot = plot();
	CvCity* pCity = pPlot->getPlotCity();
	if (pPlot->isCity())
	{
		fXPRate += pCity->getTrainXPRate(getUnitCombatType());
	}
	return fXPRate;
}
void CvUnit::setCasterXPRate(float fNewValue)
{
	m_fCasterXPRate = fNewValue;
}
void CvUnit::changeCasterXPRate(float fChange)
{
	m_fCasterXPRate += fChange;
}
int CvUnit::getAirCombat() const
{
	return m_iAirCombat;
}
void CvUnit::setAirCombat(int iNewValue)
{
	m_iAirCombat = iNewValue;
}
void CvUnit::changeAirCombat(int iChange)
{
	setAirCombat(getAirCombat() + iChange);
}
int CvUnit::getAirCombatLimitBoost() const
{
	return m_iAirCombatLimitBoost;
}
void CvUnit::setAirCombatLimitBoost(int iNewValue)
{
	m_iAirCombatLimitBoost = iNewValue;
}
void CvUnit::changeAirCombatLimitBoost(int iChange)
{
	setAirCombatLimitBoost(getAirCombatLimitBoost() + iChange);
}
int CvUnit::getExtraDropRange() const
{
	return m_iExtraDropRange;
}
void CvUnit::setExtraDropRange(int iNewValue)
{
	m_iExtraDropRange = iNewValue;
}
void CvUnit::changeExtraDropRange(int iChange)
{
	setExtraDropRange(getExtraDropRange() + iChange);
}
int CvUnit::getSpellExtraRange() const
{
	return m_iSpellExtraRange;
}
void CvUnit::setSpellExtraRange(int iNewValue)
{
	m_iSpellExtraRange = iNewValue;
}
void CvUnit::changeSpellExtraRange(int iChange)
{
	setSpellExtraRange(getSpellExtraRange() + iChange);
}
int CvUnit::getCombatConversionChance() const
{
	return m_iCombatConversionChance;
}
void CvUnit::setCombatConversionChance(int iNewValue)
{
	m_iCombatConversionChance = iNewValue;
}
void CvUnit::changeCombatConversionChance(int iChange)
{
	setCombatConversionChance(getCombatConversionChance() + iChange);
}
int CvUnit::getCombatUnitGenerationChance() const
{
	return m_iCombatUnitGenerationChance;
}
void CvUnit::setCombatUnitGenerationChance(int iNewValue)
{
	m_iCombatUnitGenerationChance = iNewValue;
}
void CvUnit::changeCombatUnitGenerationChance(int iChange)
{
	setCombatUnitGenerationChance(getCombatUnitGenerationChance() + iChange);
}
int CvUnit::getSlaveGenerationChance() const
{
	return m_iSlaveGenerationChance;
}
void CvUnit::setSlaveGenerationChance(int iNewValue)
{
	m_iSlaveGenerationChance = iNewValue;
}
void CvUnit::changeSlaveGenerationChance(int iChange)
{
	setSlaveGenerationChance(getSlaveGenerationChance() + iChange);
}
int CvUnit::getGiftableXP() const
{
	return m_iGiftableXP;
}
void CvUnit::setGiftableXP(int iNewValue)
{
	m_iGiftableXP = iNewValue;
}
void CvUnit::changeGiftableXP(int iChange)
{
	setGiftableXP(getGiftableXP() + iChange);
}
int CvUnit::getCombatExtraDuration() const
{
	return m_iCombatExtraDuration;
}
void CvUnit::setCombatExtraDuration(int iNewValue)
{
	m_iCombatExtraDuration = iNewValue;
}
void CvUnit::changeCombatExtraDuration(int iChange)
{
	setCombatExtraDuration(getCombatExtraDuration() + iChange);
}
int CvUnit::getDurationPerTurn() const
{
	return m_iDurationPerTurn;
}
void CvUnit::setDurationPerTurn(int iNewValue)
{
	m_iDurationPerTurn = iNewValue;
}
void CvUnit::changeDurationPerTurn(int iChange)
{
	setDurationPerTurn(getDurationPerTurn() + iChange);
}
void CvUnit::changeDurationAlter(int iChange)
{
	if (getDuration() != 0)
	{
		changeDuration(iChange);
		if (getDuration() <= 0)
		{
			setMustDie(true);
		}
	}
}
void CvUnit::changeChangeDuration(int iChange)
{
	if (getDuration() == 0)
	{
		m_bNonTemporary = true;
	}
	changeDuration(iChange);
	if (getDuration() <= 0)
	{
		if (m_bNonTemporary)
		{
			setDuration(0);
		}
		else
		{
			setMustDie(true);
		}
	}
}
bool CvUnit::isMustDie() const
{
	return m_bMustDie;
}
void CvUnit::setMustDie(bool bNewValue)
{
	m_bMustDie = bNewValue;
}
void CvUnit::setNullPromoteAvailable(bool bActivate)
{
	if (GC.getDefineINT("NULL_PROMOTION") != -1)
	{
		m_bNullPromotionAvailable = bActivate;
	}
}
bool CvUnit::isNullPromoteAvailable() const
{
	return (GC.getDefineINT("NULL_PROMOTION") != -1 ? m_bNullPromotionAvailable : false);
}
int CvUnit::getExtraSupport() const
{
	return m_iExtraSupport + m_pUnitInfo->getExtraCost();
}
void CvUnit::setExtraSupport(int iNewValue)
{
	GET_PLAYER(getOwnerINLINE()).changeExtraUnitCost(-m_iExtraSupport);
	m_iExtraSupport = iNewValue;
	GET_PLAYER(getOwnerINLINE()).changeExtraUnitCost(m_iExtraSupport);
}
void CvUnit::changeExtraSupport(int iChange)
{
	m_iExtraSupport += iChange;
	GET_PLAYER(getOwnerINLINE()).changeExtraUnitCost(iChange);
}
int CvUnit::getChanceMiscast() const
{
	return m_iChanceMiscast;
}
void CvUnit::setChanceMiscast(int iNewValue)
{
	m_iChanceMiscast = iNewValue;
}
void CvUnit::changeChanceMiscast(int iChange)
{
	setChanceMiscast(getChanceMiscast() + iChange);
}
int CvUnit::getCombatDmgCapBoost() const
{
/*************************************************************************************************/
/**	Higher hitpoints				28/01/11				Imported from wiser orcs by Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_iCombatDmgCapBoost;
/**								----  End Original Code  ----									**/
	return m_iCombatDmgCapBoost * GC.getDefineINT("HIT_POINT_FACTOR");
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
}
void CvUnit::setCombatDmgCapBoost(int iNewValue)
{
	m_iCombatDmgCapBoost = iNewValue;
}
void CvUnit::changeCombatDmgCapBoost(int iChange)
{
	setCombatDmgCapBoost(getCombatDmgCapBoost() + iChange);
}
int CvUnit::getCollateralLimitCap() const
{
	return m_iCollateralLimitCap;
}
void CvUnit::setCollateralLimitCap(int iNewValue)
{
	m_iCollateralLimitCap = iNewValue;
}
void CvUnit::changeCollateralLimitCap(int iChange)
{
	setCollateralLimitCap(getCollateralLimitCap() + iChange);
}
int CvUnit::getCollateralLimitBoost() const
{
	return m_iCollateralLimitBoost;
}
void CvUnit::setCollateralLimitBoost(int iNewValue)
{
	m_iCollateralLimitBoost = iNewValue;
}
void CvUnit::changeCollateralLimitBoost(int iChange)
{
	setCollateralLimitBoost(getCollateralLimitBoost() + iChange);
}
int CvUnit::getCollateralTargetsLimit() const
{
	return m_iCollateralTargetsLimit;
}
void CvUnit::setCollateralTargetsLimit(int iNewValue)
{
	m_iCollateralTargetsLimit = iNewValue;
}
void CvUnit::changeCollateralTargetsLimit(int iChange)
{
	setCollateralTargetsLimit(getCollateralTargetsLimit() + iChange);
}
int CvUnit::getCollateralExtraTargets() const
{
	return m_iCollateralExtraTargets;
}
void CvUnit::setCollateralExtraTargets(int iNewValue)
{
	m_iCollateralExtraTargets = iNewValue;
}
void CvUnit::changeCollateralExtraTargets(int iChange)
{
	setCollateralExtraTargets(getCollateralExtraTargets() + iChange);
}
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/

int CvUnit::getFlankingLimitBoost() const					{return m_iFlankingLimitBoost;}
void CvUnit::setFlankingLimitBoost(int iNewValue)			{m_iFlankingLimitBoost = iNewValue;}
void CvUnit::changeFlankingLimitBoost(int iChange)			{setFlankingLimitBoost(getFlankingLimitBoost() + iChange);}
int	CvUnit::getFlankingExtraTargets() const					{return m_iFlankingExtraTargets;}
void CvUnit::setFlankingExtraTargets(int iNewValue)			{m_iFlankingExtraTargets = iNewValue;}
void CvUnit::changeFlankingExtraTargets(int iChange)		{setFlankingExtraTargets(getFlankingExtraTargets() + iChange);}
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

int CvUnit::getHammerSacrifice() const
{
	return m_iHammerSacrifice;
}
void CvUnit::setHammerSacrifice(int iNewValue)
{
	m_iHammerSacrifice = iNewValue;
}
void CvUnit::changeHammerSacrifice(int iChange)
{
	setHammerSacrifice(getHammerSacrifice() + iChange);
}
int CvUnit::getExtraHammerPerPop() const
{
	return m_iExtraHammerPerPop;
}
void CvUnit::setExtraHammerPerPop(int iNewValue)
{
	m_iExtraHammerPerPop = iNewValue;
}
void CvUnit::changeExtraHammerPerPop(int iChange)
{
	setExtraHammerPerPop(getExtraHammerPerPop() + iChange);
}
int CvUnit::getFoodSacrifice() const
{
	return m_iFoodSacrifice;
}
void CvUnit::setFoodSacrifice(int iNewValue)
{
	m_iFoodSacrifice = iNewValue;
}
void CvUnit::changeFoodSacrifice(int iChange)
{
	setFoodSacrifice(getFoodSacrifice() + iChange);
}
int CvUnit::getPopulationAdd() const
{
	return m_iPopulationAdd;
}
void CvUnit::setPopulationAdd(int iNewValue)
{
	m_iPopulationAdd = iNewValue;
}
void CvUnit::changePopulationAdd(int iChange)
{
	setPopulationAdd(getPopulationAdd() + iChange);
}
int CvUnit::getBeakerSacrifice() const
{
	return m_iBeakerSacrifice;
}
void CvUnit::setBeakerSacrifice(int iNewValue)
{
	m_iBeakerSacrifice = iNewValue;
}
void CvUnit::changeBeakerSacrifice(int iChange)
{
	setBeakerSacrifice(getBeakerSacrifice() + iChange);
}
int CvUnit::getExtraBeakerPerPop() const
{
	return m_iExtraBeakerPerPop;
}
void CvUnit::setExtraBeakerPerPop(int iNewValue)
{
	m_iExtraBeakerPerPop = iNewValue;
}
void CvUnit::changeExtraBeakerPerPop(int iChange)
{
	setExtraBeakerPerPop(getExtraBeakerPerPop() + iChange);
}
int CvUnit::getGoldSacrifice() const
{
	return m_iGoldSacrifice;
}
void CvUnit::setGoldSacrifice(int iNewValue)
{
	m_iGoldSacrifice = iNewValue;
}
void CvUnit::changeGoldSacrifice(int iChange)
{
	setGoldSacrifice(getGoldSacrifice() + iChange);
}
int CvUnit::getExtraGoldPerPop() const
{
	return m_iExtraGoldPerPop;
}
void CvUnit::setExtraGoldPerPop(int iNewValue)
{
	m_iExtraGoldPerPop = iNewValue;
}
void CvUnit::changeExtraGoldPerPop(int iChange)
{
	setExtraGoldPerPop(getExtraGoldPerPop() + iChange);
}
int CvUnit::getCultureSacrifice() const
{
	return m_iCultureSacrifice;
}
void CvUnit::setCultureSacrifice(int iNewValue)
{
	m_iCultureSacrifice = iNewValue;
}
void CvUnit::changeCultureSacrifice(int iChange)
{
	setCultureSacrifice(getCultureSacrifice() + iChange);
}
int CvUnit::getExtraCulturePerPop() const
{
	return m_iExtraCulturePerPop;
}
void CvUnit::setExtraCulturePerPop(int iNewValue)
{
	m_iExtraCulturePerPop = iNewValue;
}
void CvUnit::changeExtraCulturePerPop(int iChange)
{
	setExtraCulturePerPop(getExtraCulturePerPop() + iChange);
}
int CvUnit::getXPTranserRate() const
{
	return m_iXPTranserRate;
}
void CvUnit::setXPTranserRate(int iNewValue)
{
	m_iXPTranserRate = iNewValue;
}
void CvUnit::changeXPTranserRate(int iChange)
{
	setXPTranserRate(getXPTranserRate() + iChange);
}
int CvUnit::getCastingLimit() const
{
	return m_iCastingLimit;
}
void CvUnit::setCastingLimit(int iNewValue)
{
	m_iCastingLimit = iNewValue;
}
void CvUnit::changeCastingLimit(int iChange)
{
	setCastingLimit(getCastingLimit() + iChange);
}
void CvUnit::setNewName(CvWString szNewValue, bool bNewValue)
{
	gDLL->stripSpecialCharacters(szNewValue);
	if (!szNewValue.empty())
	{
		if (bNewValue)
		{
			m_szNewName = szNewValue;
		}
		else
		{
			m_szNewName.clear();
		}
	}
	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
	}
}
CvUnit* CvUnit::getMasterUnit() const
{
	return getUnit(m_MasterUnit);
}
void CvUnit::setMasterUnit(IDInfo iID)
{
	m_MasterUnit = iID;
	CvUnit* pMaster = getMasterUnit();
	for(int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		CvPromotionInfo &kLoopPromotion = GC.getPromotionInfo((PromotionTypes)iI);
		for (int iK=0;iK<pMaster->countHasPromotion((PromotionTypes)iI);++iK)
		{
			for (int iJ = 0; iJ < kLoopPromotion.getNumSlavePromotions(); ++iJ)
			{
				changeSupplementalPromotions(kLoopPromotion.getSlavePromotion(iJ), true);
			}
		}
		for (int iK=0;iK<countHasPromotion((PromotionTypes)iI);++iK)
		{
			for (int iJ = 0; iJ < kLoopPromotion.getNumMasterPromotions(); ++iJ)
			{
				pMaster->changeSupplementalPromotions(kLoopPromotion.getMasterPromotion(iJ), true);
			}
		}
	}
}
int CvUnit::getNumSlavesOfType(UnitTypes eType) const
{
	int iCount = 0;
	std::list<int> summonedUnitList = getAllSlaveUnits();
	for (std::list<int>::const_iterator iter = summonedUnitList.begin(); iter != summonedUnitList.end(); ++iter)
	{
		if (getUnit(IDInfo (getOwner(), *iter))->getUnitType() == eType)
		{
			iCount++;
		}
	}
	return iCount;
}
int CvUnit::getNumSlavesOfClass(UnitClassTypes eType) const
{
	int iCount = 0;
	std::list<int> summonedUnitList = getAllSlaveUnits();
	for (std::list<int>::const_iterator iter = summonedUnitList.begin(); iter != summonedUnitList.end(); ++iter)
	{
		if (getUnit(IDInfo (getOwner(), *iter))->getUnitClassType() == eType)
		{
			iCount++;
		}
	}
	return iCount;
}
int CvUnit::getNumSlaves() const
{
	return m_pSlaveUnitList.size();
}
void CvUnit::addSlaveUnit(int iID)
{
	m_pSlaveUnitList.push_back(iID);
}
void CvUnit::removeSlaveUnit(int iID)
{
	m_pSlaveUnitList.remove(iID);
}
void CvUnit::removeAllSlaveUnits()
{
	m_pSlaveUnitList.clear();
}
std::list<int> CvUnit::getAllSlaveUnits() const
{
	return m_pSlaveUnitList;
}
CvUnit* CvUnit::getSlaveUnit(int iI) const
{
	int iCount = 0;
	int iIDTemp;
	for (std::list<int>::const_iterator iter = m_pSlaveUnitList.begin(); iter != m_pSlaveUnitList.end(); ++iter)
	{
		if (iCount == iI)
		{
			iIDTemp = *iter;
		}
		iCount++;
	}
	return getUnit(IDInfo (getOwner(), iIDTemp));
}
CvUnit* CvUnit::getCommanderUnit() const
{
	return getUnit(m_CommanderUnit);
}
//NOTE:  Control who is linked to who using add/remove Minions.   Control who gets/loses what using set/clear Commander.  NEVER call the Commander controls directly, always go through Minions
void CvUnit::setCommanderUnit(IDInfo iID)
{
	m_CommanderUnit = iID;
	CvUnit* pCommander = getCommanderUnit();

	if(pCommander == NULL)
	{
		m_CommanderUnit.reset();
		return;
	}
	//ReligiousCommander by BI 07/24/11
	if (pCommander -> isReligiousCommander() && pCommander->getReligion() != getReligion())
	{
		return;
	}
	if (plotDistance(getX_INLINE(), getY_INLINE(), pCommander->getX_INLINE(), pCommander->getY_INLINE()) <= pCommander->getCommandRange())
	{

		for(int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
		{
			CvPromotionInfo &kLoopPromotion = GC.getPromotionInfo((PromotionTypes)iI);
			for (int iK = 0; iK < pCommander->countHasPromotion((PromotionTypes)iI); ++iK)
			{
				for (int iJ = 0; iJ < kLoopPromotion.getNumMinionPromotions(); ++iJ)
				{
					if(isPromotionValid(kLoopPromotion.getMinionPromotion(iJ)))
					{
						changeSupplementalPromotions(kLoopPromotion.getMinionPromotion(iJ), true);
					}
				}
			}
			for (int iK = 0; iK < countHasPromotion((PromotionTypes)iI); ++iK)
			{
				for (int iJ = 0; iJ < kLoopPromotion.getNumCommanderPromotions(); ++iJ)
				{
					pCommander->changeSupplementalPromotions(kLoopPromotion.getCommanderPromotion(iJ), true);
				}
			}
		}
	}
	if (getOwnerINLINE() == GC.getGameINLINE().getActivePlayer())
	{
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
	}
}
void CvUnit::clearCommanderUnit()
{
	CvUnit* pCommander = getCommanderUnit();
	if(pCommander != NULL)
	{
		if (plotDistance(getX_INLINE(), getY_INLINE(), pCommander->getX_INLINE(), pCommander->getY_INLINE()) <= pCommander->getCommandRange())
		{
			for(int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
			{
				CvPromotionInfo &kLoopPromotion = GC.getPromotionInfo((PromotionTypes)iI);
				for (int iK = 0; iK < pCommander->countHasPromotion((PromotionTypes)iI); ++iK)
				{
					for (int iJ = 0; iJ < kLoopPromotion.getNumMinionPromotions(); ++iJ)
					{
						if(isPromotionValid(kLoopPromotion.getMinionPromotion(iJ)))
						{
							changeSupplementalPromotions(kLoopPromotion.getMinionPromotion(iJ), false);
						}
					}
				}
				for (int iK = 0; iK < countHasPromotion((PromotionTypes)iI); ++iK)
				{
					for (int iJ = 0; iJ < kLoopPromotion.getNumCommanderPromotions(); ++iJ)
					{
						pCommander->changeSupplementalPromotions(kLoopPromotion.getCommanderPromotion(iJ), false);
					}
				}
			}
		}
	}
	m_CommanderUnit.reset();
	if(getPreviousOwner() != NO_PLAYER)
	{
		if (GET_PLAYER(getPreviousOwner()).isAlive())
		{
/*************************************************************************************************/
/**	Bugfix								04/07/13										Snarko	**/
/**																								**/
/**							Do not betray if we are dying.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			betray(getPreviousOwner());
/**								----  End Original Code  ----									**/
			if (!isMustDie() && !isDead())
			{
				betray(getPreviousOwner());
			}
/*************************************************************************************************/
/**	Bugfix									END													**/
/*************************************************************************************************/
		}
	}
	if (getOwnerINLINE() == GC.getGameINLINE().getActivePlayer())
	{
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
	}
}
int CvUnit::getNumMinions() const
{
	return m_pMinionUnitList.size();
}
int CvUnit::getNumForcedMinions() const
{
	return m_iNumForcedMinions;
}
//NOTE:  Control who is linked to who using add/remove Minions.   Control who gets/loses what using set/clear Commander.  NEVER call the Commander controls directly, always go through Minions
void CvUnit::addMinionUnit(int iID)
{
	CvUnit* pNewMinion = getUnit(IDInfo(getOwner(),iID));
	if (pNewMinion == NULL)
	{
		return;
	}
	CvUnit* pOldCommander = pNewMinion->getCommanderUnit();
	if(pOldCommander != NULL)
	{
		if(pOldCommander == this)
		{
			return;
		}
		pOldCommander->removeMinionUnit(pNewMinion->getID());
	}
	pNewMinion->setCommanderUnit(getIDInfo());

	m_pMinionUnitList.push_back(iID);
	if(pNewMinion->getPreviousOwner() != NO_PLAYER)
	{
		m_iNumForcedMinions++;
	}
	if(pNewMinion->getGroupID() != getGroupID())
	{
		if(pNewMinion->getGroup()->getNumUnits() == 1)
		{
			pNewMinion->joinGroup(NULL);
			pNewMinion->joinGroup(getGroup());
		}
		else if (getGroup()->getNumUnits() == 1)
		{
			joinGroup(NULL);
			joinGroup(pNewMinion->getGroup());
		}
	}
	if (getOwnerINLINE() == GC.getGameINLINE().getActivePlayer())
	{
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
	}
}
void CvUnit::removeMinionUnit(int iID)
{
	CvUnit* pOldMinion = getUnit(IDInfo(getOwner(),iID));
	if (pOldMinion == NULL)
	{
		m_pMinionUnitList.remove(iID);
		return;
	}
	pOldMinion->clearCommanderUnit();

	m_pMinionUnitList.remove(iID);
	if(pOldMinion->getPreviousOwner() != NO_PLAYER)
	{
		m_iNumForcedMinions--;
	}
	if (getOwnerINLINE() == GC.getGameINLINE().getActivePlayer())
	{
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
	}
}
std::list<int> CvUnit::getAllMinionUnits() const
{
	return m_pMinionUnitList;
}
CvUnit* CvUnit::getMinionUnit(int iI) const
{
	int iCount = 0;
	int iIDTemp;
	for (std::list<int>::const_iterator iter = m_pMinionUnitList.begin(); iter != m_pMinionUnitList.end(); ++iter)
	{
		if (iCount == iI)
		{
			iIDTemp = *iter;
			break;
		}
		iCount++;
	}
	return getUnit(IDInfo (getOwner(), iIDTemp));
}
void CvUnit::validateCommanderMinion()
{
	for(int iI = 0; iI < getNumMinions();++iI)
	{
		CvUnit* pLoopUnit = getMinionUnit(iI);
		if(pLoopUnit->getCommanderUnit() != this)
		{
			removeMinionUnit(pLoopUnit->getID());
		}
	}
	CvUnit* pCommander = getCommanderUnit();
	if(pCommander != NULL)
	{
		bool bValid = false;
		for(int iI = 0; iI < pCommander->getNumMinions();++iI)
		{
			if(pCommander->getMinionUnit(iI) == this)
			{
				bValid = true;
				break;
			}
		}
		if(!bValid)
		{
			clearCommanderUnit();
		}
	}
}
int CvUnit::getYieldFromWin(int iI) const
{
	return m_piYieldFromWin[iI];
}
void CvUnit::changeYieldFromWin(int iI, int iChange)
{
	if (iChange != 0)
	{
		m_piYieldFromWin[iI] = std::max(0, m_piYieldFromWin[iI] + iChange);
	}
}
int CvUnit::getYieldForLoss(int iI) const
{
	return m_piYieldForLoss[iI] + m_pUnitInfo->getYieldFromKill(iI);
}
void CvUnit::changeYieldForLoss(int iI, int iChange)
{
	if (iChange != 0)
	{
		m_piYieldForLoss[iI] = std::max(0, m_piYieldForLoss[iI] + iChange);
	}
}
int CvUnit::getCommerceFromWin(int iI) const
{
	return m_piCommerceFromWin[iI];
}
void CvUnit::changeCommerceFromWin(int iI, int iChange)
{
	if (iChange != 0)
	{
		m_piCommerceFromWin[iI] = std::max(0, m_piCommerceFromWin[iI] + iChange);
	}
}
int CvUnit::getCommerceForLoss(int iI) const
{
	return m_piCommerceForLoss[iI] + m_pUnitInfo->getCommerceFromKill(iI);
}
void CvUnit::changeCommerceForLoss(int iI, int iChange)
{
	if (iChange != 0)
	{
		m_piCommerceForLoss[iI] = std::max(0, m_piCommerceForLoss[iI] + iChange);
	}
}
int CvUnit::getTruePromotionDuration(PromotionTypes eIndex) const
{
	return m_piPromotionDuration[eIndex];
}
int CvUnit::getPromotionDuration(PromotionTypes eIndex) const
{
/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Use autocasting. This was removed because it takes too much time.					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_piPromotionDuration[eIndex] != 0)
	{
		CLLNode<IDInfo>* pUnitNode = plot()->headUnitNode();
		while (pUnitNode != NULL)
		{
			CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = plot()->nextUnitNode(pUnitNode);
			for (int iJ = 0; iJ < GC.getNumSpellInfos(); iJ++)
			{
				if (pLoopUnit->canCast(iJ, true))
				{
					if (!GC.getSpellInfo((SpellTypes)iJ).isBuffCasterOnly() || pLoopUnit == this)
					{
						if ((PromotionTypes)GC.getSpellInfo((SpellTypes)iJ).getAddPromotionType1() == eIndex || (PromotionTypes)GC.getSpellInfo((SpellTypes)iJ).getAddPromotionType2() == eIndex || (PromotionTypes)GC.getSpellInfo((SpellTypes)iJ).getAddPromotionType3() == eIndex)
						{
							return 0;
						}
					}
				}
			}
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/
	return m_piPromotionDuration[eIndex];
}
void CvUnit::setPromotionDuration(PromotionTypes eIndex, int iNewValue)
{
	m_piPromotionDuration[eIndex] = std::max(0, iNewValue);
}
int CvUnit::getNumCityBonuses() const
{
	return m_iNumCityBonuses;
}
CityBonuses CvUnit::getCityBonus(int iI) const
{
	int iCount = 0;
	CityBonuses cbTemp;
	for (std::list<CityBonuses>::const_iterator iter = m_cbCityBonuses.begin(); iter != m_cbCityBonuses.end(); ++iter)
	{
		if (iCount == iI)
		{
			cbTemp = *iter;
		}
		iCount++;
	}
	return cbTemp;
}
std::list<CityBonuses> CvUnit::listCityBonuses()
{
	return m_cbCityBonuses;
}
void CvUnit::changeCityBonuses(bool bApply, std::list<CityBonuses> cbCityBonus)
{
	if (bApply)
	{
		while (!cbCityBonus.empty())
		{
			m_iNumCityBonuses++;
			CityBonuses cvTemp = cbCityBonus.front();
			m_cbCityBonuses.push_back(cvTemp);
			cbCityBonus.pop_front();
		}
	}
	else
	{
		while (!cbCityBonus.empty())
		{
			if (m_cbCityBonuses.front().compare(cbCityBonus.front()))
			{
				m_iNumCityBonuses--;
				cbCityBonus.pop_front();
				m_cbCityBonuses.pop_front();
			}
			else
			{
				m_cbCityBonuses.push_back(m_cbCityBonuses.front());
				m_cbCityBonuses.pop_front();
			}
		}
	}
}
bool CvUnit::isAllowPromotion(PromotionTypes eIndex) const
{
	return (m_pUnitInfo->isAllowPromotion(eIndex) || m_piAllowPromotion[eIndex] > 0);
}
void CvUnit::changeAllowPromotion(PromotionTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_piAllowPromotion[eIndex] = std::max(0, m_piAllowPromotion[eIndex] + iChange);
	}
}
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
bool CvUnit::isSecondaryUnitCombat(UnitCombatTypes eIndex) const
{
	return (m_piSecondaryUnitCombat[eIndex] > 0);
}
void CvUnit::changeSecondaryUnitCombat(UnitCombatTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_piSecondaryUnitCombat[eIndex] = std::max(0, m_piSecondaryUnitCombat[eIndex] + iChange);
	}
}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
bool CvUnit::isDenyPromotion(PromotionTypes eIndex) const
{
	return (m_pUnitInfo->isDenyPromotion(eIndex) || m_piDenyPromotion[eIndex] > 0);
}
void CvUnit::changeDenyPromotion(PromotionTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_piDenyPromotion[eIndex] = std::max(0, m_piDenyPromotion[eIndex] + iChange);
	}
}
bool CvUnit::isDisablePyDeath() const
{
	return m_bDisablePyDeath;
}
void CvUnit::setDisablePyDeath(bool bNewValue)
{
	m_bDisablePyDeath = bNewValue;
}
CvPlot* CvUnit::getSpawnPlot() const
{
	return GC.getMapINLINE().plotINLINE(m_iSpawnPlotX, m_iSpawnPlotY);
}
// adds to the numLairSpawnAlive on plot if fitting for immediate or regular spawn type for a valid improvmeent
void CvUnit::setSpawnPlot(CvPlot* pPlot)
{
	if (pPlot != NULL && pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		if (GC.getImprovementInfo(pPlot->getImprovementType()).getImmediateSpawnUnitType() == getUnitType()
		 || GC.getImprovementInfo(pPlot->getImprovementType()).getSpawnUnitType() == getUnitType())
		{
			pPlot->changeNumLairSpawnsAlive(1);
		}
	}

	m_iSpawnPlotX = pPlot->getX();
	m_iSpawnPlotY = pPlot->getY();
}
int CvUnit::getNoBadExplore() const
{
	return std::max(0, m_iNoBadExplore);
}
void CvUnit::changeNoBadExplore(int iChange)
{
	m_iNoBadExplore += iChange;
}
const wchar* CvUnit::getQuote() const
{
	return m_szQuote.GetCString();
}
void CvUnit::setQuote(CvWString szNewValue)
{
	gDLL->stripSpecialCharacters(szNewValue);
	m_szQuote = szNewValue;
}
const TCHAR* CvUnit::getImage() const
{
	if (m_szImage.empty())
	{
		return m_pUnitInfo->getImage();
	}
	else
	{
		return m_szImage;
	}
}
bool CvUnit::isImage() const
{
	if (isWorldUnitClass((UnitClassTypes)(m_pUnitInfo->getUnitClassType())))
	{
		if (GC.getGameINLINE().getUnitClassCreatedCount((UnitClassTypes)(m_pUnitInfo->getUnitClassType())) > 1)
		{
			return false;
		}
	}
	if (!GC.getGameINLINE().isFinalInitialized())
	{
		return false;
	}
	if (gDLL->GetWorldBuilderMode())
	{
		return false;
	}
	if (isSuppressImage())
	{
		return false;
	}
	if (m_szImage.empty())
	{
		return (!CvString(m_pUnitInfo->getImage()).empty());
	}
	else
	{
		return true;
	}
}
void CvUnit::setImage(CvString szNewValue)
{
	m_szImage = szNewValue;
}
bool CvUnit::isSuppressImage() const
{
	return m_bSuppressImage;
}
void CvUnit::setSuppressImage(bool bNewValue)
{
	m_bSuppressImage = bNewValue;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
int CvUnit::getEnemyRouteCount() const
{
	return m_iEnemyRouteCount;
}

bool CvUnit::isEnemyRoute() const
{
	return (getEnemyRouteCount() > 0);
}

void CvUnit::changeEnemyRouteCount(int iChange)
{
	m_iEnemyRouteCount += iChange;
	FAssert(getEnemyRouteCount() >= 0);
}

int CvUnit::getAlwaysHealCount() const
{
	return m_iAlwaysHealCount;
}

bool CvUnit::isAlwaysHeal() const
{
	return (getAlwaysHealCount() > 0);
}

void CvUnit::changeAlwaysHealCount(int iChange)
{
	m_iAlwaysHealCount += iChange;
	FAssert(getAlwaysHealCount() >= 0);
}

int CvUnit::getHillsDoubleMoveCount() const
{
	return m_iHillsDoubleMoveCount;
}

bool CvUnit::isHillsDoubleMove() const
{
	return (getHillsDoubleMoveCount() > 0);
}

void CvUnit::changeHillsDoubleMoveCount(int iChange)
{
	m_iHillsDoubleMoveCount += iChange;
	FAssert(getHillsDoubleMoveCount() >= 0);
}

int CvUnit::getImmuneToFirstStrikesCount() const
{
	return m_iImmuneToFirstStrikesCount;
}

void CvUnit::changeImmuneToFirstStrikesCount(int iChange)
{
	m_iImmuneToFirstStrikesCount += iChange;
	FAssert(getImmuneToFirstStrikesCount() >= 0);
}


int CvUnit::getExtraVisibilityRange() const
{
	return m_iExtraVisibilityRange;
}

void CvUnit::changeExtraVisibilityRange(int iChange)
{
	if (iChange != 0)
	{
		plot()->changeAdjacentSight(getTeam(), visibilityRange(), false, this, true);

		m_iExtraVisibilityRange += iChange;
	//	FAssert(getExtraVisibilityRange() >= 0);

		plot()->changeAdjacentSight(getTeam(), visibilityRange(), true, this, true);
	}
}

int CvUnit::getExtraMoves() const
{
	return m_iExtraMoves;
}


void CvUnit::changeExtraMoves(int iChange)
{
	if (iChange == 0)
	{
		return;
	}
	m_iExtraMoves += iChange;
/*************************************************************************************************/
/**	Xienwolf Tweak							12/27/08											**/
/**																								**/
/**		Pointless Assert since the code has been written to prevent negative move scores		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(getExtraMoves() >= 0);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Improved AI								10/02/12									Snarko	**/
/**																								**/
/**					Don't allow grouping with immobile, or leashed, units						**/
/*************************************************************************************************/
	if (baseMoves() == 0)
	{
		joinGroup(NULL, true);
	}
/*************************************************************************************************/
/**	Improved AI END																				**/
/*************************************************************************************************/
}


int CvUnit::getExtraMoveDiscount() const
{
	return m_iExtraMoveDiscount;
}


void CvUnit::changeExtraMoveDiscount(int iChange)
{
	m_iExtraMoveDiscount += iChange;
/*************************************************************************************************/
/**	Tweak									29/05/10									Snarko	**/
/**																								**/
/**							Not applicable (intended to work this way)							**/
/*************************************************************************************************/
/**			---- Start Original Code ----						**
	FAssert(getExtraMoveDiscount() >= 0);
/**			----  End Original Code  ----						**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getExtraAirRange() const
{
	return m_iExtraAirRange;
}

void CvUnit::changeExtraAirRange(int iChange)
{
	m_iExtraAirRange += iChange;
}

int CvUnit::getExtraIntercept() const
{
	return m_iExtraIntercept;
}

void CvUnit::changeExtraIntercept(int iChange)
{
	m_iExtraIntercept += iChange;
}

int CvUnit::getExtraEvasion() const
{
	return m_iExtraEvasion;
}

void CvUnit::changeExtraEvasion(int iChange)
{
	m_iExtraEvasion += iChange;
}

int CvUnit::getExtraFirstStrikes() const
{
	return m_iExtraFirstStrikes;
}

void CvUnit::changeExtraFirstStrikes(int iChange)
{
	m_iExtraFirstStrikes += iChange;
/*************************************************************************************************/
/**	Tweak									25/05/10									Snarko	**/
/**																								**/
/**							Not applicable (intended to work this way)							**/
/*************************************************************************************************/
/**			---- Start Original Code ----						**
	FAssert(getExtraFirstStrikes() >= 0);
/**			----  End Original Code  ----						**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getExtraChanceFirstStrikes() const
{
	return m_iExtraChanceFirstStrikes;
}

void CvUnit::changeExtraChanceFirstStrikes(int iChange)
{
	m_iExtraChanceFirstStrikes += iChange;
/*************************************************************************************************/
/**	Tweak									13/07/10									Snarko	**/
/**																								**/
/**							Not applicable (intended to work this way)							**/
/*************************************************************************************************/
/**			---- Start Original Code ----						**
	FAssert(getExtraChanceFirstStrikes() >= 0);
/**			----  End Original Code  ----						**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}


int CvUnit::getExtraWithdrawal() const
{
	return m_iExtraWithdrawal;
}

int CvUnit::getExtraEnemyWithdrawal() const
{
	return m_iExtraEnemyWithdrawal;

}
void CvUnit::changeExtraEnemyWithdrawal(int iChange)
{
	m_iExtraEnemyWithdrawal += iChange;
}
void CvUnit::changeExtraWithdrawal(int iChange)
{
	m_iExtraWithdrawal += iChange;
/*************************************************************************************************/
/**	Tweak									25/05/10									Snarko	**/
/**																								**/
/**							Not applicable (intended to work this way)							**/
/*************************************************************************************************/
/**			---- Start Original Code ----						**
	FAssert(getExtraWithdrawal() >= 0);
/**			----  End Original Code  ----						**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getExtraCollateralDamage() const
{
	return m_iExtraCollateralDamage;
}

void CvUnit::changeExtraCollateralDamage(int iChange)
{
	m_iExtraCollateralDamage += iChange;
	FAssert(getExtraCollateralDamage() >= 0);
}

int CvUnit::getExtraBombardRate() const
{
	return m_iExtraBombardRate;
}

void CvUnit::changeExtraBombardRate(int iChange)
{
	m_iExtraBombardRate += iChange;
/*************************************************************************************************/
/**	Tweak									11/02/12									Snarko	**/
/**																								**/
/**							Not applicable (intended to work this way)							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(getExtraBombardRate() >= 0);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getExtraEnemyHeal() const
{
	return m_iExtraEnemyHeal;
}

void CvUnit::changeExtraEnemyHeal(int iChange)
{
	m_iExtraEnemyHeal += iChange;
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**		Pointless Assert since the code has been written to prevent negative Heal Values		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(getExtraEnemyHeal() >= 0);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getExtraNeutralHeal() const
{
	return m_iExtraNeutralHeal;
}

void CvUnit::changeExtraNeutralHeal(int iChange)
{
	m_iExtraNeutralHeal += iChange;
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**		Pointless Assert since the code has been written to prevent negative Heal Values		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(getExtraNeutralHeal() >= 0);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getExtraFriendlyHeal() const
{
	return m_iExtraFriendlyHeal;
}


void CvUnit::changeExtraFriendlyHeal(int iChange)
{
	m_iExtraFriendlyHeal += iChange;
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**		Pointless Assert since the code has been written to prevent negative Heal Values		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(getExtraFriendlyHeal() >= 0);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getSameTileHeal() const
{
	return m_iSameTileHeal;
}

void CvUnit::changeSameTileHeal(int iChange)
{
	m_iSameTileHeal += iChange;
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**		Pointless Assert since the code has been written to prevent negative Heal Values		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(getSameTileHeal() >= 0);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getAdjacentTileHeal() const
{
	return m_iAdjacentTileHeal;
}

void CvUnit::changeAdjacentTileHeal(int iChange)
{
	m_iAdjacentTileHeal += iChange;
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**		Pointless Assert since the code has been written to prevent negative Heal Values		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(getAdjacentTileHeal() >= 0);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

int CvUnit::getExtraCombatPercent() const
{
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
//FfH: Modified by Kael 10/26/2007
//	return m_iExtraCombatPercent;
	int i = m_iExtraCombatPercent;
	if (plot()->getOwnerINLINE() == getOwnerINLINE())
	{
		i += getCombatPercentInBorders();
	}
	return i;
//FfH: End Modify
/**								----  End Original Code  ----									**/
	return m_iExtraCombatPercent;
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
}

void CvUnit::changeExtraCombatPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCombatPercent += iChange;
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
		calculatePower();
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/

		setInfoBarDirty(true);
	}
}
int CvUnit::getExtraCombatPercentDefense() const
{
	/*************************************************************************************************/
	/**	Unit power						17/02/12										Snarko		**/
	/**																								**/
	/**							Rewriting unit power system											**/
	/*************************************************************************************************/
	/**								---- Start Original Code ----									**
	//FfH: Modified by Kael 10/26/2007
	//	return m_iExtraCombatPercent;
		int i = m_iExtraCombatPercent;
		if (plot()->getOwnerINLINE() == getOwnerINLINE())
		{
			i += getCombatPercentInBorders();
		}
		return i;
	//FfH: End Modify
	/**								----  End Original Code  ----									**/
	return m_iExtraCombatPercentDefense;
	/*************************************************************************************************/
	/**	Unit power						END															**/
	/*************************************************************************************************/
}

void CvUnit::changeExtraCombatPercentDefense(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCombatPercentDefense += iChange;
		/*************************************************************************************************/
		/**	Unit power						17/02/12										Snarko		**/
		/**																								**/
		/**							Rewriting unit power system											**/
		/*************************************************************************************************/
		calculatePower();
		/*************************************************************************************************/
		/**	Unit power						END															**/
		/*************************************************************************************************/

		setInfoBarDirty(true);
	}
}

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/**		Ensures that stacked promotions are counted equally; Should have no gameplay change		**/
/*************************************************************************************************/
int CvUnit::getExtraRangedCombatPercent() const
{
	int i = m_iExtraRangedCombatPercent;
	if (plot()->getOwnerINLINE() == getOwnerINLINE())
	{
		i += getRangedCombatPercentInBorders();
	}
	return i;
}

void CvUnit::changeExtraRangedCombatPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraRangedCombatPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getRangedCombatPercentInBorders() const
{
	return m_iRangedCombatPercentInBorders;
}

void CvUnit::changeRangedCombatPercentInBorders(int iChange)
{
	if (iChange != 0)
	{
		m_iRangedCombatPercentInBorders = (m_iRangedCombatPercentInBorders + iChange);
		setInfoBarDirty(true);
	}
}

int CvUnit::getRangedCombatPercentGlobalCounter() const
{
	return m_iRangedCombatPercentGlobalCounter;
}

void CvUnit::changeRangedCombatPercentGlobalCounter(int iChange)
{
	if (iChange != 0)
	{
		m_iRangedCombatPercentGlobalCounter = (m_iRangedCombatPercentGlobalCounter + iChange);
		setInfoBarDirty(true);
	}
}
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/

int CvUnit::getExtraCityAttackPercent() const
{
	return m_iExtraCityAttackPercent;
}

void CvUnit::changeExtraCityAttackPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCityAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraCityDefensePercent() const
{
	return m_iExtraCityDefensePercent;
}

void CvUnit::changeExtraCityDefensePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCityDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraHillsAttackPercent() const
{
	return m_iExtraHillsAttackPercent;
}

void CvUnit::changeExtraHillsAttackPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraHillsAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraHillsDefensePercent() const
{
	return m_iExtraHillsDefensePercent;
}

void CvUnit::changeExtraHillsDefensePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraHillsDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getRevoltProtection() const
{
	return m_iRevoltProtection;
}

void CvUnit::changeRevoltProtection(int iChange)
{
	if (iChange != 0)
	{
		m_iRevoltProtection += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCollateralDamageProtection() const
{
	return m_iCollateralDamageProtection;
}

void CvUnit::changeCollateralDamageProtection(int iChange)
{
	if (iChange != 0)
	{
		m_iCollateralDamageProtection += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getPillageChange() const
{
	return m_iPillageChange;
}

void CvUnit::changePillageChange(int iChange)
{
	if (iChange != 0)
	{
		m_iPillageChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getUpgradeDiscount() const
{
	return m_iUpgradeDiscount;
}

void CvUnit::changeUpgradeDiscount(int iChange)
{
	if (iChange != 0)
	{
		m_iUpgradeDiscount += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExperiencePercent() const
{
	return m_iExperiencePercent;
}

void CvUnit::changeExperiencePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExperiencePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getKamikazePercent() const
{
	return m_iKamikazePercent;
}

void CvUnit::changeKamikazePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iKamikazePercent += iChange;

		setInfoBarDirty(true);
	}
}

// checkLineOfSightProperty true returns NO_DIRECTION, false gives the unit's facing direction
DirectionTypes CvUnit::getFacingDirection(bool checkLineOfSightProperty) const
{
	return checkLineOfSightProperty ? NO_DIRECTION : m_eFacingDirection;
}

void CvUnit::setFacingDirection(DirectionTypes eFacingDirection)
{
	if (eFacingDirection != m_eFacingDirection)
	{
		m_eFacingDirection = eFacingDirection;
		//update formation
		NotifyEntity(NO_MISSION);
	}
}

void CvUnit::rotateFacingDirectionClockwise()
{
	//change direction
	DirectionTypes eNewDirection = (DirectionTypes) ((m_eFacingDirection + 1) % NUM_DIRECTION_TYPES);
	setFacingDirection(eNewDirection);
}

void CvUnit::rotateFacingDirectionCounterClockwise()
{
	//change direction
	DirectionTypes eNewDirection = (DirectionTypes) ((m_eFacingDirection + NUM_DIRECTION_TYPES - 1) % NUM_DIRECTION_TYPES);
	setFacingDirection(eNewDirection);
}

int CvUnit::getImmobileTimer() const
{

//FfH: Added by Kael 09/15/2008
	if (isHeld())
	{
		return 999;
	}
//FfH: End Add

	return m_iImmobileTimer;
}

void CvUnit::setImmobileTimer(int iNewValue)
{

//FfH: Modified by Kael 09/15/2008
//	if (iNewValue != getImmobileTimer())
//	{
//		m_iImmobileTimer = iNewValue;
//		setInfoBarDirty(true);
	if (iNewValue != getImmobileTimer() && !isHeld())
	{
		m_iImmobileTimer = iNewValue;
		setInfoBarDirty(true);
		if (getImmobileTimer() == 0)
		{
			SpellTypes delayedSpell = (SpellTypes)getDelayedSpell();
			if (delayedSpell != NO_SPELL)
			{
				cast(delayedSpell);
/*************************************************************************************************/
/**	Xienwolf Tweak							02/14/09											**/
/**																								**/
/**				Allows you to cast when you regain control of the unit							**/
/*************************************************************************************************/
				if (GC.getSpellInfo((SpellTypes)delayedSpell).isHasCasted())
				{
					if (isHasCasted())
					{
						setHasCasted(false);
					}
					else
					{
						changeCastingLimit(1);
					}
				}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
			}
		}
//FfH: End Modify

	}
}

void CvUnit::changeImmobileTimer(int iChange)
{
	if (iChange != 0)
	{
		setImmobileTimer(std::max(0, getImmobileTimer() + iChange));
	}
}

/*************************************************************************************************/
/**	MobileCage								 6/17/2009								Cyther		**/
/**	Expanded by Valkrionn					01/28/2010											**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
int CvUnit::getLeashX() const
{
	return m_iLeashX;
}

void CvUnit::setLeashX(int iNewValue)
{
	m_iLeashX = iNewValue;
}


int CvUnit::getLeashY() const
{
	return m_iLeashY;
}

void CvUnit::setLeashY(int iNewValue)
{
	m_iLeashY = iNewValue;
}

CvUnit* CvUnit::getLeashUnit() const
{
	return getUnit(m_LeashUnit);
}

void CvUnit::setLeashUnit(IDInfo iID)
{
	m_LeashUnit = iID;
}

void CvUnit::clearLeashUnit()
{
	m_LeashUnit.reset();
}

int CvUnit::getLeashRange() const
{
	return m_iLeashRange;
}

void CvUnit::setLeashRange(int iNewValue)
{
	m_iLeashRange = iNewValue;
}

void CvUnit::changeLeashRange(int iChange)
{
	m_iLeashRange += iChange;
}

int CvUnit::getLeashChance() const
{
	return m_iLeashChance;
}

void CvUnit::setLeashChance(int iNewValue)
{
	m_iLeashChance = iNewValue;
}

void CvUnit::changeLeashChance(int iChange)
{
	m_iLeashChance += iChange;
}

int CvUnit::getRandLeash() const
{
	return m_iRandLeash;
}

void CvUnit::setRandLeash(int iNewValue)
{
	m_iRandLeash = iNewValue;
}

void CvUnit::changeRandLeash(int iChange)
{
	m_iRandLeash += iChange;
}

bool CvUnit::isLeashed() const
{
	if (getLeashRange() >= 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
bool CvUnit::isLeveledImmortality() const
{
	return m_bLeveledImmortality;
}

void CvUnit::setLeveledImmortality(bool bNewValue)
{
	m_bLeveledImmortality = bNewValue;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Immortal Respawn fix						3/5/2010								Cyth	**/
/*************************************************************************************************/
bool CvUnit::isImmortDeath() const
{
	return m_bImmortDeath;
}

void CvUnit::setImmortDeath(bool bNewValue)
{
	m_bImmortDeath = bNewValue;
}
/*************************************************************************************************/
/**	TEST											END											**/
/*************************************************************************************************/

bool CvUnit::isMadeAttack() const
{
	return m_bMadeAttack;
}


void CvUnit::setMadeAttack(bool bNewValue)
{
	m_bMadeAttack = bNewValue;
}


bool CvUnit::isMadeInterception() const
{
	return m_bMadeInterception;
}


void CvUnit::setMadeInterception(bool bNewValue)
{
	m_bMadeInterception = bNewValue;
}


bool CvUnit::isPromotionReady() const
{
	return m_bPromotionReady;
}


void CvUnit::setPromotionReady(bool bNewValue)
{
	if (isPromotionReady() != bNewValue)
	{
		m_bPromotionReady = bNewValue;

/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**			Prevents loss of Build Queue when a Worker becomes ready for Promotion				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (m_bPromotionReady)
/**								----  End Original Code  ----									**/
		if (m_bPromotionReady && getBuildType() == NO_BUILD)
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		{
			getGroup()->setAutomateType(NO_AUTOMATE);
			getGroup()->clearMissionQueue();
			getGroup()->setActivityType(ACTIVITY_AWAKE);
		}

		gDLL->getEntityIFace()->showPromotionGlow(getUnitEntity(), bNewValue);

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
		}
	}
}


void CvUnit::testPromotionReady()
{
	setPromotionReady((getExperience() >= experienceNeeded()) && canAcquirePromotionAny());
}


bool CvUnit::isDelayedDeath() const
{
	return m_bDeathDelay;
}


void CvUnit::startDelayedDeath()
{
	m_bDeathDelay = true;
}


// Returns true if killed...
bool CvUnit::doDelayedDeath()
{
	if (m_bDeathDelay && !isFighting())
	{
		kill(false);
		return true;
	}

	return false;
}


bool CvUnit::isCombatFocus() const
{
	return m_bCombatFocus;
}


bool CvUnit::isInfoBarDirty() const
{
	return m_bInfoBarDirty;
}


void CvUnit::setInfoBarDirty(bool bNewValue)
{
	m_bInfoBarDirty = bNewValue;
}

bool CvUnit::isBlockading() const
{
	return m_bBlockading;
}

void CvUnit::setBlockading(bool bNewValue)
{
	if (bNewValue != isBlockading())
	{
		m_bBlockading = bNewValue;

		updatePlunder(isBlockading() ? 1 : -1, true);
	}
}

void CvUnit::collectBlockadeGold()
{
	if (plot()->getTeam() == getTeam())
	{
		return;
	}

	int iBlockadeRange = GC.getDefineINT("SHIP_BLOCKADE_RANGE");

	for (int i = -iBlockadeRange; i <= iBlockadeRange; ++i)
	{
		for (int j = -iBlockadeRange; j <= iBlockadeRange; ++j)
		{
			CvPlot* pLoopPlot = ::plotXY(getX_INLINE(), getY_INLINE(), i, j);

			if (NULL != pLoopPlot && pLoopPlot->isRevealed(getTeam(), false))
			{
				CvCity* pCity = pLoopPlot->getPlotCity();

				if (NULL != pCity && !pCity->isPlundered() && isEnemy(pCity->getTeam()) && !atWar(pCity->getTeam(), getTeam()))
				{
					if (pCity->area() == area() || pCity->plot()->isAdjacentToArea(area()))
					{
						int iGold = pCity->calculateTradeProfit(pCity) * pCity->getTradeRoutes();
						if (iGold > 0)
						{
							pCity->setPlundered(true);
							GET_PLAYER(getOwnerINLINE()).changeGold(iGold);
							GET_PLAYER(pCity->getOwnerINLINE()).changeGold(-iGold);

							CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRADE_ROUTE_PLUNDERED", getNameKey(), pCity->getNameKey(), iGold);
							gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BUILD_BANK", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE());

							szBuffer = gDLL->getText("TXT_KEY_MISC_TRADE_ROUTE_PLUNDER", getNameKey(), pCity->getNameKey(), iGold);
							gDLL->getInterfaceIFace()->addMessage(pCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BUILD_BANK", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pCity->getX_INLINE(), pCity->getY_INLINE());
						}
					}
				}
			}
		}
	}
}


PlayerTypes CvUnit::getOwner() const
{
	return getOwnerINLINE();
}

PlayerTypes CvUnit::getVisualOwner(TeamTypes eForTeam) const
{
	if (NO_TEAM == eForTeam)
	{
		eForTeam = GC.getGameINLINE().getActiveTeam();
	}

/*************************************************************************************************/
/**	MultiBarb							12/23/08									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (getTeam() != eForTeam && eForTeam != BARBARIAN_TEAM)
	{

//FfH Hidden Nationality: Modified by Kael 08/27/2007
//		if (m_pUnitInfo->isHiddenNationality())
		if (isHiddenNationality())
//FfH: End Modify

		{
			if (!plot()->isCity(true, getTeam()))
			{
				return BARBARIAN_PLAYER;
			}
		}
	}
/**								----  End Original Code  ----									**/
	if (getTeam() != eForTeam && eForTeam != ORC_TEAM && eForTeam != ANIMAL_TEAM && eForTeam != DEMON_TEAM)
	{
		if (isHiddenNationality())
		{
			if (!plot()->isCity(true, getTeam()))
			{
				if (isAnimal())
				{
					return ANIMAL_PLAYER;
				}
				else
				{
					return ORC_PLAYER;
				}
			}
		}
	}
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/

	return getOwnerINLINE();
}


PlayerTypes CvUnit::getCombatOwner(TeamTypes eForTeam, const CvPlot* pPlot) const
{
/*************************************************************************************************/
/**	MultiBarb							12/23/08									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (eForTeam != NO_TEAM && getTeam() != eForTeam && eForTeam != BARBARIAN_TEAM)
	{
		if (isAlwaysHostile(pPlot))
		{
			return BARBARIAN_PLAYER;
		}
	}
/**								----  End Original Code  ----									**/
	if (eForTeam != NO_TEAM && getTeam() != eForTeam && eForTeam != ORC_TEAM && eForTeam != ANIMAL_TEAM && eForTeam != DEMON_TEAM)
	{
		if (isAlwaysHostile(pPlot) || isHiddenNationality())
		{
			if (isAnimal())
			{
				return ANIMAL_PLAYER;
			}
			else
			{
				return ORC_PLAYER;
			}
		}
	}
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/

	return getOwnerINLINE();
}

TeamTypes CvUnit::getTeam() const
{
	return GET_PLAYER(getOwnerINLINE()).getTeam();
}


PlayerTypes CvUnit::getCapturingPlayer() const
{
	return m_eCapturingPlayer;
}


void CvUnit::setCapturingPlayer(PlayerTypes eNewValue)
{

//FfH: Modified by Kael 08/12/2007
//	m_eCapturingPlayer = eNewValue;
	if (!isImmuneToCapture())
	{
		m_eCapturingPlayer = eNewValue;
	}
//FfH: End Add

}


const UnitTypes CvUnit::getUnitType() const
{
	return m_eUnitType;
}

CvUnitInfo &CvUnit::getUnitInfo() const
{
	return *m_pUnitInfo;
}


UnitClassTypes CvUnit::getUnitClassType() const
{
	return (UnitClassTypes)m_pUnitInfo->getUnitClassType();
}

const UnitTypes CvUnit::getLeaderUnitType() const
{
	return m_eLeaderUnitType;
}

void CvUnit::setLeaderUnitType(UnitTypes leaderUnitType)
{
	if(m_eLeaderUnitType != leaderUnitType)
	{
		m_eLeaderUnitType = leaderUnitType;
		reloadEntity();
	}
}

CvUnit* CvUnit::getCombatUnit() const
{
	return getUnit(m_combatUnit);
}


void CvUnit::setCombatUnit(CvUnit* pCombatUnit, bool bAttacking)
{
	if (isCombatFocus())
	{
		gDLL->getInterfaceIFace()->setCombatFocus(false);
	}

	if (pCombatUnit != NULL)
	{
		if (bAttacking)
		{
			if (GC.getLogging())
			{
				if (gDLL->getChtLvl() > 0)
				{
					// Log info about this combat...
					char szOut[1024];
					sprintf( szOut, "*** KOMBAT!\n     ATTACKER: Player %d Unit %d (%S's %S), CombatStrength=%d\n     DEFENDER: Player %d Unit %d (%S's %S), CombatStrength=%d\n",
						getOwnerINLINE(), getID(), GET_PLAYER(getOwnerINLINE()).getName(), getName().GetCString(), currCombatStr(NULL, NULL),
						pCombatUnit->getOwnerINLINE(), pCombatUnit->getID(), GET_PLAYER(pCombatUnit->getOwnerINLINE()).getName(), pCombatUnit->getName().GetCString(), pCombatUnit->currCombatStr(pCombatUnit->plot(), this));
					gDLL->messageControlLog(szOut);
				}
			}

			if (getDomainType() == DOMAIN_LAND
				&& !m_pUnitInfo->isIgnoreBuildingDefense()
				&& pCombatUnit->plot()->getPlotCity()
				&& pCombatUnit->plot()->getPlotCity()->getBuildingDefense() > 0
				&& cityAttackModifier() >= GC.getDefineINT("MIN_CITY_ATTACK_MODIFIER_FOR_SIEGE_TOWER"))
			{
				CvDLLEntity::SetSiegeTower(true);
			}
		}

		FAssertMsg(getCombatUnit() == NULL, "Combat Unit is not expected to be assigned");
		FAssertMsg(!(plot()->isFighting()), "(plot()->isFighting()) did not return false as expected");
		m_bCombatFocus = (bAttacking && !(gDLL->getInterfaceIFace()->isFocusedWidget()) && ((getOwnerINLINE() == GC.getGameINLINE().getActivePlayer()) || ((pCombatUnit->getOwnerINLINE() == GC.getGameINLINE().getActivePlayer()) && !(GC.getGameINLINE().isMPOption(MPOPTION_SIMULTANEOUS_TURNS)))));
		m_combatUnit = pCombatUnit->getIDInfo();
/*************************************************************************************************/
/**	Higher hitpoints				28/02/12				Imported from wiser orcs by Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : (firstStrikes() + GC.getGameINLINE().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike")));
/**								----  End Original Code  ----									**/
		// Smarter Orcs start
		static int iFirstStrikeFactor = GC.getDefineINT("HIT_POINT_FACTOR");
		setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : iFirstStrikeFactor * ((firstStrikes() + GC.getGameINLINE().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike"))));
		// Smarter Orcs end
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
	}
	else
	{
		if(getCombatUnit() != NULL)
		{
			FAssertMsg(getCombatUnit() != NULL, "getCombatUnit() is not expected to be equal with NULL");
			FAssertMsg(plot()->isFighting(), "plot()->isFighting is expected to be true");
			m_bCombatFocus = false;
			m_combatUnit.reset();
			setCombatFirstStrikes(0);

			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}

			if (plot() == gDLL->getInterfaceIFace()->getSelectionPlot())
			{
				gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
			}

			CvDLLEntity::SetSiegeTower(false);
		}
	}

	setCombatTimer(0);
	setInfoBarDirty(true);

	if (isCombatFocus())
	{
		gDLL->getInterfaceIFace()->setCombatFocus(true);
	}
}


CvUnit* CvUnit::getTransportUnit() const
{
	return getUnit(m_transportUnit);
}


bool CvUnit::isCargo() const
{
	return (getTransportUnit() != NULL);
}


void CvUnit::setTransportUnit(CvUnit* pTransportUnit)
{
	CvUnit* pOldTransportUnit;

	pOldTransportUnit = getTransportUnit();

	if (pOldTransportUnit != pTransportUnit)
	{
		if (pOldTransportUnit != NULL)
		{
			pOldTransportUnit->changeCargo(-1);
		}

		if (pTransportUnit != NULL)
		{
			FAssertMsg(pTransportUnit->cargoSpaceAvailable(getSpecialUnitType(), getDomainType()) > 0, "Cargo space is expected to be available");

			joinGroup(NULL, true); // Because what if a group of 3 tries to get in a transport which can hold 2...

			m_transportUnit = pTransportUnit->getIDInfo();

			if (getDomainType() != DOMAIN_AIR)
			{
				getGroup()->setActivityType(ACTIVITY_SLEEP);
			}

			if (GC.getGameINLINE().isFinalInitialized())
			{
				finishMoves();
			}

			pTransportUnit->changeCargo(1);
			pTransportUnit->getGroup()->setActivityType(ACTIVITY_AWAKE);
		}
		else
		{
			m_transportUnit.reset();

			getGroup()->setActivityType(ACTIVITY_AWAKE);
		}

#ifdef _DEBUG
		std::vector<CvUnit*> aCargoUnits;
		if (pOldTransportUnit != NULL)
		{
			pOldTransportUnit->getCargoUnits(aCargoUnits);
		}
		if (pTransportUnit != NULL)
		{
			pTransportUnit->getCargoUnits(aCargoUnits);
		}
#endif

	}
}


int CvUnit::getExtraDomainModifier(DomainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiExtraDomainModifier[eIndex];
}


void CvUnit::changeExtraDomainModifier(DomainTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	m_aiExtraDomainModifier[eIndex] = (m_aiExtraDomainModifier[eIndex] + iChange);
}


const CvWString CvUnit::getName(uint uiForm) const
{
	CvWString szBuffer;

	if (m_szName.empty())
/*************************************************************************************************/
/**	Moniker							07/13/08										Xienwolf	**/
/**																								**/
/**						Allows Overriding of the Base Description of the Unit					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	{
		return m_pUnitInfo->getDescription(uiForm);
	}

	szBuffer.Format(L"%s (%s)", m_szName.GetCString(), m_pUnitInfo->getDescription(uiForm));
/**								----  End Original Code  ----									**/
	{
		return (m_szNewName.empty() ? m_pUnitInfo->getDescription(uiForm) : gDLL->getObjectText(m_szNewName, uiForm, true));
	}

	szBuffer.Format(L"%s (%s)", m_szName.GetCString(), (m_szNewName.empty() ? m_pUnitInfo->getDescription(uiForm) : gDLL->getObjectText(m_szNewName, uiForm, true)));
/*************************************************************************************************/
/**	Moniker										END												**/
/*************************************************************************************************/

	return szBuffer;
}


const wchar* CvUnit::getNameKey() const
{
	if (m_szName.empty())
	{
		return m_pUnitInfo->getTextKeyWide();
	}
	else
	{
		return m_szName.GetCString();
	}
}


const CvWString& CvUnit::getNameNoDesc() const
{
	return m_szName;
}


void CvUnit::setName(CvWString szNewValue)
{
	gDLL->stripSpecialCharacters(szNewValue);

	m_szName = szNewValue;

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
	}
}


std::string CvUnit::getScriptData() const
{
	return m_szScriptData;
}


void CvUnit::setScriptData(std::string szNewValue)
{
	m_szScriptData = szNewValue;
}
const TCHAR* CvUnit::getReplaceArtDefineTag() const
{
	return m_szReplaceArtDefineTag;
}


void CvUnit::setReplaceArtDefineTag(const TCHAR* szNewValue)
{
	m_szReplaceArtDefineTag = szNewValue;
}

const TCHAR* CvUnit::getExtraArtDefineTag() const
{
	return m_szExtraArtDefineTag;
}


void CvUnit::setExtraArtDefineTag(const TCHAR* szNewValue)
{
	m_szExtraArtDefineTag = szNewValue;
}

const TCHAR* CvUnit::getExtraArtDefineTag2() const
{
	return m_szExtraArtDefineTag2;
}


void CvUnit::setExtraArtDefineTag2(const TCHAR* szNewValue)
{
	m_szExtraArtDefineTag2 = szNewValue;
}

const TCHAR* CvUnit::getExtraArtDefineTag3() const
{
	return m_szExtraArtDefineTag3;
}


void CvUnit::setExtraArtDefineTag3(const TCHAR* szNewValue)
{
	m_szExtraArtDefineTag3 = szNewValue;
}


int CvUnit::getNoBadExploreImprovement(ImprovementTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiNoBadExploreImprovement[eIndex];
}
void CvUnit::changeNoBadExploreImprovement(ImprovementTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiNoBadExploreImprovement[eIndex] = (m_paiNoBadExploreImprovement[eIndex] + iChange);
}

int CvUnit::getTerrainDoubleMoveCount(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiTerrainDoubleMoveCount[eIndex];
}


bool CvUnit::isTerrainDoubleMove(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return (getTerrainDoubleMoveCount(eIndex) > 0);
}


void CvUnit::changeTerrainDoubleMoveCount(TerrainTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiTerrainDoubleMoveCount[eIndex] = (m_paiTerrainDoubleMoveCount[eIndex] + iChange);
	FAssert(getTerrainDoubleMoveCount(eIndex) >= 0);
}


int CvUnit::getFeatureDoubleMoveCount(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiFeatureDoubleMoveCount[eIndex];
}


bool CvUnit::isFeatureDoubleMove(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return (getFeatureDoubleMoveCount(eIndex) > 0);
}


void CvUnit::changeFeatureDoubleMoveCount(FeatureTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiFeatureDoubleMoveCount[eIndex] = (m_paiFeatureDoubleMoveCount[eIndex] + iChange);
	FAssert(getFeatureDoubleMoveCount(eIndex) >= 0);
}


int CvUnit::getExtraTerrainAttackPercent(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraTerrainAttackPercent[eIndex];
}


void CvUnit::changeExtraTerrainAttackPercent(TerrainTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiExtraTerrainAttackPercent[eIndex] += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraTerrainDefensePercent(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraTerrainDefensePercent[eIndex];
}


void CvUnit::changeExtraTerrainDefensePercent(TerrainTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiExtraTerrainDefensePercent[eIndex] += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraFeatureAttackPercent(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraFeatureAttackPercent[eIndex];
}


void CvUnit::changeExtraFeatureAttackPercent(FeatureTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiExtraFeatureAttackPercent[eIndex] += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraFeatureDefensePercent(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraFeatureDefensePercent[eIndex];
}


void CvUnit::changeExtraFeatureDefensePercent(FeatureTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiExtraFeatureDefensePercent[eIndex] += iChange;

		setInfoBarDirty(true);
	}
}
int CvUnit::getPlotEffectDoubleMoveCount(PlotEffectTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPlotEffectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiPlotEffectDoubleMoveCount[eIndex];
}


bool CvUnit::isPlotEffectDoubleMove(PlotEffectTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPlotEffectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return (getPlotEffectDoubleMoveCount(eIndex) > 0);
}


void CvUnit::changePlotEffectDoubleMoveCount(PlotEffectTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPlotEffectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiPlotEffectDoubleMoveCount[eIndex] = (m_paiPlotEffectDoubleMoveCount[eIndex] + iChange);
	FAssert(getPlotEffectDoubleMoveCount(eIndex) >= 0);
}


int CvUnit::getExtraPlotEffectAttackPercent(PlotEffectTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPlotEffectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraPlotEffectAttackPercent[eIndex];
}


void CvUnit::changeExtraPlotEffectAttackPercent(PlotEffectTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPlotEffectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiExtraPlotEffectAttackPercent[eIndex] += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraPlotEffectDefensePercent(PlotEffectTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPlotEffectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraPlotEffectDefensePercent[eIndex];
}


void CvUnit::changeExtraPlotEffectDefensePercent(PlotEffectTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPlotEffectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiExtraPlotEffectDefensePercent[eIndex] += iChange;

		setInfoBarDirty(true);
	}
}

/*************************************************************************************************/
/**	GWS							2010-08-23												Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
int CvUnit::getHillCostModifier() const
{
	return m_iHillCost;
}

void CvUnit::changeHillCostModifier(int iChange)
{
	if (iChange != 0)
	{
		m_iHillCost += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getPeakCostModifier() const
{
	return m_iPeakCost;
}

void CvUnit::changePeakCostModifier(int iChange)
{
	if (iChange != 0)
	{
		m_iPeakCost += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getTerrainCostModifier(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiTerrainCost[eIndex];
}

void CvUnit::changeTerrainCostModifier(TerrainTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	if (iChange != 0)
	{
		m_paiTerrainCost[eIndex] += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getFeatureCostModifier(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiFeatureCost[eIndex];
}

void CvUnit::changeFeatureCostModifier(FeatureTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	if (iChange != 0)
	{
		m_paiFeatureCost[eIndex] += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getHillCost() const
{
	return (m_pUnitInfo->getUnitHillCost() + getHillCostModifier());
}

int CvUnit::getPeakCost() const
{
	return (m_pUnitInfo->getUnitPeakCost() + getPeakCostModifier());
}

int CvUnit::getTerrainCost(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getUnitTerrainCost(eIndex) + getTerrainCostModifier(eIndex));
}

int CvUnit::getFeatureCost(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return (m_pUnitInfo->getUnitFeatureCost(eIndex) + getFeatureCostModifier(eIndex));
}

/*
// Promotions
int CvUnit::getPromotionPeakCost() const
{
	return m_iPromotionPeakCost;
}

void CvUnit::changePromotionPeakCost(int iChange)
{
	if (iChange != 0)
	{
		m_iPromotionPeakCost += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getPromotionHillCost() const
{
	return m_iPromotionHillCost;
}

void CvUnit::changePromotionHillCost(int iChange)
{
	if (iChange != 0)
	{
		m_iPromotionHillCost += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getPromotionTerrainCost(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiPromotionTerrainCost[eIndex];
}

void CvUnit::changePromotionTerrainCost(TerrainTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	if (iChange != 0)
	{
		m_paiPromotionTerrainCost[eIndex] += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getPromotionFeatureCost(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiPromotionFeatureCost[eIndex];
}

void CvUnit::changePromotionFeatureCost(FeatureTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	if (iChange != 0)
	{
		m_paiPromotionFeatureCost[eIndex] += iChange;
		setInfoBarDirty(true);
	}
}

// Units
int CvUnit::getUnitPeakCost() const
{
	return m_iUnitPeakCost;
}

void CvUnit::changeUnitPeakCost(int iChange)
{
	if (iChange != 0)
	{
		m_iUnitPeakCost += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getUnitHillCost() const
{
	return m_iUnitHillCost;
}

void CvUnit::changeUnitHillCost(int iChange)
{
	if (iChange != 0)
	{
		m_iUnitHillCost += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getUnitTerrainCost(TerrainTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitTerrainCost[eIndex];
}

void CvUnit::changeUnitTerrainCost(TerrainTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	if (iChange != 0)
	{
		m_paiUnitTerrainCost[eIndex] += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getUnitFeatureCost(FeatureTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitFeatureCost[eIndex];
}

void CvUnit::changeUnitFeatureCost(FeatureTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumFeatureInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	if (iChange != 0)
	{
		m_paiUnitFeatureCost[eIndex] += iChange;
		setInfoBarDirty(true);
	}
}
*/
/*************************************************************************************************/
/**	GWS											END												**/
/*************************************************************************************************/

int CvUnit::getExtraUnitCombatModifier(UnitCombatTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumUnitCombatInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraUnitCombatModifier[eIndex];
}


void CvUnit::changeExtraUnitCombatModifier(UnitCombatTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumUnitCombatInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiExtraUnitCombatModifier[eIndex] = (m_paiExtraUnitCombatModifier[eIndex] + iChange);
}

int CvUnit::getExtraSpellClassPower(SpellClassTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumSpellClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiExtraSpellClassPower[eIndex];
}


void CvUnit::changeExtraSpellClassPower(SpellClassTypes eIndex, int iChange)
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumSpellClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiExtraSpellClassPower[eIndex] = (m_paiExtraSpellClassPower[eIndex] + iChange);
}


bool CvUnit::canAcquirePromotion(PromotionTypes ePromotion,bool bMustMaintainCheck) const
{
	FAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	FAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");

	PROFILE("CvUnit::canAcquirePromotion");
/*************************************************************************************************/
/**	Tweak								30/01/12										Snarko	**/
/**																								**/
/**		Reordering to improve speed by making common fails first and slow checks last			**/
/**		I have not kept the original code because... well this is the original code.			**/
/**		I just changed the order of the calls to accomplish what I said above					**/
/*************************************************************************************************/
	if (GC.getPromotionInfo(ePromotion).getMinLevel() == -1 && !bMustMaintainCheck)
	{
		return false;
	}
	if (GC.getPromotionInfo(ePromotion).isRace())
	{
		return false;
	}
	if (GC.getPromotionInfo(ePromotion).isEquipment() && GC.getPromotionInfo(ePromotion).getGoldCost()==0)
	{
		return false;
	}

	if (GC.getPromotionInfo(ePromotion).getTechPrereq() != NO_TECH)
	{
		if (!(GET_TEAM(getTeam()).isHasTech((TechTypes)(GC.getPromotionInfo(ePromotion).getTechPrereq()))))
		{
			return false;
		}
	}

	if (GC.getPromotionInfo(ePromotion).getGoldCost() > 0 && GET_PLAYER(getOwnerINLINE()).getGold() < GC.getPromotionInfo(ePromotion).getGoldCost() && !GC.getPromotionInfo(ePromotion).isMustMaintain())
	{
		return false;
	}

	if (GC.getPromotionInfo(ePromotion).getPrereqPromotion() != NO_PROMOTION)
	{
		if (!isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPrereqPromotion())))
		{
			return false;
		}
	}


/*************************************************************************************************/
/**	Stackable								07/16/08								Xienwolf	**/
/**	AutoBots								07/16/08								Xienwolf	**/
/**						Allows a Promotion to be gained multiple Times							**/
/**				Prevents having the promotion from counting as a loss condition					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (isHasPromotion(ePromotion))
/**								----  End Original Code  ----									**/
	if (isHasPromotion(ePromotion) && !GC.getPromotionInfo(ePromotion).isStackEffect() && !GC.getPromotionInfo(ePromotion).isMustMaintain())
/*************************************************************************************************/
/**	Stackable									END												**/
/**	AutoBots									END												**/
/*************************************************************************************************/
	{
		return false;
	}

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	if ((GC.getPromotionInfo(ePromotion).getMaxApplications() > 0) || (GC.getPromotionInfo(ePromotion).getUnitCombatMaxApplications(getUnitCombatType()) > 0))
	{
		int iMaxApplications = GC.getPromotionInfo(ePromotion).getMaxApplications();
		if (GC.getPromotionInfo(ePromotion).getUnitCombatMaxApplications(getUnitCombatType()) > 0)
		{
			iMaxApplications = GC.getPromotionInfo(ePromotion).getUnitCombatMaxApplications(getUnitCombatType());
		}
		if (countHasPromotion(ePromotion) >= iMaxApplications)
		{
			return false;
		}
	}
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		08/09/08								Xienwolf	**/
/**																								**/
/**								Blocks Actions based on New PreReqs								**/
/*************************************************************************************************/
	if (isDenyPromotion(ePromotion) || (GC.getPromotionInfo(ePromotion).isRequirePermission() && !isAllowPromotion(ePromotion)))
	{
	   return false;
	}

	if (ePromotion == GC.getDefineINT("NULL_PROMOTION"))
	{
		return isNullPromoteAvailable();
	}

	bool bValid;

	int iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqUnits();
	if (iNumPrereqs > 0 && !isAllowPromotion(ePromotion))
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (getUnitType() == (UnitTypes)GC.getPromotionInfo(ePromotion).getPrereqUnit(iI))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqReligions();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).getStateReligion() == GC.getPromotionInfo(ePromotion).getPrereqReligion(iI))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqCivics();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).isCivic((CivicTypes)GC.getPromotionInfo(ePromotion).getPrereqCivic(iI)))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqTechANDs();
	if (iNumPrereqs > 0)
	{
		bValid = true;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (!GET_TEAM(getTeam()).isHasTech((TechTypes)GC.getPromotionInfo(ePromotion).getPrereqTechAND(iI)))
			{
				bValid = false;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqTechORs();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_TEAM(getTeam()).isHasTech((TechTypes)GC.getPromotionInfo(ePromotion).getPrereqTechOR(iI)))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqAlignments();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).getAlignment() == GC.getPromotionInfo(ePromotion).getPrereqAlignment(iI))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqEthicalAlignments();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).getEthicalAlignment() == GC.getPromotionInfo(ePromotion).getPrereqEthicalAlignment(iI))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqCivilizations();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).getCivilizationType() == (CivilizationTypes)GC.getPromotionInfo(ePromotion).getPrereqCivilization(iI))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**				Check relocated to isPromotionValid for benefit of Goody Validation				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (!isAllowPromotion(ePromotion) && GC.getPromotionInfo(ePromotion).getPrereqTier() != 0 && m_pUnitInfo->getTier() < GC.getPromotionInfo(ePromotion).getPrereqTier())
	{
		return false;
	}

	if (!isAllowPromotion(ePromotion) && GC.getPromotionInfo(ePromotion).getPrereqWeaponTier() != 0 && (m_pUnitInfo->getWeaponTierMax() < GC.getPromotionInfo(ePromotion).getPrereqWeaponTier() || m_pUnitInfo->getWeaponTierMin() > GC.getPromotionInfo(ePromotion).getPrereqWeaponTier()))
	{
		return false;
	}

/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if ((GC.getPromotionInfo(ePromotion).isPrereqInCity() || GC.getPromotionInfo(ePromotion).getNumPrereqBuildingORs() > 0 || GC.getPromotionInfo(ePromotion).getNumPrereqBuildingANDs() > 0))
	{
		if (plot() == NULL || !plot()->isCity())
		{
			return false;
		}
	}

	if (GC.getPromotionInfo(ePromotion).getPrereqMinAge() > 0)
	{
		if (((GC.getGameINLINE().getGameTurn() - getGameTurnCreated()) * 100 / GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent()) < (GC.getPromotionInfo(ePromotion).getPrereqMinAge()))
		{
			return false;
		}
	}
	if (GC.getPromotionInfo(ePromotion).isPrereqRevealed() && (!isRevealed()))
	{
		return false;
	}
	if (GC.getPromotionInfo(ePromotion).isPrereqHidden() && (!isHidden()))
	{
		return false;
	}

	if (GC.getPromotionInfo(ePromotion).getPrereqMaxAge() > 0)
	{
		if (((GC.getGameINLINE().getGameTurn() - getGameTurnCreated()) * 100 / GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent()) > (GC.getPromotionInfo(ePromotion).getPrereqMaxAge()))
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqTraits();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).hasTrait((TraitTypes)GC.getPromotionInfo(ePromotion).getPrereqTrait(iI)))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqCorporations();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).countCorporations((CorporationTypes)GC.getPromotionInfo(ePromotion).getPrereqCorporation(iI)) > 0)
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	if (plot() == NULL)
	{
		if (GC.getPromotionInfo(ePromotion).isPrereqInBorderEnemy())
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).isPrereqInBorderRival())
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).isPrereqInBorderTeam())
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).isPrereqInBorderSelf())
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).isPrereqInBorderNone()) //Technically NULL plot doesn't belong to anyone, does it?
		{
			return false;
		}

		if (GC.getPromotionInfo(ePromotion).getNumPrereqFeatures() > 0)
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).getNumPrereqPlotEffects() > 0)
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).getNumPrereqImprovements() > 0)
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).getNumPrereqTerrains() > 0)
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).getNumPrereqPromotionsOnTile() > 0)
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).getNumPrereqUnitClassesOnTile() > 0)
		{
			return false;
		}
		if (GC.getPromotionInfo(ePromotion).getNumPrereqUnitTypesOnTile() > 0)
		{
			return false;
		}
	}
	else
	{
		//Not neccesarily faster this way, I just found it hard to read that old stuff with a really long if statement.
		bValid = true;
		if (GC.getPromotionInfo(ePromotion).isPrereqInBorderSelf() && plot()->getOwner() != getOwner())
		{
			bValid = false;
		}
		else if (GC.getPromotionInfo(ePromotion).isPrereqInBorderTeam() && plot()->getTeam() != getTeam())
		{
			bValid = false;
		}
		else if (plot()->isOwned())
		{
			if (GC.getPromotionInfo(ePromotion).isPrereqInBorderEnemy() && !GET_TEAM(plot()->getTeam()).isAtWar(getTeam()))
			{
				bValid = false;
			}
			else if (GC.getPromotionInfo(ePromotion).isPrereqInBorderRival() && (plot()->getTeam() == getTeam()))
			{
				bValid = false;
			}
		}
		else
		{
			if (GC.getPromotionInfo(ePromotion).isPrereqInBorderNone() && plot()->isOwned())
			{
				bValid = false;
			}
		}
		if (!bValid)
		{
			return false;
		}

		CvCity* pCity = plot()->getPlotCity();
		if (pCity != NULL)
		{
			iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqBuildingORs();
			if (iNumPrereqs > 0)
			{
				bValid = false;
				for (int iI = 0; iI < iNumPrereqs; iI++)
				{
					if (pCity->getNumBuilding((BuildingTypes)GC.getPromotionInfo(ePromotion).getPrereqBuildingOR(iI)) > 0)
					{
						bValid = true;
						break;
					}
				}
				if (!bValid)
				{
					return false;
				}
			}

			iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqBuildingANDs();
			if (iNumPrereqs > 0)
			{
				bValid = true;
				for (int iI = 0; iI < iNumPrereqs; iI++)
				{
					if (pCity->getNumBuilding((BuildingTypes)GC.getPromotionInfo(ePromotion).getPrereqBuildingAND(iI)) < 1)
					{
						bValid = false;
						break;
					}
				}
				if (!bValid)
				{
					return false;
				}
			}
		}

		int iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqUnitTypesOnTile();
		if (iNumPrereqs > 0)
		{
			bValid = true;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getNumUnitType((UnitTypes)GC.getPromotionInfo(ePromotion).getPrereqUnitTypeOnTile(iI), getOwner()) == 0)
				{
					bValid = false;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqUnitClassesOnTile();
		if (iNumPrereqs > 0)
		{
			bValid = true;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getNumUnitClass((UnitClassTypes)GC.getPromotionInfo(ePromotion).getPrereqUnitClassOnTile(iI), getOwner()) == 0)
				{
					bValid = false;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqPromotionsOnTile();
		if (iNumPrereqs > 0)
		{
			bValid = true;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getNumPromotion((PromotionTypes)GC.getPromotionInfo(ePromotion).getPrereqPromotionOnTile(iI),true, getOwner()) == 0)
				{
					bValid = false;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqUnitTypesNOTOnTile();
		if (iNumPrereqs > 0)
		{
			bValid = true;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getNumUnitType((UnitTypes)GC.getPromotionInfo(ePromotion).getPrereqUnitTypeNOTOnTile(iI), getOwner()) > 0)
				{
					bValid = false;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqUnitClassesNOTOnTile();
		if (iNumPrereqs > 0)
		{
			bValid = true;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getNumUnitClass((UnitClassTypes)GC.getPromotionInfo(ePromotion).getPrereqUnitClassNOTOnTile(iI), getOwner()) > 0)
				{
					bValid = false;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqPromotionsNOTOnTile();
		if (iNumPrereqs > 0)
		{
			bValid = true;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getNumPromotion((PromotionTypes)GC.getPromotionInfo(ePromotion).getPrereqPromotionNOTOnTile(iI), true, getOwner()) > 0)
				{
					bValid = false;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqFeatures();
		if (iNumPrereqs > 0)
		{
			bValid = false;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getFeatureType() == (FeatureTypes)GC.getPromotionInfo(ePromotion).getPrereqFeature(iI))
				{
					bValid = true;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqPlotEffects();
		if (iNumPrereqs > 0)
		{
			bValid = false;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getPlotEffectType() == (PlotEffectTypes)GC.getPromotionInfo(ePromotion).getPrereqPlotEffect(iI))
				{
					bValid = true;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqImprovements();
		if (iNumPrereqs > 0)
		{
			bValid = false;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getImprovementType() == (ImprovementTypes)GC.getPromotionInfo(ePromotion).getPrereqImprovement(iI))
				{
					bValid = true;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}

		iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqTerrains();
		if (iNumPrereqs > 0)
		{
			bValid = false;
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (plot()->getTerrainType() == (TerrainTypes)GC.getPromotionInfo(ePromotion).getPrereqTerrain(iI))
				{
					bValid = true;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqBonusORs();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).hasBonus((BonusTypes)GC.getPromotionInfo(ePromotion).getPrereqBonusOR(iI)))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqBonusANDs();
	if (iNumPrereqs > 0)
	{
		bValid = true;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (!GET_PLAYER(getOwner()).hasBonus((BonusTypes)GC.getPromotionInfo(ePromotion).getPrereqBonusAND(iI)))
			{
				bValid = false;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqEventANDs();
	if (iNumPrereqs > 0)
	{
		bValid = true;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).getEventOccured((EventTypes)GC.getPromotionInfo(ePromotion).getPrereqEventAND(iI)) == NULL)
			{
				bValid = false;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqEventORs();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).getEventOccured((EventTypes)GC.getPromotionInfo(ePromotion).getPrereqEventOR(iI)) != NULL)
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqFeatANDs();
	if (iNumPrereqs > 0)
	{
		bValid = true;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (!GET_PLAYER(getOwner()).isFeatAccomplished((FeatTypes)GC.getPromotionInfo(ePromotion).getPrereqFeatAND(iI)))
			{
				bValid = false;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqFeatORs();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).isFeatAccomplished((FeatTypes)GC.getPromotionInfo(ePromotion).getPrereqFeatOR(iI)))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqFeatNOTs();
	if (iNumPrereqs > 0)
	{
		bValid = true;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			if (GET_PLAYER(getOwner()).isFeatAccomplished((FeatTypes)GC.getPromotionInfo(ePromotion).getPrereqFeatNOT(iI)))
			{
				bValid = false;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH: Modified by Kael 07/30/2007
//	if (GC.getPromotionInfo(ePromotion).getPrereqOrPromotion1() != NO_PROMOTION)
//	{
//		if (!isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPrereqOrPromotion1())))
//		{
//			if ((GC.getPromotionInfo(ePromotion).getPrereqOrPromotion2() == NO_PROMOTION) || !isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPrereqOrPromotion2())))
//			{
//				return false;
//			}
//		}
//	}
	if (GC.getPromotionInfo(ePromotion).getMinLevel() > getLevel())
	{
		return false;
	}
/*************************************************************************************************/
/**	PrereqStrBoostSize						10/16/09								Valkrionn	**/
/**																								**/
/**					Allows a units StrBoost to be used as a promotion prereq					**/
/*************************************************************************************************/
	if (GC.getPromotionInfo(ePromotion).getPrereqStrBoostSize() >0 && GC.getPromotionInfo(ePromotion).getPrereqStrBoostSize()> getStrBoost())
	{
		return false;
	}
/*************************************************************************************************/
/**	PrereqStrBoostSize							END												**/
/*************************************************************************************************/
	if (GC.getPromotionInfo(ePromotion).getPromotionPrereqAnd() != NO_PROMOTION)
	{
		if (!isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPromotionPrereqAnd())))
		{
			return false;
		}
	}
	//PrereqUnitReligion by BI 07/24/11
	if (GC.getPromotionInfo(ePromotion).getUnitReligionPrereq() != NO_RELIGION)
	{
		if (getReligion()!=GC.getPromotionInfo(ePromotion).getUnitReligionPrereq())
		{
			return false;
		}
	}
	//PrereqUnitReligion by BI 07/24/11  END
	if (GC.getPromotionInfo(ePromotion).getPrereqOrPromotion1() != NO_PROMOTION)
	{
		bool bValid = false;
		if (isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPrereqOrPromotion1())))
		{
			bValid = true;
		}
		if (GC.getPromotionInfo(ePromotion).getPrereqOrPromotion2() != NO_PROMOTION)
		{
			if (isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPrereqOrPromotion2())))
			{
				bValid = true;
			}
		}
		if (GC.getPromotionInfo(ePromotion).getPromotionPrereqOr3() != NO_PROMOTION)
		{
			if (isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPromotionPrereqOr3())))
			{
				bValid = true;
			}
		}
		if (GC.getPromotionInfo(ePromotion).getPromotionPrereqOr4() != NO_PROMOTION)
		{
			if (isHasPromotion((PromotionTypes)(GC.getPromotionInfo(ePromotion).getPromotionPrereqOr4())))
			{
				bValid = true;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}
	if (GC.getPromotionInfo(ePromotion).getBonusPrereq() != NO_BONUS)
	{
		if (!GET_PLAYER(getOwnerINLINE()).hasBonus((BonusTypes)GC.getPromotionInfo(ePromotion).getBonusPrereq()))
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**				Check relocated to isPromotionValid for benefit of Goody Validation				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune1() == ePromotion)
			{
				return false;
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune2() == ePromotion)
			{
				return false;
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune3() == ePromotion)
			{
				return false;
			}
		}
	}
	if (GC.getPromotionInfo(ePromotion).isPrereqAlive())
	{
		if (!isAlive())
		{
			return false;
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
//FfH: End Add

/*************************************************************************************************/
/**	Broader Alignments						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**					Allows Promotions to be Restricted to certain Alignments					**/
/*************************************************************************************************/
	if (GC.getGameINLINE().isOption(GAMEOPTION_BROADER_ALIGNMENTS))
	{
		if (GC.getPromotionInfo(ePromotion).getPrereqBroadAlignment() != 0)
		{
			if (GC.getPromotionInfo(ePromotion).getPrereqBroadAlignment() > 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadAlignment() < GC.getPromotionInfo(ePromotion).getPrereqBroadAlignment())
				{
					return false;
				}
			}
			if (GC.getPromotionInfo(ePromotion).getPrereqBroadAlignment() < 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadAlignment() > GC.getPromotionInfo(ePromotion).getPrereqBroadAlignment())
				{
					return false;
				}
			}
		}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
		if (GC.getPromotionInfo(ePromotion).getPrereqBroadEthicalAlignment() != 0)
		{
			if (GC.getPromotionInfo(ePromotion).getPrereqBroadEthicalAlignment() > 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadEthicalAlignment() < GC.getPromotionInfo(ePromotion).getPrereqBroadEthicalAlignment())
				{
					return false;
				}
			}
			if (GC.getPromotionInfo(ePromotion).getPrereqBroadEthicalAlignment() < 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadEthicalAlignment() > GC.getPromotionInfo(ePromotion).getPrereqBroadEthicalAlignment())
				{
					return false;
				}
			}
		}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	}
/*************************************************************************************************/
/**	Broader Alignments							END												**/
/*************************************************************************************************/
	if (GC.getPromotionInfo(ePromotion).getStateReligionPrereq() != NO_RELIGION)
	{
		if (GET_PLAYER(getOwnerINLINE()).getStateReligion() != GC.getPromotionInfo(ePromotion).getStateReligionPrereq())
		{
			return false;
		}
	}

/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
	/* original code
	bool bOrPrereqFound = false;
	bool bOrPrereqValid = false;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (GC.getPromotionInfo(ePromotion).getPrereqPromotionANDs(iI) > 0)
		{
			if (!(countHasPromotion((PromotionTypes)iI) >= GC.getPromotionInfo(ePromotion).getPrereqPromotionANDs(iI)))
			{
				return false;
			}
		}
		if (GC.getPromotionInfo(ePromotion).getPrereqPromotionORs(iI) > 0)
		{
			bOrPrereqFound = true;
			PromotionTypes ePrereqOR = (PromotionTypes)iI;
			if (countHasPromotion((PromotionTypes)iI) >= GC.getPromotionInfo(ePromotion).getPrereqPromotionORs(iI))
			{
				bOrPrereqValid = true;
			}
		}
	}
	if (bOrPrereqFound && !bOrPrereqValid)
	{
		return false;
	}
	*/
	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqPromotionANDs();
	if (iNumPrereqs > 0)
	{
		bValid = true;
		int iPromotion;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			iPromotion = GC.getPromotionInfo(ePromotion).getPrereqPromotionANDs(iI);
			if (countHasPromotion((PromotionTypes)iPromotion) < GC.getPromotionInfo(ePromotion).getPrereqPromotionANDs(iI, true))
			{
				bValid = false;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}
	iNumPrereqs = GC.getPromotionInfo(ePromotion).getNumPrereqPromotionORs();
	if (iNumPrereqs > 0)
	{
		bValid = false;
		int iPromotion;
		for (int iI = 0; iI < iNumPrereqs; iI++)
		{
			iPromotion = GC.getPromotionInfo(ePromotion).getPrereqPromotionORs(iI);
			if (countHasPromotion((PromotionTypes)iPromotion) >= GC.getPromotionInfo(ePromotion).getPrereqPromotionORs(iI, true))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/

	if (!(isPromotionValid(ePromotion)||(bMustMaintainCheck && GC.getPromotionInfo(ePromotion).isMustMaintain() && isHasPromotion(ePromotion)) ))
	{
		return false;
	}

	return true;
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

bool CvUnit::isPromotionValid(PromotionTypes ePromotion) const
{
	PROFILE_FUNC();

/*************************************************************************************************/
/**	Xienwolf Tweak							09/24/08											**/
/**																								**/
/**		There are no checks in this function which remain Globally valid for Fall Further		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	CvPromotionInfo& promotionInfo = GC.getPromotionInfo(ePromotion);

	if (!::isPromotionValid(ePromotion, getUnitType(), true))
	{
		return false;
	}

	CvPromotionInfo& promotionInfo = GC.getPromotionInfo(ePromotion);

//FfH: Modified by Kael 10/28/2008
//	if (promotionInfo.getWithdrawalChange() + m_pUnitInfo->getWithdrawalProbability() + getExtraWithdrawal() > GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"))
//	{
//		return false;
//	}
	if (promotionInfo.getWithdrawalChange() > 0)
	{
		if (promotionInfo.getWithdrawalChange() + m_pUnitInfo->getWithdrawalProbability() + getExtraWithdrawal() > GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"))
		{
			return false;
		}
	}
//FfH: End Modify
/**								----  End Original Code  ----									**/
	CvPromotionInfo& promotionInfo = GC.getPromotionInfo(ePromotion);
	if (isDenyPromotion(ePromotion) || (GC.getPromotionInfo(ePromotion).isRequirePermission() && !isAllowPromotion(ePromotion)))
	{
	   return false;
	}
	if (!isAllowPromotion(ePromotion) && getUnitCombatType() == NO_UNITCOMBAT && !promotionInfo.isAllowNULLUnitCombat())
	{
		return false;
	}
	else if (!isAllowPromotion(ePromotion) && promotionInfo.getNumPrereqUnits() == 0 && !(getUnitCombatType() == NO_UNITCOMBAT || promotionInfo.getUnitCombat(getUnitCombatType())))
	{
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
		bool bSecondaryJob = false;
		for (int iK = 0; iK < GC.getNumUnitCombatInfos(); iK++)
		{
			if (isSecondaryUnitCombat((UnitCombatTypes)iK) && promotionInfo.getUnitCombat(iK))
			{
				bSecondaryJob = true;
			}
		}
		if (!bSecondaryJob)
		{
			return false;
		}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
	}
	if (promotionInfo.isLeader())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak						15/08/10								Snarko					**/
/**			Sometimes we want to give units a promotion like this (tame)						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (GC.getUnitInfo(getUnitType()).isOnlyDefensive() && !isAllowAttacks() && !GC.getPromotionInfo(ePromotion).isAllowAttacks())
	{
		if ((GC.getPromotionInfo(ePromotion).getCityAttackPercent() != 0) ||
			  (GC.getPromotionInfo(ePromotion).getCollateralDamageChange() != 0) ||
			  (GC.getPromotionInfo(ePromotion).isAmphib()) ||
			  (GC.getPromotionInfo(ePromotion).isRiver()))
		{
			return false;
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak							END															**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								30/01/12										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/**			Use PromotionExcludes instead, both faster and more flexible						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune1() == ePromotion)
			{
				return false;
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune2() == ePromotion)
			{
				return false;
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune3() == ePromotion)
			{
				return false;
			}
		}
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	if (GC.getPromotionInfo(ePromotion).isPrereqAlive())
	{
		if (!isAlive())
		{
			return false;
		}
	}
	if (!isAllowPromotion(ePromotion) && GC.getPromotionInfo(ePromotion).getPrereqTier() != 0 && m_pUnitInfo->getTier() < GC.getPromotionInfo(ePromotion).getPrereqTier())
	{
		return false;
	}

	if (!isAllowPromotion(ePromotion) && GC.getPromotionInfo(ePromotion).getPrereqWeaponTier() != 0 && (m_pUnitInfo->getWeaponTierMax() < GC.getPromotionInfo(ePromotion).getPrereqWeaponTier() || m_pUnitInfo->getWeaponTierMin() > GC.getPromotionInfo(ePromotion).getPrereqWeaponTier()))
	{
		return false;
	}

/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	if (promotionInfo.getInterceptChange() + maxInterceptionProbability() > GC.getDefineINT("MAX_INTERCEPTION_PROBABILITY"))
	{
		return false;
	}

	if (promotionInfo.getEvasionChange() + evasionProbability() > GC.getDefineINT("MAX_EVASION_PROBABILITY"))
	{
		return false;
	}

	return true;
}


bool CvUnit::canAcquirePromotionAny() const
{
	int iI;

	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (canAcquirePromotion((PromotionTypes)iI))
		{
			return true;
		}
	}

	return false;
}


bool CvUnit::isHasPromotion(PromotionTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPromotionInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return m_pabHasPromotion[eIndex];
}
/**								----  End Original Code  ----									**/
	return m_paiHasPromotion[eIndex] > 0;
}

int CvUnit::countHasPromotion(PromotionTypes eIndex) const
{
	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < GC.getNumPromotionInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiHasPromotion[eIndex];
}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/


/*************************************************************************************************/
/**	Xienwolf Tweak							03/27/09											**/
/**	NOTE:  Change to using kPromotion enhances speed significantly for such a large function	**/
/**							Disables Special Removal Effects on Promotions						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
void CvUnit::setHasPromotion(PromotionTypes eIndex, bool bNewValue)
{
/**								----  End Original Code  ----									**/
void CvUnit::setHasPromotion(PromotionTypes eIndex, bool bNewValue, bool bSupressEffects, bool bConvertUnit)
{
	CvPromotionInfo &kPromotion = GC.getPromotionInfo(eIndex);
	bool bChange = false;
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	int iChange;
	int iI;

	if (isHasPromotion(eIndex) != bNewValue || kPromotion.isStackEffect())
	{
		TraitTriggeredData kTrigger;
		//kTrigger.eLevel = getLevel();
		kTrigger.m_iUnitClass = getUnitClassType();
		kTrigger.m_iUnitCombat = getUnitCombatType();
		kTrigger.m_iPromotion = eIndex;
		kTrigger.m_iRace = (PromotionTypes)getRace();
		kTrigger.m_iReligion = GET_PLAYER(getOwner()).getStateReligion();
		kTrigger.m_iAlignment = GET_PLAYER(getOwner()).getAlignment();
		kTrigger.m_iEthicalAlignment = GET_PLAYER(getOwner()).getEthicalAlignment();
		if (bNewValue)
			GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_UNIT_GAIN_PROMOTION, &kTrigger);
		else
			GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_UNIT_LOSE_PROMOTION, &kTrigger);
	}
//FfH: Added by Kael 07/28/2008
	if (bNewValue)
	{
/*************************************************************************************************/
/**	PromExclusivity						10/03/08									Xienwolf	**/
/**																								**/
/**					Blocks access to Promotions which are Excluded								**/
/*************************************************************************************************/
		if (isDenyPromotion(eIndex))
		{
			return;
		}
		if (kPromotion.isEnraged())
		{
			if (area()->getNumUnownedTiles() == 0 && area()->getNumCities() == area()->getCitiesPerPlayer(getOwner()))
			{
				return;
			}
		}
/*************************************************************************************************/
/**	PromExclusivity								END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Cutting								30/01/12										Snarko	**/
/**																								**/
/**				Removing rarely used/redundant stuff to improve speed.							**/
/**			Use PromotionExcludes instead, both faster and more flexible						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (isHasPromotion((PromotionTypes)iI))
			{
				if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune1() == eIndex)
				{
					return;
				}
				if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune2() == eIndex)
				{
					return;
				}
				if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionImmune3() == eIndex)
				{
					return;
				}
			}
		}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Cutting									END													**/
/*************************************************************************************************/
	}
//FfH: End Add
/*************************************************************************************************/
/**	EquipRedux								05/31/09								Xienwolf	**/
/**	Prevents the container from gaining stats from the equipment, and cleans them up when empty	**/
/**		Removes the need to add units for each equipment item introduced into the game			**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (kPromotion.getReplaceArtType() != cDefault)
	{
		if (bNewValue)
		{
			setReplaceArtDefineTag(kPromotion.getReplaceArtType());
		}
		else
		{
			setReplaceArtDefineTag(cDefault);
		}
		reloadEntity();
	}
	if(kPromotion.getExtraArtType()!=cDefault)
	{
		if (bNewValue)
		{
			if (getExtraArtDefineTag() == cDefault)
			{
				setExtraGroupSize(getExtraGroupSize() + 1);
				setExtraArtDefineTag(kPromotion.getExtraArtType());
			}
			else if (getExtraArtDefineTag2() == cDefault)
			{
				setExtraGroupSize(getExtraGroupSize() + 1);
				setExtraArtDefineTag2(kPromotion.getExtraArtType());
			}
			else if (getExtraArtDefineTag3() == cDefault)
			{
				setExtraGroupSize(getExtraGroupSize() + 1);
				setExtraArtDefineTag3(kPromotion.getExtraArtType());
			}
			reloadEntity();
		}
		else
		{
			if (getExtraArtDefineTag() == kPromotion.getExtraArtType())
			{
				setExtraGroupSize(getExtraGroupSize() - 1);
				if (getExtraArtDefineTag3() != cDefault)
				{
					setExtraArtDefineTag(getExtraArtDefineTag3());
					setExtraArtDefineTag3(cDefault);
				}
				else if (getExtraArtDefineTag2() != cDefault)
				{
					setExtraArtDefineTag(getExtraArtDefineTag2());
					setExtraArtDefineTag2(cDefault);
				}
				else
				{
					setExtraArtDefineTag(cDefault);
				}
			}
			else if (getExtraArtDefineTag2() == kPromotion.getExtraArtType())

			{
				setExtraGroupSize(getExtraGroupSize() - 1);
				if (getExtraArtDefineTag3() != cDefault)
				{
					setExtraArtDefineTag2(getExtraArtDefineTag3());
					setExtraArtDefineTag3(cDefault);
				}
				else
				{
					setExtraArtDefineTag2(cDefault);
				}

			}
			else if (getExtraArtDefineTag3() == kPromotion.getExtraArtType())
			{
				setExtraGroupSize(getExtraGroupSize() - 1);
				
				setExtraArtDefineTag2(cDefault);
			}
			reloadEntity();
		}
	}
	if (kPromotion.getSpecialCargo() != NO_SPECIALUNIT)
	{
		if (bNewValue)
		{
			setSpecialCargo(kPromotion.getSpecialCargo());
		}
		else
		{
			setSpecialCargo(NO_SPECIALUNIT);
		}
	}
	if (kPromotion.getDomainCargo() != NO_DOMAIN)
	{
		if (bNewValue)
		{
			setExtraDomainCargo(kPromotion.getDomainCargo());
		}
		else
		{
			setExtraDomainCargo(NO_DOMAIN);
		}
	}
	if (getUnitType() == GC.getDefineINT("EQUIPMENT_HOLDER"))
	{
		if (!kPromotion.isEquipment()) //Letting them have other promotions is an invitation to trouble
			return;
		iChange = bNewValue ? 1 : -1;
		m_paiHasPromotion[eIndex] += iChange;
		changeNumPromotions(iChange);
		if(getNumPromotions() == 0 && !bSupressEffects)
		{
			kill(false);
		}
		return;
	}
/*************************************************************************************************/
/**	EquipRedux								END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	Stackable								07/16/08								Xienwolf	**/
/**																								**/
/**						Allows a Promotion to be gained multiple Times							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (isHasPromotion(eIndex) != bNewValue)
	{
/**								----  End Original Code  ----									**/
	if (isHasPromotion(eIndex) != bNewValue || kPromotion.isStackEffect())
	{
/*************************************************************************************************/
/**	Stackable									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Xienwolf Tweak							03/27/09											**/
/**																								**/
/**							Python Intercept on attempted PromotionLoss							**/
/*************************************************************************************************/
		if (!bNewValue && !bSupressEffects)
		{
			if (!CvString(kPromotion.getPyOnRemove()).empty())
			{
				CyUnit* pyCaster = new CyUnit(this);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));
				argsList.add(eIndex);
				long lResult=0;
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "promotionRemove", argsList.makeFunctionArgs(), &lResult);
				delete pyCaster;
				if (lResult == 1)
					return;
			}
		}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		m_pabHasPromotion[eIndex] = bNewValue;
/**								----  End Original Code  ----									**/
		iChange = bNewValue ? 1 : -1;
		m_paiHasPromotion[eIndex] += iChange;
		bChange = true;
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**				Prevents Leader System Promotions from interferring with "Normal" ones			**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
		if(getSupplementalPromotionQuantity(eIndex) == 0)
		{
			//Just gained the promotion, didn't get it from the Leader System, so flag it as legitimate
			setRealPromotion(eIndex, bNewValue);
		}
		else
		{
			//This promotion is tied up in the Leader System somehow.  If we are gaining it, just proceed as normal
				//NOTE:  This doesn't work so well for gaining a StackEffect Promotion by "normal" means which you already had by leader, but that is unlikely to ever happen
			if(!bNewValue)
			{
				if(isRealPromotion(eIndex))
				{
					//This means we gained this promotion by "normal" means, then ALSO gained it by Leader Promotion at a later time.
					//So we remove the "normal means" flag, but keep the promotion since it comes from a seperate source
					//This could possibly have some conflicts with Dispell type of actions, but again, overlap between "normal" and "Leader" promotions should be rare and not include such a case
					setRealPromotion(eIndex, bNewValue);
					if (!kPromotion.isStackEffect())
					{
						return;
					}
				}
				else if(!kPromotion.isStackEffect())
				{
					//If we get to this point, the promotion was from the Leader Promotion System, and is being removed by something OUTSIDE of that system
					//Again, conflicts with Dispell type of abilities, but this case should be reserved for when UnitCombat changes and bValidate strips the promotion
					//Thus meaning that the unit is no longer allowed this promotion, so it needs fully removed from him
					m_aiSupplementalPromotions[eIndex] = 0;
				}
			}
		}
		if (countHasPromotion(eIndex) < 0)
		{
			m_paiHasPromotion[eIndex] = 0;
			return;
		}
		changeNumPromotions(iChange);
/*************************************************************************************************/
/**	CommandingPresence						END													**/
/*************************************************************************************************/

		iChange = ((bNewValue) ? 1 : -1);

		changeBlitzCount((kPromotion.isBlitz()) ? iChange : 0);
		changeTradeDefenderCount((kPromotion.isTradeDefender()) ? iChange : 0);
		changeAmphibCount((kPromotion.isAmphib()) ? iChange : 0);
		changeRiverCount((kPromotion.isRiver()) ? iChange : 0);
		changeEnemyRouteCount((kPromotion.isEnemyRoute()) ? iChange : 0);
		changeAlwaysHealCount((kPromotion.isAlwaysHeal()) ? iChange : 0);
		changeHillsDoubleMoveCount((kPromotion.isHillsDoubleMove()) ? iChange : 0);
		changeImmuneToFirstStrikesCount((kPromotion.isImmuneToFirstStrikes()) ? iChange : 0);

		changeExtraVisibilityRange(kPromotion.getVisibilityChange() * iChange);
		changeExtraMoves(kPromotion.getMovesChange() * iChange);
		changeExtraMoveDiscount(kPromotion.getMoveDiscountChange() * iChange);
		changeExtraAirRange(kPromotion.getAirRangeChange() * iChange);
		changeExtraIntercept(kPromotion.getInterceptChange() * iChange);
		changeExtraEvasion(kPromotion.getEvasionChange() * iChange);
		changeExtraFirstStrikes(kPromotion.getFirstStrikesChange() * iChange);
		changeExtraChanceFirstStrikes(kPromotion.getChanceFirstStrikesChange() * iChange);
		changeExtraWithdrawal(kPromotion.getWithdrawalChange() * iChange);
		changeBetrayalChance(kPromotion.getBetrayalChance() * iChange);
		changeExtraEnemyWithdrawal(kPromotion.getEnemyWithdrawalChange() * iChange);
		changeExtraCollateralDamage(kPromotion.getCollateralDamageChange() * iChange);
		changeExtraBombardRate(kPromotion.getBombardRateChange() * iChange);
		changeExtraEnemyHeal(kPromotion.getEnemyHealChange() * iChange);
		changeExtraNeutralHeal(kPromotion.getNeutralHealChange() * iChange);
		changeExtraFriendlyHeal(kPromotion.getFriendlyHealChange() * iChange);
		changeSameTileHeal(kPromotion.getSameTileHealChange() * iChange);
		changeAdjacentTileHeal(kPromotion.getAdjacentTileHealChange() * iChange);
		changeExtraCombatPercent(kPromotion.getCombatPercent() * iChange);
		changeExtraCombatPercentDefense(kPromotion.getCombatPercentDefense()* iChange);
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/*************************************************************************************************/
		changeExtraRangedCombatPercent(kPromotion.getRangedCombatPercent() * iChange);
		changeRangedCombatPercentInBorders(kPromotion.getRangedCombatPercentInBorders() * iChange);
		changeRangedCombatPercentGlobalCounter(kPromotion.getRangedCombatPercentGlobalCounter() * iChange);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
		changeExtraCityAttackPercent(kPromotion.getCityAttackPercent() * iChange);
		changeExtraCityDefensePercent(kPromotion.getCityDefensePercent() * iChange);
		changeExtraHillsAttackPercent(kPromotion.getHillsAttackPercent() * iChange);
		changeExtraHillsDefensePercent(kPromotion.getHillsDefensePercent() * iChange);
		changeRevoltProtection(kPromotion.getRevoltProtection() * iChange);
		changeCollateralDamageProtection(kPromotion.getCollateralDamageProtection() * iChange);
		changePillageChange(kPromotion.getPillageChange() * iChange);
		changeUpgradeDiscount(kPromotion.getUpgradeDiscount() * iChange);
		changeExperiencePercent(kPromotion.getExperiencePercent() * iChange);
		changeKamikazePercent((kPromotion.getKamikazePercent()) * iChange);
		changeCargoSpace(kPromotion.getCargoChange() * iChange);
		if (kPromotion.getMaxExpReward() > -1)
		{
			changeMaxExpReward(kPromotion.getMaxExpReward() * iChange);
		}

/*************************************************************************************************/
/**	MobileCage								 6/17/2009								Cyther		**/
/**	Expanded by Valkrionn					01/28/2010											**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
		if (kPromotion.isLeashed())
		{
			setLeashRange(0);
			if (kPromotion.getLeashRange() != -100)
			{
				changeLeashRange(kPromotion.getLeashRange() * iChange);
				if (kPromotion.getLeashRange() == 0 && iChange == -1)
				{
					changeLeashRange(-1);
				}
			}
			if (kPromotion.getLeashChance() > 0)
			{
				changeLeashChance(kPromotion.getLeashChance() * iChange);
			}

			if (isLeashed())
			{
				if (kPromotion.getLeashRange() == 0 && iChange == -1)
				{
					changeLeashRange(1);
				}

				if (getLeashX() == INVALID_PLOT_COORD)
				{
					setLeashX(getX());
				}
				if (getLeashY() == INVALID_PLOT_COORD)
				{
					setLeashY(getY());
				}
			}
			else
			{
				setLeashRange(-1);
				setLeashX(INVALID_PLOT_COORD);
				setLeashY(INVALID_PLOT_COORD);
			}
		}
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
		setLeveledImmortality((kPromotion.isLeveledImmortality()) ? iChange : 0);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**																								**/
/**						Loads Promotion Information onto the Unit Information  					**/
/*************************************************************************************************/
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
		setNonInfluence(kPromotion.isNonInfluence() * iChange);
		setInfluence(kPromotion.isInfluence() * iChange);
		changeVictoryInfluenceModifier((kPromotion.getVictoryInfluenceModifier() - 100) * iChange);
		changeDefeatInfluenceModifier((kPromotion.getDefeatInfluenceModifier() - 100) * iChange);
		changePillageInfluenceModifier((kPromotion.getPillageInfluenceModifier() - 100) * iChange);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
		changePerception(kPromotion.getExtraPerception() * iChange);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
		changeCommandLimit(kPromotion.getCommandLimit()*iChange);
		changeCommandRange(kPromotion.getCommandRange()*iChange);
		changeCommandXPShareRate(kPromotion.getCommandXPShareRate()*iChange);
		changeCommunalProperty((kPromotion.isCommunalProperty()) ? iChange : 0);
		changeNeverHostile((kPromotion.isNeverHostile()) ? iChange : 0);
		changeBlind((kPromotion.isBlind()) ? iChange : 0);
		if (kPromotion.getNumPromotionExcludes() > 0)
		{
			for (int iJ = 0; iJ < kPromotion.getNumPromotionExcludes(); iJ++)
			{
				changeDenyPromotion(kPromotion.getPromotionExcludes(iJ), iChange);
			}
		}
		if (kPromotion.getNumPromotionAllows() > 0)
		{
			for (int iJ = 0; iJ < kPromotion.getNumPromotionAllows(); iJ++)
			{
				changeAllowPromotion(kPromotion.getPromotionAllows(iJ), iChange);
			}
		}
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
		if (kPromotion.getNumSecondaryUnitCombats() > 0)
		{
			for (int iJ = 0; iJ < kPromotion.getNumSecondaryUnitCombats(); iJ++)
			{
				changeSecondaryUnitCombat((UnitCombatTypes)kPromotion.getSecondaryUnitCombats(iJ), iChange);
			}
		}
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
		if (kPromotion.getNumAffinities() > 0)
		{
			for (int iJ = 0; iJ < kPromotion.getNumAffinities(); iJ++)
			{
				changeAffinities((AffinityTypes)kPromotion.getAffinities(iJ), iChange);
			}
		}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
		if (kPromotion.getDamageOnRemove() != 0 && !bNewValue && !bSupressEffects)
		{
			changeDamage(kPromotion.getDamageOnRemove(), NO_PLAYER);
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_PROMOTION_REMOVE_DAMAGED", kPromotion.getTextKeyWide(), getNameKey(), kPromotion.getDamageOnRemove()), "AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
		}
		changeAssetValue(kPromotion.getAssetValue() * iChange);

		if (kPromotion.getTempUnitCombat() != -1)
		{
			setTempUnitCombat(bNewValue ? kPromotion.getTempUnitCombat(): -1);
		}
		changeFreeXPCap(kPromotion.getFreeXPCap() * iChange);
		changeCasterXPRate(kPromotion.getCasterXPRate() * iChange);
		setPromotionDuration(eIndex, (bNewValue ? kPromotion.getDuration() : 0));
		if (bNewValue)
		{
			for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
			{
				if (isHasPromotion((PromotionTypes)iI))
				{
					if (GC.getPromotionInfo((PromotionTypes)iI).getNumPromotionReplacedBy() > 0)
					{
						for (int iJ = 0; iJ < kPromotion.getNumPromotionReplacedBy(); iJ++)
						{
							if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionReplacedBy(iJ) == eIndex)
							{
								setHasPromotion((PromotionTypes)iI, false);
							}
						}
					}
				
					//PromotionClass
					if (eIndex != iI && kPromotion.getPromotionClass() == GC.getPromotionInfo((PromotionTypes)iI).getPromotionClass() && kPromotion.getPromotionClass() != NO_PROMOTIONCLASS) {
						if (GC.getPromotionInfo((PromotionTypes)iI).isEquipment() && getUnitType() != GC.getDefineINT("EQUIPMENT_HOLDER"))
						{
							PromotionTypes ePromotion = (PromotionTypes)iI;
							if (ePromotion != NO_PROMOTION)
							{
								bool bPlaced = false;
								CLLNode<IDInfo>* pUnitNode;
								CvUnit* pLoopUnit;
								CvPlot* pPlot;
								pPlot = plot();
								pUnitNode = pPlot->headUnitNode();
								while (pUnitNode != NULL)
								{
									pLoopUnit = ::getUnit(pUnitNode->m_data);
									pUnitNode = pPlot->nextUnitNode(pUnitNode);
									
									if (pLoopUnit->getUnitType() == GC.getDefineINT("EQUIPMENT_HOLDER"))
									{
										pLoopUnit->setHasPromotion(ePromotion, true);
										bPlaced = true;
									}
								}
								if (!bPlaced)
								{
									pLoopUnit = GET_PLAYER(ORC_PLAYER).initUnit((UnitTypes)GC.getDefineINT("EQUIPMENT_HOLDER"), pPlot->getX(), pPlot->getY());
									pLoopUnit->setHasPromotion(ePromotion, true);
								}
							}
						}
						setHasPromotion((PromotionTypes)iI, false);
					}
				}
			}
			if (kPromotion.getNumPromotionOverwrites() > 0)
			{
				for (iI = 0; iI < kPromotion.getNumPromotionOverwrites(); iI++)
				{
					if (isHasPromotion(kPromotion.getPromotionOverwrites(iI)))
					{
						setHasPromotion(kPromotion.getPromotionOverwrites(iI), false);
					}
				}
			}
		}
		setNewName(kPromotion.getNewName(), bNewValue);
		if (!bNewValue)
		{
			if (kPromotion.getNumPromotionDegradesTo() > 0 && !bSupressEffects)
			{
				for (iI = 0; iI < kPromotion.getNumPromotionDegradesTo(); iI++)
				{
					setHasPromotion(kPromotion.getPromotionDegradesTo(iI), true);
					wchar szBuffer[1024];
					if (kPromotion.getPromotionDegradesTo(iI) == eIndex)
					{
						swprintf(szBuffer, gDLL->getText("TXT_KEY_MESSAGE_PROMOTION_SELF_DEGRADE", kPromotion.getTextKeyWide(), getNameKey()).GetCString());
					}
					else
					{
						swprintf(szBuffer, gDLL->getText("TXT_KEY_MESSAGE_PROMOTION_DEGRADED", kPromotion.getTextKeyWide(), getNameKey(), GC.getPromotionInfo(kPromotion.getPromotionDegradesTo(iI)).getTextKeyWide()).GetCString());
					}
					gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, -1, szBuffer, NULL, MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX_INLINE(), getY_INLINE(), true, true);
				}
			}
		}
	//	if (kPromotion.getNumInvisibleTypes() > 0)
	//	{
	//		for (iI = 0; iI < kPromotion.getNumInvisibleTypes(); iI++)
	//		{
	//			setInvisibleType(kPromotion.getInvisibleType(iI), bNewValue);
	//		}
	//	}
		if (kPromotion.getInvisibleLevel() > 0)
		{
			updateInvisibleLevel();
		}
	//	if (kPromotion.getNumSeeInvisibleTypes() > 0)
	//	{
	//		for (iI = 0; iI < kPromotion.getNumSeeInvisibleTypes(); iI++)
	//		{
	//			setSeeInvisibleType(kPromotion.getSeeInvisibleType(iI), bNewValue);
	//		}
	//	}

		changeCannotCast((kPromotion.isCannotCast()) ? iChange : 0);
		changeFreeUnit((kPromotion.isFreeUnit()) ? iChange : 0);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
		setPromotionBuild((kPromotion.getNumPromotionBuilds() != -1) ? 1 : 0);
		setPromotionBuild((kPromotion.getNumPromotionCannotBuilds() != -1) ? 1 : 0);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
		changeNoSupply((kPromotion.isNoSupply()) ? iChange : 0);
		changeTerritorial((kPromotion.isTerritorial()) ? iChange : 0);
		changeRivalTerritoryExplore((kPromotion.isRivalTerritoryExplore()) ? iChange : 0);
		changeRivalTerritoryBlock((kPromotion.isRivalTerritoryBlock()) ? iChange : 0);
		changePillageOnMove((kPromotion.isPillageOnMove()) ? iChange : 0);
		changeSelfPillage((kPromotion.isSelfPillage()) ? iChange : 0);
		changeGetCasterXP((kPromotion.isGetCasterXP()) ? iChange : 0);
		changeNonWarWeariness((kPromotion.isNonWarWeariness()) ? iChange : 0);
		changeNoMapReveal((kPromotion.isNoMapReveal()) ? iChange : 0);
		changeCannotCapture((kPromotion.isCannotCapture()) ? iChange : 0);
		changeCityHappy((kPromotion.isCityHappy()) ? iChange : 0);
		changeCityNoHappy((kPromotion.isCityNoHappy()) ? iChange : 0);
		changeNoSupport((kPromotion.isNoSupport()) ? iChange : 0);
		changeCanPillage((kPromotion.isCanPillage()) ? iChange : 0);
		changeCannotPillage((kPromotion.isCannotPillage()) ? iChange : 0);
		changeCitySpy((kPromotion.isCitySpy()) ? iChange : 0);
		changeStartGoldenAge((kPromotion.isStartGoldenAge()) ? iChange : 0);
		changeNoDefenseBonus((kPromotion.isNoDefenseBonus()) ? iChange : 0);
		changeMoveImpassable((kPromotion.isMoveImpassable()) ? iChange : 0);
		changeClimbPeaks((kPromotion.isClimbPeaks()) ? iChange : 0);
		changeFlatMoveCost((kPromotion.isFlatMoveCost()) ? iChange : 0);
		changeIgnoreTerrainCosts((kPromotion.isIgnoreTerrainCosts()) ? iChange : 0);
		changeAttackNoWar((kPromotion.isAttackNoWar()) ? iChange : 0);
		changeAllowAttacks((kPromotion.isAllowAttacks()) ? iChange : 0);
		changeFirstStrikeVulnerable((kPromotion.isFirstStrikeVulnerable()) ? iChange : 0);
		changeAllowDefenseBonuses((kPromotion.isAllowDefenseBonuses()) ? iChange : 0);
		changeNonAbandon((kPromotion.isNonAbandon()) ? iChange : 0);
		changeIndependant((kPromotion.isIndependant()) ? iChange : 0);
		changeAirCombat(kPromotion.getAirCombat() * iChange);
		changeAirCombatLimitBoost(kPromotion.getAirCombatLimitBoost() * iChange);
		changeExtraDropRange(kPromotion.getExtraDropRange() * iChange);
		changeSpellExtraRange(kPromotion.getSpellExtraRange() * iChange);
		changeCombatConversionChance(kPromotion.getCombatConversionChance() * iChange);
		changeCombatUnitGenerationChance(kPromotion.getCombatUnitGenerationChance() * iChange);
		changeSlaveGenerationChance(kPromotion.getSlaveGenerationChance() * iChange);
		changeGiftableXP(kPromotion.getGiftableXP() * iChange);
		changeCombatExtraDuration(kPromotion.getCombatExtraDuration() * iChange);
		changeDurationPerTurn(kPromotion.getDurationPerTurn() * iChange);
		changeDurationAlter(kPromotion.getDurationAlter() * iChange);
		changeChangeDuration(kPromotion.getChangeDuration() * iChange);
		changeExtraSupport(kPromotion.getExtraSupport() * iChange);
		changeChanceMiscast(kPromotion.getChanceMiscast() * iChange);
		changeCombatDmgCapBoost(kPromotion.getCombatDmgCapBoost() * iChange);
		changeCollateralLimitCap(kPromotion.getCollateralLimitCap() * iChange);
		changeCollateralLimitBoost(kPromotion.getCollateralLimitBoost() * iChange);
		changeCollateralTargetsLimit(kPromotion.getCollateralTargetsLimit() * iChange);
		changeCollateralExtraTargets(kPromotion.getCollateralExtraTargets() * iChange);

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
		changeFlankingLimitBoost(kPromotion.getCollateralLimitBoost() * iChange);
		changeFlankingExtraTargets(kPromotion.getCollateralExtraTargets() * iChange);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/

		changeHammerSacrifice(kPromotion.getHammerSacrifice() * iChange);
		changeExtraHammerPerPop(kPromotion.getExtraHammerPerPop() * iChange);
		changeFoodSacrifice(kPromotion.getFoodSacrifice() * iChange);
		changePopulationAdd(kPromotion.getPopulationAdd() * iChange);
		changeBeakerSacrifice(kPromotion.getBeakerSacrifice() * iChange);
		changeExtraBeakerPerPop(kPromotion.getExtraBeakerPerPop() * iChange);
		changeGoldSacrifice(kPromotion.getGoldSacrifice() * iChange);
		changeExtraGoldPerPop(kPromotion.getExtraGoldPerPop() * iChange);
		changeCultureSacrifice(kPromotion.getCultureSacrifice() * iChange);
		changeExtraCulturePerPop(kPromotion.getExtraCulturePerPop() * iChange);
		changeXPTranserRate(kPromotion.getXPTranserRate() * iChange);
		changeCastingLimit((kPromotion.isTwincast()) ? iChange : 0);
		applyCityBonusEffects(false, true);
		if (kPromotion.getNumCityBonuses() > 0)
		{
			changeCityBonuses(bNewValue, kPromotion.listCityBonuses());
		}
		applyCityBonusEffects(true, true);
		for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			changeYieldFromWin(iI, (kPromotion.getYieldFromWin(iI) * iChange));
			changeYieldForLoss(iI, (kPromotion.getYieldForLoss(iI) * iChange));
		}
		for (iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
		{
			changeCommerceFromWin(iI, (kPromotion.getCommerceFromWin(iI) * iChange));
			changeCommerceForLoss(iI, (kPromotion.getCommerceForLoss(iI) * iChange));
		}
		changeNoBadExplore(kPromotion.getNoBadExplore() * iChange);
		if(kPromotion.getNumMinionPromotions() > 0)
		{
			for (iI = 0; iI < getNumMinions(); ++iI)
			{
				if (plotDistance(getMinionUnit(iI)->getX_INLINE(), getMinionUnit(iI)->getY_INLINE(), getX_INLINE(), getY_INLINE()) <= getCommandRange())
				{
					for (int iJ = 0; iJ < kPromotion.getNumMinionPromotions(); ++iJ)
					{
						if(getMinionUnit(iI)->isPromotionValid(kPromotion.getMinionPromotion(iJ)))
						{
							getMinionUnit(iI)->changeSupplementalPromotions(kPromotion.getMinionPromotion(iJ), bNewValue);
						}
					}
				}
			}
		}
		if (getCommanderUnit() != NULL)
		{
			if (plotDistance(getCommanderUnit()->getX_INLINE(), getCommanderUnit()->getY_INLINE(), getX_INLINE(), getY_INLINE()) <= getCommanderUnit()->getCommandRange())
			{
				for (int iJ = 0; iJ < kPromotion.getNumCommanderPromotions(); ++iJ)
				{
					getCommanderUnit()->changeSupplementalPromotions(kPromotion.getCommanderPromotion(iJ), bNewValue);
				}
			}
		}
		for (iI = 0; iI < getNumSlaves(); ++iI)
		{
			for (int iJ = 0; iJ < kPromotion.getNumSlavePromotions(); ++iJ)
			{
				getSlaveUnit(iI)->changeSupplementalPromotions(kPromotion.getSlavePromotion(iJ), bNewValue);
			}
		}
		if (getMasterUnit() != NULL)
		{
			for (int iJ = 0; iJ < kPromotion.getNumMasterPromotions(); ++iJ)
			{
				getMasterUnit()->changeSupplementalPromotions(kPromotion.getMasterPromotion(iJ), bNewValue);
			}
		}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
		changeEnraged((kPromotion.isEnraged()) ? iChange : 0);
		changeAlive((kPromotion.isNotAlive()) ? iChange : 0);
		changeBaseCombatStr(kPromotion.getExtraCombatStr() * iChange);
		changeBaseCombatStrDefense(kPromotion.getExtraCombatDefense() * iChange);
		changeBetterDefenderThanPercent(kPromotion.getBetterDefenderThanPercent() * iChange);
		changeBoarding((kPromotion.isBoarding()) ? iChange : 0);
		changeCombatHealPercent(kPromotion.getCombatHealPercent() * iChange);
		changeCombatPercentInBorders(kPromotion.getCombatPercentInBorders() * iChange);
		changeCombatPercentGlobalCounter(kPromotion.getCombatPercentGlobalCounter() * iChange);
		changeDefensiveStrikeChance(kPromotion.getDefensiveStrikeChance() * iChange);
		changeDefensiveStrikeDamage(kPromotion.getDefensiveStrikeDamage() * iChange);
		changeDoubleFortifyBonus((kPromotion.isDoubleFortifyBonus()) ? iChange : 0);
		changeFear((kPromotion.isFear()) ? iChange : 0);
		changeFlying((kPromotion.isFlying()) ? iChange : 0);
		changeHeld((kPromotion.isHeld()) ? iChange : 0);
		changeHiddenNationality((kPromotion.isHiddenNationality()) ? iChange : 0);
		changeIgnoreBuildingDefense((kPromotion.isIgnoreBuildingDefense()) ? iChange : 0);
		changeImmortal((kPromotion.isImmortal()) ? iChange : 0);
		changeImmuneToCapture((kPromotion.isImmuneToCapture()) ? iChange : 0);
		changeImmuneToDefensiveStrike((kPromotion.isImmuneToDefensiveStrike()) ? iChange : 0);
		changeImmuneToFear((kPromotion.isImmuneToFear()) ? iChange : 0);
		changeImmuneToMagic((kPromotion.isImmuneToMagic()) ? iChange : 0);
		changeOnlyDefensive((kPromotion.isOnlyDefensive()) ? iChange : 0);
		changeResist(kPromotion.getResistMagic() * iChange);
		changeResistModify(kPromotion.getCasterResistModify() * iChange);
		changeResistModify(kPromotion.getCasterResistModify() * iChange);
		changeSpellCasterXP(kPromotion.getSpellCasterXP() * iChange);
		changeSpellDamageModify(kPromotion.getSpellDamageModify() * iChange);
		changeTargetWeakestUnit((kPromotion.isTargetWeakestUnit()) ? iChange : 0);
		changeTargetWeakestUnitCounter((kPromotion.isTargetWeakestUnitCounter()) ? iChange : 0);
		changeTwincast((kPromotion.isTwincast()) ? iChange : 0);
		changeWaterWalking((kPromotion.isWaterWalking()) ? iChange : 0);
		changeWorkRateModify(kPromotion.getWorkRateModify() * iChange);
/*************************************************************************************************/
/**	WorldBreakers						01/05/09									Xienwolf	**/
/**																								**/
/**							Tracks AC Contributions on a player basis							**/
/*************************************************************************************************/
		GET_PLAYER(getOwner()).changeGlobalCounterContrib(kPromotion.getModifyGlobalCounter() * iChange);
/*************************************************************************************************/
/**	WorldBreakers							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Lethality								07/10/08								Xienwolf	**/
/**																								**/
/**						Recalculates Unit Damage Cap when Promotion Assigned					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (GC.getPromotionInfo(eIndex).getCombatLimit() != 0)
/**								----  End Original Code  ----									**/
		if (kPromotion.getCombatLimit() != 0 || kPromotion.getCombatDmgCapBoost() != 0)
/*************************************************************************************************/
/**	Lethality									END												**/
/*************************************************************************************************/
		{
			calcCombatLimit();
		}
/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
	//	if (kPromotion.isInvisible())
	//	{
	//		setInvisibleType(GC.getDefineINT("INVISIBLE_TYPE"), bNewValue);
	//	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		if (eIndex == GC.getDefineINT("MUTATED_PROMOTION") && bNewValue && !bConvertUnit)
		{
			mutate();
		}
		if (kPromotion.isRace())
		{
			if (bNewValue)
			{
				setRace(eIndex);
			}
			else
			{
				setRace(NO_PROMOTION);
			}
		}
		if (kPromotion.isGraphicalAddOnPromotion())
		{
			if (bNewValue)
			{
				setGraphicalAddOnPromotion(eIndex);
				reloadEntity();
			}
			else
			{
				setGraphicalAddOnPromotion(NO_PROMOTION);
				reloadEntity();
			}
		}

		for (iI = 0; iI < GC.getNumDamageTypeInfos(); iI++)
		{
			changeDamageTypeCombat(((DamageTypes)iI), (kPromotion.getDamageTypeCombat(iI) * iChange));
		}
		for (iI = 0; iI < GC.getNumBonusInfos(); iI++)
		{
			changeBonusAffinity(((BonusTypes)iI), (kPromotion.getBonusAffinity(iI) * iChange));
		}
		for (iI = 0; iI < GC.getNumDamageTypeInfos(); iI++)
		{
			changeDamageTypeResist(((DamageTypes)iI), (kPromotion.getDamageTypeResist(iI) * iChange));
		}
//FfH: End Add

		for (iI = 0; iI < GC.getNumImprovementInfos(); iI++)
		{
			changeNoBadExploreImprovement(((ImprovementTypes)iI), ((kPromotion.getNoBadExploreImprovement(iI)) * iChange ));

		}

		for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			changeExtraTerrainAttackPercent(((TerrainTypes)iI), (kPromotion.getTerrainAttackPercent(iI) * iChange));
			changeExtraTerrainDefensePercent(((TerrainTypes)iI), (kPromotion.getTerrainDefensePercent(iI) * iChange));
			changeTerrainDoubleMoveCount(((TerrainTypes)iI), ((kPromotion.getTerrainDoubleMove(iI)) ? iChange : 0));
			changeTerrainCostModifier(((TerrainTypes)iI), (kPromotion.getPromotionTerrainCost(iI) * iChange));			// GWS
		}

		for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeExtraFeatureAttackPercent(((FeatureTypes)iI), (kPromotion.getFeatureAttackPercent(iI) * iChange));
			changeExtraFeatureDefensePercent(((FeatureTypes)iI), (kPromotion.getFeatureDefensePercent(iI) * iChange));
			changeFeatureDoubleMoveCount(((FeatureTypes)iI), ((kPromotion.getFeatureDoubleMove(iI)) ? iChange : 0));
			changeFeatureCostModifier(((FeatureTypes)iI), (kPromotion.getPromotionFeatureCost(iI) * iChange));			// GWS
		}
		for (iI = 0; iI < GC.getNumPlotEffectInfos(); iI++)
		{
			changeExtraPlotEffectAttackPercent(((PlotEffectTypes)iI), (kPromotion.getPlotEffectAttackPercent(iI) * iChange));
			changeExtraPlotEffectDefensePercent(((PlotEffectTypes)iI), (kPromotion.getPlotEffectDefensePercent(iI) * iChange));
			changePlotEffectDoubleMoveCount(((PlotEffectTypes)iI), ((kPromotion.getPlotEffectDoubleMove(iI)) ? iChange : 0));
		}
		/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
		changeHillCostModifier(kPromotion.getPromotionHillCost() * iChange);
		changePeakCostModifier(kPromotion.getPromotionPeakCost() * iChange);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/

		for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			changeExtraUnitCombatModifier(((UnitCombatTypes)iI), (kPromotion.getUnitCombatModifierPercent(iI) * iChange));
		}

		for (iI = 0; iI < GC.getNumSpellClassInfos(); iI++)
		{
			changeExtraSpellClassPower(((SpellClassTypes)iI), (kPromotion.getExtraSpellClassPower(iI) * iChange));
		}
	

		for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeExtraDomainModifier(((DomainTypes)iI), (kPromotion.getDomainModifierPercent(iI) * iChange));
		}
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
		changeInquisition((kPromotion.isInquisition()) ? iChange : 0);
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
		//Magic Rework
		changeExtraMagicalPower(kPromotion.getMagicalPower() * iChange);
	//	changeExtraDominionCapacity(kPromotion.getDominionCapacity() * iChange);
	//	for (int i = 0; i < GC.getNumSpellClassInfos(); i++)
	//	{
	//		changeSpellClassExtraPower(i, kPromotion.getSpellClassExtraPower(i) * iChange);
	//	}

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}

		//update graphics
		gDLL->getEntityIFace()->updatePromotionLayers(getUnitEntity());

//FfH: Added by Kael 07/04/2009
		if (kPromotion.getUnitArtStyleType() != NO_UNIT_ARTSTYLE)
		{
			if (iChange > 0)
			{
				setUnitArtStyleType(kPromotion.getUnitArtStyleType());
			}
			else
			{
				if (kPromotion.getUnitArtStyleType() == getUnitArtStyleType())
				{
					setUnitArtStyleType(NO_UNIT_ARTSTYLE);
				}
			}
			reloadEntity();
		}
		if (kPromotion.getGroupSize() != 0)
		{
			if (bNewValue)
			{
				setGroupSize(kPromotion.getGroupSize());
			}
			else
			{
				setGroupSize(0);
			}
			reloadEntity();
		}
//FfH: End Add
/*************************************************************************************************/
/**	PyOnPromoTaken							   08/28/10								Valkrionn	**/
/*************************************************************************************************/
		if (bNewValue)
		{
			if (!CvString(kPromotion.getPyOnPromoTaken()).empty())
			{
/*************************************************************************************************/
/**	Tweak								31/01/12										Snarko	**/
/**																								**/
/**		WTH was this? Why look through every promotion to find eIndex? eIndex is eIndex!		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
				{
					if (isHasPromotion((PromotionTypes)iI) && (PromotionTypes)iI == eIndex)
					{
						CyUnit* pyUnit = new CyUnit(this);
						CyArgsList argsList;
						argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit)); // pass in unit class
						argsList.add(iI);	// promotion
						gDLL->getPythonIFace()->callFunction(PYSpellModule, "onPromoTaken", argsList.makeFunctionArgs()); //, &lResult
						delete pyUnit; // python fxn must not hold on to this pointer
					}
				}
/**								----  End Original Code  ----									**/
				CyUnit* pyUnit = new CyUnit(this);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit)); // pass in unit class
				argsList.add(eIndex);	// promotion
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "onPromoTaken", argsList.makeFunctionArgs()); //, &lResult
				delete pyUnit; // python fxn must not hold on to this pointer
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
			}
		}
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/

	}
/*************************************************************************************************/
/**	AutoBots								07/12/09								Xienwolf	**/
/**																								**/
/**					Automatically applies a Promotion if Unit meets conditions					**/
/*************************************************************************************************/
	if(bChange)
	{
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (isHasPromotion((PromotionTypes)iI) && GC.getPromotionInfo((PromotionTypes)iI).isMustMaintain() && !canAcquirePromotion((PromotionTypes)iI,true) && !m_pUnitInfo->getFreePromotions(iI))
			{
				for(int k=0;k<countHasPromotion((PromotionTypes)iI);++k)
				{
					setHasPromotion(((PromotionTypes)iI), false);
				}
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).isAutoAcquire() && canPromote((PromotionTypes)iI, -1))
			{
				promote(((PromotionTypes)iI), -1);
			}
		}
	}
/*************************************************************************************************/
/**	AutoBots									END												**/
/*************************************************************************************************/
}


int CvUnit::getSubUnitCount() const
{
	return getGroupSize();
}


int CvUnit::getSubUnitsAlive() const
{
/*************************************************************************************************/
/**	Higher hitpoints				08/04/11											Snarko	**/
/**						Makes higher values than 100 HP possible.								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return getSubUnitsAlive( getDamage());
/**								----  End Original Code  ----									**/
	return getSubUnitsAlive( getDamageReal());
/*************************************************************************************************/
/**	Higher hitpoints						END													**/
/*************************************************************************************************/
}


int CvUnit::getSubUnitsAlive(int iDamage) const
{
	if (iDamage >= maxHitPoints())
	{
		return 0;
	}
	else
	{
		return std::max(1, (((getGroupSize() * (maxHitPoints() - iDamage)) + (maxHitPoints() / ((getGroupSize() * 2) + 1))) / maxHitPoints()));
	}
}
// returns true if unit can initiate a war action with plot (possibly by declaring war)
bool CvUnit::potentialWarAction(const CvPlot* pPlot) const
{
	TeamTypes ePlotTeam = pPlot->getTeam();
	TeamTypes eUnitTeam = getTeam();

	if (ePlotTeam == NO_TEAM)
	{
		return false;
	}

	if (isEnemy(ePlotTeam, pPlot))
	{
		return true;
	}

	if (getGroup()->AI_isDeclareWar(pPlot) && GET_TEAM(eUnitTeam).AI_getWarPlan(ePlotTeam) != NO_WARPLAN)
	{
		return true;
	}

	return false;
}

//FfH Spell System: Added by Kael 07/23/2007
bool CvUnit::canCastAnyPlot(int spell, bool bTestVisible)
{
	if (GC.getSpellInfo((SpellTypes)spell).isTargeted())
	{
		bool bValid = false;
		int iRange = getSpellTargetRange(spell);//GC.getSpellInfo((SpellTypes)spell).getTargetRange();// +getSpellExtraRange();
		int iDX, iDY;
		for (iDX = -(iRange); iDX <= iRange; iDX++)
		{
			for (iDY = -(iRange); iDY <= iRange; iDY++)
			{
				CvPlot* pTargetLoopPlot = plotXY(getX_INLINE(), getY_INLINE(), iDX, iDY);

				if (pTargetLoopPlot != NULL && canCast((SpellTypes)spell, bTestVisible, pTargetLoopPlot))
				{
					bValid = true;
					break;
				}
			}
		}
		return bValid;
	}
	else
	{
		return canCast(spell, bTestVisible);
	}
}
bool CvUnit::canCast(int spell, bool bTestVisible, CvPlot* pTargetPlot)
{
	PROFILE_FUNC();

	SpellTypes eSpell = (SpellTypes)spell;
	CvPlot* pPlot = plot();
	CvUnit* pLoopUnit;
	CLLNode<IDInfo>* pUnitNode;
	bool bValid = false;

	/*************************************************************************************************/
	/**	City Actions							03/28/10								Grey Fox	**/
	/*************************************************************************************************/
	if (GC.getSpellInfo(eSpell).isCityAction())
	{
		return false;
	}
	/*************************************************************************************************/
	/**	END																							**/
	/*************************************************************************************************/


	//TargetedSpell 0924 blackimp
	if (GC.getSpellInfo(eSpell).isTargeted() && pTargetPlot==NULL)
	{
		bValid = false;
		int iRange = getSpellTargetRange(eSpell);//GC.getSpellInfo(eSpell).getTargetRange();// + getSpellExtraRange();
		int iDX, iDY;
		for (iDX = -(iRange); iDX <= iRange; iDX++)
		{
			for (iDY = -(iRange); iDY <= iRange; iDY++)
			{
				CvPlot* pTargetLoopPlot = plotXY(getX_INLINE(), getY_INLINE(), iDX, iDY);

				if (pTargetLoopPlot != NULL && canSpellTargetPlot(pTargetLoopPlot, eSpell))
				{
					bValid = true;
					break;
				}
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	if (plotDistance(plot()->getX_INLINE(), plot()->getY_INLINE(), pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE()) > getSpellTargetRange(spell))//GC.getSpellInfo((SpellTypes)spell).getTargetRange())
	{
		return false;
	}
	if (GC.getSpellInfo((SpellTypes)spell).isTargeted() && (GC.getSpellInfo((SpellTypes)spell).isResistable() || GC.getSpellInfo((SpellTypes)spell).isCausesWar()|| GC.getSpellInfo((SpellTypes)spell).getDamage()>0))

	{
		if (!pTargetPlot->isVisibleEnemyUnit(getOwnerINLINE()))
		{
			return false;
		}
	}
	if (!canSpellTargetPlot(pTargetPlot, eSpell))
	{
		return false;
	}
	if (!canCastTargetPlot(eSpell, bTestVisible, pTargetPlot))
	{
		return false;
	}

/*************************************************************************************************/
/**	Orbis Held units can cast (Acheron's meteors and roar!)		Ahwaric 20.05.2009	**/
/*************************************************************************************************/
	if (getImmobileTimer() > 0 && !isHeld())
/*************************************************************************************************/
/**	Orbis 			END								**/
/*************************************************************************************************/
	{
		return false;
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							05/12/09											**/
/**																								**/
/**			Places same restrictions on the AI as are placed on the Player for Blindness		**/
/*************************************************************************************************/
	if (isBlind() && (!pTargetPlot->isVisible(getTeam(), false) || !pTargetPlot->isRevealed(getTeam(), false)))
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (!isHuman())
	{
		if (!GC.getSpellInfo(eSpell).isAllowAI())
		{
			return false;
		}
	}
	//Magic Rework
	if (GC.getSpellInfo(eSpell).getMagicalPowerPrereq() != 0)
	{
		if (GC.getSpellInfo(eSpell).getMagicalPowerPrereq() > getSpellMagicalPower(spell))
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getCrimePrereq() != 0)
	{
		if (!plot()->isCity())
		{
			return false;
		}

		if (GC.getSpellInfo(eSpell).getCrimePrereq() > plot()->getPlotCity()->getCrime())
		{
			return false;
		}
	}

	
	
	int iNumPrereqs = GC.getSpellInfo((SpellTypes)spell).getNumPromotionsPrereq();
	bool bVal = false;
	bool bIgno = false;
	if (!bIgno)
	{
		if (GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq1() != NO_PROMOTION)
		{
			if (!isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq1()))
			{
				return false;
			}
		}
		if (GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq2() != NO_PROMOTION)
		{
			if (!isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq2()))
			{
				return false;
			}
		}
		if (iNumPrereqs > 0)
		{
			for (int iI = 0; iI < iNumPrereqs; iI++)
			{
				if (isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq(iI)))
				{
					bVal = true;
				}
			}
			if (!bVal)
			{
				return false;
			}
		}
	}
	if (GC.getSpellInfo(eSpell).getUnitClassPrereq() != NO_UNITCLASS)
	{
		if (getUnitClassType() != (UnitClassTypes)GC.getSpellInfo(eSpell).getUnitClassPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getUnitPrereq() != NO_UNIT)
	{
		if (getUnitType() != (UnitTypes)GC.getSpellInfo(eSpell).getUnitPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getUnitCombatPrereq() != NO_UNITCOMBAT)
	{
		if (getUnitCombatType() != (UnitCombatTypes)GC.getSpellInfo(eSpell).getUnitCombatPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getBuildingPrereq() != NO_BUILDING)
	{
		if (!pPlot->isCity())
		{
			return false;
		}
		if (pPlot->getPlotCity()->getNumBuilding((BuildingTypes)GC.getSpellInfo(eSpell).getBuildingPrereq()) == 0)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getBuildingTargetPrereq() != NO_BUILDING)
	{
		if (!pTargetPlot->isCity())
		{
			return false;
		}
		if (pTargetPlot->getPlotCity()->getNumBuilding((BuildingTypes)GC.getSpellInfo(eSpell).getBuildingTargetPrereq()) == 0)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getBuildingClassOwnedPrereq() != NO_BUILDINGCLASS)
	{
		if (GET_PLAYER(getOwnerINLINE()).getBuildingClassCount((BuildingClassTypes)GC.getSpellInfo(eSpell).getBuildingClassOwnedPrereq())  == 0)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getCivilizationPrereq() != NO_CIVILIZATION)
	{
		if (getCivilizationType() != (CivilizationTypes)GC.getSpellInfo(eSpell).getCivilizationPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getNumPrereqTraits() > 0)
	{
		bool bValid = false;
		for (int i = 0; i < GC.getSpellInfo(eSpell).getNumPrereqTraits(); i++)
		{
			if (GET_PLAYER(getOwner()).hasTrait((TraitTypes)GC.getSpellInfo(eSpell).getPrereqTrait(i))) {
				bValid = true;
			}
		}
		if (!bValid) 
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getCorporationPrereq() != NO_CORPORATION)
	{
		if (!pPlot->isCity())
		{
			return false;
		}
		if (!pPlot->getPlotCity()->isHasCorporation((CorporationTypes)GC.getSpellInfo(eSpell).getCorporationPrereq()))
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getImprovementPrereq() != NO_IMPROVEMENT)
	{
		if (pPlot->getImprovementType() != GC.getSpellInfo(eSpell).getImprovementPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getPlotEffectPrereq() != NO_PLOT_EFFECT)
	{
		if (pPlot->getPlotEffectType() != GC.getSpellInfo(eSpell).getPlotEffectPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getReligionPrereq() != NO_RELIGION)
	{
		if (getReligion() != (ReligionTypes)GC.getSpellInfo(eSpell).getReligionPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getStateReligionPrereq() != NO_RELIGION)
	{
		if (GET_PLAYER(getOwnerINLINE()).getStateReligion() != (ReligionTypes)GC.getSpellInfo(eSpell).getStateReligionPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getTechPrereq() != NO_TECH)
	{
		if (!GET_TEAM(getTeam()).isHasTech((TechTypes)GC.getSpellInfo(eSpell).getTechPrereq()))
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Broader Alignments						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**	New Tag Defs	(SpellInfos)			07/25/08											**/
/**																								**/
/**							Prevents Casting based on Prereqs specified							**/
/*************************************************************************************************/
	if (GC.getGameINLINE().isOption(GAMEOPTION_BROADER_ALIGNMENTS))
	{
		if (GC.getSpellInfo(eSpell).getPrereqBroadAlignment() != 0)
		{
			if (GC.getSpellInfo(eSpell).getPrereqBroadAlignment() > 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadAlignment() < GC.getSpellInfo(eSpell).getPrereqBroadAlignment())
				{
					return false;
				}
			}
			if (GC.getSpellInfo(eSpell).getPrereqBroadAlignment() < 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadAlignment() > GC.getSpellInfo(eSpell).getPrereqBroadAlignment())
				{
					return false;
				}
			}
		}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
		if (GC.getSpellInfo(eSpell).getPrereqBroadEthicalAlignment() != 0)
		{
			if (GC.getSpellInfo(eSpell).getPrereqBroadEthicalAlignment() > 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadEthicalAlignment() < GC.getSpellInfo(eSpell).getPrereqBroadEthicalAlignment())
				{
					return false;
				}
			}
			if (GC.getSpellInfo(eSpell).getPrereqBroadEthicalAlignment() < 0)
			{
				if (GET_PLAYER(getOwnerINLINE()).getBroadEthicalAlignment() > GC.getSpellInfo(eSpell).getPrereqBroadEthicalAlignment())
				{
					return false;
				}
			}
		}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	}
	if (GC.getSpellInfo(eSpell).isPrereqAvailableCommander())
	{
		bool bValid = false;
		pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->getOwner() == getOwner() && pLoopUnit->getNumMinions() < pLoopUnit->getCommandLimit())
			{
				if(pLoopUnit != getCommanderUnit() && pLoopUnit != this)
				{
					bValid = true;
					break;
				}
			}
		}
		if(!bValid)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isPrereqIsNOTMinion())
	{
		if(getCommanderUnit() != NULL)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isPrereqIsMinion())
	{
		if(getCommanderUnit() == NULL)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isPrereqNotAttacked())
	{
		if(isMadeAttack())
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	if (GC.getSpellInfo(eSpell).getConvertUnitType() != NO_UNIT)
	{
		if (getUnitType() == (UnitTypes)GC.getSpellInfo(eSpell).getConvertUnitType())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isGlobal())
	{
		if (GC.getGameINLINE().isOption(GAMEOPTION_NO_WORLD_SPELLS))
		{
			return false;
		}
		if (GET_PLAYER(getOwnerINLINE()).isFeatAccomplished(FEAT_GLOBAL_SPELL))
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isPrereqSlaveTrade())
	{
		if (!GET_PLAYER(getOwnerINLINE()).isSlaveTrade())
		{
			return false;
		}
	}
	if (GC.getUnitInfo((UnitTypes)getUnitType()).getEquipmentPromotion() != NO_PROMOTION)
	{
		if (GC.getSpellInfo(eSpell).getUnitClassPrereq() != getUnitClassType())
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	EquipRedux								05/31/09								Xienwolf	**/
/**		Need this exception if we ever want a droppable (but not carryable) building or effect	**/
/**		Removes the need to add units for each equipment item introduced into the game			**/
/*************************************************************************************************/
	if (getUnitType() == GC.getDefineINT("EQUIPMENT_HOLDER"))
	{
		if (GC.getSpellInfo(eSpell).getUnitClassPrereq() != getUnitClassType())
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	EquipRedux								END													**/
/*************************************************************************************************/
	if (GC.getSpellInfo(eSpell).getCasterMinLevel() != 0)
	{
		if (getLevel() < GC.getSpellInfo(eSpell).getCasterMinLevel())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isCasterMustBeAlive())
	{
		if (!isAlive())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isCasterNoDuration())
	{
		if (getDuration() != 0)
		{
			return false;
		}
	}
	
/*************************************************************************************************/
/**	FeedbackCast						12/13/08									Xienwolf	**/
/**																								**/
/**							Allows disabling of Spellcasting Capabilities						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (GET_PLAYER(getOwnerINLINE()).getDisableSpellcasting() > 0)
/**								----  End Original Code  ----									**/
	if (GET_PLAYER(getOwnerINLINE()).getDisableSpellcasting() > 0 || isCannotCast())
/*************************************************************************************************/
/**	FeedbackCast							END													**/
/*************************************************************************************************/
	{
		if (!GC.getSpellInfo(eSpell).isAbility())
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							01/19/09											**/
/**																								**/
/**			Allows casting of spells with a seperate unit in stack meeting requirement			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (GC.getSpellInfo(eSpell).getPromotionInStackPrereq() != NO_PROMOTION)
	{
		if (isHasPromotion((PromotionTypes)GC.getSpellInfo(eSpell).getPromotionInStackPrereq()))
		{
			return false;
		}
		bValid = false;
		pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo(eSpell).getPromotionInStackPrereq()))
			{
				if (getOwner() == pLoopUnit->getOwner())
				{
					bValid = true;
				}
			}
		}
		if (bValid == false)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getUnitInStackPrereq() != NO_UNIT)
	{
		if (getUnitType() == GC.getSpellInfo(eSpell).getUnitInStackPrereq())
		{
			return false;
		}
		bValid = false;
		pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->getUnitType() == (UnitTypes)GC.getSpellInfo(eSpell).getUnitInStackPrereq())
			{
				if (getOwner() == pLoopUnit->getOwner())
				{
					bValid = true;
				}
			}
		}
		if (bValid == false)
		{
			return false;
		}
	}
/**								----  End Original Code  ----									**/
	if (GC.getSpellInfo(eSpell).getPromotionInStackPrereq() != NO_PROMOTION)
	{
		bValid = false;
		pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo(eSpell).getPromotionInStackPrereq()))
			{
				if ((getOwner() == pLoopUnit->getOwner() || pLoopUnit->isCommunalProperty()) && pLoopUnit->getID() != getID())
				{
					bValid = true;
					break;
				}
			}
		}
		if (bValid == false)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getUnitInStackPrereq() != NO_UNIT)
	{
		if (getUnitType() == GC.getSpellInfo(eSpell).getUnitInStackPrereq())
			return false;
		bValid = false;
		pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->getUnitType() == (UnitTypes)GC.getSpellInfo(eSpell).getUnitInStackPrereq())
			{
				if ((getOwner() == pLoopUnit->getOwner() || pLoopUnit->isCommunalProperty()) && pLoopUnit->getID() != getID())
				{
					bValid = true;
					break;
				}
			}
		}
		if (bValid == false)
		{
			return false;
		}
	}
	/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (bTestVisible)
	{
		if (GC.getSpellInfo(eSpell).isDisplayWhenDisabled())
		{
			return true;
		}
	}
	for (int iSpellClass = 0; iSpellClass < GC.getNumSpellClassInfos(); iSpellClass++)
	{
		if (GC.getSpellInfo(eSpell).isSpellClass(iSpellClass))
		{
			for (int iProm = 0; iProm < GC.getNumPromotionInfos(); iProm++)
			{
				if (isHasPromotion((PromotionTypes)iProm))
				{
					if (GC.getPromotionInfo((PromotionTypes)iProm).getBlockedSpellClass() == iSpellClass)
					{
						return false;
					}
				}
			}
		}
	}
	if (GC.getSpellInfo(eSpell).getFeatureOrPrereq1() != NO_FEATURE)
	{
		if (pPlot->getFeatureType() != GC.getSpellInfo(eSpell).getFeatureOrPrereq1())
		{
			if (GC.getSpellInfo(eSpell).getFeatureOrPrereq2() == NO_FEATURE || pPlot->getFeatureType() != GC.getSpellInfo(eSpell).getFeatureOrPrereq2())
			{
				return false;
			}
		}
	}
	if (!GC.getSpellInfo(eSpell).isIgnoreHasCasted())
	{
		if (isHasCasted())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isAdjacentToWaterOnly())
	{
		if (!pPlot->isAdjacentToWater())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isInBordersOnly())
	{
		if (pPlot->getOwner() != getOwner())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isInCityOnly())
	{
		if (!pPlot->isCity())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getChangePopulation() != 0)
	{
		if (!pTargetPlot->isCity())
		{
			return false;
		}
		if (pTargetPlot->getPlotCity()->getPopulation() <= (-1 * GC.getSpellInfo(eSpell).getChangePopulation()))
		{
			return false;
		}
	}
	int iGameSpeedPercent = GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();
	int iCost = GC.getSpellInfo(eSpell).getCost()*iGameSpeedPercent/100;
	if (iCost != 0)
	{
		if (GC.getSpellInfo(eSpell).getConvertUnitType() != NO_UNIT)
		{
			iCost += (iCost * GET_PLAYER(getOwnerINLINE()).getUpgradeCostModifier()) / 100;
		}
		if (GET_PLAYER(getOwnerINLINE()).getGold() < iCost)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isRemoveHasCasted())
	{
		if (!isHasCasted())
		{
			return false;
		}
		if (getDuration() > 0)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getCreateUnitType() != NO_UNIT)
	{
		if (!canCreateUnit(spell,pTargetPlot))
		{
			return false;
		//	int iRange = GC.getSpellInfo(eSpell).getRange() + getSpellExtraRange();
		//	int iDX, iDY;
		//	bValid = false;
		//	for (iDX = -(iRange); iDX <= iRange; iDX++)
		//	{
		//		for (iDY = -(iRange); iDY <= iRange; iDY++)
		//		{
		//			CvPlot* pTargetLoopPlot = plotXY(pTargetPlot->getX(), pTargetPlot->getY(), iDX, iDY);	
		//
		//			if (pTargetLoopPlot != NULL && canCreateUnit(eSpell, pTargetLoopPlot))
		//			{
		//				bValid = true;
		//				break;
		//			}
		//		}
		//	}
		//	if (!bValid)
		//	{
		//		return false;
		//	}
		}
	}
	if (GC.getSpellInfo(eSpell).getCreateBuildingType() != NO_BUILDING)
	{
		if (!canCreateBuilding(spell,pTargetPlot))
		{
			return false;
		}
	}
	if (!CvString(GC.getSpellInfo(eSpell).getPyRequirement()).empty())
	{
		CyUnit* pyUnit = new CyUnit(this);
		CyPlot* pyPlot = new CyPlot(pTargetPlot);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
		argsList.add(spell);//the spell #
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyPlot));	// pass in plot
		long lResult=0;
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "canCast", argsList.makeFunctionArgs(), &lResult);
		delete pyUnit; // python fxn must not hold on to this pointer
		delete pyPlot;
		if (lResult == 0)
		{
			return false;
		}
		return true;
	}
	if (GC.getSpellInfo(eSpell).isRemoveHasCasted())
	{
		if (isHasCasted())
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getNumAddPromotions() > 0)
	{
		if (canAddPromotion(spell,pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getNumRemovePromotions() > 0)
	{
		if (canRemovePromotion(spell,pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getConvertUnitType() != NO_UNIT)
	{
		return true;
	}
	if (GC.getSpellInfo(eSpell).getCreateFeatureType() != NO_FEATURE)
	{
		if (canCreateFeature(spell,pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getCreatePlotEffectType() != NO_PLOT_EFFECT)
	{
		if (canCreatePlotEffect(spell, pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getRemovePlotEffectType() != NO_PLOT_EFFECT)
	{
		if (canRemovePlotEffect(spell, pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getCreateImprovementType() != NO_IMPROVEMENT)
	{
		if (canCreateImprovement(spell,pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getSpreadReligion() != NO_RELIGION)
	{
		if (canSpreadReligion(spell,pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getCreateBuildingType() != NO_BUILDING)
	{
		return true;
	}
	if (GC.getSpellInfo(eSpell).getCreateUnitType() != NO_UNIT)
	{
		return true;
	}
	if (GC.getSpellInfo(eSpell).getDamage() != 0)
	{
		if (canCastDamage(spell, pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).isDispel())
	{
		if (canDispel(spell,pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getImmobileTurns() > 0)
	{
		if (canImmobile(spell,pTargetPlot))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).isPush())
	{
		if (canPush(spell))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).getChangePopulation() > 0)
	{
		return true;
	}
	if (!CvString(GC.getSpellInfo(eSpell).getPyResult()).empty())
	{
		return true;
	}
/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			07/25/08								Xienwolf	**/
/**																								**/
/**						Allows a Spell with only this function to be cast						**/
/*************************************************************************************************/
	if (GC.getSpellInfo(eSpell).isSummonMaster())
	{
		if (canSummonMaster(spell))
		{
			return true;
		}
	}
	if (GC.getSpellInfo(eSpell).isRemoveHasAttacked())
	{
		if (isMadeAttack())
		{
			return true;
		}
	}

	if (GC.getSpellInfo(eSpell).isPrereqAvailableCommander())
	{
		pUnitNode = pPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->getOwner() == getOwner() && pLoopUnit->getNumMinions() < pLoopUnit->getCommandLimit())
			{
				if(pLoopUnit != getCommanderUnit() && pLoopUnit != this)
				{
					return true;
				}
			}
		}
	}
	if (GC.getSpellInfo(eSpell).getCost() < 0) {
		return true;
	}

	//TargetedSpell 0924 blackimp
	
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	return false;
}
SpellUpgradeData CvUnit::getSpellData(int spell)
{
	int iMagicalPower = getSpellMagicalPower(spell);
	int iExtraPower = iMagicalPower - GC.getSpellInfo((SpellTypes)spell).getMagicalPowerPrereq();
	SpellUpgradeData data;
	SpellBonuses bonus;
	int iNumBonusApplications=0;
	//Core Spell Data
	data.iDamage = GC.getSpellInfo((SpellTypes)spell).getDamage();
	data.iMaxDamage = GC.getSpellInfo((SpellTypes)spell).getDamageLimit();
	data.iNumTargets = GC.getSpellInfo((SpellTypes)spell).getNumTargets();


	//Applying Spell Bonuses
	for (int iI = 0; iI < GC.getSpellInfo((SpellTypes)spell).getNumSpellBonuses(); iI++)
	{
		 bonus = GC.getSpellInfo((SpellTypes)spell).getSpellBonus(iI);

		 iNumBonusApplications =std::min( (iExtraPower/(bonus.iPrereqExtraPower)), bonus.iMaxApplications);
		if (iNumBonusApplications > 0)
		{
			data.iDamage += bonus.iExtraDamage * iNumBonusApplications;
			data.iMaxDamage += bonus.iExtraMaxDamage * iNumBonusApplications;
			data.iNumTargets += bonus.iExtraNumTargets * iNumBonusApplications;
		}
	}
	return data;
}
int CvUnit::getSpellTargetRange(int spell)
{
	int iMagicalPower = getSpellMagicalPower(spell);
	int iExtraPower = iMagicalPower - GC.getSpellInfo((SpellTypes)spell).getMagicalPowerPrereq();
	int iTargetRange = GC.getSpellInfo((SpellTypes)spell).getTargetRange();
	SpellBonuses bonus;
	int iNumBonusApplications = 0; 
	//Applying Spell Bonuses
	for (int iI = 0; iI < GC.getSpellInfo((SpellTypes)spell).getNumSpellBonuses(); iI++)
	{
		bonus = GC.getSpellInfo((SpellTypes)spell).getSpellBonus(iI);
		iNumBonusApplications = 0;
		if(bonus.iPrereqExtraPower>0)
			iNumBonusApplications = std::min((iExtraPower / (bonus.iPrereqExtraPower)), bonus.iMaxApplications);
		if (iNumBonusApplications > 0)
		{
			iTargetRange += bonus.iExtraTargetRange * iNumBonusApplications;
		}
	}
	return iTargetRange;
}
bool CvUnit::isSpellImmuneTeam(int spell)
{
	int iMagicalPower = getSpellMagicalPower(spell);
	int iExtraPower = iMagicalPower - GC.getSpellInfo((SpellTypes)spell).getMagicalPowerPrereq();
	int iTargetRange = GC.getSpellInfo((SpellTypes)spell).getTargetRange();
	SpellBonuses bonus;
	int iNumBonusApplications = 0;
	//Applying Spell Bonuses
	for (int iI = 0; iI < GC.getSpellInfo((SpellTypes)spell).getNumSpellBonuses(); iI++)
	{
	
		bonus = GC.getSpellInfo((SpellTypes)spell).getSpellBonus(iI);
		if (bonus.bExtraImmuneTeam)
		{
			iNumBonusApplications = 0;
			if (bonus.iPrereqExtraPower > 0)
				iNumBonusApplications = std::min((iExtraPower / (bonus.iPrereqExtraPower)), bonus.iMaxApplications);
			if (iNumBonusApplications > 0)
			{
				return true;
			}
		}
	}
	return false;
}
bool CvUnit::canCastTargetPlot(int spell, bool bTestVisible, CvPlot* pTargetPlot) const
{
	SpellTypes eSpell = (SpellTypes)spell;
	CvUnit* pLoopUnit;
	CLLNode<IDInfo>* pUnitNode;
	bool bValid = false;

	if (GC.getSpellInfo(eSpell).getCorporationTargetPrereq() != NO_CORPORATION)
	{
		if (!pTargetPlot->isCity())
		{
			return false;
		}
		if (!pTargetPlot->getPlotCity()->isHasCorporation((CorporationTypes)GC.getSpellInfo(eSpell).getCorporationTargetPrereq()))
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getImprovementTargetPrereq() != NO_IMPROVEMENT)
	{
		if (pTargetPlot->getImprovementType() != GC.getSpellInfo(eSpell).getImprovementTargetPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getPlotEffectTargetPrereq() != NO_PLOT_EFFECT)
	{
		if (pTargetPlot->getPlotEffectType() != GC.getSpellInfo(eSpell).getPlotEffectTargetPrereq())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getNumTargetPromotionsPrereq() > 0)
	{
		bValid = false;
		for (int i = 0; i < GC.getSpellInfo(eSpell).getNumTargetPromotionsPrereq(); i++)
		{
			pUnitNode = pTargetPlot->headUnitNode();
			while (pUnitNode != NULL)
			{
				pLoopUnit = ::getUnit(pUnitNode->m_data);
				pUnitNode = pTargetPlot->nextUnitNode(pUnitNode);
				if (pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo(eSpell).getTargetPromotionPrereq(i)))
				{
					bValid = true;
					break;
				}
			}
		}
		if (bValid == false)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getPromotionInStackTargetPrereq() != NO_PROMOTION)
	{
		bValid = false;
		pUnitNode = pTargetPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pTargetPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo(eSpell).getPromotionInStackTargetPrereq()))
			{
				bValid = true;
				break;
			}
		}
		if (bValid == false)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getUnitInStackTargetPrereq() != NO_UNIT)
	{
		bValid = false;
		pUnitNode = pTargetPlot->headUnitNode();
		while (pUnitNode != NULL)
		{
			pLoopUnit = ::getUnit(pUnitNode->m_data);
			pUnitNode = pTargetPlot->nextUnitNode(pUnitNode);
			if (pLoopUnit->getUnitType() == (UnitTypes)GC.getSpellInfo(eSpell).getUnitInStackTargetPrereq())
			{
				bValid = true;
				break;
			}
		}
		if (bValid == false)
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).getFeatureOrTargetPrereq1() != NO_FEATURE)
	{
		if (pTargetPlot->getFeatureType() != GC.getSpellInfo(eSpell).getFeatureOrTargetPrereq1())
		{
			if (GC.getSpellInfo(eSpell).getFeatureOrTargetPrereq2() == NO_FEATURE || pTargetPlot->getFeatureType() != GC.getSpellInfo(eSpell).getFeatureOrTargetPrereq2())
			{
				return false;
			}
		}
	}
	if (GC.getSpellInfo(eSpell).isTargetAdjacentToWaterOnly())
	{
		if (!pTargetPlot->isAdjacentToWater())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isTargetInBordersOnly())
	{
		if (pTargetPlot->getOwner() != getOwner())
		{
			return false;
		}
	}
	if (GC.getSpellInfo(eSpell).isTargetInCityOnly())
	{
		if (!pTargetPlot->isCity())
		{
			return false;
		}
	}

	return true;
}

int CvUnit::getSpellDefenderValue(CvUnit* pLoopUnit, CvPlot* pTargetplot, int iDmgType) const {
	int iValue = 0;

	if (pLoopUnit == pTargetplot->getBestDefender(getOwnerINLINE()))
	{
		iValue = MAX_INT;
	}
	else if (pLoopUnit->getTeam() == getTeam())
	{
		iValue = 1;
	}
	else if (!GET_TEAM(getTeam()).isAtWar(pLoopUnit->getTeam()))
	{
		iValue = 2;
	}
	else
	{
		iValue = (pLoopUnit->baseCombatStr() + pLoopUnit->baseCombatStrDefense()) * 100 / (10 + pLoopUnit->getDamage());
		if (iDmgType != -1)
		{
			iValue *= 100;
			iValue /= std::max(1, 100 - pLoopUnit->getDamageTypeResist((DamageTypes)iDmgType));
		}
		iValue = std::max(iValue, 3);
	}

	return iValue;
}

bool CvUnit::canCreateUnit(int spell, CvPlot* pTargetPlot) const
{
	if (getDuration() > 0) // to prevent summons summoning spinlocks
	{
		if (GC.getSpellInfo((SpellTypes)spell).getCreateUnitType() == getUnitType())
		{
			return false;
		}
	}
	if (pTargetPlot->isVisibleEnemyUnit(getOwnerINLINE())) // keeps invisible units from CtDing summoning on top of enemies
	{
		return false;
	}
	if (!(pTargetPlot->isValidDomainForAction(GC.getSpellInfo((SpellTypes)spell).getCreateUnitType())) && GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)spell).getCreateUnitType()).getDomainType()!=DOMAIN_AIR)
	{
		return false;
	}
	if (pTargetPlot->isPeak() && !GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)spell).getCreateUnitType()).isCanClimbPeaks() && !GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)spell).getCreateUnitType()).isCanMoveAllTerrain())
	{
		return false;
	}
	if (GC.getSpellInfo((SpellTypes)spell).isPermanentUnitCreate())
	{
/*************************************************************************************************/
/**	Whiplash								07/23/08								Xienwolf	**/
/**	Can now easily allow more than 1 of specific units per caster, by Spell/Summoner/Civ/etc..	**/
/**			Tracks Unit's Summoned by Caster and Caster who Summoned Conjured Units				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		int iCount = 0;
		int iLoop = 0;
		CvUnit* pLoopUnit;
		CvPlayer& kPlayer = GET_PLAYER(getOwnerINLINE());
		for (pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))
		{
			if ((GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq1() == NO_PROMOTION ||
			  pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq1())) &&
			  (GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq2() == NO_PROMOTION ||
			  pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getPromotionPrereq2())) &&
			  (GC.getSpellInfo((SpellTypes)spell).getReligionPrereq() == NO_RELIGION ||
			  pLoopUnit->getReligion() == GC.getSpellInfo((SpellTypes)spell).getReligionPrereq()))
			{
				iCount += 1;
			}
		}
		if (iCount <= kPlayer.getUnitClassCount((UnitClassTypes)GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)spell).getCreateUnitType()).getUnitClassType()))
/**								----  End Original Code  ----									**/
		if (getNumSlavesOfClass((UnitClassTypes)GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)spell).getCreateUnitType()).getUnitClassType()) > 0)
/*************************************************************************************************/
/**	Whiplash								END													**/
/*************************************************************************************************/
		{
			return false;
		}
	}
	return true;
}

/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			07/25/08								Xienwolf	**/
/**																								**/
/**					Checks to ensure spell is castable for current location/unit				**/
/*************************************************************************************************/
bool CvUnit::canSummonMaster(int spell)
{
	if (getMasterUnit() == NULL)
	{
		return false;
	}
	if (isCargo())
	{
		return false;
	}

	CvPlot* pPlot = plot();
	return (getMasterUnit()->canAdvance(pPlot, 0) && getMasterUnit()->canMoveInto(pPlot, false, false, true));
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
bool CvUnit::canAddPromotion(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	for (int promidx = 0; promidx < GC.getSpellInfo((SpellTypes)spell).getNumAddPromotions(); promidx++)
	{
		PromotionTypes ePromotion1 = (PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getAddPromotion(promidx);

		if (GC.getSpellInfo((SpellTypes)spell).isBuffCasterOnly())
		{
			if (ePromotion1 != NO_PROMOTION)
			{
				/*************************************************************************************************/
				/**	Xienwolf Tweak							03/18/09											**/
				/**																								**/
				/**				Accounts for Blocked Promotions on a unit to prevent useless casting			**/
				/*************************************************************************************************/
				/**								---- Start Original Code ----									**
							if (!isHasPromotion(ePromotion1))
							{
								return true;
							}
						}
						if (ePromotion2 != NO_PROMOTION)
						{
							if (!isHasPromotion(ePromotion2))
							{
								return true;
							}
						}
						if (ePromotion3 != NO_PROMOTION)
						{
							if (!isHasPromotion(ePromotion3))
							{
								return true;
							}
				/**								----  End Original Code  ----									**/
				if (!isHasPromotion(ePromotion1) || GC.getPromotionInfo(ePromotion1).isStackEffect())
				{
					if (!isDenyPromotion(ePromotion1))
					{
						return true;
					}
				}
			}

			return false;
		}
		CvUnit* pLoopUnit;
		CvPlot* pLoopPlot;
		int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
		/*************************************************************************************************/
		/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
		/**																								**/
		/**						Allows SpellRange to be extended by Promotions							**/
		/*************************************************************************************************/
		iRange += getSpellExtraRange();
		/*************************************************************************************************/
		/**	Spellcasting Range						END													**/
		/*************************************************************************************************/
		for (int i = -iRange; i <= iRange; ++i)
		{
			for (int j = -iRange; j <= iRange; ++j)
			{
				pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
				if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
				{
					CLLNode<IDInfo>* pUnitNode = pLoopPlot->headUnitNode();
					while (pUnitNode != NULL)
					{
						pLoopUnit = ::getUnit(pUnitNode->m_data);
						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
						if (!pLoopUnit->isImmuneToSpell(this, spell))
						{
							if (ePromotion1 != NO_PROMOTION)
							{
								if (pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT)
								{
									if (GC.getPromotionInfo(ePromotion1).getUnitCombat(pLoopUnit->getUnitCombatType()))
									{
										/*************************************************************************************************/
										/**	Xienwolf Tweak							03/18/09											**/
										/**																								**/
										/**				Accounts for Blocked Promotions on a unit to prevent useless casting			**/
										/*************************************************************************************************/
										/**								---- Start Original Code ----									**
																			if (!pLoopUnit->isHasPromotion(ePromotion1))
																			{
																				return true;
																			}
																		}
																	}
																}
																if (ePromotion2 != NO_PROMOTION)
																{
																	if (pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT)
																	{
																		if (GC.getPromotionInfo(ePromotion2).getUnitCombat(pLoopUnit->getUnitCombatType()))
																		{
																			if (!pLoopUnit->isHasPromotion(ePromotion2))
																			{
																				return true;
																			}
																		}
																	}
																}
																if (ePromotion3 != NO_PROMOTION)
																{
																	if (pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT)
																	{
																		if (GC.getPromotionInfo(ePromotion3).getUnitCombat(pLoopUnit->getUnitCombatType()))
																		{
																			if (!pLoopUnit->isHasPromotion(ePromotion3))
																			{
																				return true;
																			}
										/**								----  End Original Code  ----									**/
										if (!pLoopUnit->isHasPromotion(ePromotion1) || GC.getPromotionInfo(ePromotion1).isStackEffect())
										{
											if (!pLoopUnit->isDenyPromotion(ePromotion1))
											{
												return true;
											}
										}
									}
									/*************************************************************************************************/
									/**	Second Job							08/28/10									Valkrionn	**/
									/**				Allows units to qualify for the promotions of other UnitCombats					**/
									/*************************************************************************************************/
									for (int iK = 0; iK < GC.getNumUnitCombatInfos(); iK++)
									{
										if (pLoopUnit->isSecondaryUnitCombat((UnitCombatTypes)iK) && GC.getPromotionInfo(ePromotion1).getUnitCombat(iK))
										{
											if (!pLoopUnit->isHasPromotion(ePromotion1) || GC.getPromotionInfo(ePromotion1).isStackEffect())
											{
												if (!pLoopUnit->isDenyPromotion(ePromotion1))
												{
													return true;
												}
											}
										}
									}
									/*************************************************************************************************/
									/**	TempCombat									END												**/
									/*************************************************************************************************/
								}
							}
						}
					}
				}
			}
		}
	}
	return false;
}
bool CvUnit::canCastDamage(int spell, CvPlot* pTargetPlot)
{
	SpellUpgradeData spellData = getSpellData(spell);
	bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
	int iDmg = spellData.iDamage;
	int iDmgLimit = spellData.iMaxDamage;
	int iNumTargets = spellData.iNumTargets;
	int iDmgType = GC.getSpellInfo((SpellTypes)spell).getDamageType();
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();


	/*************************************************************************************************/
	/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
	/**																								**/
	/**						Allows SpellRange to be extended by Promotions							**/
	/*************************************************************************************************/
	iRange += getSpellExtraRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						END													**/
	/*************************************************************************************************/


	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	bool* bUnitHit = NULL;
	bool bValid = true;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell, false, pLoopPlot))
			{
				if (pLoopPlot->getX() != plot()->getX() || pLoopPlot->getY() != plot()->getY())
				{
					pUnitNode = pLoopPlot->headUnitNode();
					while (pUnitNode != NULL)
					{
						pLoopUnit = ::getUnit(pUnitNode->m_data);
						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
						if (pLoopUnit != NULL)
						{
							if (GC.getSpellInfo((SpellTypes)spell).getNumTargetPromotionsPrereq() > 0)
							{
								bValid = false;
								for (int k = 0; k < GC.getSpellInfo((SpellTypes)spell).getNumTargetPromotionsPrereq(); k++)
								{
									if (pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getTargetPromotionPrereq(k)))
									{
										bValid = true;
										break;
									}
								}
							}
							if (bValid && !pLoopUnit->isImmuneToSpell(this, spell))
							{
								return true;
							}
						}
					}
				}
			}
		}
	}
	return false;
}

bool CvUnit::canCreateBuilding(int spell, CvPlot* pTargetPlot) const
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	if (!pTargetPlot->isCity())
	{
		return false;
	}
	if (pTargetPlot->getPlotCity()->getNumBuilding((BuildingTypes)GC.getSpellInfo((SpellTypes)spell).getCreateBuildingType()) > 0)
	{
		return false;
	}
	return true;
}
bool CvUnit::canCreateFeature(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	CvPlot* pLoopPlot;
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
	/**																								**/
	/**						Allows SpellRange to be extended by Promotions							**/
	/*************************************************************************************************/
	iRange += getSpellExtraRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						END													**/
	/*************************************************************************************************/
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell, false, pLoopPlot))
			{
				if (canCreateFeaturePlot(spell, pLoopPlot))
				{
					return true;
				}
			}
		}
	}
	return false;
}

bool CvUnit::canCreateFeaturePlot(int spell, CvPlot* pTargetPlot) const
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	if (pTargetPlot->isCity())
	{
		return false;
	}
	if (!pTargetPlot->canHaveFeature((FeatureTypes)GC.getSpellInfo((SpellTypes)spell).getCreateFeatureType()))
	{
		return false;
	}
	if (pTargetPlot->getFeatureType() != NO_FEATURE)
	{
		return false;
	}
	if (pTargetPlot->getImprovementType() != NO_IMPROVEMENT)
	{
/*************************************************************************************************/
/**	Feature Spread 	 	   				added by Ahwaric  23.09.09	**/
/*************************************************************************************************/
		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).getAllowsFeature(GC.getSpellInfo((SpellTypes)spell).getCreateFeatureType()))
		{
			return true;
		}
/*************************************************************************************************/
/**	Feature Spread		END								**/
/*************************************************************************************************/
		if (!GC.getCivilizationInfo(getCivilizationType()).isMaintainFeatures(GC.getSpellInfo((SpellTypes)spell).getCreateFeatureType()))
		{
			return false;
		}
	}
	return true;
}

bool CvUnit::canCreatePlotEffect(int spell, CvPlot* pTargetPlot) const
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}

//	if (pTargetPlot->isCity())
//	{
//		return false;
//	}
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
	/**																								**/
	/**						Allows SpellRange to be extended by Promotions							**/
	/*************************************************************************************************/
	iRange += getSpellExtraRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						END													**/
	/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	bool bValid = false;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
			{
				if (pLoopPlot->canHavePlotEffect((PlotEffectTypes)GC.getSpellInfo((SpellTypes)spell).getCreatePlotEffectType()) && !pLoopPlot->getPlotEffectType() != NO_PLOT_EFFECT)
				{
					bValid = true;
				}
			}
		}
	}
	if (!bValid)
	{
		return false;
	}
	return true;
}

bool CvUnit::canRemovePlotEffect(int spell, CvPlot* pTargetPlot) const
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}

	//	if (pTargetPlot->isCity())
	//	{
	//		return false;
	//	}
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
	/**																								**/
	/**						Allows SpellRange to be extended by Promotions							**/
	/*************************************************************************************************/
	iRange += getSpellExtraRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						END													**/
	/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	bool bValid = false;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell, false, pLoopPlot))
			{
				if (pLoopPlot->getPlotEffectType()==GC.getSpellInfo((SpellTypes)spell).getRemovePlotEffectType())
				{
					bValid = true;
				}
			}
		}
	}
	if (!bValid)
	{
		return false;
	}
	return true;
}

bool CvUnit::canCreateImprovement(int spell, CvPlot* pTargetPlot) const
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}

	//	if (pTargetPlot->isCity())
	//	{
	//		return false;
	//	}
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
	/**																								**/
	/**						Allows SpellRange to be extended by Promotions							**/
	/*************************************************************************************************/
	iRange += getSpellExtraRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						END													**/
	/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	bool bValid = false;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell, false, pLoopPlot))
			{
				if (canCreateImprovementPlot(spell,pLoopPlot))
				{
					bValid = true;
				}
			}
		}
	}
	if (!bValid)
	{
		return false;
	}
	return true;
}

bool CvUnit::canCreateImprovementPlot(int spell, CvPlot* pTargetPlot) const
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	if (pTargetPlot->isCity())
	{
		return false;
	}
	if (!pTargetPlot->canHaveImprovement((ImprovementTypes)GC.getSpellInfo((SpellTypes)spell).getCreateImprovementType()))
	{
		return false;
	}
	if (pTargetPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		return false;
	}
	return true;
}

bool CvUnit::canDispel(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
/*************************************************************************************************/
/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**						Allows SpellRange to be extended by Promotions							**/
/*************************************************************************************************/
	iRange += getSpellExtraRange();
/*************************************************************************************************/
/**	Spellcasting Range						END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
			{
				if (pLoopPlot->getPlotEffectType()!=NO_PLOT_EFFECT && GC.getPlotEffectInfo((PlotEffectTypes)pLoopPlot->getPlotEffectType()).isDispellable())
				{
					return true;
				}
				pUnitNode = pLoopPlot->headUnitNode();
				while (pUnitNode != NULL)
				{
					pLoopUnit = ::getUnit(pUnitNode->m_data);
					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
					if (!pLoopUnit->isImmuneToSpell(this, spell))
					{
						for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
						{
							if (pLoopUnit->isHasPromotion((PromotionTypes)iI))
							{
								if (GC.getPromotionInfo((PromotionTypes)iI).isDispellable())
								{
									if ((GC.getPromotionInfo((PromotionTypes)iI).getAIWeight() < 0 && pLoopUnit->getTeam() == getTeam())
									|| (GC.getPromotionInfo((PromotionTypes)iI).getAIWeight() > 0 && pLoopUnit->isEnemy(getTeam())))
									{
										return true;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return false;
}

bool CvUnit::canImmobile(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
/*************************************************************************************************/
/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**						Allows SpellRange to be extended by Promotions							**/
/*************************************************************************************************/
	iRange += getSpellExtraRange();
/*************************************************************************************************/
/**	Spellcasting Range						END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
			{
				pUnitNode = pLoopPlot->headUnitNode();
				while (pUnitNode != NULL)
				{
					pLoopUnit = ::getUnit(pUnitNode->m_data);
					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
					if (!pLoopUnit->isImmuneToSpell(this, spell))
					{
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool CvUnit::canPush(int spell)
{
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
/*************************************************************************************************/
/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**						Allows SpellRange to be extended by Promotions							**/
/*************************************************************************************************/
	iRange += getSpellExtraRange();
/*************************************************************************************************/
/**	Spellcasting Range						END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
			{
				if (!pLoopPlot->isCity())
				{
					pUnitNode = pLoopPlot->headUnitNode();
					while (pUnitNode != NULL)
					{
						pLoopUnit = ::getUnit(pUnitNode->m_data);
						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
						if (!pLoopUnit->isImmuneToSpell(this, spell))
						{
							return true;
						}
					}
				}
			}
		}
	}
	return false;
}

bool CvUnit::canRemovePromotion(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	CvSpellInfo& kSpell = GC.getSpellInfo((SpellTypes)spell);
	for (int promidx = 0; promidx < kSpell.getNumRemovePromotions(); promidx++)
	{
		PromotionTypes ePromotion1 = (PromotionTypes)kSpell.getRemovePromotion(promidx);
		if (pTargetPlot->isVisibleEnemyUnit(getOwnerINLINE()))
		{
			if (ePromotion1 == (PromotionTypes)GC.getDefineINT("HIDDEN_NATIONALITY_PROMOTION"))
			{
				return false;
			}

		}
		if (GC.getSpellInfo((SpellTypes)spell).isBuffCasterOnly())
		{
			if (ePromotion1 != NO_PROMOTION)
			{
				if (isHasPromotion(ePromotion1))
				{
					return true;
				}
			}

			return false;
		}
		CvUnit* pLoopUnit;
		CvPlot* pLoopPlot;
		int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
		/*************************************************************************************************/
		/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
		/**																								**/
		/**						Allows SpellRange to be extended by Promotions							**/
		/*************************************************************************************************/
		iRange += getSpellExtraRange();
		/*************************************************************************************************/
		/**	Spellcasting Range						END													**/
		/*************************************************************************************************/
		for (int i = -iRange; i <= iRange; ++i)
		{
			for (int j = -iRange; j <= iRange; ++j)
			{
				pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
				if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
				{
					CLLNode<IDInfo>* pUnitNode = pLoopPlot->headUnitNode();
					while (pUnitNode != NULL)
					{
						pLoopUnit = ::getUnit(pUnitNode->m_data);
						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
						if (!pLoopUnit->isImmuneToSpell(this, spell))
						{
							if (ePromotion1 != NO_PROMOTION)
							{
								if (pLoopUnit->isHasPromotion(ePromotion1))
								{
									return true;
								}
							}

						}
					}
				}
			}
		}
	}
	return false;
}

bool CvUnit::canSpreadReligion(int spell, CvPlot* pTargetPlot) const
{
	ReligionTypes eReligion = (ReligionTypes)GC.getSpellInfo((SpellTypes)spell).getSpreadReligion();
	if (eReligion == NO_RELIGION)
	{
		return false;
	}
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}

	CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity == NULL)
	{
		return false;
	}
	if (pCity->isHasReligion(eReligion))
	{
		return false;
	}
	return true;
}

//TargetedSpell 0924 blackimp
void CvUnit::cast(int spell,CvPlot* pTargetPlot)
{

	TraitTriggeredData kTrigger;
	kTrigger.m_iSpell = (SpellTypes)spell;
	kTrigger.m_iUnitClass = getUnitClassType();
	kTrigger.m_iUnitCombat = getUnitCombatType();
	kTrigger.m_iRace = (PromotionTypes)getRace();
	//kTrigger.eLevel = getLevel();
	kTrigger.m_iReligion = GET_PLAYER(getOwner()).getStateReligion();
	kTrigger.m_iAlignment = GET_PLAYER(getOwner()).getBroadAlignment();
	kTrigger.m_iEthicalAlignment = GET_PLAYER(getOwner()).getBroadEthicalAlignment();
	kTrigger.m_iAlignmentStatus = GET_PLAYER(getOwner()).getAlignment();
	kTrigger.m_iEthicalAlignmentStatus = GET_PLAYER(getOwner()).getEthicalAlignment();
	GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_CAST_SPELL, &kTrigger);

	//TargetedSpell 0924 blackimp
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	GC.getGame().clearSpellColoredPlot();


	if (GC.getSpellInfo((SpellTypes)spell).isHasCasted())
	{
/*************************************************************************************************/
/**	Xienwolf Tweak							10/07/08											**/
/**																								**/
/**						Allows Twincast to cast a seperate spell, and stack						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		setHasCasted(true);
	}
/**								----  End Original Code  ----									**/
		if (getCastingLimit() > 0)
		{
			changeCastingLimit(-1);
		}
		else
		{
			setHasCasted(true);
		}
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Broader Alignments						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**					Allows the casting of a spell to modify alignment							**/
/*************************************************************************************************/
	if (GC.getGameINLINE().isOption(GAMEOPTION_BROADER_ALIGNMENTS))
	{
		if (GC.getSpellInfo((SpellTypes)spell).getAlignmentModifier() != 0)
		{
			GET_PLAYER(getOwnerINLINE()).changeBroadEventModifier(GC.getSpellInfo((SpellTypes)spell).getAlignmentModifier());
			GET_PLAYER(getOwnerINLINE()).updateAlignment();
		}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments 				11/06/09								Valkrionn	**/
/**																								**/
/**							Adds a new alignment axis to the game								**/
/*************************************************************************************************/
		if (GC.getSpellInfo((SpellTypes)spell).getEthicalAlignmentModifier() != 0)
		{
			GET_PLAYER(getOwnerINLINE()).changeBroadEthicalEventModifier(GC.getSpellInfo((SpellTypes)spell).getEthicalAlignmentModifier());
			GET_PLAYER(getOwnerINLINE()).updateEthicalAlignment();
		}
/*************************************************************************************************/
/**	Lawful-Chaotic Alignments					END												**/
/*************************************************************************************************/
	}
/*************************************************************************************************/
/**	Broader Alignments							END												**/
/*************************************************************************************************/
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedByCasting())
			{
				setHasPromotion((PromotionTypes)iI, false);
			}
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isGlobal())
	{
		GET_PLAYER(getOwnerINLINE()).setFeatAccomplished(FEAT_GLOBAL_SPELL, true);
		for (int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; ++iPlayer)
		{
			if (GET_PLAYER((PlayerTypes)iPlayer).isAlive())
			{
				gDLL->getInterfaceIFace()->addMessage((PlayerTypes)iPlayer, false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_GLOBAL_SPELL", GC.getSpellInfo((SpellTypes)spell).getDescription()), "AS2D_CIVIC_ADOPT", MESSAGE_TYPE_MINOR_EVENT);
			}
		}
	}
/*************************************************************************************************/
/**	Fizzle									07/10/08								Xienwolf	**/
/**																								**/
/**						Modifies the Chance of a spell Miscasting								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	int iMiscastChance = GC.getSpellInfo((SpellTypes)spell).getMiscastChance() + m_pUnitInfo->getMiscastChance();
/**								----  End Original Code  ----									**/
	int iMiscastChance = GC.getSpellInfo((SpellTypes)spell).getMiscastChance() + m_pUnitInfo->getMiscastChance() + getChanceMiscast();
/*************************************************************************************************/
/**	Fizzle										END												**/
/*************************************************************************************************/
	if (iMiscastChance > 0 && !GC.getSpellInfo((SpellTypes)spell).isAbility())
	{
		if (GC.getGameINLINE().getSorenRandNum(100, "Miscast") < iMiscastChance)
		{
			if (!CvString(GC.getSpellInfo((SpellTypes)spell).getPyMiscast()).empty())
			{
				CyUnit* pyUnit = new CyUnit(this);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
				argsList.add(spell);//the spell #
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "miscast", argsList.makeFunctionArgs()); //, &lResult
				delete pyUnit; // python fxn must not hold on to this pointer
			}
/*************************************************************************************************/
/**	Fizzle								12/13/08									Xienwolf	**/
/**																								**/
/**						Loss of Casting capabilites briefly after a Miscast						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
			gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_MISCAST"), "AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, "art/interface/buttons/spells/miscast.dds", (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
/**								----  End Original Code  ----									**/
			int iBlock = 0;
			if (GC.getDefineINT("MISCAST_PROMOTION") != -1)
			{
				setHasPromotion((PromotionTypes)GC.getDefineINT("MISCAST_PROMOTION"), true);
				iBlock = GC.getGameINLINE().getSorenRandNum(GC.getDefineINT("BASE_MISCAST_DURATION")*GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent()/100, "MiscastDuration");
				setPromotionDuration((PromotionTypes)GC.getDefineINT("MISCAST_PROMOTION"), 2+iBlock);
			}
			gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_MISCAST", GC.getSpellInfo((SpellTypes)spell).getTextKeyWide(), getNameKey()), "AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, "art/interface/buttons/spells/miscast.dds", (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
			/*************************************************************************************************/
/**	Fizzle									END													**/
/*************************************************************************************************/
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
			return;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).getDelay() > 0)
	{
		if (getDelayedSpell() == NO_SPELL)
		{
			changeImmobileTimer(GC.getSpellInfo((SpellTypes)spell).getDelay());
			setDelayedSpell(spell);
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**									Prevents AI Group Lock-ups									**/
/*************************************************************************************************/
			joinGroup(NULL, true, true);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
			gDLL->getInterfaceIFace()->changeCycleSelectionCounter((GET_PLAYER(getOwnerINLINE()).isOption(PLAYEROPTION_QUICK_MOVES)) ? 1 : 2);
			return;
		}
		setDelayedSpell(NO_SPELL);
	}
	if (GC.getSpellInfo((SpellTypes)spell).getCreateUnitType() != -1)
	{
		int iUnitNum = GC.getSpellInfo((SpellTypes)spell).getCreateUnitNum();
/*************************************************************************************************/
/**	Xienwolf Tweak							10/07/08											**/
/**																								**/
/**						Allows Twincast to cast a seperate spell, and stack						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		if (isTwincast())
		{
			iUnitNum *= 2;
		}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		for (int i=0; i < iUnitNum; ++i)
		{
			castCreateUnit(spell,pTargetPlot);
		}
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							09/27/08											**/
/**																								**/
/**				Need these the other way around for some Promotion Immunes						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (GC.getSpellInfo((SpellTypes)spell).getAddPromotionType1() != -1)
	{
		castAddPromotion(spell);
	}
	if (GC.getSpellInfo((SpellTypes)spell).getRemovePromotionType1() != -1)
	{
		castRemovePromotion(spell);
	}
/**								----  End Original Code  ----									**/
	if (GC.getSpellInfo((SpellTypes)spell).getNumRemovePromotions() > 0)
	{
		castRemovePromotion(spell,pTargetPlot);
	}
	if (GC.getSpellInfo((SpellTypes)spell).getNumAddPromotions() > 0)
	{
		castAddPromotion(spell,pTargetPlot);
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (GC.getSpellInfo((SpellTypes)spell).getConvertUnitType() != NO_UNIT)
	{
		castConvertUnit(spell);
	}
	if (GC.getSpellInfo((SpellTypes)spell).getCreateBuildingType() != NO_BUILDING)
	{
		if (canCreateBuilding(spell,pTargetPlot))
		{
			pTargetPlot->getPlotCity()->setNumRealBuilding((BuildingTypes)GC.getSpellInfo((SpellTypes)spell).getCreateBuildingType(), true);
			// DynTraits Start
//	szError.Format("before doTraitTriggers(TRAITHOOK_CONSTRUCT_BUILDING for city ");
//	gDLL->logMsg("trait.log", szError);
			TraitTriggeredData kTriggerData;
			kTriggerData.m_iBuildingClass = (BuildingClassTypes)GC.getBuildingInfo((BuildingTypes)GC.getSpellInfo((SpellTypes)spell).getCreateBuildingType()).getBuildingClassType();
			//kTriggerData.eSpecialBuilding = (SpecialBuildingTypes)GC.getBuildingInfo(eConstructBuilding).getSpecialBuildingType();
			//kTriggerData.bShrine = (GC.getBuildingInfo(eConstructBuilding).getGlobalReligionCommerce() != NO_RELIGION);
			//kTriggerData.bNationalWonder = (GC.getBuildingClassInfo((BuildingClassTypes)GC.getBuildingInfo(eConstructBuilding).getBuildingClassType()).getMaxPlayerInstances() > 0);
			//kTriggerData.bTeamWonder = (GC.getBuildingClassInfo((BuildingClassTypes)GC.getBuildingInfo(eConstructBuilding).getBuildingClassType()).getMaxTeamInstances() > 0);
			//kTriggerData.bWorldWonder = (GC.getBuildingClassInfo((BuildingClassTypes)GC.getBuildingInfo(eConstructBuilding).getBuildingClassType()).getMaxGlobalInstances() > 0);
			kTriggerData.m_bHappy = (GC.getBuildingInfo((BuildingTypes)GC.getSpellInfo((SpellTypes)spell).getCreateBuildingType()).getHappiness() > 0);
			//kTriggerData.bAreaHappiness = (GC.getBuildingInfo(eConstructBuilding).getAreaHappiness() > 0);
			//kTriggerData.bGlobalHappiness = (GC.getBuildingInfo(eConstructBuilding).getGlobalHappiness() > 0);
			kTriggerData.m_bHealth = (GC.getBuildingInfo((BuildingTypes)GC.getSpellInfo((SpellTypes)spell).getCreateBuildingType()).getHealth() > 0);
			//kTriggerData.bAreaHealth = (GC.getBuildingInfo(eConstructBuilding).getAreaHealth() > 0);
			//kTriggerData.bGlobalHealth = (GC.getBuildingInfo(eConstructBuilding).getGlobalHealth() > 0);
			//	szError.Format("before pTrainXPCap for city ");
			//	gDLL->logMsg("trait.log", szError);
			//for (UnitCombatTypes eUnitCombat = (UnitCombatTypes)0; eUnitCombat < GC.getNumUnitCombatInfos(); eUnitCombat = (UnitCombatTypes)(eUnitCombat + 1))
			//{
				//		szError.Format("eUnitCombat %i",eUnitCombat);
				//	gDLL->logMsg("trait.log", szError);
				//		szError.Format("pbTrainXPCap %s",kTriggerData.pbTrainXPCap);
				//	gDLL->logMsg("trait.log", szError);
				//kTriggerData.pbTrainXPCap[eUnitCombat] = (GC.getBuildingInfo(eConstructBuilding).getTrainXPCap(eUnitCombat) > 0);
				//kTriggerData.pbTrainXPRate[eUnitCombat] = (GC.getBuildingInfo(eConstructBuilding).getTrainXPRate(eUnitCombat) > 0);
			//}
			kTriggerData.m_iReligion = GET_PLAYER(getOwner()).getStateReligion();
			//kTriggerData.m_bStateReligion = (GC.getBuildingInfo(eConstructBuilding).getReligionType() == GET_PLAYER(getOwner()).getStateReligion());
			kTriggerData.m_iAlignment = GET_PLAYER(getOwner()).getBroadAlignment();
			kTriggerData.m_iEthicalAlignment = GET_PLAYER(getOwner()).getBroadEthicalAlignment();
			kTriggerData.m_iAlignmentStatus = GET_PLAYER(getOwner()).getAlignment();
			kTriggerData.m_iEthicalAlignmentStatus = GET_PLAYER(getOwner()).getEthicalAlignment();

			GET_PLAYER(getOwnerINLINE()).doTraitTriggers(TRAITHOOK_CONSTRUCT_BUILDING, &kTriggerData);
			// DynTraits End

		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).getCreateFeatureType() != NO_FEATURE)
	{
		if (canCreateFeature(spell,pTargetPlot))
		{
			pTargetPlot->setFeatureType((FeatureTypes)GC.getSpellInfo((SpellTypes)spell).getCreateFeatureType(), -1);
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).getCreatePlotEffectType() != NO_PLOT_EFFECT)
	{
		if (canCreatePlotEffect(spell, pTargetPlot))
		{
			int iRange = (GC.getSpellInfo((SpellTypes)spell).getRange());
			iRange += getSpellExtraRange();
			for (int i = -iRange; i <= iRange; ++i)
			{
				for (int j = -iRange; j <= iRange; ++j)
				{
					CvPlot* pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
					pLoopPlot->setPlotEffectType((PlotEffectTypes)GC.getSpellInfo((SpellTypes)spell).getCreatePlotEffectType());
				}
			}
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).getRemovePlotEffectType() != NO_PLOT_EFFECT)
	{
		if (canRemovePlotEffect(spell, pTargetPlot))
		{
			int iRange = (GC.getSpellInfo((SpellTypes)spell).getRange());
			iRange += getSpellExtraRange();
			for (int i = -iRange; i <= iRange; ++i)
			{
				for (int j = -iRange; j <= iRange; ++j)
				{
					CvPlot* pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
					if (pLoopPlot != NULL)
					{
						pLoopPlot->setPlotEffectType(NO_PLOT_EFFECT);
					}
				}
			}
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).getCreateImprovementType() != NO_IMPROVEMENT)
	{
		if (canCreateImprovement(spell,pTargetPlot))
		{
			pTargetPlot->setImprovementType((ImprovementTypes)GC.getSpellInfo((SpellTypes)spell).getCreateImprovementType());
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).getSpreadReligion() != NO_RELIGION)
	{
		if (canSpreadReligion(spell,pTargetPlot))
		{
			pTargetPlot->getPlotCity()->setHasReligion((ReligionTypes)GC.getSpellInfo((SpellTypes)spell).getSpreadReligion(), true, true, true);
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).getDamage() != 0)
	{
		castDamage(spell,pTargetPlot);
	}
	if (GC.getSpellInfo((SpellTypes)spell).getImmobileTurns() != 0)
	{
		castImmobile(spell,pTargetPlot);
	}
	if (GC.getSpellInfo((SpellTypes)spell).isPush())
	{
		castPush(spell);
	}
	if (GC.getSpellInfo((SpellTypes)spell).isRemoveHasCasted())
	{
		if (getDuration() == 0)
		{
			setHasCasted(false);
/*************************************************************************************************/
/**	Xienwolf Tweak							10/07/08											**/
/**						Allows Twincast to cast a seperate spell, and stack						**/
/**	Function Disabled Temporarily.  Currently it would allow infinite casting with Enchant III	**/
/*************************************************************************************************
			setCastingLimit(getTwincast());
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		}
	}
	int iGameSpeedPercent = GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();

	int iCost = GC.getSpellInfo((SpellTypes)spell).getCost()*iGameSpeedPercent/100;
	if (iCost != 0)
	{
		if (GC.getSpellInfo((SpellTypes)spell).getConvertUnitType() != NO_UNIT)
		{
			iCost += (iCost * GET_PLAYER(getOwnerINLINE()).getUpgradeCostModifier()) / 100;
		}
		GET_PLAYER(getOwnerINLINE()).changeGold(-1 * iCost);
	}
	if (GC.getSpellInfo((SpellTypes)spell).getChangePopulation() != 0)
	{
		pTargetPlot->getPlotCity()->changePopulation(GC.getSpellInfo((SpellTypes)spell).getChangePopulation());
	}
	if (GC.getSpellInfo((SpellTypes)spell).isDispel())
	{
		castDispel(spell,pTargetPlot);
	}
	if (!CvString(GC.getSpellInfo((SpellTypes)spell).getPyResult()).empty())
	{
		CyUnit* pyUnit = new CyUnit(this);
		CyPlot* pyTargetPlot = new CyPlot(pTargetPlot);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyUnit));	// pass in unit class
		argsList.add(spell);//the spell #
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyTargetPlot));	// pass in target plot
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "cast", argsList.makeFunctionArgs()); //, &lResult
		delete pyUnit; // python fxn must not hold on to this pointer
	}
	if (pTargetPlot->isVisibleToWatchingHuman())
	{
		if (GC.getSpellInfo((SpellTypes)spell).getEffect() != -1)
		{
			gDLL->getEngineIFace()->TriggerEffect(GC.getSpellInfo((SpellTypes)spell).getEffect(), pTargetPlot->getPoint(), (float)(GC.getASyncRand().get(360)));
		}
		if (GC.getSpellInfo((SpellTypes)spell).getSound() != NULL)
		{
			gDLL->getInterfaceIFace()->playGeneralSound(GC.getSpellInfo((SpellTypes)spell).getSound(), pTargetPlot->getPoint());
		}
		gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getSpellInfo((SpellTypes)spell).getDescription(), "AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
	}
	gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			07/25/08								Xienwolf	**/
/**																								**/
/**									Executes Spell Function										**/
/*************************************************************************************************/
	if (GC.getSpellInfo((SpellTypes)spell).isSummonMaster())
	{
		castSummonMaster();
	}
	if (GC.getSpellInfo((SpellTypes)spell).isSetHasAttacked())
	{
		setMadeAttack(true);
	}
	if (GC.getSpellInfo((SpellTypes)spell).isRemoveHasAttacked())
	{
		setMadeAttack(false);
	}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	UnitStatistics							07/18/08	Written: Teg Navanis Imported: Xienwolf	**/
/**																								**/
/**							Sends Spellcasting Information to Python							**/
/*************************************************************************************************/
	if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
	{
		ReportEventToPython(this, spell, "spellCast");
	}
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/
	if (GC.getSpellInfo((SpellTypes)spell).isSacrificeCaster())
	{
		kill(true);
	}
}

/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			07/25/08								Xienwolf	**/
/**																								**/
/**									Performs spell Action										**/
/*************************************************************************************************/
void CvUnit::castSummonMaster()
{
	CvPlot* pPlot = plot();
	getMasterUnit()->setXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), false, false, pPlot->isVisibleToWatchingHuman(), false);
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
void CvUnit::castAddPromotion(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	for (int promidx = 0; promidx < GC.getSpellInfo((SpellTypes)spell).getNumAddPromotions(); promidx++)
	{
		PromotionTypes ePromotion1 = (PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getAddPromotion(promidx);

		if (GC.getSpellInfo((SpellTypes)spell).isBuffCasterOnly())
		{
			if (ePromotion1 != NO_PROMOTION)
			{
				setHasPromotion(ePromotion1, true);
				/*************************************************************************************************/
				/**	TickTock							11/04/08									Xienwolf	**/
				/**																								**/
				/**					Allows SpellInfos to override default duration of a Promotion				**/
				/*************************************************************************************************/
				if (GC.getSpellInfo((SpellTypes)spell).getPromotionDuration() != -1)
				{
					setPromotionDuration(ePromotion1, GC.getSpellInfo((SpellTypes)spell).getPromotionDuration());
				}
				/*************************************************************************************************/
				/**	TickTock									END												**/
				/*************************************************************************************************/
			}

		}
		//TargetedSpell 0924 blackimp
		else
		{
			int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
			/*************************************************************************************************/
			/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
			/**																								**/
			/**						Allows SpellRange to be extended by Promotions							**/
			/*************************************************************************************************/
			iRange += getSpellExtraRange();
			/*************************************************************************************************/
			/**	Spellcasting Range						END													**/
			/*************************************************************************************************/
			bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
			CLLNode<IDInfo>* pUnitNode;
			CvUnit* pLoopUnit;
			CvPlot* pLoopPlot;

			for (int i = -iRange; i <= iRange; ++i)
			{
				for (int j = -iRange; j <= iRange; ++j)
				{
					pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
					if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
					{
						pUnitNode = pLoopPlot->headUnitNode();
						while (pUnitNode != NULL)
						{
							pLoopUnit = ::getUnit(pUnitNode->m_data);
							pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
							if (!pLoopUnit->isImmuneToSpell(this, spell))
							{
								if (bResistable)
								{
									if (!pLoopUnit->isResisted(this, spell))
									{
										if (ePromotion1 != NO_PROMOTION)
										{
											if (pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT)
											{
												if (GC.getPromotionInfo(ePromotion1).getUnitCombat(pLoopUnit->getUnitCombatType())|| isAllowPromotion(ePromotion1))
												{
													pLoopUnit->setHasPromotion(ePromotion1, true);
													/*************************************************************************************************/
													/**	TickTock							11/04/08									Xienwolf	**/
													/**																								**/
													/**					Allows SpellInfos to override default duration of a Promotion				**/
													/*************************************************************************************************/
													if (GC.getSpellInfo((SpellTypes)spell).getPromotionDuration() != -1)
													{
														pLoopUnit->setPromotionDuration(ePromotion1, GC.getSpellInfo((SpellTypes)spell).getPromotionDuration());
													}
													/*************************************************************************************************/
													/**	TickTock									END												**/
													/*************************************************************************************************/
												}
												/*************************************************************************************************/
												/**	Second Job							08/28/10									Valkrionn	**/
												/**				Allows units to qualify for the promotions of other UnitCombats					**/
												/*************************************************************************************************/
												for (int iK = 0; iK < GC.getNumUnitCombatInfos(); iK++)
												{
													if (pLoopUnit->isSecondaryUnitCombat((UnitCombatTypes)iK) && GC.getPromotionInfo(ePromotion1).getUnitCombat(iK))
													{
														pLoopUnit->setHasPromotion(ePromotion1, true);
														if (GC.getSpellInfo((SpellTypes)spell).getPromotionDuration() != -1)
														{
															pLoopUnit->setPromotionDuration(ePromotion1, GC.getSpellInfo((SpellTypes)spell).getPromotionDuration());
														}
													}
												}
												/*************************************************************************************************/
												/**	TempCombat									END												**/
												/*************************************************************************************************/
											}
										}

									}
								}
								else
								{
									if (ePromotion1 != NO_PROMOTION)
									{
										if (pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT)
										{
											if (GC.getPromotionInfo(ePromotion1).getUnitCombat(pLoopUnit->getUnitCombatType()))
											{
												pLoopUnit->setHasPromotion(ePromotion1, true);
												/*************************************************************************************************/
												/**	TickTock							11/04/08									Xienwolf	**/
												/**																								**/
												/**					Allows SpellInfos to override default duration of a Promotion				**/
												/*************************************************************************************************/
												if (GC.getSpellInfo((SpellTypes)spell).getPromotionDuration() != -1)
												{
													pLoopUnit->setPromotionDuration(ePromotion1, GC.getSpellInfo((SpellTypes)spell).getPromotionDuration());
												}
												/*************************************************************************************************/
												/**	TickTock									END												**/
												/*************************************************************************************************/
											}
											/*************************************************************************************************/
											/**	Second Job							08/28/10									Valkrionn	**/
											/**				Allows units to qualify for the promotions of other UnitCombats					**/
											/*************************************************************************************************/
											for (int iK = 0; iK < GC.getNumUnitCombatInfos(); iK++)
											{
												if (pLoopUnit->isSecondaryUnitCombat((UnitCombatTypes)iK) && GC.getPromotionInfo(ePromotion1).getUnitCombat(iK))
												{
													pLoopUnit->setHasPromotion(ePromotion1, true);
													if (GC.getSpellInfo((SpellTypes)spell).getPromotionDuration() != -1)
													{
														pLoopUnit->setPromotionDuration(ePromotion1, GC.getSpellInfo((SpellTypes)spell).getPromotionDuration());
													}
												}
											}
											/*************************************************************************************************/
											/**	TempCombat									END												**/
											/*************************************************************************************************/
										}
									}

								}
							}
						}
					}
				}
			}
		}
	}
}

void CvUnit::castDamage(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	SpellUpgradeData spellData = getSpellData(spell);
	bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
	int iDmg = spellData.iDamage;
	int iDmgLimit = spellData.iMaxDamage;
	int iNumTargets = spellData.iNumTargets;
	int iDmgType = GC.getSpellInfo((SpellTypes)spell).getDamageType();
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();


/*************************************************************************************************/
/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**						Allows SpellRange to be extended by Promotions							**/
/*************************************************************************************************/
	iRange += getSpellExtraRange();
/*************************************************************************************************/
/**	Spellcasting Range						END													**/
/*************************************************************************************************/
	
	
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	bool* bUnitHit = NULL;
	bool bValid=true;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
			{
				if (pLoopPlot->getX() != plot()->getX() || pLoopPlot->getY() != plot()->getY())
				{
					if (iNumTargets == -1 || iNumTargets < pLoopPlot->getNumUnits())
					{
						pUnitNode = pLoopPlot->headUnitNode();
						while (pUnitNode != NULL)
						{
							pLoopUnit = ::getUnit(pUnitNode->m_data);
							pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
							if (pLoopUnit != NULL)
							{
								if (GC.getSpellInfo((SpellTypes)spell).getNumTargetPromotionsPrereq() > 0)
								{
									bValid = false;
									for (int k = 0; k < GC.getSpellInfo((SpellTypes)spell).getNumTargetPromotionsPrereq(); k++)
									{
										if (pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getTargetPromotionPrereq(k)))
										{
												bValid = true;
												break;
										}
									}	
								}
								if (bValid && !pLoopUnit->isImmuneToSpell(this, spell))
								{
									if (bResistable)
									{
										if (!pLoopUnit->isResisted(this, spell))
										{
											pLoopUnit->doDamage((iDmg / 2) + GC.getGameINLINE().getSorenRandNum(iDmg, "doDamage"), iDmgLimit, this, iDmgType, true);
										}
									}
									else
									{
										pLoopUnit->doDamage((iDmg / 2) + GC.getGameINLINE().getSorenRandNum(iDmg, "doDamage"), iDmgLimit, this, iDmgType, true);
									}
								}
							}
						}
					}
					else
					{
						int iUnitsOnPlot = pLoopPlot->getNumUnits();
						int iValue;
						int iBestValue = 0;
						int iBestUnitCounter = -1;
						CvUnit* pBestUnit = NULL;
						int iNumUnitsHit = 0;

						bUnitHit = new bool[iUnitsOnPlot];

						for (int k = 0; k < iUnitsOnPlot; k++)
						{
							bUnitHit[k] = false;
						}

						for (int iI = 0; iI < std::min(iUnitsOnPlot, iNumTargets); iI++)
						{
							pUnitNode = pLoopPlot->headUnitNode();
							int iCounter = -1;
							iBestValue = 0;
							pBestUnit = NULL;
							while (pUnitNode != NULL)
							{
								iCounter++; // Start at 0
								pLoopUnit = ::getUnit(pUnitNode->m_data);
								pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
								if (GC.getSpellInfo((SpellTypes)spell).getNumTargetPromotionsPrereq() > 0)
								{
									bValid = false;
									for (int k = 0; k < GC.getSpellInfo((SpellTypes)spell).getNumTargetPromotionsPrereq(); k++)
									{
										if (pLoopUnit->isHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getTargetPromotionPrereq(k)))
										{
											bValid = true;
											break;
										}
									}
								}
								if (bValid && !pLoopUnit->isImmuneToSpell(this, spell))
								{
									if (GC.getSpellInfo((SpellTypes)spell).isCausesWar() || GET_TEAM(getTeam()).isAtWar(pLoopUnit->getTeam()))
									{
										if (!bUnitHit[iCounter])
										{
											iValue = getSpellDefenderValue(pLoopUnit, pLoopPlot, iDmgType);

											if (iValue > iBestValue)
											{
												iBestValue = iValue;
												pBestUnit = pLoopUnit;
												iBestUnitCounter = iCounter;
											}
										}
									}
								}
							}
							if (pBestUnit != NULL)
							{
								pBestUnit->doDamage(iDmg, iDmgLimit, this, iDmgType, true);
								bUnitHit[iBestUnitCounter] = true;
							}
						}
						SAFE_DELETE_ARRAY(bUnitHit);

					}
				}
				
			}
		}
	}
}

void CvUnit::castDispel(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
/*************************************************************************************************/
/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**						Allows SpellRange to be extended by Promotions							**/
/*************************************************************************************************/
	iRange += getSpellExtraRange();
/*************************************************************************************************/
/**	Spellcasting Range						END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	
	CvPlot* pLoopPlot;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pTargetPlot))
			{
				if (pLoopPlot->getPlotEffectType()!=NO_PLOT_EFFECT && GC.getPlotEffectInfo((PlotEffectTypes)pLoopPlot->getPlotEffectType()).isDispellable())
				{
					pLoopPlot->setPlotEffectType(NO_PLOT_EFFECT);
				}
				pUnitNode = pLoopPlot->headUnitNode();
				while (pUnitNode != NULL)
				{
					pLoopUnit = ::getUnit(pUnitNode->m_data);
					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
					if (!pLoopUnit->isImmuneToSpell(this, spell))
					{
						if (pLoopUnit->isEnemy(getTeam()))
						{
							if (bResistable)
							{
								if (pLoopUnit->isResisted(this, spell))
								{
									continue;
								}
							}
							for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
							{
								if (GC.getPromotionInfo((PromotionTypes)iI).isDispellable() && GC.getPromotionInfo((PromotionTypes)iI).getAIWeight() > 0)
								{
									pLoopUnit->setHasPromotion((PromotionTypes)iI, false);
								}
							}
						}
						else
						{
							for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
							{
								if (GC.getPromotionInfo((PromotionTypes)iI).isDispellable() && GC.getPromotionInfo((PromotionTypes)iI).getAIWeight() < 0)
								{
									pLoopUnit->setHasPromotion((PromotionTypes)iI, false);
								}
							}
						}
					}
				}
			}
		}
	}
}

void CvUnit::castImmobile(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
	int iImmobileTurns = GC.getSpellInfo((SpellTypes)spell).getImmobileTurns();
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
/*************************************************************************************************/
/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**						Allows SpellRange to be extended by Promotions							**/
/*************************************************************************************************/
	iRange += getSpellExtraRange();
/*************************************************************************************************/
/**	Spellcasting Range						END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
			{
				if (pLoopPlot->getX() != pTargetPlot->getX() || pTargetPlot->getY() != plot()->getY())
				{
					pUnitNode = pLoopPlot->headUnitNode();
					while (pUnitNode != NULL)
					{
						pLoopUnit = ::getUnit(pUnitNode->m_data);
						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
						if (!pLoopUnit->isImmuneToSpell(this, spell) && pLoopUnit->getImmobileTimer() == 0)
						{
							if (bResistable)
							{
								if (!pLoopUnit->isResisted(this, spell))
								{
									pLoopUnit->changeImmobileTimer(iImmobileTurns);
									/*************************************************************************************************/
									/**	Xienwolf Tweak							09/06/08											**/
									/**																								**/
									/**									Prevents AI Group Lock-ups									**/
									/*************************************************************************************************/
									pLoopUnit->joinGroup(NULL, true, true);
									/*************************************************************************************************/
									/**	Tweak									END													**/
									/*************************************************************************************************/
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoopUnit->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_IMMOBILE"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_IMMOBILE"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
								}
							}
							else
							{
								pLoopUnit->changeImmobileTimer(iImmobileTurns);
								/*************************************************************************************************/
								/**	Xienwolf Tweak							09/06/08											**/
								/**																								**/
								/**									Prevents AI Group Lock-ups									**/
								/*************************************************************************************************/
								pLoopUnit->joinGroup(NULL, true, true);
								/*************************************************************************************************/
								/**	Tweak									END													**/
								/*************************************************************************************************/
								gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoopUnit->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_IMMOBILE"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
								gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_IMMOBILE"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
							}
						}
					}
				}
			}
		}
	}
}

void CvUnit::castPush(int spell)
{
	bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
/*************************************************************************************************/
/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**						Allows SpellRange to be extended by Promotions							**/
/*************************************************************************************************/
	iRange += getSpellExtraRange();
/*************************************************************************************************/
/**	Spellcasting Range						END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	CvPlot* pPushPlot;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			int iPushY = plot()->getY_INLINE() + (i*2);
			pLoopPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i, j);
			pPushPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i*2, j*2);
			if (!pLoopPlot->isCity())
			{
				if (NULL != pLoopPlot)
				{
					if (NULL != pPushPlot)
					{
						if (pLoopPlot->getX() != plot()->getX() || pLoopPlot->getY() != plot()->getY())
						{
							pUnitNode = pLoopPlot->headUnitNode();
							while (pUnitNode != NULL)
							{
								pLoopUnit = ::getUnit(pUnitNode->m_data);
								pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
								if (pLoopUnit->canMoveInto(pPushPlot, false, false, false))
								{
									if (!pLoopUnit->isImmuneToSpell(this, spell))
									{
										if (bResistable)
										{
											if (!pLoopUnit->isResisted(this, spell))
											{
												pLoopUnit->setXY(pPushPlot->getX(),pPushPlot->getY(),false,true,true);
												gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_PUSH"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
												gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_PUSH"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
											}
										}
										else
										{
											pLoopUnit->setXY(pPushPlot->getX(),pPushPlot->getY(),false,true,true);
											gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_PUSH"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
											gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_PUSH"), "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT, GC.getSpellInfo((SpellTypes)spell).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

void CvUnit::castRemovePromotion(int spell, CvPlot* pTargetPlot)
{
	if (pTargetPlot == NULL)
	{
		pTargetPlot = plot();
	}
	CvSpellInfo& kSpell = GC.getSpellInfo((SpellTypes)spell);
	for (int promidx = 0; promidx < kSpell.getNumRemovePromotions(); promidx++)
	{
		PromotionTypes ePromotion1 = (PromotionTypes)kSpell.getRemovePromotion(promidx);
		if (GC.getSpellInfo((SpellTypes)spell).isBuffCasterOnly())
		{
			if (ePromotion1 != NO_PROMOTION)
			{
				setHasPromotion(ePromotion1, false);
			}

		}
		else
		{
			int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
			/*************************************************************************************************/
			/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
			/**																								**/
			/**						Allows SpellRange to be extended by Promotions							**/
			/*************************************************************************************************/
			iRange += getSpellExtraRange();
			/*************************************************************************************************/
			/**	Spellcasting Range							END												**/
			/*************************************************************************************************/
			bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
			CLLNode<IDInfo>* pUnitNode;
			CvUnit* pLoopUnit;
			CvPlot* pLoopPlot;
			for (int i = -iRange; i <= iRange; ++i)
			{
				for (int j = -iRange; j <= iRange; ++j)
				{
					pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
					if (NULL != pLoopPlot && canCastTargetPlot(spell,false,pLoopPlot))
					{
						pUnitNode = pLoopPlot->headUnitNode();
						while (pUnitNode != NULL)
						{
							pLoopUnit = ::getUnit(pUnitNode->m_data);
							pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
							if (!pLoopUnit->isImmuneToSpell(this, spell))
							{
								if (bResistable)
								{
									if (!pLoopUnit->isResisted(this, spell))
									{
										if (ePromotion1 != NO_PROMOTION)
										{
											pLoopUnit->setHasPromotion(ePromotion1, false);
										}

									}
								}
								else
								{
									if (ePromotion1 != NO_PROMOTION)
									{
										pLoopUnit->setHasPromotion(ePromotion1, false);
									}

								}
							}
						}
					}
				}
			}
		}
	}
}


void CvUnit::castConvertUnit(int spell)
{
	CvUnit* pUnit;
	pUnit = GET_PLAYER(getOwnerINLINE()).initUnit((UnitTypes)GC.getSpellInfo((SpellTypes)spell).getConvertUnitType(), getX_INLINE(), getY_INLINE(), AI_getUnitAIType());
	pUnit->convert(this);
	pUnit->changeImmobileTimer(1);
}

void CvUnit::castCreateUnit(int spell, CvPlot* pTargetPlot)
{
	int iI;
	CvUnit* pUnit;
	int iRange = GC.getSpellInfo((SpellTypes)spell).getRange();
	/*************************************************************************************************/
	/**	Spellcasting Range						04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
	/**																								**/
	/**						Allows SpellRange to be extended by Promotions							**/
	/*************************************************************************************************/
	iRange += getSpellExtraRange();
	/*************************************************************************************************/
	/**	Spellcasting Range							END												**/
	/*************************************************************************************************/
	bool bResistable = GC.getSpellInfo((SpellTypes)spell).isResistable();
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), i, j);
			if (NULL != pLoopPlot && canCastTargetPlot(spell, false, pLoopPlot) && canCreateUnit(spell,pLoopPlot))
			{
				pUnit = GET_PLAYER(getOwnerINLINE()).initUnit((UnitTypes)GC.getSpellInfo((SpellTypes)spell).getCreateUnitType(), pLoopPlot->getX(), pLoopPlot->getY(), UNITAI_ATTACK);
				pUnit->setSummoner(getID());
				/*************************************************************************************************/
				/**	Whiplash								07/23/08								Xienwolf	**/
				/**						Prevents Unit Upkeep costs from Summons									**/
				/**			Tracks Unit's Summoned by Caster and Caster who Summoned Conjured Units				**/
				/*************************************************************************************************/
				pUnit->changeFreeUnit(1);
				pUnit->changeNoSupply(1);
				pUnit->setMasterUnit(getIDInfo());
				pUnit->setLeashUnit(getIDInfo());

				addSlaveUnit(pUnit->getID());
				/*************************************************************************************************/
				/**	Whiplash								END													**/
				/*************************************************************************************************/
				if (GC.getSpellInfo((SpellTypes)spell).isPermanentUnitCreate())
				{
					pUnit->changeImmobileTimer(2);
				}
				else
				{
					pUnit->changeDuration(2);
					if (pUnit->getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL"))
					{
						pUnit->changeDuration(GET_PLAYER(getOwnerINLINE()).getSummonDuration());
					}
					/*************************************************************************************************/
					/**	Xienwolf Tweak							06/18/09											**/
					/**																								**/
					/**						This is already handled by setFreeUnit(1) above							**/
					/*************************************************************************************************/
					/**								---- Start Original Code ----									**
							if (plot()->getTeam() != getTeam())
							{
								GET_PLAYER(getOwnerINLINE()).changeNumOutsideUnits(-1);
							}
					/**								----  End Original Code  ----									**/
					/*************************************************************************************************/
					/**	Tweak									END													**/
					/*************************************************************************************************/
				}
				for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
				{
					if (isHasPromotion((PromotionTypes)iI))
					{
						if (GC.getSpellInfo((SpellTypes)spell).isCopyCastersPromotions())
						{
							if (!GC.getPromotionInfo((PromotionTypes)iI).isEquipment() && !GC.getPromotionInfo((PromotionTypes)iI).isRace() && !GC.getPromotionInfo((PromotionTypes)iI).isEffectProm() && iI != GC.getDefineINT("GREAT_COMMANDER_PROMOTION") && !GC.getPromotionInfo((PromotionTypes)iI).isGraphicalAddOnPromotion())
							{
								pUnit->setHasPromotion((PromotionTypes)iI, true);
							}
						}
						else
						{
							if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk() != NO_PROMOTION)
							{
								/*************************************************************************************************/
								/**	Xienwolf Tweak							10/01/08											**/
								/**																								**/
								/**						Prevents Duration Enhancements on Fireballs								**/
								/*************************************************************************************************/
								CvPromotionInfo& kPerkInfo = GC.getPromotionInfo((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk());
								bool bDurationAlter = (kPerkInfo.getDurationAlter() > 0 || kPerkInfo.getDurationPerTurn() > 0 || kPerkInfo.getChangeDuration() > 0);
								if (pUnit->getSpecialUnitType() != GC.getDefineINT("SPECIALUNIT_SPELL") || !bDurationAlter)
								{
									/*************************************************************************************************/
									/**	1.4										03/28/11								Valkrionn	**/
									/**																								**/
									/**									New tags required for 1.4									**/
									/*************************************************************************************************/
									if (GC.getPromotionInfo((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk()).isStackEffect())
									{
										int iApplications = pUnit->countHasPromotion((PromotionTypes)iI);
										iApplications = std::min(iApplications, GC.getPromotionInfo((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk()).getMaxApplications());
										for (int iJ = 0; iJ < iApplications; iJ++)
										{
											pUnit->setHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk(), true);
										}
									}
									else
									{
										pUnit->setHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk(), true);
									}
									/*************************************************************************************************/
									/**												END												**/
									/*************************************************************************************************/
								}
								/*************************************************************************************************/
								/**	Tweak									END													**/
								/*************************************************************************************************/
							}
						}
					}
				}
				if (GC.getSpellInfo((SpellTypes)spell).getCreateUnitPromotion() != NO_PROMOTION)
				{
					pUnit->setHasPromotion((PromotionTypes)GC.getSpellInfo((SpellTypes)spell).getCreateUnitPromotion(), true);
				}
				pUnit->doTurn();
				/*************************************************************************************************/
				/**	Tweak									09/06/10									Snarko	**/
				/**																								**/
				/**					No need to try to move the unit if it can't (skeletons etc)					**/
				/*************************************************************************************************/
				/**			---- Start Original Code ----						**
					if (!isHuman())
				/**			----  End Original Code  ----						**/
				if (!isHuman() && pUnit->canMove())
					/*************************************************************************************************/
					/**	Tweak									END													**/
					/*************************************************************************************************/
				{
					pUnit->AI_update();
				}
			}
		}
	}
}

bool CvUnit::isHasCasted() const
{
	return m_bHasCasted;
}

void CvUnit::setHasCasted(bool bNewValue)
{
	m_bHasCasted = bNewValue;
}

/*************************************************************************************************/
/**	Xienwolf Tweak							12/19/08											**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::isIgnoreHide() const
{
	return m_bIgnoreHide;
}

void CvUnit::setIgnoreHide(bool bNewValue)
{
	m_bIgnoreHide = bNewValue;
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

bool CvUnit::isImmuneToSpell(CvUnit* pCaster, int spell) const
{
	if (isImmuneToMagic())
	{
		if (!GC.getSpellInfo((SpellTypes)spell).isAbility())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneTeam() || pCaster->isSpellImmuneTeam(spell))
	{
		if (getTeam() == pCaster->getTeam())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneNeutral())
	{
		if (getTeam() != pCaster->getTeam())
		{
			if (!isEnemy(pCaster->getTeam()))
			{
				return true;
			}
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneEnemy())
	{
		if (isEnemy(pCaster->getTeam()))
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneFlying())
	{
		if (isFlying())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneNotAlive())
	{
		if (!isAlive())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isTargetSummon())
	{
		if (getSummoner()==-1)
		{
			return true;
		}
	}
	return false;
}

/*************************************************************************************************/
/**	City Actions							05/26/10								Grey Fox	**/
/*************************************************************************************************/
bool CvUnit::isImmuneToSpell(CvCity* pCaster, int spell) const
{
	if (isImmuneToMagic())
	{
		if (!GC.getSpellInfo((SpellTypes)spell).isAbility())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneTeam())
	{
		if (getTeam() == pCaster->getTeam())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneNeutral())
	{
		if (getTeam() != pCaster->getTeam())
		{
			if (!isEnemy(pCaster->getTeam()))
			{
				return true;
			}
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneEnemy())
	{
		if (isEnemy(pCaster->getTeam()))
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneFlying())
	{
		if (isFlying())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isImmuneNotAlive())
	{
		if (!isAlive())
		{
			return true;
		}
	}
	if (GC.getSpellInfo((SpellTypes)spell).isTargetSummon())
	{
		if (getSummoner()==-1)
		{
			return true;
		}
	}
	return false;
}
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/


int CvUnit::getDelayedSpell() const
{
	return m_iDelayedSpell;
}

void CvUnit::setDelayedSpell(int iNewValue)
{
	m_iDelayedSpell = iNewValue;
}

int CvUnit::getDuration() const
{
	return m_iDuration;
}

void CvUnit::setDuration(int iNewValue)
{
	m_iDuration = iNewValue;
}

void CvUnit::changeDuration(int iChange)
{
	setDuration(getDuration() + iChange);
}

bool CvUnit::isFleeWithdrawl() const
{
	return m_bFleeWithdrawl;
}

void CvUnit::setFleeWithdrawl(bool bNewValue)
{
	m_bFleeWithdrawl = bNewValue;
}

bool CvUnit::isAlive() const
{
	return m_iAlive == 0 ? true : false;
}

void CvUnit::changeAlive(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iAlive += iNewValue;
	}
}

bool CvUnit::isEnraged() const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							12/27/08											**/
/**																								**/
/**						Prevent non-combatants from becoming Enraged							**/
/*************************************************************************************************/
	if (!canAttack())
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	return m_iEnraged == 0 ? false : true;
}

void CvUnit::changeEnraged(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iEnraged += iNewValue;
/*************************************************************************************************/
/**	Xienwolf Tweak							12/27/08											**/
/**																								**/
/**				Help to prevent Enraged Units from wandering off with your Stack				**/
/*************************************************************************************************/
		joinGroup(NULL, true, true);
		getGroup()->clearMissionQueue();
		getGroup()->setAutomateType(NO_AUTOMATE);
		getGroup()->setActivityType(ACTIVITY_AWAKE);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	}
}

bool CvUnit::isBoarding() const
{
	return m_iBoarding == 0 ? false : true;
}

void CvUnit::changeBoarding(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iBoarding += iNewValue;
	}
}

int CvUnit::getDefensiveStrikeChance() const
{
	return m_iDefensiveStrikeChance;
}

void CvUnit::changeDefensiveStrikeChance(int iChange)
{
	if (iChange != 0)
	{
		m_iDefensiveStrikeChance += iChange;
	}
}

int CvUnit::getDefensiveStrikeDamage() const
{
	return m_iDefensiveStrikeDamage;
}

void CvUnit::changeDefensiveStrikeDamage(int iChange)
{
	if (iChange != 0)
	{
		m_iDefensiveStrikeDamage += iChange;
	}
}

bool CvUnit::isDoubleFortifyBonus() const
{
	return m_iDoubleFortifyBonus == 0 ? false : true;
}

void CvUnit::changeDoubleFortifyBonus(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iDoubleFortifyBonus += iNewValue;
	}
}

bool CvUnit::isFear() const
{
	return m_iFear == 0 ? false : true;
}

void CvUnit::changeFear(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iFear += iNewValue;
	}
}

bool CvUnit::isFlying() const
{
	return m_iFlying == 0 ? false : true;
}

void CvUnit::changeFlying(int iNewValue)
{
	if (iNewValue == 0)
		return;

	plot()->changeAdjacentSight(getTeam(), visibilityRange(), false, this, true);
	m_iFlying += iNewValue;
	plot()->changeAdjacentSight(getTeam(), visibilityRange(), true, this, true);

}

bool CvUnit::isHeld() const
{
	return m_iHeld == 0 ? false : true;
}

void CvUnit::changeHeld(int iNewValue)
{
	int oldheld = m_iHeld;
	if (iNewValue != 0)
	{
		m_iHeld += iNewValue;
	}

/*************************************************************************************************/
/**	Improved AI								10/02/12									Snarko	**/
/**																								**/
/**					Don't allow grouping with immobile, or leashed, units						**/
/*************************************************************************************************/
	if (m_iHeld > 0 && oldheld<=0)
	{
		joinGroup(NULL, true);
	}
/*************************************************************************************************/
/**	Improved AI END																				**/
/*************************************************************************************************/
}

bool CvUnit::isHiddenNationality() const
{
	if (isCargo())
	{
		if (!getTransportUnit()->isHiddenNationality())
		{
			return false;
		}
	}
	return m_iHiddenNationality == 0 ? false : true;
}

void CvUnit::changeHiddenNationality(int iNewValue)
{
	if (iNewValue != 0)
	{
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**				Clears Blockades when HN Unit is Declared/Revealed while Blockading				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		m_iHiddenNationality += iNewValue;
		if (!isHiddenNationality())
		{
			updatePlunder(-1, false);
			joinGroup(NULL, true);
			updatePlunder(1, false);
		}
/**								----  End Original Code  ----									**/
		if (isBlockading())
		{
			updatePlunder(-1, false);
		}
		m_iHiddenNationality += iNewValue;
		joinGroup(NULL, true);
		if (isBlockading())
		{
			updatePlunder(1, false);
		}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	}
}

void CvUnit::changeIgnoreBuildingDefense(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iIgnoreBuildingDefense += iNewValue;
	}
}

bool CvUnit::isImmortal() const
{
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**						Immortality on a temporary unit makes no sense							**/
/*************************************************************************************************/
	if (getDuration() > 0)
	{
		return false;
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	return m_iImmortal == 0 ? false : true;
}

void CvUnit::changeImmortal(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iImmortal += iNewValue;
		if (m_iImmortal < 0)
		{
			m_iImmortal = 0;
		}
	}
}

bool CvUnit::isImmuneToCapture() const
{
	return m_iImmuneToCapture == 0 ? false : true;
}

void CvUnit::changeImmuneToCapture(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iImmuneToCapture += iNewValue;
	}
}

bool CvUnit::isImmuneToDefensiveStrike() const
{
	return m_iImmuneToDefensiveStrike == 0 ? false : true;
}

void CvUnit::changeImmuneToDefensiveStrike(int iChange)
{
	if (iChange != 0)
	{
		m_iImmuneToDefensiveStrike += iChange;
	}
}

bool CvUnit::isImmuneToFear() const
{
	if(!isAlive())
	{
		return true;
	}
	return m_iImmuneToFear == 0 ? false : true;
}

void CvUnit::changeImmuneToFear(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iImmuneToFear += iNewValue;
	}
}

bool CvUnit::isImmuneToMagic() const
{
	return m_iImmuneToMagic == 0 ? false : true;
}

void CvUnit::changeImmuneToMagic(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iImmuneToMagic += iNewValue;
	}
}

/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::isInvisibleFromPromotion() const
{
	return m_iInvisible == 0 ? false : true;
}

void CvUnit::changeInvisibleFromPromotion(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iInvisible += iNewValue;
		if (!isInvisibleFromPromotion() && plot()->isVisibleEnemyUnit(this))
		{
			jumpToNearestValidPlot();
		}
	}
}

bool CvUnit::isSeeInvisible() const
{
	return m_iSeeInvisible == 0 ? false : true;
}

void CvUnit::changeSeeInvisible(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iSeeInvisible += iNewValue;
	}
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/

void CvUnit::changeOnlyDefensive(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iOnlyDefensive += iNewValue;
	}
}

bool CvUnit::isTargetWeakestUnit() const
{
	return m_iTargetWeakestUnit == 0 ? false : true;
}

void CvUnit::changeTargetWeakestUnit(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iTargetWeakestUnit += iNewValue;
	}
}

bool CvUnit::isTargetWeakestUnitCounter() const
{
	return m_iTargetWeakestUnitCounter == 0 ? false : true;
}

void CvUnit::changeTargetWeakestUnitCounter(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iTargetWeakestUnitCounter += iNewValue;
	}
}

/*************************************************************************************************/
/**	Xienwolf Tweak							10/07/08											**/
/**																								**/
/**						Allows Twincast to cast a seperate spell, and stack						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::isTwincast() const
{
	return m_iTwincast == 0 ? false : true;
}
/**								----  End Original Code  ----									**/
int CvUnit::getTwincast() const
{
	return m_iTwincast;
}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

void CvUnit::changeTwincast(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iTwincast += iNewValue;
	}
}

bool CvUnit::isWaterWalking() const
{
	return m_iWaterWalking == 0 ? false : true;
}

void CvUnit::changeWaterWalking(int iNewValue)
{
	if (iNewValue != 0)
	{
		m_iWaterWalking += iNewValue;
	}
}

int CvUnit::getBetterDefenderThanPercent() const
{
	return m_iBetterDefenderThanPercent;
}

void CvUnit::changeBetterDefenderThanPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iBetterDefenderThanPercent = (m_iBetterDefenderThanPercent + iChange);
	}
}

int CvUnit::getCombatHealPercent() const
{
	return m_iCombatHealPercent;
}

void CvUnit::changeCombatHealPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iCombatHealPercent = (m_iCombatHealPercent + iChange);
	}
}

// 
void CvUnit::calcCombatLimit()
{
	int iBestValue = m_pUnitInfo->getCombatLimit();
	int iValue = 0;

	// Lethality - Xienwolf - 07/10/08 - Enhances the Combat Limit of a Unit
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (!isHasPromotion((PromotionTypes)iI))
			continue;

		iValue = GC.getPromotionInfo((PromotionTypes)iI).getCombatLimit();

		if (iValue < iBestValue)
			iBestValue = iValue;
	}

	// Higher hitpoints - Imported from wiser orcs by Snarko
	m_iCombatLimit = std::min(GC.getMAX_HIT_POINTS(), iBestValue + getCombatDmgCapBoost());
}

int CvUnit::getCombatPercentInBorders() const
{
	return m_iCombatPercentInBorders;
}

void CvUnit::changeCombatPercentInBorders(int iChange)
{
	if (iChange != 0)
	{
		m_iCombatPercentInBorders = (m_iCombatPercentInBorders + iChange);
		setInfoBarDirty(true);
	}
}

int CvUnit::getCombatPercentGlobalCounter() const
{
	return m_iCombatPercentGlobalCounter;
}

void CvUnit::changeCombatPercentGlobalCounter(int iChange)
{
	if (iChange != 0)
	{
		m_iCombatPercentGlobalCounter = (m_iCombatPercentGlobalCounter + iChange);
		setInfoBarDirty(true);
	}
}

int CvUnit::getFreePromotionPick() const
{
	return m_iFreePromotionPick;
}

void CvUnit::changeFreePromotionPick(int iChange)
{
	if (iChange != 0)
	{
		m_iFreePromotionPick = getFreePromotionPick() + iChange;
	}
}

/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
int CvUnit::getGoldFromCombat() const
{
	return m_iGoldFromCombat;
}

void CvUnit::changeGoldFromCombat(int iChange)
{
	if (iChange != 0)
	{
		m_iGoldFromCombat = getGoldFromCombat() + iChange;
	}
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/

void CvUnit::setGroupSize(int iNewValue)
{
	m_iGroupSize = iNewValue;
}

void CvUnit::setExtraGroupSize(int iNewValue)
{
	m_iExtraGroupSize = iNewValue;
}

int CvUnit::getExtraGroupSize() const
{
	return m_iExtraGroupSize;
}
/*************************************************************************************************/
/**	Dynamic Mutation						06/15/10								Valkrionn	**/
/**																								**/
/**							Allows for a more dynamic Mutation system							**/
/*************************************************************************************************/
void CvUnit::mutate()
{
	bool bGood, bBad;
	int iWeight, iTargetWeight, iMax, iMin, iI, iJ, iK, iBestPromotion, iNumApplied, iNumApplications, iEffectType;
	int iGoodMutation = GC.getDefineINT("GOOD_MUTATION");
	int iBadMutation = GC.getDefineINT("BAD_MUTATION");
	int iMutationChances = GC.getDefineINT("MUTATION_CHANCE");
	int iNumEffects = GC.getGameINLINE().getSorenRandNum(iMutationChances, "Mutation Effects") + 1;

	for (iI = 0; iI < iNumEffects; iI++)
	{
		iEffectType = GC.getGameINLINE().getSorenRandNum(100, "Mutation Type");
		if (iEffectType < iGoodMutation)
		{
			bGood = true;
			bBad = false;
		}
		else if (iEffectType < iBadMutation)
		{
			bGood = false;
			bBad = true;
		}
		else
		{
			bGood = true;
			bBad = true;
		}


		if (bGood)
		{
			iWeight = 0;
			iTargetWeight = 0;
			iBestPromotion = -1;
			iNumApplications = 0;
			for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
			{
				if (GC.getPromotionInfo((PromotionTypes)iJ).isMutation())
				{
					if (!GC.getPromotionInfo((PromotionTypes)iJ).isBadEffect())
					{
						if (isHasPromotion((PromotionTypes)iJ))
						{
							iNumApplications = countHasPromotion((PromotionTypes)iJ);

							if (GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() > iNumApplications)
							{
								iWeight += GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();
							}
						}
						else
						{
							iWeight += GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();
						}
					}
				}
			}

			iTargetWeight = GC.getGameINLINE().getSorenRandNum(iWeight, "Mutation Weighting");

			for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
			{
				if (GC.getPromotionInfo((PromotionTypes)iJ).isMutation())
				{
					if (!GC.getPromotionInfo((PromotionTypes)iJ).isBadEffect())
					{
						if (isHasPromotion((PromotionTypes)iJ))
						{
							iNumApplications = countHasPromotion((PromotionTypes)iJ);

							if (GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() > iNumApplications)
							{
								iTargetWeight -= GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();

								if (iTargetWeight <= 0)
								{
									iBestPromotion = iJ;
									break;
								}
							}
						}
						else
						{
							iTargetWeight -= GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();

							if (iTargetWeight <= 0)
							{
								iBestPromotion = iJ;
								break;
							}
						}
					}
				}
			}

			if (iBestPromotion != -1)
			{
				iMax = GC.getPromotionInfo((PromotionTypes)iBestPromotion).getMutationMax();
				iMin = GC.getPromotionInfo((PromotionTypes)iBestPromotion).getMutationMin();

				iNumApplied = GC.getGameINLINE().getSorenRandNum((iMax - iMin), "Num Effects") + iMin;

				if (isHasPromotion((PromotionTypes)iJ))
				{
					iNumApplications = countHasPromotion((PromotionTypes)iJ);

					if (GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() >= iNumApplications)
					{
						iNumApplied = 1;
					}
					else if ((iNumApplied + countHasPromotion((PromotionTypes)iJ)) > GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications())
					{
						iNumApplied = GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() - countHasPromotion((PromotionTypes)iJ);
					}
				}

				for (iK = 0; iK < iNumApplied; iK++)
				{
					setHasPromotion(((PromotionTypes)iBestPromotion), true);
				}
			}
		}

		if (bBad)
		{
			iWeight = 0;
			iTargetWeight = 0;
			iBestPromotion = -1;
			iNumApplications = 0;
			for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
			{
				if (GC.getPromotionInfo((PromotionTypes)iJ).isMutation())
				{
					if (GC.getPromotionInfo((PromotionTypes)iJ).isBadEffect())
					{
						if (isHasPromotion((PromotionTypes)iJ))
						{
							iNumApplications = countHasPromotion((PromotionTypes)iJ);

							if (GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() > iNumApplications)
							{
								iWeight += GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();
							}
						}
						else
						{
							iWeight += GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();
						}
					}
				}
			}

			iTargetWeight = GC.getGameINLINE().getSorenRandNum(iWeight, "Mutation Weighting");

			for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
			{
				if (GC.getPromotionInfo((PromotionTypes)iJ).isMutation())
				{
					if (GC.getPromotionInfo((PromotionTypes)iJ).isBadEffect())
					{
						if (isHasPromotion((PromotionTypes)iJ))
						{
							iNumApplications = countHasPromotion((PromotionTypes)iJ);

							if (GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() > iNumApplications)
							{
								iTargetWeight -= GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();

								if (iTargetWeight <= 0)
								{
									iBestPromotion = iJ;
									break;
								}
							}
						}
						else
						{
							iTargetWeight -= GC.getPromotionInfo((PromotionTypes)iJ).getMutationWeight();

							if (iTargetWeight <= 0)
							{
								iBestPromotion = iJ;
								break;
							}
						}
					}
				}
			}

			if (iBestPromotion != -1)
			{
				iMax = GC.getPromotionInfo((PromotionTypes)iBestPromotion).getMutationMax();
				iMin = GC.getPromotionInfo((PromotionTypes)iBestPromotion).getMutationMin();

				iNumApplied = GC.getGameINLINE().getSorenRandNum((iMax - iMin), "Num Effects") + iMin;

				if (isHasPromotion((PromotionTypes)iJ))
				{
					iNumApplications = countHasPromotion((PromotionTypes)iJ);

					if (GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() >= iNumApplications)
					{
						iNumApplied = 1;
					}
					else if ((iNumApplied + countHasPromotion((PromotionTypes)iJ)) > GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications())
					{
						iNumApplied = GC.getPromotionInfo((PromotionTypes)iJ).getMutationMaxApplications() - countHasPromotion((PromotionTypes)iJ);
					}
				}

				for (iK = 0; iK < iNumApplied; iK++)
				{
					setHasPromotion(((PromotionTypes)iBestPromotion), true);
				}
			}
		}
	}
}


/*************************************************************************************************/
/**	CandyMan								04/04/09								Xienwolf	**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
void CvUnit::setInvisibleType(int iNewValue)
{
	m_iInvisibleType = iNewValue;
}
/**								----  End Original Code  ----									**/
//void CvUnit::setInvisibleType(int iInvisibleType, bool bAdd)
//{
//	int iCount = 0;
//	int iRemove = 0;
//	if (bAdd)
//	{
//		m_aiInvisibleTypes.push_back(iInvisibleType);
//	}
//	else
//	{
//		for (int iI = 0; iI < getNumInvisibleTypes(); iI++)
//		{
//			if (getInvisibleType(iI) == iInvisibleType)
//			{
//				iRemove = iCount;
//			}
//			iCount++;
//		}
//		m_aiInvisibleTypes.erase(m_aiInvisibleTypes.begin()+iRemove);
//	}
//}
void CvUnit::updateInvisibleLevel()
{
	if (m_aiInvisibleTypes.size() > 0)
	{
		m_aiInvisibleTypes.pop_back();
	}
	int iNewValue = getUnitInfo().getInvisibleLevel();
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI) && GC.getPromotionInfo((PromotionTypes)iI).getInvisibleLevel()>iNewValue)
		{
			iNewValue = GC.getPromotionInfo((PromotionTypes)iI).getInvisibleLevel();
		}
	}
	if (iNewValue != 0)
	{
		m_aiInvisibleTypes.push_back(iNewValue);
	}
}

void CvUnit::setSeeInvisibleType(int iInvisibleType, bool bAdd)
{
	int iCount = 0;
	int iRemove = 0;
	plot()->changeAdjacentSight(getTeam(), visibilityRange(), false, this, true);

	if (bAdd)
	{
		m_aiSeeInvisibleTypes.push_back(iInvisibleType);
	}
	else
	{
		for (int iI = 0; iI < getNumSeeInvisibleTypes(); iI++)
		{
			if (getSeeInvisibleType(iI) == iInvisibleType)
			{
				iRemove = iCount;
			}
			iCount++;
		}
		m_aiSeeInvisibleTypes.erase(m_aiSeeInvisibleTypes.begin()+iRemove);
	}

	plot()->changeAdjacentSight(getTeam(), visibilityRange(), true, this, true);
}
/*************************************************************************************************/
/**	CandyMan								END													**/
/*************************************************************************************************/

int CvUnit::getRace() const
{
	return m_iRace;
}

void CvUnit::setRace(int iNewValue)
{
	if (m_iRace != NO_PROMOTION)
	{
		setHasPromotion((PromotionTypes)m_iRace, false);
	}
	m_iRace = iNewValue;
}
int CvUnit::getGraphicalAddOnPromotion() const
{
	return m_iGraphicalAddOnPromotion;
}

void CvUnit::setGraphicalAddOnPromotion(int iNewValue)
{
	
	m_iGraphicalAddOnPromotion = iNewValue;
}
int CvUnit::getReligion() const
{
	return m_iReligion;
}

void CvUnit::setReligion(int iReligion)
{
	m_iReligion = iReligion;
}

int CvUnit::getResist() const
{
	return m_iResist;
}

void CvUnit::setResist(int iNewValue)
{
	m_iResist = iNewValue;
}

void CvUnit::changeResist(int iChange)
{
	setResist(getResist() + iChange);
}

int CvUnit::getResistModify() const
{
	return m_iResistModify;
}

void CvUnit::setResistModify(int iNewValue)
{
	m_iResistModify = iNewValue;
}

void CvUnit::changeResistModify(int iChange)
{
	setResistModify(getResistModify() + iChange);
}

int CvUnit::getScenarioCounter() const
{
	return m_iScenarioCounter;
}

void CvUnit::setScenarioCounter(int iNewValue)
{
	m_iScenarioCounter = iNewValue;
}

int CvUnit::getRealSpellCasterXPRate() const
{
	int iXPGain = (int)((10000 * (1 + getCasterXPRate())) / ((GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent() / 50) * (getExperience() + 100)));
	return std::max((int)(5 * (1 + getCasterXPRate())), iXPGain);
}

int CvUnit::getSpellCasterXP() const
{
/*************************************************************************************************/
/**	CasterXP 								05/25/08								Xienwolf	**/
/**																								**/
/**					Completely Revised Training System is hijaking this function				**/
/*************************************************************************************************/
	int iXPCap = 0;
	if (plot() != NULL)
	{
		CvCity* pCity = plot()->getPlotCity();
		if (pCity != NULL)
		{
			iXPCap += pCity->getTrainXPCap(getUnitCombatType());
		}
	}
	if (!(getUnitCombatType() == (UnitCombatTypes)GC.getDefineINT("WORKER_UNITCOMBAT") && GC.getGameINLINE().isOption(GAMEOPTION_NO_WORKER_XP)))
	{
		if (m_pUnitInfo->isFreeXP() || isGetCasterXP())
		{
			iXPCap += m_iSpellCasterXP;
		}
	}

	return iXPCap;
/*************************************************************************************************/
/**	CasterXP 									END												**/
/*************************************************************************************************/
}

void CvUnit::changeSpellCasterXP(int iChange)
{
	if (iChange != 0)
	{
		m_iSpellCasterXP += iChange;
	}
}

int CvUnit::getSpellDamageModify() const
{
	return m_iSpellDamageModify;
}

void CvUnit::changeSpellDamageModify(int iChange)
{
	if (iChange != 0)
	{
		m_iSpellDamageModify += iChange;
	}
}

int CvUnit::getSummoner() const
{
	return m_iSummoner;
}

void CvUnit::setSummoner(int iNewValue)
{
	m_iSummoner = iNewValue;
}

int CvUnit::getWorkRateModify() const
{
	return m_iWorkRateModify;
}

void CvUnit::changeWorkRateModify(int iChange)
{
	if (iChange != 0)
	{
		m_iWorkRateModify += iChange;
	}
}

bool CvUnit::isResisted(CvUnit* pCaster, int iSpell) const
{
	if (GC.getGameINLINE().getSorenRandNum(100, "is Resisted") <= getResistChance(pCaster, iSpell))
	{
		gDLL->getInterfaceIFace()->addMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_RESISTED"), "", MESSAGE_TYPE_MAJOR_EVENT, "art/interface/buttons/promotions/magicresistance.dds", (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
		gDLL->getInterfaceIFace()->addMessage(pCaster->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_RESISTED"), "", MESSAGE_TYPE_MAJOR_EVENT, "art/interface/buttons/promotions/magicresistance.dds", (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
		gDLL->getInterfaceIFace()->playGeneralSound("AS3D_RESIST", plot()->getPoint());
		return true;
	}
	return false;
}

bool CvUnit::isResisted(CvCity* pCaster, int iSpell) const
{
	if (GC.getGameINLINE().getSorenRandNum(100, "is Resisted") <= getResistChance(pCaster, iSpell))
	{
		gDLL->getInterfaceIFace()->addMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_RESISTED"), "", MESSAGE_TYPE_MAJOR_EVENT, "art/interface/buttons/promotions/magicresistance.dds", (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
		gDLL->getInterfaceIFace()->addMessage(pCaster->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_SPELL_RESISTED"), "", MESSAGE_TYPE_MAJOR_EVENT, "art/interface/buttons/promotions/magicresistance.dds", (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
		gDLL->getInterfaceIFace()->playGeneralSound("AS3D_RESIST", plot()->getPoint());
		return true;
	}
	return false;
}

int CvUnit::getResistChance(CvUnit* pCaster, int iSpell) const
{
	if (isImmuneToSpell(pCaster, iSpell))
	{
		return 100;
	}
	int iResist = GC.getDefineINT("SPELL_RESIST_CHANCE_BASE");
	iResist += getLevel() * 5;
	iResist += getResist();
	iResist += pCaster->getResistModify();
	iResist += GC.getSpellInfo((SpellTypes)iSpell).getResistModify();
	iResist += GET_PLAYER(getOwnerINLINE()).getResistModify();
	iResist += GET_PLAYER(pCaster->getOwnerINLINE()).getResistEnemyModify();
	if (plot()->isCity())
	{
		iResist += 10;
		iResist += plot()->getPlotCity()->getResistMagic();
	}
	if (iResist >= GC.getDefineINT("SPELL_RESIST_CHANCE_MAX"))
	{
		iResist = GC.getDefineINT("SPELL_RESIST_CHANCE_MAX");
	}
	if (iResist <= GC.getDefineINT("SPELL_RESIST_CHANCE_MIN"))
	{
		iResist = GC.getDefineINT("SPELL_RESIST_CHANCE_MIN");
	}
	return iResist;
}

int CvUnit::getResistChance(CvCity* pCaster, int iSpell) const
{
	if (isImmuneToSpell(pCaster, iSpell))
	{
		return 100;
	}
	int iResist = GC.getDefineINT("SPELL_RESIST_CHANCE_BASE");
	iResist += getLevel() * 5;
	iResist += getResist();
	iResist += pCaster->getResistModify();
	iResist += GC.getSpellInfo((SpellTypes)iSpell).getResistModify();
	iResist += GET_PLAYER(getOwnerINLINE()).getResistModify();
	iResist += GET_PLAYER(pCaster->getOwnerINLINE()).getResistEnemyModify();
	if (plot()->isCity())
	{
		iResist += 10;
		iResist += plot()->getPlotCity()->getResistMagic();
	}
	if (iResist >= GC.getDefineINT("SPELL_RESIST_CHANCE_MAX"))
	{
		iResist = GC.getDefineINT("SPELL_RESIST_CHANCE_MAX");
	}
	if (iResist <= GC.getDefineINT("SPELL_RESIST_CHANCE_MIN"))
	{
		iResist = GC.getDefineINT("SPELL_RESIST_CHANCE_MIN");
	}
	return iResist;
}
void CvUnit::changeBaseCombatStr(int iChange)
{
	setBaseCombatStr(m_iBaseCombat + iChange);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
	calculatePower();
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
}

void CvUnit::changeBaseCombatStrDefense(int iChange)
{
	setBaseCombatStrDefense(m_iBaseCombatDefense + iChange);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
	calculatePower();
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
}

int CvUnit::getUnitArtStyleType() const
{
	return m_iUnitArtStyleType;
}

void CvUnit::setUnitArtStyleType(int iNewValue)
{
	m_iUnitArtStyleType = iNewValue;
}

int CvUnit::chooseSpell()
{
	int iBestSpell = -1;
	int iRange;
	int iTempValue;
	int iValue;
	int iBestSpellValue = 0;
	CvPlot* pLoopPlot;
	CvUnit* pLoopUnit;
	CLLNode<IDInfo>* pUnitNode;

	for (int iSpell = 0; iSpell < GC.getNumSpellInfos(); iSpell++)
	{
		iValue = 0;
		if (canCast(iSpell, false))
		{
			iRange = std::max(GC.getSpellInfo((SpellTypes)iSpell).getTargetRange(),GC.getSpellInfo((SpellTypes)iSpell).getRange());
			if (GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitType() != NO_UNIT)
			{
				int iMoveRange = GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitType()).getMoves() + getExtraSpellMove();
				bool bEnemy = false;
				for (int i = -iMoveRange; i <= iMoveRange; ++i)
				{
					for (int j = -iMoveRange; j <= iMoveRange; ++j)
					{
						pLoopPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i, j);
						if (NULL != pLoopPlot)
						{
							if (pLoopPlot->isVisibleEnemyUnit(this))
							{
								bEnemy = true;
							}
						}
					}
				}
				if (bEnemy)
				{
					iTempValue = GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitType()).getCombat();
					for (int iI = 0; iI < GC.getNumDamageTypeInfos(); iI++)
					{
						iTempValue += GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitType()).getDamageTypeCombat(iI);
					}
					iTempValue *= 100;
					iTempValue *= GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitNum();
					iValue += iTempValue;
				}
			}
/*************************************************************************************************/
/**	New Tag Defs	(SpellInfos)			07/25/08								Xienwolf	**/
/**																								**/
/**						Assists the AI in Spellmaking Decisions									**/
/*************************************************************************************************/
			if (GC.getSpellInfo((SpellTypes)iSpell).isPermanentUnitCreate() && GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitType() != NO_UNIT)
			{
				iValue += GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitNum() + GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitType()).getCombat() + GC.getUnitInfo((UnitTypes)GC.getSpellInfo((SpellTypes)iSpell).getCreateUnitType()).getMoves() + getExtraSpellMove();
			}

			if (GC.getSpellInfo((SpellTypes)iSpell).isSummonMaster())
			{
				int iMoveRange = getMasterUnit()->movesLeft();
				int iEnemySlave = 0;
				for (int i = -iMoveRange; i <= iMoveRange; ++i)
				{
					for (int j = -iMoveRange; j <= iMoveRange; ++j)
					{
						pLoopPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i, j);
						if (NULL != pLoopPlot)
						{
							if (pLoopPlot->isVisibleEnemyUnit(getOwner()))
							{
								iEnemySlave += pLoopPlot->getNumVisibleEnemyDefenders(getMasterUnit());
							}
						}
					}
				}
				if (iEnemySlave > 0)
				{
					iValue += ((getMasterUnit()->maxHitPoints() * 9/10) - getMasterUnit()->currHitPoints() / 3) - iEnemySlave;
					iValue += plot()->getNumDefenders(getOwner());
				}

				int iEnemyMaster = 0;
				for (int i = -2; i <= 2; ++i)
				{
					for (int j = -2; j <= 2; ++j)
					{
						pLoopPlot = ::plotXY(getMasterUnit()->plot()->getX_INLINE(), getMasterUnit()->plot()->getY_INLINE(), i, j);
						if (NULL != pLoopPlot)
						{
							iEnemyMaster += pLoopPlot->getNumVisibleEnemyDefenders(getMasterUnit());
						}
					}
				}
				if (getMasterUnit()->plot()->isCity(false, getMasterUnit()->getTeam()))
				{
					iValue +=  iEnemyMaster;
					iValue += ((getMasterUnit()->maxHitPoints() * 2/3) - getMasterUnit()->currHitPoints()) / 8;
					iValue -= plot()->getNumDefenders(getOwner());
				}

				iValue += plotDistance(plot()->getX_INLINE(), plot()->getY_INLINE(), getMasterUnit()->plot()->getX_INLINE(), getMasterUnit()->plot()->getY_INLINE()) - 6;
			}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
			if (GC.getSpellInfo((SpellTypes)iSpell).getDamage() != 0)
			{
				int iDmg = GC.getSpellInfo((SpellTypes)iSpell).getDamage();
				int iDmgLimit = GC.getSpellInfo((SpellTypes)iSpell).getDamageLimit();
				for (int i = -iRange; i <= iRange; ++i)
				{
					for (int j = -iRange; j <= iRange; ++j)
					{
						pLoopPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i, j);
						if (NULL != pLoopPlot)
						{
							if (pLoopPlot->getX() != plot()->getX() || pLoopPlot->getY() != plot()->getY())
							{
								pUnitNode = pLoopPlot->headUnitNode();
								while (pUnitNode != NULL)
								{
									pLoopUnit = ::getUnit(pUnitNode->m_data);
									pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
									if (!pLoopUnit->isImmuneToSpell(this, iSpell))
									{
										if (pLoopUnit->isEnemy(getTeam()))
										{
											if (pLoopUnit->getDamage() < iDmgLimit)
											{
												iValue += iDmg * 10;
											}
										}
										if (pLoopUnit->getTeam() == getTeam())
										{
											iValue -= iDmg * 20;
										}
										if (pLoopUnit->getTeam() != getTeam() && pLoopUnit->isEnemy(getTeam()) == false)
										{
											iValue -= 1000;
										}
									}
								}
							}
						}
					}
				}
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getAddPromotionType1() != NO_PROMOTION)
			{
				iValue += AI_promotionValue((PromotionTypes)GC.getSpellInfo((SpellTypes)iSpell).getAddPromotionType1());
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getAddPromotionType2() != NO_PROMOTION)
			{
				iValue += AI_promotionValue((PromotionTypes)GC.getSpellInfo((SpellTypes)iSpell).getAddPromotionType2());
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getAddPromotionType3() != NO_PROMOTION)
			{
				iValue += AI_promotionValue((PromotionTypes)GC.getSpellInfo((SpellTypes)iSpell).getAddPromotionType3());
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getRemovePromotionType1() != NO_PROMOTION)
			{
				iValue -= AI_promotionValue((PromotionTypes)GC.getSpellInfo((SpellTypes)iSpell).getRemovePromotionType1());
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getRemovePromotionType2() != NO_PROMOTION)
			{
				iValue -= AI_promotionValue((PromotionTypes)GC.getSpellInfo((SpellTypes)iSpell).getRemovePromotionType2());
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getRemovePromotionType3() != NO_PROMOTION)
			{
				iValue -= AI_promotionValue((PromotionTypes)GC.getSpellInfo((SpellTypes)iSpell).getRemovePromotionType3());
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getConvertUnitType() != NO_UNIT)
			{
/*************************************************************************************************/
/**	AITweak								02/02/12							Snarko				**/
/**																								**/
/**					Evaluate the unit based on it's current unitai								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				iValue += GET_PLAYER(getOwnerINLINE()).AI_unitValue((UnitTypes)GC.getSpellInfo((SpellTypes)iSpell).getConvertUnitType(), UNITAI_ATTACK, area());
				iValue -= GET_PLAYER(getOwnerINLINE()).AI_unitValue((UnitTypes)getUnitType(), UNITAI_ATTACK, area());
/**								----  End Original Code  ----									**/
				iValue += GET_PLAYER(getOwnerINLINE()).AI_unitValue((UnitTypes)GC.getSpellInfo((SpellTypes)iSpell).getConvertUnitType(), AI_getUnitAIType(), area());
				iValue -= GET_PLAYER(getOwnerINLINE()).AI_unitValue((UnitTypes)getUnitType(), AI_getUnitAIType(), area());
/*************************************************************************************************/
/**	AITweak									END													**/
/*************************************************************************************************/
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getCreateBuildingType() != NO_BUILDING)
			{
				iValue += plot()->getPlotCity()->AI_buildingValue((BuildingTypes)GC.getSpellInfo((SpellTypes)iSpell).getCreateBuildingType());
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getCreateFeatureType() != NO_FEATURE)
			{
				iValue += 10;
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getCreatePlotEffectType() != NO_PLOT_EFFECT)
			{
				iValue += 10;
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getCreateImprovementType() != NO_IMPROVEMENT)
			{
				iValue += 10;
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).isDispel())
			{
				iValue += 25 * (iRange + 1) * (iRange + 1);
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).isPush())
			{
				iValue += 20 * (iRange + 1) * (iRange + 1);
				if (plot()->isCity())
				{
					iValue *= 3;
				}
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getChangePopulation() != 0)
			{
				iValue += 50 * GC.getSpellInfo((SpellTypes)iSpell).getChangePopulation();
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getCost() != 0)
			{
				iValue -= 4 * GC.getSpellInfo((SpellTypes)iSpell).getCost();
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).getImmobileTurns() != 0)
			{
				iValue += 20 * GC.getSpellInfo((SpellTypes)iSpell).getImmobileTurns() * (iRange + 1) * (iRange + 1);
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).isSacrificeCaster())
			{
/*************************************************************************************************/
/**	AITweak								02/02/12							Snarko				**/
/**																								**/
/**					Evaluate the unit based on it's current unitai								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				iValue -= getLevel() * GET_PLAYER(getOwnerINLINE()).AI_unitValue((UnitTypes)getUnitType(), UNITAI_ATTACK, area());
/**								----  End Original Code  ----									**/
				iValue -= getLevel() * GET_PLAYER(getOwnerINLINE()).AI_unitValue((UnitTypes)getUnitType(), AI_getUnitAIType(), area());
/*************************************************************************************************/
/**	AITweak									END													**/
/*************************************************************************************************/
			}
			if (GC.getSpellInfo((SpellTypes)iSpell).isResistable())
			{
				iValue /= 2;
			}
			iValue += GC.getSpellInfo((SpellTypes)iSpell).getAIWeight();
			if (iValue > iBestSpellValue)
			{
				iBestSpellValue = iValue;
				iBestSpell = iSpell;
			}
		}
	}

	return iBestSpell;
}

CvPlot* CvUnit::chooseSpellTarget(int iSpell)
{
	CvPlot* pBestPlot;
	int iBestValue=-1;
	int iLoopValue = 0;
	int iRange = getSpellTargetRange(iSpell);//GC.getSpellInfo(eSpell).getTargetRange();// + getSpellExtraRange();
	int iDX, iDY;
	for (iDX = -(iRange); iDX <= iRange; iDX++)
	{
		for (iDY = -(iRange); iDY <= iRange; iDY++)
		{
			CvPlot* pTargetLoopPlot = plotXY(getX_INLINE(), getY_INLINE(), iDX, iDY);
			iLoopValue = GC.getGameINLINE().getSorenRandNum(100, "Target spell Choice");
			if (pTargetLoopPlot != NULL && canSpellTargetPlot(pTargetLoopPlot, iSpell))
			{
				if (iLoopValue>iBestValue)
				{
					iBestValue = iLoopValue;
					pBestPlot = pTargetLoopPlot;
				}
			}
		}
	}
	return pBestPlot;
}

int CvUnit::getExtraSpellMove() const
{
	int iCount = 0;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk() != NO_PROMOTION)
			{
				iCount += GC.getPromotionInfo((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionSummonPerk()).getMovesChange();
			}
		}
	}
	return iCount;
}


void CvUnit::doDamage(int iDmg, int iDmgLimit, CvUnit* pAttacker, int iDmgType, bool bStartWar)
{
	// Treasure chests immune to damage. Could be thematic, but... more often annoying : Blazenclaw 2025
	if (isCommunalProperty()) return;

	CvWString szMessage;
	int iResist;

	iResist = baseCombatStrDefense() *2;
	iResist += getLevel() * 2;

	if (plot()->getPlotCity() != NULL)
		iResist += (plot()->getPlotCity()->getDefenseModifier(false) / 4);

	if (iDmgType != -1)
		iResist += getDamageTypeResist((DamageTypes)iDmgType);

	if (pAttacker != NULL && iDmgType != DAMAGE_PHYSICAL)
		iDmg += pAttacker->getSpellDamageModify();

	if (iResist >= 100)
		return;

	// From here on, using real damage instead of just percentile
	iDmg *= GC.getDefineINT("HIT_POINT_FACTOR");

	iDmg = GC.getGameINLINE().getSorenRandNum(iDmg, "Damage") + GC.getGameINLINE().getSorenRandNum(iDmg, "Damage");
	iDmg = iDmg * (100 - iResist) / 100;

	if (iDmg + getDamageReal() > iDmgLimit * GC.getDefineINT("HIT_POINT_FACTOR"))
		iDmg = iDmgLimit * GC.getDefineINT("HIT_POINT_FACTOR") - getDamageReal();

	if (iDmg <= 0)
		return;

	if (iDmg + getDamageReal() >= GC.getMAX_HIT_POINTS())
		szMessage = gDLL->getText("TXT_KEY_MESSAGE_KILLED_BY", m_pUnitInfo->getDescription(), GC.getDamageTypeInfo((DamageTypes)iDmgType).getDescription());
	else
		szMessage = gDLL->getText("TXT_KEY_MESSAGE_DAMAGED_BY", m_pUnitInfo->getDescription(), iDmg/GC.getDefineINT("HIT_POINT_FACTOR"), GC.getDamageTypeInfo((DamageTypes)iDmgType).getDescription());

	gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)getOwner()), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szMessage, "", MESSAGE_TYPE_MINOR_EVENT,
		GC.getDamageTypeInfo((DamageTypes)iDmgType).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);

	if (pAttacker != NULL)
	{
		// Only report successful damage to attacker if they can see the unit
		if (plot()->isVisible(pAttacker->getTeam(), false) && !isInvisible(pAttacker->getTeam(), false, false))
		{
			gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)pAttacker->getOwner()), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szMessage, "", MESSAGE_TYPE_MINOR_EVENT,
				GC.getDamageTypeInfo((DamageTypes)iDmgType).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
		}

		changeDamageReal(iDmg, pAttacker->getOwner());

		// Blaze: There may be a weird interaction here if the user is at peace with savages, say, and there's a hidden nationality unit pretending to be one?
		if (bStartWar && !pAttacker->isHiddenNationality() && !isHiddenNationality())
		{
			if (GET_TEAM(pAttacker->getTeam()).canDeclareWar(getTeam()))
				GET_TEAM(pAttacker->getTeam()).declareWar(getTeam(), false, WARPLAN_TOTAL);
		}
	}
	else
		changeDamageReal(iDmg, NO_PLAYER);
}


// The only difference between this and the above is the pAttacker pointer type here is CvCity* instead of CvUnit*
// There's got to be a way to merge this cleanly, no? Also not sure if overloading works for python exposure
void CvUnit::doDamageCity(int iDmg, int iDmgLimit, CvCity* pAttacker, int iDmgType, bool bStartWar)
{
	// Treasure chests immune to damage. Could be thematic, but... more often annoying : Blazenclaw 2025
	if (isCommunalProperty()) return;

	CvWString szMessage;
	int iResist;

	iResist = baseCombatStrDefense() *2;
	iResist += getLevel() * 2;

	if (plot()->getPlotCity() != NULL)
		iResist += (plot()->getPlotCity()->getDefenseModifier(false) / 4);

	if (iDmgType != -1)
		iResist += getDamageTypeResist((DamageTypes)iDmgType);

	if (pAttacker != NULL && iDmgType != DAMAGE_PHYSICAL)
		iDmg += pAttacker->getSpellDamageModify();

	if (iResist >= 100)
		return;

	// From here on, using real damage instead of just percentile
	iDmg *= GC.getDefineINT("HIT_POINT_FACTOR");

	iDmg = GC.getGameINLINE().getSorenRandNum(iDmg, "Damage") + GC.getGameINLINE().getSorenRandNum(iDmg, "Damage");
	iDmg = iDmg * (100 - iResist) / 100;

	if (iDmg + getDamageReal() > iDmgLimit * GC.getDefineINT("HIT_POINT_FACTOR"))
		iDmg = iDmgLimit * GC.getDefineINT("HIT_POINT_FACTOR") - getDamageReal();

	if (iDmg <= 0)
		return;

	if (iDmg + getDamageReal() >= GC.getMAX_HIT_POINTS())
		szMessage = gDLL->getText("TXT_KEY_MESSAGE_KILLED_BY", m_pUnitInfo->getDescription(), GC.getDamageTypeInfo((DamageTypes)iDmgType).getDescription());
	else
		szMessage = gDLL->getText("TXT_KEY_MESSAGE_DAMAGED_BY", m_pUnitInfo->getDescription(), iDmg/GC.getDefineINT("HIT_POINT_FACTOR"), GC.getDamageTypeInfo((DamageTypes)iDmgType).getDescription());

	gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)getOwner()), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szMessage, "", MESSAGE_TYPE_MINOR_EVENT,
		GC.getDamageTypeInfo((DamageTypes)iDmgType).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);

	if (pAttacker != NULL)
	{
		// Only report successful damage to attacker if they can see the unit
		if (plot()->isVisible(pAttacker->getTeam(), false) && !isInvisible(pAttacker->getTeam(), false, false))
		{
			gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)pAttacker->getOwner()), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szMessage, "", MESSAGE_TYPE_MINOR_EVENT,
				GC.getDamageTypeInfo((DamageTypes)iDmgType).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
		}

		changeDamageReal(iDmg, pAttacker->getOwner());

		// Blaze: There may be a weird interaction here if the user is at peace with savages, say, and there's a hidden nationality unit pretending to be one?
		if (bStartWar && !pAttacker->isHiddenNationality() && !isHiddenNationality())
		{
			if (GET_TEAM(pAttacker->getTeam()).canDeclareWar(getTeam()))
				GET_TEAM(pAttacker->getTeam()).declareWar(getTeam(), false, WARPLAN_TOTAL);
		}
	}
	else
		changeDamageReal(iDmg, NO_PLAYER);
}

void CvUnit::doDefensiveStrike(CvUnit* pAttacker)
{
	CvUnit* pBestUnit=NULL;
	int iBestDamage = 0;
	CvPlot* pPlot = plot();
	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
	while (pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
		if (pLoopUnit->getDefensiveStrikeChance() > 0)
		{
			if (atWar(pLoopUnit->getTeam(), pAttacker->getTeam()))
			{
				if (pLoopUnit->isBlitz() || !pLoopUnit->isMadeAttack())
				{
					if (GC.getGameINLINE().getSorenRandNum(100, "Defensive Strike") < pLoopUnit->getDefensiveStrikeChance())
					{
						if (pLoopUnit->getDefensiveStrikeDamage() > iBestDamage)
						{
							iBestDamage = pLoopUnit->getDefensiveStrikeDamage();
							pBestUnit = pLoopUnit;
						}
					}
				}
			}
		}
	}
	if (iBestDamage > 0)
	{
		if (!pBestUnit->isBlitz())
		{
			pBestUnit->setMadeAttack(true);
		}
		int iDmg = 0;
		iDmg += GC.getGameINLINE().getSorenRandNum(pBestUnit->getDefensiveStrikeDamage(), "Defensive Strike 1");
		iDmg += GC.getGameINLINE().getSorenRandNum(pBestUnit->getDefensiveStrikeDamage(), "Defensive Strike 2");
		iDmg -= pAttacker->baseCombatStrDefense() * 2;
		iDmg -= pAttacker->getLevel();

		if (iDmg + pAttacker->getDamage() > 95)
		{
			iDmg = 95 - pAttacker->getDamage();
		}
		if (iDmg > 0)
		{
			pAttacker->changeDamage(iDmg, pBestUnit->getOwner());
			CvWString szMessage = gDLL->getText("TXT_KEY_MESSAGE_DEFENSIVE_STRIKE_BY", GC.getUnitInfo((UnitTypes)pAttacker->getUnitType()).getDescription(), iDmg, GC.getUnitInfo((UnitTypes)pBestUnit->getUnitType()).getDescription());
			gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)pAttacker->getOwner()), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szMessage, "", MESSAGE_TYPE_MAJOR_EVENT, GC.getUnitInfo((UnitTypes)pBestUnit->getUnitType()).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pAttacker->getX(), pAttacker->getY(), true, true);
			szMessage = gDLL->getText("TXT_KEY_MESSAGE_DEFENSIVE_STRIKE", GC.getUnitInfo((UnitTypes)pBestUnit->getUnitType()).getDescription(), GC.getUnitInfo((UnitTypes)pAttacker->getUnitType()).getDescription(), iDmg);
			gDLL->getInterfaceIFace()->addMessage(((PlayerTypes)pBestUnit->getOwner()), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szMessage, "", MESSAGE_TYPE_MAJOR_EVENT, GC.getUnitInfo((UnitTypes)pBestUnit->getUnitType()).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pAttacker->getX(), pAttacker->getY(), true, true);
			pBestUnit->changeExperience(1, 100, true, false, false);
		}
	}
}

bool CvUnit::doEscape()
{
	if (GET_PLAYER(getOwnerINLINE()).getCapitalCity() != NULL)
	{
		setXY(GET_PLAYER(getOwnerINLINE()).getCapitalCity()->getX(), GET_PLAYER(getOwnerINLINE()).getCapitalCity()->getY(), false, true, true);
		return true;
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							02/06/09											**/
/**																								**/
/**		Allows units with no valid Capital a chance to resurrect wherever they were created		**/
/*************************************************************************************************/
	else
	{
		if (getSpawnPlot() != NULL)
		{
			if (canMoveInto(getSpawnPlot()))
			{
				setXY(getSpawnPlot()->getX(), getSpawnPlot()->getY(), false, true, true);
				return true;
			}
		}
	}
	return false;
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
}

bool CvUnit::doImmortalRebirth()
{
	joinGroup(NULL);
	setDamage(75, NO_PLAYER);
	bool bFromProm = false;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).isImmortal())
			{
				setHasPromotion(((PromotionTypes)iI), false);
				bFromProm = true;
				break;
			}
		}
	}
	if (!bFromProm)
	{
		changeImmortal(-1);
	}

/*************************************************************************************************/
/**	Immortal Respawn fix						3/5/2010								Cyth	**/
/*************************************************************************************************/
	setImmortDeath(true);
/*************************************************************************************************/
/**	TEST											END											**/
/*************************************************************************************************/

	return doEscape();
}

void CvUnit::combatWon(CvUnit* pLoser, bool bAttacking)
{
	PROFILE_FUNC();

	PromotionTypes ePromotion;
	bool bConvert = false;
	int iUnit = NO_UNIT;
	int iI;
/*************************************************************************************************/
/**	Xienwolf Tweak							09/06/08											**/
/**																								**/
/**							Display information for Unit Capture/Conversion						**/
/*************************************************************************************************/
	int iNew = NO_UNIT;
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pPlot;
	CvUnit* pUnit;

	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getFreeXPFromCombat() != 0)
			{
/*************************************************************************************************/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**																								**/
/**				Allows Commanders to gain XP when their Minions take part in battle				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
				changeExperience(GC.getPromotionInfo((PromotionTypes)iI).getFreeXPFromCombat(), -1, false, false, false);
/**								----  End Original Code  ----									**/
				changeExperience(GC.getPromotionInfo((PromotionTypes)iI).getFreeXPFromCombat(), -1, false, false, false, true);
/*************************************************************************************************/
/**	CommandingPresence						END													**/
/*************************************************************************************************/
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getModifyGlobalCounterOnCombat() != 0)
			{
				if (pLoser->isAlive())
				{
/*************************************************************************************************/
/**	WorldBreakers						01/05/09									Xienwolf	**/
/**																								**/
/**							Tracks AC Contributions on a player basis							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
					GC.getGameINLINE().changeGlobalCounter(GC.getPromotionInfo((PromotionTypes)iI).getModifyGlobalCounterOnCombat());
/**								----  End Original Code  ----									**/
					GET_PLAYER(getOwner()).changeGlobalCounterContrib(GC.getPromotionInfo((PromotionTypes)iI).getModifyGlobalCounterOnCombat());
/*************************************************************************************************/
/**	WorldBreakers							END													**/
/*************************************************************************************************/
				}
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).isRemovedByCombat())
			{
				setHasPromotion(((PromotionTypes)iI), false);
			}
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply() != NO_PROMOTION)
			{
				ePromotion = (PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply();
				pPlot = pLoser->plot();
				pUnitNode = pPlot->headUnitNode();
				while (pUnitNode != NULL)
				{
					pLoopUnit = ::getUnit(pUnitNode->m_data);
					pUnitNode = pPlot->nextUnitNode(pUnitNode);
					if (pLoopUnit->isHasPromotion(ePromotion) == false)
					{
						if (pLoopUnit->isAlive() || !GC.getPromotionInfo(ePromotion).isPrereqAlive())
						{
							if (isEnemy(pLoopUnit->getTeam()))
							{
								if (GC.getGameINLINE().getSorenRandNum(100, "Combat Apply") <= GC.getDefineINT("COMBAT_APPLY_CHANCE"))
								{
									// reimplemented; was commented out because...?
									if (pLoopUnit->canAcquirePromotion(ePromotion))
									{
										pLoopUnit->setHasPromotion(ePromotion, true);
										gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoopUnit->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
										gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
									}
								}
							}
						}
					}
				}
			}
		/*************************************************************************************************/
/**	PyPromote								04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**							Allows Promotions to grant a Python Call							**/
/*************************************************************************************************/
			if (!CvString(GC.getPromotionInfo((PromotionTypes)iI).getPyPostCombatWon()).empty())
			{
				CyUnit* pyCaster = new CyUnit(this);
				CyUnit* pyOpponent = new CyUnit(pLoser);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));	// pass in unit class
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyOpponent));	// pass in unit class
				argsList.add(iI);	// Promotion
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "postPromotionCombatWon", argsList.makeFunctionArgs()); //, &lResult
				delete pyCaster; // python fxn must not hold on to this pointer
				delete pyOpponent; // python fxn must not hold on to this pointer
			}
/*************************************************************************************************/
/**	PyPromote								END													**/
/*************************************************************************************************/
		}
		if (pLoser->isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply() != NO_PROMOTION)
			{
				ePromotion = (PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply();
				if (isHasPromotion(ePromotion) == false)
				{
					if (isAlive() || !GC.getPromotionInfo(ePromotion).isPrereqAlive())
					{
						if (pLoser->isEnemy(getTeam()))
						{
							if (GC.getGameINLINE().getSorenRandNum(100, "Combat Apply") <= GC.getDefineINT("COMBAT_APPLY_CHANCE"))
							{
								// Check was missing here, and commented out for apply to defenders and bombard/range because...?
								if (canAcquirePromotion(ePromotion))
								{
									setHasPromotion(ePromotion, true);
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoser->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
								}
							}
						}
					}
				}
			}
/*************************************************************************************************/
/**	PyPromote								04/08/08	Written: Grey Fox	Imported: Xienwolf	**/
/**																								**/
/**							Allows Promotions to grant a Python Call							**/
/*************************************************************************************************/
			if (!CvString(GC.getPromotionInfo((PromotionTypes)iI).getPyPostCombatLost()).empty())
			{
				CyUnit* pyCaster = new CyUnit(pLoser);
				CyUnit* pyOpponent = new CyUnit(this);
				CyArgsList argsList;
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));	// pass in unit class
				argsList.add(gDLL->getPythonIFace()->makePythonObject(pyOpponent));	// pass in unit class
				argsList.add(iI);	// promotion
				gDLL->getPythonIFace()->callFunction(PYSpellModule, "postPromotionCombatLost", argsList.makeFunctionArgs()); //, &lResult
				delete pyCaster; // python fxn must not hold on to this pointer
				delete pyOpponent; // python fxn must not hold on to this pointer
			}
/*************************************************************************************************/
/**	PyPromote								END													**/
/*************************************************************************************************/
		}
	}
	if (m_pUnitInfo->getUnitCreateFromCombat() != NO_UNIT)
	{
		/*************************************************************************************************/
		/**	Xienwolf Tweak							11/30/08											**/
		/**																								**/
		/**					Prevents double unit gain when enslaving a worker unit						**/
		/*************************************************************************************************/
		/**								---- Start Original Code ----									**
				if (!pLoser->isImmuneToCapture() && pLoser->isAlive() && GC.getUnitInfo((UnitTypes)pLoser->getUnitType()).getEquipmentPromotion() == NO_PROMOTION)
		/**								----  End Original Code  ----									**/
		if (  GC.getUnitInfo((UnitTypes)pLoser->getUnitType()).getEquipmentPromotion() == NO_PROMOTION )
			/*************************************************************************************************/
			/**	Tweak									END													**/
			/*************************************************************************************************/
		{
			if (GC.getGameINLINE().getSorenRandNum(100, "Create Unit from Combat") <= m_pUnitInfo->getUnitCreateFromCombatChance())
			{
				/*************************************************************************************************/
				/**	Xienwolf Tweak							09/06/08											**/
				/**																								**/
				/**							Display information for Unit Capture/Conversion						**/
				/*************************************************************************************************/
				iNew = m_pUnitInfo->getUnitCreateFromCombat();
				/*************************************************************************************************/
				/**	Tweak  									END													**/
				/*************************************************************************************************/
				pUnit = GET_PLAYER(getOwnerINLINE()).initUnit((UnitTypes)m_pUnitInfo->getUnitCreateFromCombat(), plot()->getX_INLINE(), plot()->getY_INLINE());
				pUnit->setDuration(getDuration());
				if (isHiddenNationality())
				{
					pUnit->setHasPromotion((PromotionTypes)GC.getDefineINT("HIDDEN_NATIONALITY_PROMOTION"), true);
				}
				//				iUnit = NO_UNIT;
			}
		}
	}

	if (GET_PLAYER(getOwnerINLINE()).getFreeXPFromCombat() != 0)
	{
/*************************************************************************************************/
/**	CommandingPresence						05/31/09								Xienwolf	**/
/**																								**/
/**				Allows Commanders to gain XP when their Minions take part in battle				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		changeExperience(GET_PLAYER(getOwnerINLINE()).getFreeXPFromCombat(), -1, false, false, false);
/**								----  End Original Code  ----									**/
		changeExperience(GET_PLAYER(getOwnerINLINE()).getFreeXPFromCombat(), -1, false, false, false, true);
/*************************************************************************************************/
/**	CommandingPresence						END													**/
/*************************************************************************************************/
	}

	if (pLoser->isAlive())
		changeDamage(-getCombatHealPercent(), NO_PLAYER);

	if (m_pUnitInfo->isExplodeInCombat() && m_pUnitInfo->isSuicide())
	{
		if (bAttacking)
		{
			pPlot = pLoser->plot();
		}
		else
		{
			pPlot = plot();
		}
		if (plot()->isVisibleToWatchingHuman())
		{
			gDLL->getEngineIFace()->TriggerEffect((EffectTypes)GC.getInfoTypeForString("EFFECT_ARTILLERY_SHELL_EXPLODE"), pPlot->getPoint(), (float)(GC.getASyncRand().get(360)));
			gDLL->getInterfaceIFace()->playGeneralSound("AS3D_UN_GRENADE_EXPLODE", pPlot->getPoint());
		}
	}
	if (GC.getUnitInfo(pLoser->getUnitType()).isExplodeInCombat())
	{
		if (plot()->isVisibleToWatchingHuman())
		{
			gDLL->getEngineIFace()->TriggerEffect((EffectTypes)GC.getInfoTypeForString("EFFECT_ARTILLERY_SHELL_EXPLODE"), plot()->getPoint(), (float)(GC.getASyncRand().get(360)));
			gDLL->getInterfaceIFace()->playGeneralSound("AS3D_UN_GRENADE_EXPLODE", plot()->getPoint());
		}
	}
	if (m_pUnitInfo->getPromotionFromCombat() != NO_PROMOTION)
	{
		if (pLoser->isAlive())
		{
			setHasPromotion((PromotionTypes)m_pUnitInfo->getPromotionFromCombat(), true);
		}
	}
/*************************************************************************************************/
/**	Xienwolf Tweak							11/21/08											**/
/**									Useless field skipped										**/
/**			Announces Gold received from Combat based on UnitInfos Tag to grant gold			**/
/*************************************************************************************************/
	if (m_pUnitInfo->getGoldFromCombat() != 0)
	{
		GET_PLAYER(getOwnerINLINE()).changeGold(m_pUnitInfo->getGoldFromCombat());
		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_GOLD_FROM_UNIT", m_pUnitInfo->getGoldFromCombat(), GC.getCommerceInfo(COMMERCE_GOLD).getChar(), GET_PLAYER(pLoser->getVisualOwner()).getCivilizationAdjectiveKey(), pLoser->getNameKey());
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX_INLINE(), getY_INLINE());
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	if (getDuration() > 0)
	{
/*************************************************************************************************/
/**	StayingPower							05/19/08								Xienwolf	**/
/**																								**/
/**							Adds Promotion Field to Duration change								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		changeDuration(m_pUnitInfo->getDurationFromCombat());
/**								----  End Original Code  ----									**/
		changeDuration(m_pUnitInfo->getDurationFromCombat() + getCombatExtraDuration());

		if (getDuration() <= 0)
		{
			setMustDie(true);
		}
/*************************************************************************************************/
/**	StayingPower								END												**/
/*************************************************************************************************/
	}
	if (pLoser->getDamageTypeCombat(DAMAGE_POISON) > 0 && GC.getDefineINT("POISONED_PROMOTION") != -1)
	{
		if (isAlive() && isHurt())
		{
			if (GC.getGameINLINE().getSorenRandNum(100, "Poisoned") >= getDamageTypeResist(DAMAGE_POISON))
			{
				setHasPromotion((PromotionTypes)GC.getDefineINT("POISONED_PROMOTION"), true);
			}
		}
	}
	if (!CvString(GC.getUnitInfo(getUnitType()).getPyPostCombatWon()).empty())
	{
		CyUnit* pyCaster = new CyUnit(this);
		CyUnit* pyOpponent = new CyUnit(pLoser);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));	// pass in unit class
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyOpponent));	// pass in unit class
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "postCombatWon", argsList.makeFunctionArgs()); //, &lResult
		delete pyCaster; // python fxn must not hold on to this pointer
		delete pyOpponent; // python fxn must not hold on to this pointer
	}
	if (!CvString(GC.getUnitInfo(pLoser->getUnitType()).getPyPostCombatLost()).empty())
	{
		CyUnit* pyCaster = new CyUnit(pLoser);
		CyUnit* pyOpponent = new CyUnit(this);
		CyArgsList argsList;
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyCaster));	// pass in unit class
		argsList.add(gDLL->getPythonIFace()->makePythonObject(pyOpponent));	// pass in unit class
		gDLL->getPythonIFace()->callFunction(PYSpellModule, "postCombatLost", argsList.makeFunctionArgs()); //, &lResult
		delete pyCaster; // python fxn must not hold on to this pointer
		delete pyOpponent; // python fxn must not hold on to this pointer
	}
	if (m_pUnitInfo->getUnitConvertFromCombat() != NO_UNIT)
	{
		if (GC.getGameINLINE().getSorenRandNum(100, "Convert Unit from Combat") <= m_pUnitInfo->getUnitConvertFromCombatChance())
		{
			pUnit = GET_PLAYER(getOwnerINLINE()).initUnit((UnitTypes)m_pUnitInfo->getUnitConvertFromCombat(), getX_INLINE(), getY_INLINE(), AI_getUnitAIType());
			pUnit->convert(this);
		}
	}
	doCombatCapture(pLoser);
}

/*************************************************************************************************/
/**	Tierable								04/04/09								Xienwolf	**/
/**																								**/
/**						No longer need the DLL to directly handle Weapon upgrades				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
void CvUnit::setWeapons()
{
	CvPlot* pPlot;
	CvCity* pCity;
	if (GC.getDefineINT("WEAPON_PROMOTION_TIER1") == -1)
	{
		return;
	}
	pPlot = plot();
	if (pPlot->isCity())
	{
		pCity = pPlot->getPlotCity();
		if (pCity->getOwner() == getOwner())
		{
			PromotionTypes ePromT1 = (PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER1");
			PromotionTypes ePromT2 = (PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER2");
			PromotionTypes ePromT3 = (PromotionTypes)GC.getDefineINT("WEAPON_PROMOTION_TIER3");
			if (isHasPromotion(ePromT3) == false)
			{
				if (pCity->hasBonus((BonusTypes)GC.getDefineINT("WEAPON_REQ_BONUS_TIER3")) &&
				  m_pUnitInfo->getWeaponTier() >= 3)
				{
					setHasPromotion(ePromT3, true);
					gDLL->getInterfaceIFace()->addMessage(getOwner(), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), gDLL->getText("TXT_KEY_MESSAGE_WEAPONS_MITHRIL"), "AS2D_REPAIR", MESSAGE_TYPE_MAJOR_EVENT, GC.getPromotionInfo(ePromT3).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX(), getY(), true, true);
					setHasPromotion(ePromT2, false);
					setHasPromotion(ePromT1, false);
				}
				else
				{
					if (isHasPromotion(ePromT2) == false)
					{
						if (pCity->hasBonus((BonusTypes)GC.getDefineINT("WEAPON_REQ_BONUS_TIER2")) &&
						  m_pUnitInfo->getWeaponTier() >= 2)
						{
							setHasPromotion(ePromT2, true);
							gDLL->getInterfaceIFace()->addMessage(getOwner(), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), gDLL->getText("TXT_KEY_MESSAGE_WEAPONS_IRON"), "AS2D_REPAIR", MESSAGE_TYPE_MAJOR_EVENT, GC.getPromotionInfo(ePromT2).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX(), getY(), true, true);
							setHasPromotion(ePromT1, false);
						}
						else
						{
							if (isHasPromotion(ePromT1) == false)
							{
								if (pCity->hasBonus((BonusTypes)GC.getDefineINT("WEAPON_REQ_BONUS_TIER1")) &&
								  m_pUnitInfo->getWeaponTier() >= 1)
								{
									gDLL->getInterfaceIFace()->addMessage(getOwner(), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), gDLL->getText("TXT_KEY_MESSAGE_WEAPONS_BRONZE"), "AS2D_REPAIR", MESSAGE_TYPE_MAJOR_EVENT, GC.getPromotionInfo(ePromT1).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX(), getY(), true, true);
									setHasPromotion(ePromT1, true);
								}
							}
						}
					}
				}
			}
		}
	}
}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tierable								END													**/
/*************************************************************************************************/

void CvUnit::changeBonusAffinity(BonusTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_paiBonusAffinity[eIndex] += iChange;
		updateBonusAffinity(eIndex);
	}
}

int CvUnit::getBonusAffinity(BonusTypes eIndex) const
{
	return m_paiBonusAffinity[eIndex];
}

void CvUnit::updateBonusAffinity(BonusTypes eIndex)
{
	int iNew = GET_PLAYER(getOwnerINLINE()).getNumAvailableBonuses(eIndex) * getBonusAffinity(eIndex);
	int iOld = m_paiBonusAffinityAmount[eIndex];
	if (GC.getBonusInfo(eIndex).getDamageType() == NO_DAMAGE)
	{
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		m_iBaseCombat += iNew - iOld;
		m_iBaseCombatDefense += iNew - iOld;
/**								----  End Original Code  ----									**/
		changeBaseCombatStr(iNew - iOld);
		changeBaseCombatStrDefense(iNew - iOld);
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	}
	else
	{
		FAssertMsg(GC.getBonusInfo(eIndex).getDamageType() >= 0, "Warning, about to Leak memory in CvUnit::updateBonusAffinity()");
		m_paiDamageTypeCombat[GC.getBonusInfo(eIndex).getDamageType()] += iNew - iOld;
		m_iTotalDamageTypeCombat += iNew - iOld;
	}
	m_paiBonusAffinityAmount[eIndex] = iNew;
}
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
bool CvUnit::isAffinity(AffinityTypes eIndex) const
{
	return (m_piAffinities[eIndex] > 0);
}

void CvUnit::changeAffinities(AffinityTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_piAffinities[eIndex] = std::max(0, m_piAffinities[eIndex] + iChange);
	}
	if (!isAffinity(eIndex))
	{
		updateAffinity(true);
	}
}

void CvUnit::changeAffinityApplications(AffinityTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_piAffinityApplications[eIndex] += iChange;
	}
}

int CvUnit::getAffinityApplications(AffinityTypes eIndex) const
{
	return m_piAffinityApplications[eIndex];
}

void CvUnit::updateAffinity(bool bKill)
{
	for (int iK = 0; iK < GC.getNumAffinityInfos(); iK++)
	{
		if (isAffinity((AffinityTypes)iK) || bKill)
		{
			CvAffinityInfo& kAffinity = GC.getAffinityInfo((AffinityTypes)iK);
			int iI, iJ, iApplications = 0, iOldApplications = getAffinityApplications((AffinityTypes)iK);
			float fValue, fApplications, fOldApplications;

			// Calculate Applications
			if (!bKill)
			{
				int iNumBonusTypes = kAffinity.getNumBonusTypes();
				if (iNumBonusTypes > 0)
				{
					for (iI = 0; iI < iNumBonusTypes; iI++)
					{
						iApplications += GET_PLAYER(getOwnerINLINE()).getNumAvailableBonuses((BonusTypes) kAffinity.getBonusTypes(iI));
					}
				}
				if (kAffinity.isNumCitiesEffect())
				{
					iApplications += GET_PLAYER(getOwnerINLINE()).getNumCities();
				}
				if (kAffinity.isCapitalPopEffect())
				{
					iApplications += GET_PLAYER(getOwnerINLINE()).getCapitalCity()->getPopulation();
				}
				if (kAffinity.isPopulationEffect())
				{
					iApplications += GET_PLAYER(getOwnerINLINE()).getTotalPopulation();
				}
				if (kAffinity.isVassalEffect())
				{
					iApplications += GET_TEAM(GET_PLAYER(getOwnerINLINE()).getTeam()).getVassalCount();
				}
			}

			// Compare against old Applications
			if ((iApplications - iOldApplications) != 0)
			{
				changeAffinityApplications((AffinityTypes)iK, (iApplications - iOldApplications));
				fApplications = (float)iApplications;
				fOldApplications = (float)-iOldApplications;

				fValue = kAffinity.getStrength();
				if (fValue != 0.00f)
				{
					changeBaseCombatStr((int)(fValue * fOldApplications));
					changeBaseCombatStrDefense((int)(fValue * fOldApplications));
					changeBaseCombatStr((int)(fValue * fApplications));
					changeBaseCombatStrDefense((int)(fValue * fApplications));
				}
				fValue = kAffinity.getStrengthMod();
				if (fValue != 0.00f)
				{
					changeExtraCombatPercent((int)(fValue * fOldApplications));
					changeExtraCombatPercent((int)(fValue * fApplications));
				}
				fValue = kAffinity.getAttackStrength();
				if (fValue != 0.00f)
				{
					changeBaseCombatStr((int)(fValue * fOldApplications));
					changeBaseCombatStr((int)(fValue * fApplications));
				}
				fValue = kAffinity.getDefenseStrength();
				if (fValue != 0.00f)
				{
					changeBaseCombatStrDefense((int)(fValue * fOldApplications));
					changeBaseCombatStrDefense((int)(fValue * fApplications));
				}
				fValue = kAffinity.getMovement();
				if (fValue != 0.00f)
				{
					changeExtraMoves((int)(fValue * fOldApplications));
					changeExtraMoves((int)(fValue * fApplications));
				}
				fValue = kAffinity.getMovementDiscount();
				if (fValue != 0.00f)
				{
					changeExtraMoveDiscount((int)(fValue * fOldApplications));
					changeExtraMoveDiscount((int)(fValue * fApplications));
				}
				fValue = kAffinity.getVisibility();
				if (fValue != 0.00f)
				{
					changeExtraVisibilityRange((int)(fValue * fOldApplications));
					changeExtraVisibilityRange((int)(fValue * fApplications));
				}
				fValue = kAffinity.getPerception();
				if (fValue != 0.00f)
				{
					changePerception((int)(fValue * fOldApplications));
					changePerception((int)(fValue * fApplications));
				}
				fValue = kAffinity.getRangedStrength();
				if (fValue != 0.00f)
				{
					changeAirCombat((int)(fValue * fOldApplications));
					changeAirCombat((int)(fValue * fApplications));
				}
				fValue = kAffinity.getRangedStrengthMod();
				if (fValue != 0.00f)
				{
					changeExtraRangedCombatPercent((int)(fValue * fOldApplications));
					changeExtraRangedCombatPercent((int)(fValue * fApplications));
				}
				fValue = kAffinity.getRange();
				if (fValue != 0.00f)
				{
					changeExtraAirRange((int)(fValue * fOldApplications));
					changeExtraAirRange((int)(fValue * fApplications));
				}
				fValue = kAffinity.getRangedLimit();
				if (fValue != 0.00f)
				{
					changeAirCombatLimitBoost((int)(fValue * fOldApplications));
					changeAirCombatLimitBoost((int)(fValue * fApplications));
				}
				fValue = kAffinity.getFirstStrikes();
				if (fValue != 0.00f)
				{
					changeExtraFirstStrikes((int)(fValue * fOldApplications));
					changeExtraFirstStrikes((int)(fValue * fApplications));
				}
				fValue = kAffinity.getFirstStrikeChance();
				if (fValue != 0.00f)
				{
					changeExtraChanceFirstStrikes((int)(fValue * fOldApplications));
					changeExtraChanceFirstStrikes((int)(fValue * fApplications));
				}
				fValue = kAffinity.getDefensiveStrikes();
				if (fValue != 0.00f)
				{
					changeDefensiveStrikeChance((int)(fValue * fOldApplications));
					changeDefensiveStrikeChance((int)(fValue * fApplications));
				}
				fValue = kAffinity.getWithdrawal();
				if (fValue != 0.00f)
				{
					changeExtraWithdrawal((int)(fValue * fOldApplications));
					changeExtraWithdrawal((int)(fValue * fApplications));
				}
				fValue = kAffinity.getXPRate();
				if (fValue != 0.00f)
				{
					changeExperiencePercent((int)(fValue * fOldApplications));
					changeExperiencePercent((int)(fValue * fApplications));
				}
				fValue = kAffinity.getCommandRange();
				if (fValue != 0.00f)
				{
					changeCommandRange((int)(fValue * fOldApplications));
					changeCommandRange((int)(fValue * fApplications));
				}
				fValue = kAffinity.getCommandLimit();
				if (fValue != 0.00f)
				{
					changeCommandLimit((int)(fValue * fOldApplications));
					changeCommandLimit((int)(fValue * fApplications));
				}
				fValue = kAffinity.getWorkRate();
				if (fValue != 0.00f)
				{
					changeWorkRateModify((int)(fValue * fOldApplications));
					changeWorkRateModify((int)(fValue * fApplications));
				}
				fValue = kAffinity.getCollateral();
				if (fValue != 0.00f)
				{
					changeExtraCollateralDamage((int)(fValue * fOldApplications));
					changeExtraCollateralDamage((int)(fValue * fApplications));
				}
				fValue = kAffinity.getCollateralLimit();
				if (fValue != 0.00f)
				{
					changeCollateralLimitBoost((int)(fValue * fOldApplications));
					changeCollateralLimitBoost((int)(fValue * fApplications));
				}
				fValue = kAffinity.getCollateralTargets();
				if (fValue != 0.00f)
				{
					changeCollateralExtraTargets((int)(fValue * fOldApplications));
					changeCollateralExtraTargets((int)(fValue * fApplications));
				}
				fValue = kAffinity.getVictoryInfluenceModifier();
				if (fValue != 0.00f)
				{
					changeVictoryInfluenceModifier((int)(fValue * fOldApplications));
					changeVictoryInfluenceModifier((int)(fValue * fApplications));
				}
				fValue = kAffinity.getDefeatInfluenceModifier();
				if (fValue != 0.00f)
				{
					changeDefeatInfluenceModifier((int)(fValue * fOldApplications));
					changeDefeatInfluenceModifier((int)(fValue * fApplications));
				}
				fValue = kAffinity.getPillageInfluenceModifier();
				if (fValue != 0.00f)
				{
					changePillageInfluenceModifier((int)(fValue * fOldApplications));
					changePillageInfluenceModifier((int)(fValue * fApplications));
				}
				fValue = kAffinity.getSlaveChance();
				if (fValue != 0.00f)
				{
					changeSlaveGenerationChance((int)(fValue * fOldApplications));
					changeSlaveGenerationChance((int)(fValue * fApplications));
				}
				fValue = kAffinity.getWillpower();
				if (fValue != 0.00f)
				{
					changeExtraMagicalPower((int)(fValue * fOldApplications));
					changeExtraMagicalPower((int)(fValue * fApplications));
				}
				fValue = kAffinity.getCombatHealPercent();
				if (fValue != 0.00f)
				{
					changeCombatHealPercent((int)(fValue * fOldApplications));
					changeCombatHealPercent((int)(fValue * fApplications));
				}
				fValue = kAffinity.getEnemyHealChange();
				if (fValue != 0.00f)
				{
					changeExtraEnemyHeal((int)(fValue * fOldApplications));
					changeExtraEnemyHeal((int)(fValue * fApplications));
				}
				fValue = kAffinity.getNeutralHealChange();
				if (fValue != 0.00f)
				{
					changeExtraNeutralHeal((int)(fValue * fOldApplications));
					changeExtraNeutralHeal((int)(fValue * fApplications));
				}
				fValue = kAffinity.getFriendlyHealChange();
				if (fValue != 0.00f)
				{
					changeExtraFriendlyHeal((int)(fValue * fOldApplications));
					changeExtraFriendlyHeal((int)(fValue * fApplications));
				}

				for (iI = 0; iI < GC.getNumDamageTypeInfos(); iI++)
				{
					fValue = kAffinity.getDamageTypeCombats(iI);
					if (fValue != 0.0f)
					{
						changeDamageTypeCombat((DamageTypes)iI, ((int)(fValue * fOldApplications)));
						changeDamageTypeCombat((DamageTypes)iI, ((int)(fValue * fApplications)));
					}
					fValue = kAffinity.getDamageTypeResists((DamageTypes)iI);
					if (fValue != 0.0f)
					{
						changeDamageTypeResist((DamageTypes)iI, ((int)(fValue * fOldApplications)));
						changeDamageTypeResist((DamageTypes)iI, ((int)(fValue * fApplications)));
					}
				}
				int iNumAffinityPromotions = kAffinity.getNumAffinityPromotions();
				if (iNumAffinityPromotions > 0)
				{
					for (iI = 0; iI < iNumAffinityPromotions; iI++)
					{
						for (iJ = 0; iJ < iOldApplications; iJ++)
						{
							setHasPromotion((PromotionTypes)kAffinity.getAffinityPromotions(iI), false);
						}
						for (iJ = 0; iJ < iApplications; iJ++)
						{
							setHasPromotion((PromotionTypes)kAffinity.getAffinityPromotions(iI), true);
						}
					}
				}
			}
		}
	}
}
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/

void CvUnit::changeDamageTypeCombat(DamageTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_paiDamageTypeCombat[eIndex] = (m_paiDamageTypeCombat[eIndex] + iChange);
		m_iTotalDamageTypeCombat = (m_iTotalDamageTypeCombat + iChange);
	}
}

int CvUnit::getDamageTypeCombat(DamageTypes eIndex) const
{
	return m_paiDamageTypeCombat[eIndex];
}

int CvUnit::getTotalDamageTypeCombat() const
{
	return m_iTotalDamageTypeCombat;
}

int CvUnit::getDamageTypeResist(DamageTypes eIndex) const
{
	int i = m_paiDamageTypeResist[eIndex];
	if (i <= -100)
	{
		return -100;
	}
	if (i >= 100)
	{
		return 100;
	}
	return i;
}

void CvUnit::changeDamageTypeResist(DamageTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		m_paiDamageTypeResist[eIndex] = (m_paiDamageTypeResist[eIndex] + iChange);
	}
}

int CvUnit::countUnitsWithinRange(int iRange, bool bEnemy, bool bNeutral, bool bTeam, bool bAny, bool bCombatantOnly)
{
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvPlot* pLoopPlot;
	int iCount = 0;
	for (int i = -iRange; i <= iRange; ++i)
	{
		for (int j = -iRange; j <= iRange; ++j)
		{
			pLoopPlot = ::plotXY(plot()->getX_INLINE(), plot()->getY_INLINE(), i, j);
			if (NULL != pLoopPlot)
			{
				pUnitNode = pLoopPlot->headUnitNode();
				while (pUnitNode != NULL)
				{
					pLoopUnit = ::getUnit(pUnitNode->m_data);
					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
					if (bCombatantOnly && !pLoopUnit->canFight()) continue;
					if (bTeam && pLoopUnit->getTeam() == getTeam())
					{
						iCount += 1;
						if (bAny) return 1;
					}
					if (bEnemy && atWar(pLoopUnit->getTeam(), getTeam()))
					{
						iCount += 1;
						if (bAny) return 1;
					}
					if (bNeutral && pLoopUnit->getTeam() != getTeam() && !atWar(pLoopUnit->getTeam(), getTeam()))
					{
						iCount += 1;
						if (bAny) return 1;
					}
				}
			}
		}
	}
	return iCount;
}

CvPlot* CvUnit::getOpenPlot() const
{
	CvPlot* pLoopPlot;
	CvPlot* pBestPlot = NULL;
	int iValue;
	int iBestValue = MAX_INT;
	bool bEquipment = false;
/*************************************************************************************************/
/**	EquipRedux								05/31/09								Xienwolf	**/
/**			Authorizes more locations for the container to be placed in if moved				**/
/**		Removes the need to add units for each equipment item introduced into the game			**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_pUnitInfo->getEquipmentPromotion() != NO_PROMOTION)
/**								----  End Original Code  ----									**/
	if (m_pUnitInfo->getEquipmentPromotion() != NO_PROMOTION || getUnitType() == GC.getDefineINT("EQUIPMENT_HOLDER"))
/*************************************************************************************************/
/**	EquipRedux								END													**/
/*************************************************************************************************/
	{
		bEquipment = true;
	}
	for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
	{
		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
		if (pLoopPlot->isValidDomainForLocation(*this))
		{
			if (canMoveInto(pLoopPlot) || bEquipment)
			{
				if (pLoopPlot->getNumUnits() == 0)
				{
					iValue = plotDistance(getX_INLINE(), getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE()) * 2;
					if (pLoopPlot->area() != area())
					{
						iValue *= 3;
					}
					if (iValue < iBestValue)
					{
						iBestValue = iValue;
						pBestPlot = pLoopPlot;
					}
				}
			}
		}
	}
	return pBestPlot;
}

// Convert to specified player
void CvUnit::betray(PlayerTypes ePlayer)
{
	if (getOwnerINLINE() == ePlayer)
		return;

	CvPlot* pNewPlot = getOpenPlot();
	if (pNewPlot == NULL)
		return;

	CvUnit* pUnit = GET_PLAYER(ePlayer).initUnit((UnitTypes)getUnitType(), pNewPlot->getX(), pNewPlot->getY(), AI_getUnitAIType());

	pUnit->convert(this);

	if (pUnit->getDuration() > 0)
		pUnit->setDuration(0);
}

void CvUnit::read(FDataStreamBase* pStream)
{
	// Init data before load
	reset();

	uint uiFlag=0;
	pStream->Read(&uiFlag);	// flags for expansion

	pStream->Read(&m_iID);
	pStream->Read(&m_iGroupID);
	pStream->Read(&m_iHotKeyNumber);
	pStream->Read(&m_iX);
	pStream->Read(&m_iY);
	pStream->Read(&m_iLastMoveTurn);
	pStream->Read(&m_iReconX);
	pStream->Read(&m_iReconY);
	pStream->Read(&m_iGameTurnCreated);
	pStream->Read(&m_iDamage);
	pStream->Read(&m_iMoves);
	pStream->Read(&m_iExperience);
	pStream->Read(&m_iLevel);
	pStream->Read(&m_iCargo);
	pStream->Read(&m_iSpecialCargo);
	pStream->Read(&m_iDomainCargo);
	pStream->Read(&m_iCargoCapacity);
	pStream->Read(&m_iMaxExpReward);
	pStream->Read(&m_iAttackPlotX);
	pStream->Read(&m_iAttackPlotY);
	pStream->Read(&m_iCombatTimer);
	pStream->Read(&m_iCombatFirstStrikes);
	pStream->Read(&m_iFortifyTurns);
	pStream->Read(&m_iBlitzCount);
	pStream->Read(&m_iTradeDefenderCount);
	pStream->Read(&m_iAmphibCount);
	pStream->Read(&m_iRiverCount);
	pStream->Read(&m_iEnemyRouteCount);
	pStream->Read(&m_iAlwaysHealCount);
	pStream->Read(&m_iHillsDoubleMoveCount);
	pStream->Read(&m_iImmuneToFirstStrikesCount);
	pStream->Read(&m_iExtraVisibilityRange);
	pStream->Read(&m_iExtraMoves);
	pStream->Read(&m_iExtraMoveDiscount);
	pStream->Read(&m_iExtraAirRange);
	pStream->Read(&m_iExtraIntercept);
	pStream->Read(&m_iExtraEvasion);
	pStream->Read(&m_iExtraFirstStrikes);
	pStream->Read(&m_iExtraChanceFirstStrikes);
	pStream->Read(&m_iExtraWithdrawal);
	pStream->Read(&m_iExtraEnemyWithdrawal);
	pStream->Read(&m_iExtraCollateralDamage);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	pStream->Read(&m_iExtraFlankingDamage);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	pStream->Read(&m_iExtraBombardRate);
	pStream->Read(&m_iExtraEnemyHeal);
	pStream->Read(&m_iExtraNeutralHeal);
	pStream->Read(&m_iExtraFriendlyHeal);
	pStream->Read(&m_iSameTileHeal);
	pStream->Read(&m_iAdjacentTileHeal);
	pStream->Read(&m_iExtraCombatPercent);
	pStream->Read(&m_iExtraCombatPercentDefense);
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/**		Ensures that stacked promotions are counted equally; Should have no gameplay change		**/
/*************************************************************************************************/
	pStream->Read(&m_iExtraRangedCombatPercent);
	pStream->Read(&m_iRangedCombatPercentInBorders);
	pStream->Read(&m_iRangedCombatPercentGlobalCounter);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	pStream->Read(&m_iExtraCityAttackPercent);
	pStream->Read(&m_iExtraCityDefensePercent);
	pStream->Read(&m_iExtraHillsAttackPercent);
	pStream->Read(&m_iExtraHillsDefensePercent);
	pStream->Read(&m_iRevoltProtection);
	pStream->Read(&m_iCollateralDamageProtection);
	pStream->Read(&m_iPillageChange);
	pStream->Read(&m_iUpgradeDiscount);
	pStream->Read(&m_iExperiencePercent);
	pStream->Read(&m_iKamikazePercent);
	pStream->Read(&m_iBaseCombat);
	pStream->Read((int*)&m_eFacingDirection);
	pStream->Read(&m_iImmobileTimer);
/*************************************************************************************************/
/**	MobileCage								 6/17/2009								Cyther		**/
/**	Expanded by Valkrionn					01/28/2010											**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	pStream->Read(&m_iLeashX);
	pStream->Read(&m_iLeashY);
	pStream->Read(&m_LeashUnit.iID);
	pStream->Read(&m_iLeashRange);
	pStream->Read(&m_iLeashChance);
	pStream->Read(&m_iRandLeash);
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	pStream->Read(&m_bLeveledImmortality);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	pStream->Read(&m_bMadeAttack);
	pStream->Read(&m_bMadeInterception);
	pStream->Read(&m_bPromotionReady);
	pStream->Read(&m_bDeathDelay);
	pStream->Read(&m_bCombatFocus);
	// m_bInfoBarDirty not saved...
	pStream->Read(&m_bBlockading);
	if (uiFlag > 0)
	{
		pStream->Read(&m_bAirCombat);
	}

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**	New Tag Defs	(UnitInfos)				05/15/08											**/
/**										Read Data from Save File								**/
/*************************************************************************************************/
	pStream->Read(GC.getNumPromotionInfos(), m_pabRealPromotion);
	pStream->Read(GC.getNumPromotionInfos(), m_aiSupplementalPromotions);
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pStream->Read(&m_bNonInfluence);
	pStream->Read(&m_bInfluence);
	pStream->Read(&m_iVictoryInfluenceModifier);
	pStream->Read(&m_iDefeatInfluenceModifier);
	pStream->Read(&m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	pStream->Read(&m_iPerception);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	pStream->Read(&m_iCommandLimit);
	pStream->Read(&m_iCommandRange);
	pStream->Read(&m_iCommandXPShareRate);
	pStream->Read((int*)&m_ePreviousOwner);
	pStream->Read(&m_iNumPromotions);
	pStream->Read(&m_iCommunalProperty);
	pStream->Read(&m_iNeverHostile);
	pStream->Read(&m_iBlind);
	pStream->Read(&m_iStrBoost);
	pStream->Read(&m_bDisablePyDeath);
	pStream->Read(&m_iCannotCast);
	pStream->Read(&m_iFreeUnit);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	pStream->Read(&m_iPromotionBuild);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
	pStream->Read(&m_iNoSupply);
	pStream->Read(&m_iTerritorial);
	pStream->Read(&m_iRivalTerritoryExplore);
	pStream->Read(&m_iRivalTerritoryBlock);
	pStream->Read(&m_iPillageOnMove);
	pStream->Read(&m_iSelfPillage);
	pStream->Read(&m_iGetCasterXP);
	pStream->Read(&m_iNonWarWeariness);
	pStream->Read(&m_iNoMapReveal);
	pStream->Read(&m_iCannotCapture);
	pStream->Read(&m_iCityHappy);
	pStream->Read(&m_iCityNoHappy);
	pStream->Read(&m_iNoSupport);
	pStream->Read(&m_iCanPillage);
	pStream->Read(&m_iCannotPillage);
	pStream->Read(&m_iCitySpy);
	pStream->Read(&m_iStartGoldenAge);
	pStream->Read(&m_iNoDefenseBonus);
	pStream->Read(&m_iMoveImpassable);
	pStream->Read(&m_iClimbPeaks);
	pStream->Read(&m_iFlatMoveCost);
	pStream->Read(&m_iIgnoreTerrainCosts);
	pStream->Read(&m_iAttackNoWar);
	pStream->Read(&m_iAllowAttacks);
	pStream->Read(&m_iFirstStrikeVulnerable);
	pStream->Read(&m_iAllowDefenseBonuses);
	pStream->Read(&m_iNonAbandon);
	pStream->Read(&m_iIndependant);
	pStream->Read(&m_iAssetValue);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Read(&m_iPowerValue);
/**								----  End Original Code  ----									**/
	pStream->Read(&m_iPower);
	pStream->Read(&m_iPowerAdd);
	pStream->Read(&m_iPowerMult);
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	pStream->Read(&m_iTempUnitCombat);
	pStream->Read(&m_iFreeXPCap);
	pStream->Read(&m_fCasterXPRate);
	pStream->Read(&m_iAirCombat);
	pStream->Read(&m_iAirCombatLimitBoost);
	pStream->Read(&m_iExtraDropRange);
	pStream->Read(&m_iCombatConversionChance);
	pStream->Read(&m_iCombatUnitGenerationChance);
	pStream->Read(&m_iSlaveGenerationChance);
	pStream->Read(&m_iGiftableXP);
	pStream->Read(&m_iCombatExtraDuration);
	pStream->Read(&m_iDurationPerTurn);
	pStream->Read(&m_iChangeDuration);
	pStream->Read(&m_bMustDie);
	pStream->Read(&m_bNullPromotionAvailable);
	pStream->Read(&m_bNonTemporary);
	pStream->Read(&m_iExtraSupport);
	pStream->Read(&m_iChanceMiscast);
	pStream->Read(&m_iCombatDmgCapBoost);
	pStream->Read(&m_iCollateralLimitCap);
	pStream->Read(&m_iCollateralLimitBoost);
	pStream->Read(&m_iCollateralTargetsLimit);
	pStream->Read(&m_iCollateralExtraTargets);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	pStream->Read(&m_iFlankingLimitBoost);
	pStream->Read(&m_iFlankingExtraTargets);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	pStream->Read(&m_iHammerSacrifice);
	pStream->Read(&m_iExtraHammerPerPop);
	pStream->Read(&m_iFoodSacrifice);
	pStream->Read(&m_iPopulationAdd);
	pStream->Read(&m_iBeakerSacrifice);
	pStream->Read(&m_iExtraBeakerPerPop);
	pStream->Read(&m_iGoldSacrifice);
	pStream->Read(&m_iExtraGoldPerPop);
	pStream->Read(&m_iCultureSacrifice);
	pStream->Read(&m_iExtraCulturePerPop);
	pStream->Read(&m_iXPTranserRate);
	pStream->Read(&m_iCastingLimit);
	pStream->ReadString(m_szNewName);
	pStream->Read((int*)&m_MasterUnit.eOwner);
	pStream->Read(&m_MasterUnit.iID);
	int iNumSlaves = 0;
	pStream->Read(&iNumSlaves);
	m_pSlaveUnitList.clear();
	if (iNumSlaves != 0)
	{
		for (int iI = 0; iI < iNumSlaves; iI++)
		{
			int iID = 0;
			pStream->Read(&iID);
			m_pSlaveUnitList.push_back(iID);
		}
	}
	pStream->Read((int*)&m_CommanderUnit.eOwner);
	pStream->Read(&m_CommanderUnit.iID);
	int iNumMinions = 0;
	pStream->Read(&iNumMinions);
	pStream->Read(&m_iNumForcedMinions);
	m_pMinionUnitList.clear();
	if (iNumMinions != 0)
	{
		for (int iI = 0; iI < iNumMinions; iI++)
		{
			int iID = 0;
			pStream->Read(&iID);
			m_pMinionUnitList.push_back(iID);
		}
	}
	pStream->Read(&m_iNumCityBonuses);
	m_cbCityBonuses.clear();
	if (m_iNumCityBonuses != 0)
	{
		CityBonuses cbTemp;
		for (int iI = 0; iI < m_iNumCityBonuses; iI++)
		{
			cbTemp.read(pStream);
			m_cbCityBonuses.push_back(cbTemp);
		}
	}
	pStream->Read(NUM_YIELD_TYPES, m_piYieldFromWin);
	pStream->Read(NUM_YIELD_TYPES, m_piYieldForLoss);
	pStream->Read(NUM_COMMERCE_TYPES, m_piCommerceFromWin);
	pStream->Read(NUM_COMMERCE_TYPES, m_piCommerceForLoss);
	pStream->Read(GC.getNumPromotionInfos(), m_piPromotionDuration);
	int iNumInvisTypes;
	pStream->Read(&iNumInvisTypes);
	for(int i=0;i<iNumInvisTypes;i++)
	{
		int iInvisibleType;
		pStream->Read(&iInvisibleType);
		m_aiInvisibleTypes.push_back(iInvisibleType);
	}
	int iNumInvisibleTypes;
	pStream->Read(&iNumInvisibleTypes);
	for(int i=0;i<iNumInvisibleTypes;i++)
	{
		int iSeeInvisibleType;
		pStream->Read(&iSeeInvisibleType);
		m_aiSeeInvisibleTypes.push_back(iSeeInvisibleType);
	}
	pStream->Read(GC.getNumPromotionInfos(), m_piAllowPromotion);
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	pStream->Read(GC.getNumUnitCombatInfos(), m_piSecondaryUnitCombat);
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	pStream->Read(GC.getNumAffinityInfos(), m_piAffinities);
	pStream->Read(GC.getNumAffinityInfos(), m_piAffinityApplications);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	pStream->Read(GC.getNumPromotionInfos(), m_piDenyPromotion);
	pStream->Read(&m_iSpawnPlotX);
	pStream->Read(&m_iSpawnPlotY);
	pStream->Read(&m_eSpawnImprovementType);
	pStream->Read(&m_iNoBadExplore);
	pStream->ReadString(m_szQuote);
	pStream->ReadString(m_szImage);
	pStream->Read(&m_bSuppressImage);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Spell System: Added by Kael 07/23/2007
	pStream->Read(&m_bFleeWithdrawl);
	pStream->Read(&m_bHasCasted);
/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Read(&m_bIgnoreHide);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/
	pStream->Read(&m_iAlive);
	pStream->Read(&m_iEnraged);
	pStream->Read(&m_iBoarding);
	pStream->Read(&m_iDefensiveStrikeChance);
	pStream->Read(&m_iDefensiveStrikeDamage);
	pStream->Read(&m_iDoubleFortifyBonus);
	pStream->Read(&m_iFear);
	pStream->Read(&m_iFlying);
	pStream->Read(&m_iHeld);
	pStream->Read(&m_iHiddenNationality);
	pStream->Read(&m_iIgnoreBuildingDefense);
	pStream->Read(&m_iImmortal);
	pStream->Read(&m_iImmuneToCapture);
	pStream->Read(&m_iImmuneToDefensiveStrike);
	pStream->Read(&m_iImmuneToFear);
	pStream->Read(&m_iImmuneToMagic);
/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Read(&m_iInvisible);
	pStream->Read(&m_iSeeInvisible);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/
	pStream->Read(&m_iOnlyDefensive);
	pStream->Read(&m_iBetrayalChance);
	pStream->Read(&m_iTargetWeakestUnit);
	pStream->Read(&m_iTargetWeakestUnitCounter);
	pStream->Read(&m_iTwincast);
	pStream->Read(&m_iWaterWalking);
	pStream->Read(&m_iBaseCombatDefense);
	pStream->Read(&m_iBetterDefenderThanPercent);
	pStream->Read(&m_iCombatHealPercent);
	pStream->Read(&m_iCombatLimit);
	pStream->Read(&m_iCombatPercentInBorders);
	pStream->Read(&m_iCombatPercentGlobalCounter);
	pStream->Read(&m_iDelayedSpell);
	pStream->Read(&m_iDuration);
	pStream->Read(&m_iFreePromotionPick);
/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Read(&m_iGoldFromCombat);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/
	pStream->Read(&m_iGroupSize);
	pStream->Read(&m_iExtraGroupSize);

/*************************************************************************************************/
/**	CandyMan								04/04/09								Xienwolf	**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Read(&m_iInvisibleType);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	CandyMan								END													**/
/*************************************************************************************************/
	pStream->Read(&m_iRace);
	pStream->Read(&m_iGraphicalAddOnPromotion);
	pStream->Read(&m_iReligion);
	pStream->Read(&m_iResist);
	pStream->Read(&m_iResistModify);
	pStream->Read(&m_iScenarioCounter);
	pStream->Read(&m_iSpellCasterXP);
	pStream->Read(&m_iSpellDamageModify);
	pStream->Read(&m_iSummoner);
	pStream->Read(&m_iTotalDamageTypeCombat);
	pStream->Read(&m_iUnitArtStyleType);
	pStream->Read(&m_iWorkRateModify);
	pStream->Read(GC.getNumBonusInfos(), m_paiBonusAffinity);
	pStream->Read(GC.getNumBonusInfos(), m_paiBonusAffinityAmount);
	pStream->Read(GC.getNumDamageTypeInfos(), m_paiDamageTypeCombat);
	pStream->Read(GC.getNumDamageTypeInfos(), m_paiDamageTypeResist);
//FfH: End Add

	pStream->Read((int*)&m_eOwner);
	pStream->Read((int*)&m_eCapturingPlayer);
	pStream->Read((int*)&m_eUnitType);
	FAssert(NO_UNIT != m_eUnitType);
	m_pUnitInfo = (NO_UNIT != m_eUnitType) ? &GC.getUnitInfo(m_eUnitType) : NULL;
	pStream->Read((int*)&m_eLeaderUnitType);

	pStream->Read((int*)&m_combatUnit.eOwner);
	pStream->Read(&m_combatUnit.iID);
	pStream->Read((int*)&m_transportUnit.eOwner);
	pStream->Read(&m_transportUnit.iID);

	pStream->Read(NUM_DOMAIN_TYPES, m_aiExtraDomainModifier);

	pStream->ReadString(m_szName);
	pStream->ReadString(m_szScriptData);

	pStream->ReadString(m_szReplaceArtDefineTag);
	pStream->ReadString(m_szExtraArtDefineTag);
	pStream->ReadString(m_szExtraArtDefineTag2);
	pStream->ReadString(m_szExtraArtDefineTag3);
	/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Read(GC.getNumPromotionInfos(), m_pabHasPromotion);
/**								----  End Original Code  ----									**/
	pStream->Read(GC.getNumPromotionInfos(), m_paiHasPromotion);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	pStream->Read(GC.getNumImprovementInfos(), m_paiNoBadExploreImprovement);

	pStream->Read(GC.getNumTerrainInfos(), m_paiTerrainDoubleMoveCount);
	pStream->Read(GC.getNumFeatureInfos(), m_paiFeatureDoubleMoveCount);
	pStream->Read(GC.getNumTerrainInfos(), m_paiExtraTerrainAttackPercent);
	pStream->Read(GC.getNumTerrainInfos(), m_paiExtraTerrainDefensePercent);
	pStream->Read(GC.getNumFeatureInfos(), m_paiExtraFeatureAttackPercent);
	pStream->Read(GC.getNumFeatureInfos(), m_paiExtraFeatureDefensePercent);
	pStream->Read(GC.getNumPlotEffectInfos(), m_paiPlotEffectDoubleMoveCount);
	pStream->Read(GC.getNumPlotEffectInfos(), m_paiExtraPlotEffectAttackPercent);
	pStream->Read(GC.getNumPlotEffectInfos(), m_paiExtraPlotEffectDefensePercent);
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
	pStream->Read(&m_iPeakCost);
	pStream->Read(&m_iHillCost);
	pStream->Read(GC.getNumTerrainInfos(), m_paiTerrainCost);
	pStream->Read(GC.getNumFeatureInfos(), m_paiFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	pStream->Read(GC.getNumUnitCombatInfos(), m_paiExtraUnitCombatModifier);
	pStream->Read(GC.getNumSpellClassInfos(), m_paiExtraSpellClassPower);
/*************************************************************************************************/
/**	AutoCast								02/09/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	pStream->Read((int*)&m_eAutoCast);
	pStream->Read(&m_bAutoCastPre);
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
	pStream->Read(&m_iNumInquisition);
	/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
//Magic rework
	pStream->Read(&m_iMissionSpell);
	pStream->Read(&m_iExtraMagicalPower);
//	pStream->Read(&m_iExtraDominionCapacity);
}


void CvUnit::write(FDataStreamBase* pStream)
{
	uint uiFlag=2;
	pStream->Write(uiFlag);		// flag for expansion

	pStream->Write(m_iID);
	pStream->Write(m_iGroupID);
	pStream->Write(m_iHotKeyNumber);
	pStream->Write(m_iX);
	pStream->Write(m_iY);
	pStream->Write(m_iLastMoveTurn);
	pStream->Write(m_iReconX);
	pStream->Write(m_iReconY);
	pStream->Write(m_iGameTurnCreated);
	pStream->Write(m_iDamage);
	pStream->Write(m_iMoves);
	pStream->Write(m_iExperience);
	pStream->Write(m_iLevel);
	pStream->Write(m_iCargo);
	pStream->Write(m_iSpecialCargo);
	pStream->Write(m_iDomainCargo);
	pStream->Write(m_iCargoCapacity);
	pStream->Write(m_iMaxExpReward);
	pStream->Write(m_iAttackPlotX);
	pStream->Write(m_iAttackPlotY);
	pStream->Write(m_iCombatTimer);
	pStream->Write(m_iCombatFirstStrikes);
	pStream->Write(m_iFortifyTurns);
	pStream->Write(m_iBlitzCount);
	pStream->Write(m_iTradeDefenderCount);
	pStream->Write(m_iAmphibCount);
	pStream->Write(m_iRiverCount);
	pStream->Write(m_iEnemyRouteCount);
	pStream->Write(m_iAlwaysHealCount);
	pStream->Write(m_iHillsDoubleMoveCount);
	pStream->Write(m_iImmuneToFirstStrikesCount);
	pStream->Write(m_iExtraVisibilityRange);
	pStream->Write(m_iExtraMoves);
	pStream->Write(m_iExtraMoveDiscount);
	pStream->Write(m_iExtraAirRange);
	pStream->Write(m_iExtraIntercept);
	pStream->Write(m_iExtraEvasion);
	pStream->Write(m_iExtraFirstStrikes);
	pStream->Write(m_iExtraChanceFirstStrikes);
	pStream->Write(m_iExtraWithdrawal);
	pStream->Write(m_iExtraEnemyWithdrawal);
	pStream->Write(m_iExtraCollateralDamage);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	pStream->Write(m_iExtraFlankingDamage);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	pStream->Write(m_iExtraBombardRate);
	pStream->Write(m_iExtraEnemyHeal);
	pStream->Write(m_iExtraNeutralHeal);
	pStream->Write(m_iExtraFriendlyHeal);
	pStream->Write(m_iSameTileHeal);
	pStream->Write(m_iAdjacentTileHeal);
	pStream->Write(m_iExtraCombatPercent);
	pStream->Write(m_iExtraCombatPercentDefense);
/*************************************************************************************************/
/**	1.4										03/28/11								Valkrionn	**/
/**																								**/
/**									New tags required for 1.4									**/
/**		Ensures that stacked promotions are counted equally; Should have no gameplay change		**/
/*************************************************************************************************/
	pStream->Write(m_iExtraRangedCombatPercent);
	pStream->Write(m_iRangedCombatPercentInBorders);
	pStream->Write(m_iRangedCombatPercentGlobalCounter);
/*************************************************************************************************/
/**												END												**/
/*************************************************************************************************/
	pStream->Write(m_iExtraCityAttackPercent);
	pStream->Write(m_iExtraCityDefensePercent);
	pStream->Write(m_iExtraHillsAttackPercent);
	pStream->Write(m_iExtraHillsDefensePercent);
	pStream->Write(m_iRevoltProtection);
	pStream->Write(m_iCollateralDamageProtection);
	pStream->Write(m_iPillageChange);
	pStream->Write(m_iUpgradeDiscount);
	pStream->Write(m_iExperiencePercent);
	pStream->Write(m_iKamikazePercent);
	pStream->Write(m_iBaseCombat);
	pStream->Write(m_eFacingDirection);
	pStream->Write(m_iImmobileTimer);
/*************************************************************************************************/
/**	MobileCage								 6/17/2009								Cyther		**/
/**	Expanded by Valkrionn					01/28/2010											**/
/**										Leashes	a unit to a plot								**/
/*************************************************************************************************/
	pStream->Write(m_iLeashX);
	pStream->Write(m_iLeashY);
	pStream->Write(m_LeashUnit.iID);
	pStream->Write(m_iLeashRange);
	pStream->Write(m_iLeashChance);
	pStream->Write(m_iRandLeash);
/*************************************************************************************************/
/**	MobileCage									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/** Shades					  				07/30/10								Valkrionn	**/
/**																								**/
/*************************************************************************************************/
	pStream->Write(m_bLeveledImmortality);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	pStream->Write(m_bMadeAttack);
	pStream->Write(m_bMadeInterception);
	pStream->Write(m_bPromotionReady);
	pStream->Write(m_bDeathDelay);
	pStream->Write(m_bCombatFocus);
	// m_bInfoBarDirty not saved...
	pStream->Write(m_bBlockading);
	pStream->Write(m_bAirCombat);

/*************************************************************************************************/
/**	New Tag Defs	(PromotionInfos)		05/15/08								Xienwolf	**/
/**	New Tag Defs	(UnitInfos)				05/15/08											**/
/**										Write Data to Save Files								**/
/*************************************************************************************************/
	pStream->Write(GC.getNumPromotionInfos(), m_pabRealPromotion);
	pStream->Write(GC.getNumPromotionInfos(), m_aiSupplementalPromotions);
/************************************************************************************************/
/* Influence Driven War                   06/08/10                                 Valkrionn    */
/*                                                                                              */
/*						Prevents IDW effects within specific borders                            */
/************************************************************************************************/
	pStream->Write(m_bNonInfluence);
	pStream->Write(m_bInfluence);
	pStream->Write(m_iVictoryInfluenceModifier);
	pStream->Write(m_iDefeatInfluenceModifier);
	pStream->Write(m_iPillageInfluenceModifier);
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
	pStream->Write(m_iPerception);
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
	pStream->Write(m_iCommandLimit);
	pStream->Write(m_iCommandRange);
	pStream->Write(m_iCommandXPShareRate);
	pStream->Write(m_ePreviousOwner);
	pStream->Write(m_iNumPromotions);
	pStream->Write(m_iCommunalProperty);
	pStream->Write(m_iNeverHostile);
	pStream->Write(m_iBlind);
	pStream->Write(m_iStrBoost);
	pStream->Write(m_bDisablePyDeath);
	pStream->Write(m_iCannotCast);
	pStream->Write(m_iFreeUnit);
/*************************************************************************************************/
/**	Workers Paradise						01/08/10											**/
/**																								**/
/**							Allows promotions to affect build orders							**/
/*************************************************************************************************/
	pStream->Write(m_iPromotionBuild);
/*************************************************************************************************/
/**	Workers Paradise						END													**/
/*************************************************************************************************/
	pStream->Write(m_iNoSupply);
	pStream->Write(m_iTerritorial);
	pStream->Write(m_iRivalTerritoryExplore);
	pStream->Write(m_iRivalTerritoryBlock);
	pStream->Write(m_iPillageOnMove);
	pStream->Write(m_iSelfPillage);
	pStream->Write(m_iGetCasterXP);
	pStream->Write(m_iNonWarWeariness);
	pStream->Write(m_iNoMapReveal);
	pStream->Write(m_iCannotCapture);
	pStream->Write(m_iCityHappy);
	pStream->Write(m_iCityNoHappy);
	pStream->Write(m_iNoSupport);
	pStream->Write(m_iCanPillage);
	pStream->Write(m_iCannotPillage);
	pStream->Write(m_iCitySpy);
	pStream->Write(m_iStartGoldenAge);
	pStream->Write(m_iNoDefenseBonus);
	pStream->Write(m_iMoveImpassable);
	pStream->Write(m_iClimbPeaks);
	pStream->Write(m_iFlatMoveCost);
	pStream->Write(m_iIgnoreTerrainCosts);
	pStream->Write(m_iAttackNoWar);
	pStream->Write(m_iAllowAttacks);
	pStream->Write(m_iFirstStrikeVulnerable);
	pStream->Write(m_iAllowDefenseBonuses);
	pStream->Write(m_iNonAbandon);
	pStream->Write(m_iIndependant);
	pStream->Write(m_iAssetValue);
/*************************************************************************************************/
/**	Unit power						17/02/12										Snarko		**/
/**																								**/
/**							Rewriting unit power system											**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Write(m_iPowerValue);
/**								----  End Original Code  ----									**/
	pStream->Write(m_iPower);
	pStream->Write(m_iPowerAdd);
	pStream->Write(m_iPowerMult);
/*************************************************************************************************/
/**	Unit power						END															**/
/*************************************************************************************************/
	pStream->Write(m_iTempUnitCombat);
	pStream->Write(m_iFreeXPCap);
	pStream->Write(m_fCasterXPRate);
	pStream->Write(m_iAirCombat);
	pStream->Write(m_iAirCombatLimitBoost);
	pStream->Write(m_iExtraDropRange);
	pStream->Write(m_iCombatConversionChance);
	pStream->Write(m_iCombatUnitGenerationChance);
	pStream->Write(m_iSlaveGenerationChance);
	pStream->Write(m_iGiftableXP);
	pStream->Write(m_iCombatExtraDuration);
	pStream->Write(m_iDurationPerTurn);
	pStream->Write(m_iChangeDuration);
	pStream->Write(m_bMustDie);
	pStream->Write(m_bNullPromotionAvailable);
	pStream->Write(m_bNonTemporary);
	pStream->Write(m_iExtraSupport);
	pStream->Write(m_iChanceMiscast);
	pStream->Write(m_iCombatDmgCapBoost);
	pStream->Write(m_iCollateralLimitCap);
	pStream->Write(m_iCollateralLimitBoost);
	pStream->Write(m_iCollateralTargetsLimit);
	pStream->Write(m_iCollateralExtraTargets);
/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
	pStream->Write(m_iFlankingLimitBoost);
	pStream->Write(m_iFlankingExtraTargets);
/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	pStream->Write(m_iHammerSacrifice);
	pStream->Write(m_iExtraHammerPerPop);
	pStream->Write(m_iFoodSacrifice);
	pStream->Write(m_iPopulationAdd);
	pStream->Write(m_iBeakerSacrifice);
	pStream->Write(m_iExtraBeakerPerPop);
	pStream->Write(m_iGoldSacrifice);
	pStream->Write(m_iExtraGoldPerPop);
	pStream->Write(m_iCultureSacrifice);
	pStream->Write(m_iExtraCulturePerPop);
	pStream->Write(m_iXPTranserRate);
	pStream->Write(m_iCastingLimit);
	pStream->WriteString(m_szNewName);
	pStream->Write(m_MasterUnit.eOwner);
	pStream->Write(m_MasterUnit.iID);
	int iNumSlaves = getNumSlaves();
	pStream->Write(iNumSlaves);
	if (iNumSlaves != 0)
		for (std::list<int>::const_iterator iter = m_pSlaveUnitList.begin(); iter != m_pSlaveUnitList.end(); ++iter)
			pStream->Write(*iter);
	pStream->Write(m_CommanderUnit.eOwner);
	pStream->Write(m_CommanderUnit.iID);
	int iNumMinions = getNumMinions();
	pStream->Write(iNumMinions);
	pStream->Write(m_iNumForcedMinions);
	if (iNumMinions != 0)
		for (std::list<int>::const_iterator iter = m_pMinionUnitList.begin(); iter != m_pMinionUnitList.end(); ++iter)
			pStream->Write(*iter);
	pStream->Write(m_iNumCityBonuses);
	if (m_iNumCityBonuses != 0)
	{
		std::list<CityBonuses> cbDupe = m_cbCityBonuses;
		while (!cbDupe.empty())
		{
			CityBonuses cbTemp = cbDupe.front();
			cbDupe.pop_front();
			cbTemp.write(pStream);
		}
	}
	pStream->Write(NUM_YIELD_TYPES, m_piYieldFromWin);
	pStream->Write(NUM_YIELD_TYPES, m_piYieldForLoss);
	pStream->Write(NUM_COMMERCE_TYPES, m_piCommerceFromWin);
	pStream->Write(NUM_COMMERCE_TYPES, m_piCommerceForLoss);
	pStream->Write(GC.getNumPromotionInfos(), m_piPromotionDuration);
	pStream->Write((int)m_aiInvisibleTypes.size());
	for(int iI=0;iI<(int)m_aiInvisibleTypes.size();iI++)
	{
		pStream->Write(m_aiInvisibleTypes[iI]);
	}
	pStream->Write((int)m_aiSeeInvisibleTypes.size());
	for(int i=0;i<(int)m_aiSeeInvisibleTypes.size();i++)
		pStream->Write(m_aiSeeInvisibleTypes[i]);
	pStream->Write(GC.getNumPromotionInfos(), m_piAllowPromotion);
/*************************************************************************************************/
/**	Second Job							08/28/10									Valkrionn	**/
/**				Allows units to qualify for the promotions of other UnitCombats					**/
/*************************************************************************************************/
	pStream->Write(GC.getNumUnitCombatInfos(), m_piSecondaryUnitCombat);
/*************************************************************************************************/
/**	TempCombat									END												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Better Affinity						01/30/11									Valkrionn	**/
/**																								**/
/**					Vastly improved Affinity system, open to many tags							**/
/*************************************************************************************************/
	pStream->Write(GC.getNumAffinityInfos(), m_piAffinities);
	pStream->Write(GC.getNumAffinityInfos(), m_piAffinityApplications);
/*************************************************************************************************/
/**	Better Affinity							END													**/
/*************************************************************************************************/
	pStream->Write(GC.getNumPromotionInfos(), m_piDenyPromotion);
	pStream->Write(m_iSpawnPlotX);
	pStream->Write(m_iSpawnPlotY);
	pStream->Write(m_eSpawnImprovementType);
	pStream->Write(m_iNoBadExplore);
	pStream->WriteString(m_szQuote);
	pStream->WriteString(m_szImage);
	pStream->Write(m_bSuppressImage);
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Spell System: Added by Kael 07/23/2007
	pStream->Write(m_bFleeWithdrawl);
	pStream->Write(m_bHasCasted);
/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Write(m_bIgnoreHide);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/
	pStream->Write(m_iAlive);
	pStream->Write(m_iEnraged);
	pStream->Write(m_iBoarding);
	pStream->Write(m_iDefensiveStrikeChance);
	pStream->Write(m_iDefensiveStrikeDamage);
	pStream->Write(m_iDoubleFortifyBonus);
	pStream->Write(m_iFear);
	pStream->Write(m_iFlying);
	pStream->Write(m_iHeld);
	pStream->Write(m_iHiddenNationality);
	pStream->Write(m_iIgnoreBuildingDefense);
	pStream->Write(m_iImmortal);
	pStream->Write(m_iImmuneToCapture);
	pStream->Write(m_iImmuneToDefensiveStrike);
	pStream->Write(m_iImmuneToFear);
	pStream->Write(m_iImmuneToMagic);
/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Write(m_iInvisible);
	pStream->Write(m_iSeeInvisible);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/
	pStream->Write(m_iOnlyDefensive);
	pStream->Write(m_iBetrayalChance);
	pStream->Write(m_iTargetWeakestUnit);
	pStream->Write(m_iTargetWeakestUnitCounter);
	pStream->Write(m_iTwincast);
	pStream->Write(m_iWaterWalking);
	pStream->Write(m_iBaseCombatDefense);
	pStream->Write(m_iBetterDefenderThanPercent);
	pStream->Write(m_iCombatHealPercent);
	pStream->Write(m_iCombatLimit);
	pStream->Write(m_iCombatPercentInBorders);
	pStream->Write(m_iCombatPercentGlobalCounter);
	pStream->Write(m_iDelayedSpell);
	pStream->Write(m_iDuration);
	pStream->Write(m_iFreePromotionPick);
/*************************************************************************************************/
/**	BeenThereDoneThat						04/04/09								Xienwolf	**/
/**																								**/
/**									Useless field skipped										**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Write(m_iGoldFromCombat);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	BeenThereDoneThat						END													**/
/*************************************************************************************************/
	pStream->Write(m_iGroupSize);
	pStream->Write(m_iExtraGroupSize);
	/*************************************************************************************************/
/**	CandyMan								04/04/09								Xienwolf	**/
/**																								**/
/**							Allows Multiple Invisible types on a Unit							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Write(m_iInvisibleType);
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	CandyMan								END													**/
/*************************************************************************************************/
	pStream->Write(m_iRace);
	pStream->Write(m_iGraphicalAddOnPromotion);
	pStream->Write(m_iReligion);
	pStream->Write(m_iResist);
	pStream->Write(m_iResistModify);
	pStream->Write(m_iScenarioCounter);
	pStream->Write(m_iSpellCasterXP);
	pStream->Write(m_iSpellDamageModify);
	pStream->Write(m_iSummoner);
	pStream->Write(m_iTotalDamageTypeCombat);
	pStream->Write(m_iUnitArtStyleType);
	pStream->Write(m_iWorkRateModify);
	pStream->Write(GC.getNumBonusInfos(), m_paiBonusAffinity);
	pStream->Write(GC.getNumBonusInfos(), m_paiBonusAffinityAmount);
	pStream->Write(GC.getNumDamageTypeInfos(), m_paiDamageTypeCombat);
	pStream->Write(GC.getNumDamageTypeInfos(), m_paiDamageTypeResist);
//FfH: End Add

	pStream->Write(m_eOwner);
	pStream->Write(m_eCapturingPlayer);
	pStream->Write(m_eUnitType);
	pStream->Write(m_eLeaderUnitType);

	pStream->Write(m_combatUnit.eOwner);
	pStream->Write(m_combatUnit.iID);
	pStream->Write(m_transportUnit.eOwner);
	pStream->Write(m_transportUnit.iID);

	pStream->Write(NUM_DOMAIN_TYPES, m_aiExtraDomainModifier);

	pStream->WriteString(m_szName);
	pStream->WriteString(m_szScriptData);

	pStream->WriteString(m_szReplaceArtDefineTag);
	pStream->WriteString(m_szExtraArtDefineTag);
	pStream->WriteString(m_szExtraArtDefineTag2);
	pStream->WriteString(m_szExtraArtDefineTag3);
	/*************************************************************************************************/
/**	Xienwolf Tweak							07/18/09											**/
/**																								**/
/**				Integer Tracking of Promotions for Containers and Stack Effects					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pStream->Write(GC.getNumPromotionInfos(), m_pabHasPromotion);
/**								----  End Original Code  ----									**/
	pStream->Write(GC.getNumPromotionInfos(), m_paiHasPromotion);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	pStream->Write(GC.getNumImprovementInfos(), m_paiNoBadExploreImprovement);

	pStream->Write(GC.getNumTerrainInfos(), m_paiTerrainDoubleMoveCount);
	pStream->Write(GC.getNumFeatureInfos(), m_paiFeatureDoubleMoveCount);
	pStream->Write(GC.getNumTerrainInfos(), m_paiExtraTerrainAttackPercent);
	pStream->Write(GC.getNumTerrainInfos(), m_paiExtraTerrainDefensePercent);
	pStream->Write(GC.getNumFeatureInfos(), m_paiExtraFeatureAttackPercent);
	pStream->Write(GC.getNumFeatureInfos(), m_paiExtraFeatureDefensePercent);
	pStream->Write(GC.getNumPlotEffectInfos(), m_paiPlotEffectDoubleMoveCount);
	pStream->Write(GC.getNumPlotEffectInfos(), m_paiExtraPlotEffectAttackPercent);
	pStream->Write(GC.getNumPlotEffectInfos(), m_paiExtraPlotEffectDefensePercent);
/*************************************************************************************************/
/**	GWS										2010-08-23									Milaga	**/
/**																								**/
/**					Units can have movement modifiers for different terrain						**/
/*************************************************************************************************/
	pStream->Write(m_iPeakCost);
	pStream->Write(m_iHillCost);
	pStream->Write(GC.getNumTerrainInfos(), m_paiTerrainCost);
	pStream->Write(GC.getNumFeatureInfos(), m_paiFeatureCost);
/*************************************************************************************************/
/**	GWS										END													**/
/*************************************************************************************************/
	pStream->Write(GC.getNumUnitCombatInfos(), m_paiExtraUnitCombatModifier);
	pStream->Write(GC.getNumSpellClassInfos(), m_paiExtraSpellClassPower);
	/*************************************************************************************************/
/**	AutoCast								02/09/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
	pStream->Write(m_eAutoCast);
	pStream->Write(m_bAutoCastPre);
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
	pStream->Write(m_iNumInquisition);
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
	pStream->Write(m_iMissionSpell);

	//Magic Rework
	pStream->Write(m_iExtraMagicalPower);
//	pStream->Write(m_iExtraDominionCapacity); 
}

// Protected Functions...

bool CvUnit::canAdvance(const CvPlot* pPlot, int iThreshold) const
{
	FAssert(canFight());
/*************************************************************************************************/
/**	Xienwolf Tweak							01/04/09											**/
/**																								**/
/**					Players can OWN animals, they WILL have some in their cities				**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	FAssert(!(isAnimal() && pPlot->isCity()));
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
	FAssert(getDomainType() != DOMAIN_AIR);
	FAssert(getDomainType() != DOMAIN_IMMOBILE);

	if (pPlot->getNumVisibleEnemyDefenders(this) > iThreshold)
	{
		return false;
	}

	if (isCannotCapture(true))
	{
		if (pPlot->isEnemyCity(*this))
		{
			return false;
		}
	}

	return true;
}

/*************************************************************************************************/
/**	UnitStatistics							07/18/08	Written: Teg Navanis Imported: Xienwolf	**/
/**																								**/
/**							Sends Combat Result Information to Python							**/
/*************************************************************************************************/
void CvUnit::ReportEventToPython(CvUnit* pUnit, char* Event)  // Unit Statistics by Teg_Navanis
{
	PROFILE("ReportEventToPython 1");

	CyUnit* pyUnit1 = new CyUnit(this);
	CyUnit* pyUnit2 = new CyUnit(pUnit);
	CyArgsList pyArgs;
	pyArgs.add(gDLL->getPythonIFace()->makePythonObject(pyUnit1));
	pyArgs.add(gDLL->getPythonIFace()->makePythonObject(pyUnit2));
	CvEventReporter::getInstance().genericEvent(Event, pyArgs.makeFunctionArgs());
	delete pyUnit1;
	delete pyUnit2;
}

void CvUnit::ReportEventToPython(CvUnit* pUnit, int iValue, char* Event)  // Unit Statistics by Teg_Navanis
{
	PROFILE("ReportEventToPython 2");

	CyUnit* pyUnit1 = new CyUnit(this);
	CyUnit* pyUnit2 = new CyUnit(pUnit);
	CyArgsList pyArgs;
	pyArgs.add(gDLL->getPythonIFace()->makePythonObject(pyUnit1));
	pyArgs.add(gDLL->getPythonIFace()->makePythonObject(pyUnit2));
	pyArgs.add(iValue);
	CvEventReporter::getInstance().genericEvent(Event, pyArgs.makeFunctionArgs());
	delete pyUnit1;
	delete pyUnit2;
}

void CvUnit::ReportEventToPython(CvUnit* pUnit, int iValue1, int iValue2, char* Event)  // Unit Statistics by Teg_Navanis
{
	PROFILE("ReportEventToPython 3");

	CyUnit* pyUnit1 = new CyUnit(this);
	CyUnit* pyUnit2 = new CyUnit(pUnit);
	CyArgsList pyArgs;
	pyArgs.add(gDLL->getPythonIFace()->makePythonObject(pyUnit1));
	pyArgs.add(gDLL->getPythonIFace()->makePythonObject(pyUnit2));
	pyArgs.add(iValue1);
	pyArgs.add(iValue2);
	CvEventReporter::getInstance().genericEvent(Event, pyArgs.makeFunctionArgs());
	delete pyUnit1;
	delete pyUnit2;

}
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/

void CvUnit::collateralCombat(const CvPlot* pPlot, CvUnit* pSkipUnit)
{
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	CvUnit* pBestUnit;
	CvWString szBuffer;
	int iTheirStrength;
	int iStrengthFactor;
	int iCollateralDamage;
	int iUnitDamage;
	int iDamageCount;
	int iPossibleTargets;
	int iCount;
	int iValue;
	int iBestValue;
	std::map<CvUnit*, int> mapUnitDamage;
	std::map<CvUnit*, int>::iterator it;

	int iCollateralStrength = (getDomainType() == DOMAIN_AIR ? airBaseCombatStr() : baseCombatStr()) * collateralDamage() / 100;
/*************************************************************************************************/
/** Unofficial Patch Barrage promotions made working again on units with no base collateral ability    adopted for Orbis by Ahwaric      18.06.09   	**/
/*************************************************************************************************/
/**						---- Start Original Code ----			**
	if (iCollateralStrength == 0)
/**						----  End Original Code  ----			**/
	if (iCollateralStrength == 0 && getExtraCollateralDamage() == 0)
/*************************************************************************************************/
/** Unofficial Patch  END															**/
/*************************************************************************************************/
	{
		return;
	}

	iPossibleTargets = std::min((pPlot->getNumVisibleEnemyDefenders(this) - 1), collateralDamageMaxUnits());

	pUnitNode = pPlot->headUnitNode();

	while (pUnitNode != NULL)
	{
		pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if (pLoopUnit != pSkipUnit)
		{
			if (isEnemy(pLoopUnit->getTeam(), pPlot))
			{
				if (!(pLoopUnit->isInvisible(getTeam(), false)))
				{
					if (pLoopUnit->canDefend())
					{
						iValue = (1 + GC.getGameINLINE().getSorenRandNum(10000, "Collateral Damage"));

						iValue *= pLoopUnit->currHitPoints();

						mapUnitDamage[pLoopUnit] = iValue;
					}
				}
			}
		}
	}

	CvCity* pCity = NULL;
	if (getDomainType() == DOMAIN_AIR)
	{
		pCity = pPlot->getPlotCity();
	}

	iDamageCount = 0;
	iCount = 0;

	while (iCount < iPossibleTargets)
	{
		iBestValue = 0;
		pBestUnit = NULL;

		for (it = mapUnitDamage.begin(); it != mapUnitDamage.end(); it++)
		{
			if (it->second > iBestValue)
			{
				iBestValue = it->second;
				pBestUnit = it->first;
			}
		}

		if (pBestUnit != NULL)
		{
			mapUnitDamage.erase(pBestUnit);

			if (NO_UNITCOMBAT == getUnitCombatType() || !pBestUnit->getUnitInfo().getUnitCombatCollateralImmune(getUnitCombatType()))
			{
				iTheirStrength = pBestUnit->baseCombatStr();

/*************************************************************************************************/
/** Unofficial Patch  Revised collateral damage formula for non-native collateral units    adopted for Orbis by Ahwaric      18.06.09   	**/
/*************************************************************************************************/
				if (iCollateralStrength == 0)
				{
					iCollateralStrength = baseCombatStr();
				}
/*************************************************************************************************/
/** Unofficial Patch  END															**/
/*************************************************************************************************/

				iStrengthFactor = ((iCollateralStrength + iTheirStrength + 1) / 2);

				iCollateralDamage = (GC.getDefineINT("COLLATERAL_COMBAT_DAMAGE") * (iCollateralStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor);

				iCollateralDamage *= 100 + getExtraCollateralDamage();

				iCollateralDamage *= std::max(0, 100 - pBestUnit->getCollateralDamageProtection());
				iCollateralDamage /= 100;

				if (pCity != NULL)
				{
					iCollateralDamage *= 100 + pCity->getAirModifier();
					iCollateralDamage /= 100;
				}

				iCollateralDamage /= 100;

				iCollateralDamage = std::max(0, iCollateralDamage);

				int iMaxDamage = std::min(collateralDamageLimit(), (collateralDamageLimit() * (iCollateralStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor));
				iUnitDamage = std::max(pBestUnit->getDamage(), std::min(pBestUnit->getDamage() + iCollateralDamage, iMaxDamage));

				if (pBestUnit->getDamage() != iUnitDamage)
				{
/*************************************************************************************************/
/**	UnitStatistics							07/18/08	Written: Teg Navanis Imported: Xienwolf	**/
/**																								**/
/**							Sends Combat Result Information to Python							**/
/*************************************************************************************************/
					if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
					{
						ReportEventToPython(pBestUnit, 3, std::min((collateralDamageLimit() - pBestUnit->getDamage()), iCollateralDamage), "combatHit");  // Unit Statistics by Teg_Navanis
					}
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/
					pBestUnit->setDamage(iUnitDamage, getOwnerINLINE());
					iDamageCount++;
				}
			}

			iCount++;
		}
		else
		{
			break;
		}
	}

	if (iDamageCount > 0)
	{
		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SUFFER_COL_DMG", iDamageCount);
		gDLL->getInterfaceIFace()->addMessage(pSkipUnit->getOwnerINLINE(), (pSkipUnit->getDomainType() != DOMAIN_AIR), GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pSkipUnit->getX_INLINE(), pSkipUnit->getY_INLINE(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_INFLICT_COL_DMG", getNameKey(), iDamageCount);
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pSkipUnit->getX_INLINE(), pSkipUnit->getY_INLINE());
	}
}


void CvUnit::flankingStrikeCombat(const CvPlot* pPlot, int iAttackerStrength, int iAttackerFirepower, int iDefenderOdds, int iDefenderDamage, CvUnit* pSkipUnit)
{
	if (pPlot->isCity(true, pSkipUnit->getTeam()))
	{
		return;
	}

	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();

	std::vector< std::pair<CvUnit*, int> > listFlankedUnits;
	while (NULL != pUnitNode)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if (pLoopUnit != pSkipUnit)
		{
			if (!pLoopUnit->isDead() && isEnemy(pLoopUnit->getTeam(), pPlot))
			{
				if (!(pLoopUnit->isInvisible(getTeam(), false)))
				{
					if (pLoopUnit->canDefend())
					{

/*************************************************************************************************/
/**	Updated Flanking						2011-10-30									Jheral	**/
/**																								**/
/**					Flanking applies to UnitCombats, rather than UnitClasses					**/
/*************************************************************************************************/
		// Old Code:	int iFlankingStrength = m_pUnitInfo->getFlankingStrikeUnitClass(pLoopUnit->getUnitClassType());
						int iFlankingStrength = flankingDamage();
/*************************************************************************************************/
/**	Bugfix								31/01/12									Snarko		**/
/**								UnitCombatType can be NO_UNITCOMBAT								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
						bool bValidUnitCombat = m_pUnitInfo->getFlankingStrikeUnitCombat(pLoopUnit->getUnitCombatType());
/**								----  End Original Code  ----									**/
						bool bValidUnitCombat = false;
						if (pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT)
							bValidUnitCombat = m_pUnitInfo->getFlankingStrikeUnitCombat(pLoopUnit->getUnitCombatType());
/*************************************************************************************************/
/**	Bugfix									END													**/
/*************************************************************************************************/

						if (bValidUnitCombat == true)
						{
							int iFlankedDefenderStrength;
							int iFlankedDefenderOdds;
							int iAttackerDamage;
							int iFlankedDefenderDamage;

							getDefenderCombatValues(*pLoopUnit, pPlot, iAttackerStrength, iAttackerFirepower, iFlankedDefenderOdds, iFlankedDefenderStrength, iAttackerDamage, iFlankedDefenderDamage);

/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      02/21/10                                jdog5000      */
/*                                                                                              */
/* Efficiency                                                                                   */
/************************************************************************************************/
							// From Lead From Behind by UncutDragon
							// original
							//if (GC.getGameINLINE().getSorenRandNum(GC.getDefineINT("COMBAT_DIE_SIDES"), "Flanking Combat") >= iDefenderOdds)
							// modified
							if (GC.getGameINLINE().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Flanking Combat") >= iDefenderOdds)
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/
							{
		/* Old Code:			int iCollateralDamage = (iFlankingStrength * iDefenderDamage) / 100;
								int iUnitDamage = std::max(pLoopUnit->getDamage(), std::min(pLoopUnit->getDamage() + iCollateralDamage, collateralDamageLimit())); */
								int iFlankingDamage = (iFlankingStrength * iDefenderDamage) / 100;
								int iUnitDamage = std::max(pLoopUnit->getDamage(), std::min(pLoopUnit->getDamage() + iFlankingDamage, flankingDamageLimit()));

/*************************************************************************************************/
/**	UnitStatistics							07/18/08	Written: Teg Navanis Imported: Xienwolf	**/
/**																								**/
/**							Sends Combat Result Information to Python							**/
/*************************************************************************************************/
								if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
								{
									ReportEventToPython(pLoopUnit, 4, (iUnitDamage - pLoopUnit->getDamage()), "combatHit");  // Unit Statistics by Teg_Navanis
								}
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/
								if (pLoopUnit->getDamage() != iUnitDamage)
								{
									listFlankedUnits.push_back(std::make_pair(pLoopUnit, iUnitDamage));
								}
							}
						}
					}
				}
			}
		}
	}
	/* Old Code:
	int iNumUnitsHit = std::min((int)listFlankedUnits.size(), collateralDamageMaxUnits());*/
	int iNumUnitsHit = std::min((int)listFlankedUnits.size(), flankingDamageMaxUnits());

/*************************************************************************************************/
/**	Updated Flanking						END													**/
/*************************************************************************************************/
	for (int i = 0; i < iNumUnitsHit; ++i)
	{
		int iIndexHit = GC.getGameINLINE().getSorenRandNum(listFlankedUnits.size(), "Pick Flanked Unit");
		CvUnit* pUnit = listFlankedUnits[iIndexHit].first;
		int iDamage = listFlankedUnits[iIndexHit].second;
		pUnit->setDamage(iDamage, getOwnerINLINE());
		if (pUnit->isDead())
		{
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_UNIT_BY_FLANKING", getNameKey(), pUnit->getNameKey(), pUnit->getVisualCivAdjective(getTeam()));
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_DIED_BY_FLANKING", pUnit->getNameKey(), getNameKey(), getVisualCivAdjective(pUnit->getTeam()));
			gDLL->getInterfaceIFace()->addMessage(pUnit->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

			pUnit->kill(false);
		}

		listFlankedUnits.erase(std::remove(listFlankedUnits.begin(), listFlankedUnits.end(), listFlankedUnits[iIndexHit]));
	}

	if (iNumUnitsHit > 0)
	{
		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_UNITS_BY_FLANKING", getNameKey(), iNumUnitsHit);
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

		if (NULL != pSkipUnit)
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNITS_DAMAGED_BY_FLANKING", getNameKey(), iNumUnitsHit);
			gDLL->getInterfaceIFace()->addMessage(pSkipUnit->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGameINLINE().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());
		}
	}
}


// Returns true if we were intercepted...
bool CvUnit::interceptTest(const CvPlot* pPlot)
{
	if (GC.getGameINLINE().getSorenRandNum(100, "Evasion Rand") >= evasionProbability())
	{
		CvUnit* pInterceptor = bestInterceptor(pPlot);

		if (pInterceptor != NULL)
		{
			if (GC.getGameINLINE().getSorenRandNum(100, "Intercept Rand (Air)") < pInterceptor->currInterceptionProbability())
			{
				fightInterceptor(pPlot, false);

				return true;
			}
		}
	}

	return false;
}


CvUnit* CvUnit::airStrikeTarget(const CvPlot* pPlot) const
{
	CvUnit* pDefender;

/*************************************************************************************************/
/**	Xienwolf Tweak							04/15/09											**/
/**																								**/
/**				Prevent Ranged attacks against units you won't actually harm					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pDefender = pPlot->getBestDefender(NO_PLAYER, getOwnerINLINE(), this, true);
/**								----  End Original Code  ----									**/
	pDefender = pPlot->getBestRangedDefender(NO_PLAYER, getOwnerINLINE(), this, true);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/

	if (pDefender != NULL)
	{
		if (!pDefender->isDead())
		{
			if (pDefender->canDefend())
			{
				return pDefender;
			}
		}
	}

	return NULL;
}


bool CvUnit::canAirStrike(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (!canAirAttack())
	{
		return false;
	}

	if (pPlot == plot())
	{
		return false;
	}

	if (!pPlot->isVisible(getTeam(), false))
	{
		return false;
	}

	if (plotDistance(getX_INLINE(), getY_INLINE(), pPlot->getX_INLINE(), pPlot->getY_INLINE()) > airRange())
	{
		return false;
	}

	if (airStrikeTarget(pPlot) == NULL)
	{
		return false;
	}

	return true;
}


// True if damage set, did recon; false if intercepted or can't attack the plot
bool CvUnit::airStrike(CvPlot* pPlot)
{
	if (!canAirStrike(pPlot))
	{
		return false;
	}

	if (interceptTest(pPlot))
	{
		return false;
	}

	CvUnit* pDefender = airStrikeTarget(pPlot);

	FAssert(pDefender != NULL);
	FAssert(pDefender->canDefend());

	setReconPlot(pPlot);

	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	int iDamage = airCombatDamage(pDefender);

	int iUnitDamage = std::max(pDefender->getDamage(), std::min((pDefender->getDamage() + iDamage), airCombatLimit()));

	// Makes higher values than 100 HP possible : Higher hitpoints Snarko 01/02/11
	CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR",
		pDefender->getNameKey(),
		getNameKey(),
		-(((iUnitDamage - pDefender->getDamage()) * 100 * GC.getDefineINT("HIT_POINT_FACTOR") ) / pDefender->maxHitPoints()),
		GET_PLAYER(getVisualOwner(pDefender->getTeam())).getCivilizationAdjectiveKey());
	gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACK", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE(), true, true);

	szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR",
		getNameKey(),
		pDefender->getNameKey(),
		-(((iUnitDamage - pDefender->getDamage()) * 100 * GC.getDefineINT("HIT_POINT_FACTOR")) / pDefender->maxHitPoints()),
		GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
	gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACKED", MESSAGE_TYPE_INFO, pDefender->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

	collateralCombat(pPlot, pDefender);

	// Sends Combat Result Information to Python : UnitStatistics Written: Teg Navanis Imported: Xienwolf 07/18/08
	if (GC.getUSE_UNIT_STATISTICS_CALLBACK())
	{
		ReportEventToPython(pDefender, 5, (std::min(iDamage, (airCombatLimit() - pDefender->getDamage()))), "combatHit");  // Unit Statistics by Teg_Navanis
	}
	pDefender->setDamage(iUnitDamage, getOwnerINLINE());

	return true;
}

/*************************************************************************************************/
/**	Xienwolf Tweak							04/15/09											**/
/**																								**/
/**				Allows AI and Automated units to check potential attackers						**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
bool CvUnit::canRangeStrike() const
/**								----  End Original Code  ----									**/
bool CvUnit::canRangeStrike(bool bTest) const
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
{
	if (getDomainType() == DOMAIN_AIR)
	{
		return false;
	}

	if (airRange() <= 0)
	{
		return false;
	}

	if (airBaseCombatStr() <= 0)
	{
		return false;
	}

/*************************************************************************************************/
/**	Vehem Tweak							02/07/09									Vehem		**/
/**																								**/
/**							Stops Blitz allowing unlimited ranged strikes						**/
/*************************************************************************************************/
/**						-- Start Original Code --
	if (!canFight())
	{
		return false;
	}

	if (isMadeAttack() && !isBlitz())
	{
		return false;
	}

	if (!canMove() && getMoves() > 0)
	{
		return false;
	}
/**								----  End Original Code  ----									**/
/*************************************************************************************************/
/**	Tweak							05/05/11								Snarko				**/
/**			Making ranged attacks cost a movement point and adjusting the AI.					**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (isMadeAttack() && !bTest)
	{
		return false;
	}
/**								----  End Original Code  ----									**/
	if (!bTest)
	{
		if (isMadeAttack() && !isBlitz())
		{
			return false;
		}

		if (!canMove() && getMoves() > 0)
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	UnitStatistics								END												**/
/*************************************************************************************************/

	return true;
}

// Checks if this unit can air strike from pPlot to iX, iY
bool CvUnit::canRangeStrikeAt(const CvPlot* pPlot, int iX, int iY, bool bTest) const
{
	// Xienwolf - 04/15/09 - Added bTest to allow AI and Automated units to check potential attackers
	if (!canRangeStrike(bTest))
		return false;

	CvPlot* pTargetPlot = GC.getMapINLINE().plotINLINE(iX, iY);

	if (NULL == pTargetPlot)
		return false;

	if (!pPlot->isVisible(getTeam(), false))
		return false;

	if (plotDistance(pPlot, pTargetPlot) > airRange())
		return false;

	CvUnit* pDefender = airStrikeTarget(pTargetPlot);
	if (NULL == pDefender)
		return false;

	if (!pPlot->canSeePlot(pTargetPlot, getTeam(), airRange()))
		return false;

	return true;
}


bool CvUnit::rangeStrike(int iX, int iY)
{
	CvUnit* pDefender;
	CvWString szBuffer;
	int iUnitDamage;
	int iDamage;

	CvPlot* pPlot = GC.getMapINLINE().plot(iX, iY);
	if (NULL == pPlot)
	{
		return false;
	}

	// Was "!canRangeStrikeAt(pPlot, iX, iY)" : UNOFFICIAL_PATCH jdog5000 05/10/10
	if (!canRangeStrikeAt(plot(), iX, iY))
	{
		return false;
	}
	pDefender = airStrikeTarget(pPlot);

	FAssert(pDefender != NULL);
	FAssert(pDefender->canDefend());

	if (GC.getDefineINT("RANGED_ATTACKS_USE_MOVES") == 0)
	{
		setMadeAttack(true);
	}

	// Note: Removing this makes ranged attacks free, not use fortification : Snarko, Vehem
	changeMoves(GC.getMOVE_DENOMINATOR());

	iDamage = rangeCombatDamage(pDefender);

	// Allow ranged attacks to grant xp, softcapped by xml : Vehem, 3/11/09
	int iInitialUnitDamage = pDefender->getDamage();
	iUnitDamage = std::max(iInitialUnitDamage, std::min((iInitialUnitDamage + iDamage), airCombatLimit()));
	int iXPPercent = GC.getDefineINT("RANGE_COMBAT_XP_PERCENTAGE");
	if (iXPPercent > 0)
	{
		// Allows Commanders to gain XP when their Minions take part in battle : CommandingPresence Xienwolf 05/31/09
		changeExperience((iUnitDamage * iXPPercent) / ((getExperience() / 500)+1) , -1, false, false, false, true);
	}

	// Display affiliation of opponent, increase hitpoints over 100 : Higher hitpoints Snarko Xienwolf 01/02/11 04/09/09
	szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR",
		pDefender->getNameKey(),
		getNameKey(),
		-(((iUnitDamage - pDefender->getDamage()) * 100 * GC.getDefineINT("HIT_POINT_FACTOR") ) / pDefender->maxHitPoints()),
		GET_PLAYER(getVisualOwner(pDefender->getTeam())).getCivilizationAdjectiveKey());
	//red icon over attacking unit
	gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), this->getX_INLINE(), this->getY_INLINE(), true, true);
	//white icon over defending unit
	gDLL->getInterfaceIFace()->addMessage(pDefender->getOwnerINLINE(), false, 0, L"", "AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, pDefender->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pDefender->getX_INLINE(), pDefender->getY_INLINE(), true, true);

	// Display affiliation of target (because why not) : Blazenclaw
	szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR",
		getNameKey(),
		pDefender->getNameKey(),
		-(((iUnitDamage - pDefender->getDamage()) * 100 * GC.getDefineINT("HIT_POINT_FACTOR")) / pDefender->maxHitPoints()),
		GET_PLAYER(pDefender->getVisualOwner(getTeam())).getCivilizationAdjectiveKey());
	//green icon over attacking unit
	gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pDefender->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), pPlot->getX_INLINE(), pPlot->getY_INLINE());

	collateralCombat(pPlot, pDefender);

	//set damage but don't update entity damage visibility
	pDefender->setDamage(iUnitDamage, getOwnerINLINE(), false);
	CLLNode<IDInfo>* pUnitNode;
	CvUnit* pLoopUnit;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI) && GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply() != NO_PROMOTION)
		{
			PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionCombatApply();
			//pPlot = pLoser->plot();
			pUnitNode = pPlot->headUnitNode();
			while (pUnitNode != NULL)
			{
				pLoopUnit = ::getUnit(pUnitNode->m_data);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);
				if (pLoopUnit->isHasPromotion(ePromotion) == false)
				{
					if (pLoopUnit->isAlive() || !GC.getPromotionInfo(ePromotion).isPrereqAlive())
					{
						if (isEnemy(pLoopUnit->getTeam()))
						{
							if (GC.getGameINLINE().getSorenRandNum(100, "Combat Apply") <= GC.getDefineINT("COMBAT_APPLY_CHANCE") / 3)
							{
								// reimplemented; was commented out because...?
								if (pLoopUnit->canAcquirePromotion(ePromotion))
								{
									pLoopUnit->setHasPromotion(ePromotion, true);
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)pLoopUnit->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
									gDLL->getInterfaceIFace()->addMessage((PlayerTypes)getOwner(), true, GC.getEVENT_MESSAGE_TIME(), GC.getPromotionInfo(ePromotion).getDescription(), "", MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromotion).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
								}
							}
						}
					}
				}
			}
		}
	}
	if (pPlot->isActiveVisible(false))
	{
		// Range strike entity mission
		CvMissionDefinition kDefiniton;
		kDefiniton.setMissionTime(GC.getMissionInfo(MISSION_RANGE_ATTACK).getTime() * gDLL->getSecsPerTurn());
		kDefiniton.setMissionType(MISSION_RANGE_ATTACK);
		kDefiniton.setPlot(pDefender->plot());
		kDefiniton.setUnit(BATTLE_UNIT_ATTACKER, this);
		kDefiniton.setUnit(BATTLE_UNIT_DEFENDER, pDefender);
		gDLL->getEntityIFace()->AddMission(&kDefiniton);

		//delay death
		// Bugfix : UNOFFICIAL_PATCH jdog5000 05/10/10
		/* original bts code
		pDefender->getGroup()->setMissionTimer(GC.getMissionInfo(MISSION_RANGE_ATTACK).getTime());
		*/
		// mission timer is not used like this in any other part of code, so it might cause OOS
		// issues ... at worst I think unit dies before animation is complete, so no real
		// harm in commenting it out.
	}
	return true;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::planBattle
//! \brief      Determines in general how a battle will progress.
//!
//!				Note that the outcome of the battle is not determined here. This function plans
//!				how many sub-units die and in which 'rounds' of battle.
//! \param      kBattleDefinition The battle definition, which receives the battle plan.
//! \retval     The number of game turns that the battle should be given.
//------------------------------------------------------------------------------------------------
int CvUnit::planBattle( CvBattleDefinition & kBattleDefinition ) const
{
#define BATTLE_TURNS_SETUP 4
#define BATTLE_TURNS_ENDING 4
#define BATTLE_TURNS_MELEE 6
#define BATTLE_TURNS_RANGED 6
#define BATTLE_TURN_RECHECK 4

	int								aiUnitsBegin[BATTLE_UNIT_COUNT];
	int								aiUnitsEnd[BATTLE_UNIT_COUNT];
	int								aiToKillMelee[BATTLE_UNIT_COUNT];
	int								aiToKillRanged[BATTLE_UNIT_COUNT];
	CvBattleRoundVector::iterator	iIterator;
	int								i, j;
	bool							bIsLoser;
	int								iRoundIndex;
	int								iTotalRounds = 0;
	int								iRoundCheck = BATTLE_TURN_RECHECK;

	// Initial conditions
	kBattleDefinition.setNumRangedRounds(0);
	kBattleDefinition.setNumMeleeRounds(0);

	int iFirstStrikesDelta = kBattleDefinition.getFirstStrikes(BATTLE_UNIT_ATTACKER) - kBattleDefinition.getFirstStrikes(BATTLE_UNIT_DEFENDER);
	if (iFirstStrikesDelta > 0) // Attacker first strikes
	{
		int iKills = computeUnitsToDie( kBattleDefinition, true, BATTLE_UNIT_DEFENDER );
		kBattleDefinition.setNumRangedRounds(std::max(iFirstStrikesDelta, iKills / iFirstStrikesDelta));
	}
	else if (iFirstStrikesDelta < 0) // Defender first strikes
	{
		int iKills = computeUnitsToDie( kBattleDefinition, true, BATTLE_UNIT_ATTACKER );
		iFirstStrikesDelta = -iFirstStrikesDelta;
		kBattleDefinition.setNumRangedRounds(std::max(iFirstStrikesDelta, iKills / iFirstStrikesDelta));
	}
	increaseBattleRounds( kBattleDefinition);


	// Keep randomizing until we get something valid
	do
	{
		iRoundCheck++;
		if ( iRoundCheck >= BATTLE_TURN_RECHECK )
		{
			increaseBattleRounds( kBattleDefinition);
			iTotalRounds = kBattleDefinition.getNumRangedRounds() + kBattleDefinition.getNumMeleeRounds();
			iRoundCheck = 0;
		}

		// Make sure to clear the battle plan, we may have to do this again if we can't find a plan that works.
		kBattleDefinition.clearBattleRounds();

		// Create the round list
		CvBattleRound kRound;
		kBattleDefinition.setBattleRound(iTotalRounds, kRound);

		// For the attacker and defender
		for ( i = 0; i < BATTLE_UNIT_COUNT; i++ )
		{
			// Gather some initial information
			BattleUnitTypes unitType = (BattleUnitTypes) i;
			aiUnitsBegin[unitType] = kBattleDefinition.getUnit(unitType)->getSubUnitsAlive(kBattleDefinition.getDamage(unitType, BATTLE_TIME_BEGIN));
			aiToKillRanged[unitType] = computeUnitsToDie( kBattleDefinition, true, unitType);
			aiToKillMelee[unitType] = computeUnitsToDie( kBattleDefinition, false, unitType);
			aiUnitsEnd[unitType] = aiUnitsBegin[unitType] - aiToKillMelee[unitType] - aiToKillRanged[unitType];

			// Make sure that if they aren't dead at the end, they have at least one unit left
			if ( aiUnitsEnd[unitType] == 0 && !kBattleDefinition.getUnit(unitType)->isDead() )
			{
				aiUnitsEnd[unitType]++;
				if ( aiToKillMelee[unitType] > 0 )
				{
					aiToKillMelee[unitType]--;
				}
				else
				{
					aiToKillRanged[unitType]--;
				}
			}

			// If one unit is the loser, make sure that at least one of their units dies in the last round
			if ( aiUnitsEnd[unitType] == 0 )
			{
				kBattleDefinition.getBattleRound(iTotalRounds - 1).addNumKilled(unitType, 1);
				if ( aiToKillMelee[unitType] > 0)
				{
					aiToKillMelee[unitType]--;
				}
				else
				{
					aiToKillRanged[unitType]--;
				}
			}

			// Randomize in which round each death occurs
			bIsLoser = aiUnitsEnd[unitType] == 0;

			// Randomize the ranged deaths
			for ( j = 0; j < aiToKillRanged[unitType]; j++ )
			{
				iRoundIndex = GC.getGameINLINE().getSorenRandNum( range( kBattleDefinition.getNumRangedRounds(), 0, kBattleDefinition.getNumRangedRounds()), "Ranged combat death");
				kBattleDefinition.getBattleRound(iRoundIndex).addNumKilled(unitType, 1);
			}

			// Randomize the melee deaths
			for ( j = 0; j < aiToKillMelee[unitType]; j++ )
			{
				iRoundIndex = GC.getGameINLINE().getSorenRandNum( range( kBattleDefinition.getNumMeleeRounds() - (bIsLoser ? 1 : 2 ), 0, kBattleDefinition.getNumMeleeRounds()), "Melee combat death");
				kBattleDefinition.getBattleRound(kBattleDefinition.getNumRangedRounds() + iRoundIndex).addNumKilled(unitType, 1);
			}

			// Compute alive sums
			int iNumberKilled = 0;
			for(int j=0;j<kBattleDefinition.getNumBattleRounds();j++)
			{
				CvBattleRound &round = kBattleDefinition.getBattleRound(j);
				round.setRangedRound(j < kBattleDefinition.getNumRangedRounds());
				iNumberKilled += round.getNumKilled(unitType);
				round.setNumAlive(unitType, aiUnitsBegin[unitType] - iNumberKilled);
			}
		}

		// Now compute wave sizes
		for(int i=0;i<kBattleDefinition.getNumBattleRounds();i++)
		{
			CvBattleRound &round = kBattleDefinition.getBattleRound(i);
			round.setWaveSize(computeWaveSize(round.isRangedRound(), round.getNumAlive(BATTLE_UNIT_ATTACKER) + round.getNumKilled(BATTLE_UNIT_ATTACKER), round.getNumAlive(BATTLE_UNIT_DEFENDER) + round.getNumKilled(BATTLE_UNIT_DEFENDER)));
		}

		if ( iTotalRounds > 400 )
		{
			kBattleDefinition.setNumMeleeRounds(1);
			kBattleDefinition.setNumRangedRounds(0);
			break;
		}
	}
	while ( !verifyRoundsValid( kBattleDefinition ));

	//add a little extra time for leader to surrender
	bool attackerLeader = false;
	bool defenderLeader = false;
	bool attackerDie = false;
	bool defenderDie = false;
	int lastRound = kBattleDefinition.getNumBattleRounds() - 1;
	if(kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->getLeaderUnitType() != NO_UNIT)
		attackerLeader = true;
	if(kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->getLeaderUnitType() != NO_UNIT)
		defenderLeader = true;
	if(kBattleDefinition.getBattleRound(lastRound).getNumAlive(BATTLE_UNIT_ATTACKER) == 0)
		attackerDie = true;
	if(kBattleDefinition.getBattleRound(lastRound).getNumAlive(BATTLE_UNIT_DEFENDER) == 0)
		defenderDie = true;

	int extraTime = 0;
	if((attackerLeader && attackerDie) || (defenderLeader && defenderDie))
		extraTime = BATTLE_TURNS_MELEE;
	if(gDLL->getEntityIFace()->GetSiegeTower(kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->getUnitEntity()) || gDLL->getEntityIFace()->GetSiegeTower(kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->getUnitEntity()))
		extraTime = BATTLE_TURNS_MELEE;

	return BATTLE_TURNS_SETUP + BATTLE_TURNS_ENDING + kBattleDefinition.getNumMeleeRounds() * BATTLE_TURNS_MELEE + kBattleDefinition.getNumRangedRounds() * BATTLE_TURNS_MELEE + extraTime;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:	CvBattleManager::computeDeadUnits
//! \brief		Computes the number of units dead, for either the ranged or melee portion of combat.
//! \param		kDefinition The battle definition.
//! \param		bRanged true if computing the number of units that die during the ranged portion of combat,
//!					false if computing the number of units that die during the melee portion of combat.
//! \param		iUnit The index of the unit to compute (BATTLE_UNIT_ATTACKER or BATTLE_UNIT_DEFENDER).
//! \retval		The number of units that should die for the given unit in the given portion of combat
//------------------------------------------------------------------------------------------------
int CvUnit::computeUnitsToDie( const CvBattleDefinition & kDefinition, bool bRanged, BattleUnitTypes iUnit ) const
{
	FAssertMsg( iUnit == BATTLE_UNIT_ATTACKER || iUnit == BATTLE_UNIT_DEFENDER, "Invalid unit index");

	BattleTimeTypes iBeginIndex = bRanged ? BATTLE_TIME_BEGIN : BATTLE_TIME_RANGED;
	BattleTimeTypes iEndIndex = bRanged ? BATTLE_TIME_RANGED : BATTLE_TIME_END;
	return kDefinition.getUnit(iUnit)->getSubUnitsAlive(kDefinition.getDamage(iUnit, iBeginIndex)) -
		kDefinition.getUnit(iUnit)->getSubUnitsAlive( kDefinition.getDamage(iUnit, iEndIndex));
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::verifyRoundsValid
//! \brief      Verifies that all rounds in the battle plan are valid
//! \param      vctBattlePlan The battle plan
//! \retval     true if the battle plan (seems) valid, false otherwise
//------------------------------------------------------------------------------------------------
bool CvUnit::verifyRoundsValid( const CvBattleDefinition & battleDefinition ) const
{
	for(int i=0;i<battleDefinition.getNumBattleRounds();i++)
	{
		if(!battleDefinition.getBattleRound(i).isValid())
			return false;
	}
	return true;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::increaseBattleRounds
//! \brief      Increases the number of rounds in the battle.
//! \param      kBattleDefinition The definition of the battle
//------------------------------------------------------------------------------------------------
void CvUnit::increaseBattleRounds( CvBattleDefinition & kBattleDefinition ) const
{
	if ( kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->isRanged() && kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->isRanged())
	{
		kBattleDefinition.addNumRangedRounds(1);
	}
	else
	{
		kBattleDefinition.addNumMeleeRounds(1);
	}
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::computeWaveSize
//! \brief      Computes the wave size for the round.
//! \param      bRangedRound true if the round is a ranged round
//! \param		iAttackerMax The maximum number of attackers that can participate in a wave (alive)
//! \param		iDefenderMax The maximum number of Defenders that can participate in a wave (alive)
//! \retval     The desired wave size for the given parameters
//------------------------------------------------------------------------------------------------
int CvUnit::computeWaveSize( bool bRangedRound, int iAttackerMax, int iDefenderMax ) const
{
	FAssertMsg( getCombatUnit() != NULL, "You must be fighting somebody!" );
	int aiDesiredSize[BATTLE_UNIT_COUNT];
	if ( bRangedRound )
	{
		aiDesiredSize[BATTLE_UNIT_ATTACKER] = getUnitInfo().getRangedWaveSize();
		aiDesiredSize[BATTLE_UNIT_DEFENDER] = getCombatUnit()->getUnitInfo().getRangedWaveSize();
	}
	else
	{
		aiDesiredSize[BATTLE_UNIT_ATTACKER] = getUnitInfo().getMeleeWaveSize();
		aiDesiredSize[BATTLE_UNIT_DEFENDER] = getCombatUnit()->getUnitInfo().getMeleeWaveSize();
	}

	aiDesiredSize[BATTLE_UNIT_DEFENDER] = aiDesiredSize[BATTLE_UNIT_DEFENDER] <= 0 ? iDefenderMax : aiDesiredSize[BATTLE_UNIT_DEFENDER];
	aiDesiredSize[BATTLE_UNIT_ATTACKER] = aiDesiredSize[BATTLE_UNIT_ATTACKER] <= 0 ? iDefenderMax : aiDesiredSize[BATTLE_UNIT_ATTACKER];
	return std::min( std::min( aiDesiredSize[BATTLE_UNIT_ATTACKER], iAttackerMax ), std::min( aiDesiredSize[BATTLE_UNIT_DEFENDER],
		iDefenderMax) );
}

bool CvUnit::isTargetOf(const CvUnit& attacker) const
{
	CvUnitInfo& attackerInfo = attacker.getUnitInfo();
	CvUnitInfo& ourInfo = getUnitInfo();

	if (!plot()->isCity(true, getTeam()))
	{
		if (NO_UNITCLASS != getUnitClassType() && attackerInfo.getTargetUnitClass(getUnitClassType()))
		{
			return true;
		}

		if (NO_UNITCOMBAT != getUnitCombatType() && attackerInfo.getTargetUnitCombat(getUnitCombatType()))
		{
			return true;
		}
	}

	if (NO_UNITCLASS != attackerInfo.getUnitClassType() && ourInfo.getDefenderUnitClass(attackerInfo.getUnitClassType()))
	{
		return true;
	}

	if (NO_UNITCOMBAT != attackerInfo.getUnitCombatType() && ourInfo.getDefenderUnitCombat(attackerInfo.getUnitCombatType()))
	{
		return true;
	}

	return false;
}

bool CvUnit::isEnemy(TeamTypes eTeam, const CvPlot* pPlot) const
{
	if (NULL == pPlot)
	{
		pPlot = plot();
	}
/*************************************************************************************************/
/**	PeaceAndFlowers							03/27/09								Xienwolf	**/
/**																								**/
/**					Makes all Combat Actions impossible for this type of Unit					**/
/*************************************************************************************************/
	if (isNeverHostile())
	{
		return false;
	}
/*************************************************************************************************/
/**	PeaceAndFlowers							END													**/
/*************************************************************************************************/

//FfH: Added by Kael 10/26/2007 (to prevent spinlocks when always hostile units attack barbarian allied teams)
	if (isAlwaysHostile(pPlot))
	{
		if (getTeam() != eTeam)
		{
			return true;
		}
	}
//FfH: End Add

	return (atWar(GET_PLAYER(getCombatOwner(eTeam, pPlot)).getTeam(), eTeam));
}

bool CvUnit::isPotentialEnemy(TeamTypes eTeam, const CvPlot* pPlot) const
{
	if (NULL == pPlot)
	{
		pPlot = plot();
	}

/*************************************************************************************************/
/**	PeaceAndFlowers							03/27/09								Xienwolf	**/
/**																								**/
/**					Makes all Combat Actions impossible for this type of Unit					**/
/*************************************************************************************************/
	if (isNeverHostile())
	{
		return false;
	}
/*************************************************************************************************/
/**	PeaceAndFlowers							END													**/
/*************************************************************************************************/
	return (::isPotentialEnemy(GET_PLAYER(getCombatOwner(eTeam, pPlot)).getTeam(), eTeam));
}

bool CvUnit::isSuicide() const
{
	return (m_pUnitInfo->isSuicide() || getKamikazePercent() != 0);
}

int CvUnit::getDropRange() const
{
/*************************************************************************************************/
/**	SkyRocket							09/19/08									Xienwolf	**/
/**																								**/
/**						Includes Promotion Field with the UnitInfo								**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	return (m_pUnitInfo->getDropRange());
/**								----  End Original Code  ----									**/
	return (m_pUnitInfo->getDropRange() + getExtraDropRange());
/*************************************************************************************************/
/**	SkyRocket									END												**/
/*************************************************************************************************/
}

void CvUnit::getDefenderCombatValues(CvUnit& kDefender, const CvPlot* pPlot, int iOurStrength, int iOurFirepower, int& iTheirOdds, int& iTheirStrength, int& iOurDamage, int& iTheirDamage, CombatDetails* pTheirDetails) const
{
	PROFILE_FUNC();

	iTheirStrength = kDefender.currCombatStr(pPlot, this, pTheirDetails);
	int iTheirFirepower = kDefender.currFirepower(pPlot, this);

	FAssert((iOurStrength + iTheirStrength) > 0);
	FAssert((iOurFirepower + iTheirFirepower) > 0);

/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      02/21/10                                jdog5000      */
/*                                                                                              */
/* Efficiency                                                                                   */
/************************************************************************************************/
	// From Lead From Behind by UncutDragon
	// original
	//iTheirOdds = ((GC.getDefineINT("COMBAT_DIE_SIDES") * iTheirStrength) / (iOurStrength + iTheirStrength));
	// modified
	iTheirOdds = ((GC.getCOMBAT_DIE_SIDES() * iTheirStrength) / (iOurStrength + iTheirStrength));

/*************************************************************************************************/
/**	MultiBarb							12/23/08									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (kDefender.isBarbarian())
/**								----  End Original Code  ----									**/
	if (kDefender.isBarbarian() && !isBarbarian())
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
	{
		if (GET_PLAYER(getOwnerINLINE()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(getOwnerINLINE()).getHandicapType()).getFreeWinsVsBarbs())
		{
			// UncutDragon
			// original
			//iTheirOdds = std::min((10 * GC.getDefineINT("COMBAT_DIE_SIDES")) / 100, iTheirOdds);
			// modified
			iTheirOdds = std::min((10 * GC.getCOMBAT_DIE_SIDES()) / 100, iTheirOdds);
			// /UncutDragon
		}
	}
/*************************************************************************************************/
/**	MultiBarb							12/23/08									Xienwolf	**/
/**																								**/
/**							Adds extra Barbarian Civilizations									**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (isBarbarian())
/**								----  End Original Code  ----									**/
	if (isBarbarian() && !kDefender.isBarbarian())
/*************************************************************************************************/
/**	MultiBarb								END													**/
/*************************************************************************************************/
	{
		if (GET_PLAYER(kDefender.getOwnerINLINE()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(kDefender.getOwnerINLINE()).getHandicapType()).getFreeWinsVsBarbs())
		{
			// UncutDragon
			// original
			//iTheirOdds =  std::max((90 * GC.getDefineINT("COMBAT_DIE_SIDES")) / 100, iTheirOdds);
			// modified
			iTheirOdds =  std::max((90 * GC.getCOMBAT_DIE_SIDES()) / 100, iTheirOdds);
			// /UncutDragon
		}
	}

	int iStrengthFactor = ((iOurFirepower + iTheirFirepower + 1) / 2);

	// UncutDragon
	// original
	//iOurDamage = std::max(1, ((GC.getDefineINT("COMBAT_DAMAGE") * (iTheirFirepower + iStrengthFactor)) / (iOurFirepower + iStrengthFactor)));
	//iTheirDamage = std::max(1, ((GC.getDefineINT("COMBAT_DAMAGE") * (iOurFirepower + iStrengthFactor)) / (iTheirFirepower + iStrengthFactor)));
	// modified
	iOurDamage = std::max(1, ((GC.getCOMBAT_DAMAGE() * (iTheirFirepower + iStrengthFactor)) / (iOurFirepower + iStrengthFactor)));
	iTheirDamage = std::max(1, ((GC.getCOMBAT_DAMAGE() * (iOurFirepower + iStrengthFactor)) / (iTheirFirepower + iStrengthFactor)));
	// /UncutDragon
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/

}

int CvUnit::getTriggerValue(EventTriggerTypes eTrigger, const CvPlot* pPlot, bool bCheckPlot) const
{
	CvEventTriggerInfo& kTrigger = GC.getEventTriggerInfo(eTrigger);
	if (kTrigger.getNumUnits() <= 0)
	{
		return MIN_INT;
	}

	if (isDead())
	{
		return MIN_INT;
	}

	if (!CvString(kTrigger.getPythonCanDoUnit()).empty())
	{
		long lResult;

		CyArgsList argsList;
		argsList.add(eTrigger);
		argsList.add(getOwnerINLINE());
		argsList.add(getID());

		gDLL->getPythonIFace()->callFunction(PYRandomEventModule, kTrigger.getPythonCanDoUnit(), argsList.makeFunctionArgs(), &lResult);

		if (0 == lResult)
		{
			return MIN_INT;
		}
	}

	if (kTrigger.getNumUnitsRequired() > 0)
	{
		bool bFoundValid = false;
		for (int i = 0; i < kTrigger.getNumUnitsRequired(); ++i)
		{
			if (getUnitClassType() == kTrigger.getUnitRequired(i))
			{
				bFoundValid = true;
				break;
			}
		}

		if (!bFoundValid)
		{
			return MIN_INT;
		}
	}

	if (bCheckPlot)
	{
		if (kTrigger.isUnitsOnPlot())
		{
			if (!plot()->canTrigger(eTrigger, getOwnerINLINE()))
			{
				return MIN_INT;
			}
		}
	}

	int iValue = 0;

	if (!isHurt() && kTrigger.getUnitDamagedWeight() > 0)
	{
		return MIN_INT;
	}

	iValue += getDamage() * kTrigger.getUnitDamagedWeight();

	iValue += getExperience() * kTrigger.getUnitExperienceWeight();

	if (NULL != pPlot)
	{
		iValue += plotDistance(getX_INLINE(), getY_INLINE(), pPlot->getX_INLINE(), pPlot->getY_INLINE()) * kTrigger.getUnitDistanceWeight();
	}

	return iValue;
}

bool CvUnit::canApplyEvent(EventTypes eEvent) const
{
	CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (0 != kEvent.getUnitExperience())
	{
		if (!canAcquirePromotionAny())
		{
			return false;
		}
	}

	if (NO_PROMOTION != kEvent.getUnitPromotion())
	{

//FfH: Modified by Kael 10/29/2007
//		if (!canAcquirePromotion((PromotionTypes)kEvent.getUnitPromotion()))
//		{
//			return false;
//		}
		if (isHasPromotion((PromotionTypes)kEvent.getUnitPromotion()))
		{
			return false;
		}
//FfH: End Modify

	}

	if (kEvent.getUnitImmobileTurns() > 0)
	{
		if (!canAttack())
		{
			return false;
		}
	}

	return true;
}

void CvUnit::applyEvent(EventTypes eEvent)
{
	if (!canApplyEvent(eEvent))
	{
		return;
	}

	CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (0 != kEvent.getUnitExperience())
	{
		setDamage(0);
		changeExperience(kEvent.getUnitExperience());
	}

	if (NO_PROMOTION != kEvent.getUnitPromotion())
	{

//FfH: Modified by Kael 02/02/2009 (if we spawn a new unit the promotion goes to the spawned unit, not to the eventtrigger target)
//		setHasPromotion((PromotionTypes)kEvent.getUnitPromotion(), true);
		if (kEvent.getUnitClass() == NO_UNITCLASS || kEvent.getNumUnits() == 0)
		{
			setHasPromotion((PromotionTypes)kEvent.getUnitPromotion(), true);
		}
//FfH: End Modify

	}

	if (kEvent.getUnitImmobileTurns() > 0)
	{
		changeImmobileTimer(kEvent.getUnitImmobileTurns());
/*************************************************************************************************/
/**	Xienwolf Tweak							09/02/08											**/
/**																								**/
/**									Prevents AI Group Lock-ups									**/
/*************************************************************************************************/
		joinGroup(NULL, true, true);
/*************************************************************************************************/
/**	Tweak									END													**/
/*************************************************************************************************/
		CvWString szText = gDLL->getText("TXT_KEY_EVENT_UNIT_IMMOBILE", getNameKey(), kEvent.getUnitImmobileTurns());
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szText, "AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX_INLINE(), getY_INLINE(), true, true);
	}

	CvWString szNameKey(kEvent.getUnitNameKey());

	if (!szNameKey.empty())
	{
		setName(gDLL->getText(kEvent.getUnitNameKey()));
	}

	if (kEvent.isDisbandUnit())
	{
/*************************************************************************************************/
/**	Bugfix								21/01/12									Snarko		**/
/**		(Foxford) event can kill the unit in setXY. Units MUST NOT die in that function.		**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		kill(false);
/**								----  End Original Code  ----									**/
		startDelayedDeath();
/*************************************************************************************************/
/**	Bugfix									END													**/
/*************************************************************************************************/
	}
}

const CvArtInfoUnit* CvUnit::getArtInfo(int i, EraTypes eEra) const
{

//FfH: Added by Kael 10/26/2007
	CvString cDefault = CvString::format("").GetCString();
	if (i < m_pUnitInfo->getGroupDefinitions())
	{
		if (i == 0 && getReplaceArtDefineTag() != cDefault)
		{
			return ARTFILEMGR.getUnitArtInfo(getReplaceArtDefineTag());
		}

		if (getUnitArtStyleType() != NO_UNIT_ARTSTYLE)
		{
			return m_pUnitInfo->getArtInfo(i, eEra, (UnitArtStyleTypes)getUnitArtStyleType(),getGraphicalAddOnPromotion());
		}
		//FfH: End Add

		return m_pUnitInfo->getArtInfo(i, eEra, (UnitArtStyleTypes)GC.getCivilizationInfo(getCivilizationType()).getUnitArtStyleType(), getGraphicalAddOnPromotion());
	}
	else if (i==m_pUnitInfo->getGroupDefinitions())
	{
		
		return ARTFILEMGR.getUnitArtInfo(getExtraArtDefineTag());
	}
	else if (i == m_pUnitInfo->getGroupDefinitions()+1)
	{

		return ARTFILEMGR.getUnitArtInfo(getExtraArtDefineTag2());
	}
	else if (i == m_pUnitInfo->getGroupDefinitions()+2)
	{

		return ARTFILEMGR.getUnitArtInfo(getExtraArtDefineTag3());
	}
}

const TCHAR* CvUnit::getButton() const
{
	const CvArtInfoUnit* pArtInfo = getArtInfo(0, GET_PLAYER(getOwnerINLINE()).getCurrentEra());

	if (NULL != pArtInfo)
	{
		return pArtInfo->getButton();
	}

	return m_pUnitInfo->getButton();
}

//FfH: Modified by Kael 06/17/2009
//int CvUnit::getGroupSize() const
//{
//	return m_pUnitInfo->getGroupSize();
//}
int CvUnit::getGroupSize() const
{
	if (GC.getGameINLINE().isOption(GAMEOPTION_ADVENTURE_MODE))
	{
		return 1;
	}
	return m_iGroupSize + getExtraGroupSize();
}
//FfH: End Modify

int CvUnit::getGroupDefinitions() const
{
	return m_pUnitInfo->getGroupDefinitions() + getExtraGroupSize();
}

int CvUnit::getUnitGroupRequired(int i) const
{
	if (i < m_pUnitInfo->getGroupDefinitions())
	{
		return m_pUnitInfo->getUnitGroupRequired(i);
	}
	else
	{
		return m_pUnitInfo->getUnitGroupRequired(0) + 1;
	}
}

bool CvUnit::isRenderAlways() const
{
	return m_pUnitInfo->isRenderAlways();
}

float CvUnit::getAnimationMaxSpeed() const
{
	return m_pUnitInfo->getUnitMaxSpeed();
}

float CvUnit::getAnimationPadTime() const
{
	return m_pUnitInfo->getUnitPadTime();
}

const char* CvUnit::getFormationType() const
{
	return m_pUnitInfo->getFormationType();
}

bool CvUnit::isMechUnit() const
{
	return m_pUnitInfo->isMechUnit();
}

bool CvUnit::isRenderBelowWater() const
{
	return m_pUnitInfo->isRenderBelowWater();
}

int CvUnit::getRenderPriority(UnitSubEntityTypes eUnitSubEntity, int iMeshGroupType, int UNIT_MAX_SUB_TYPES) const
{
	if (eUnitSubEntity == UNIT_SUB_ENTITY_SIEGE_TOWER)
	{
		return (getOwner() * (GC.getNumUnitInfos() + 2) * UNIT_MAX_SUB_TYPES) + iMeshGroupType;
	}
	else
	{
		return (getOwner() * (GC.getNumUnitInfos() + 2) * UNIT_MAX_SUB_TYPES) + m_eUnitType * UNIT_MAX_SUB_TYPES + iMeshGroupType;
	}
}

// Checks for isNeverHostile, isHiddenNationality, isAttackNoWar, and conditionally if not on something acting as a city
bool CvUnit::isAlwaysHostile(const CvPlot* pPlot) const
{
	// PeaceAndFlowers - Xienwolf - 03/27/09 - Makes all Combat Actions impossible for this type of Unit
	if (isNeverHostile())
		return false;

	//FfH: Added by Kael 09/15/2007
	if (isHiddenNationality())
		return true;

	// Hostility - Xienwolf - 05/15/08 - add isAttackNoWar functionality
	if (!(m_pUnitInfo->isAlwaysHostile() || isAttackNoWar()))
		return false;

	if (pPlot != NULL && pPlot->isCity(true, getTeam()))
		return false;

	return true;
}

bool CvUnit::verifyStackValid()
{
	if (!alwaysInvisible())
	{
		if (plot()->isVisibleEnemyUnit(this))
		{
			return jumpToNearestValidPlot();
		}
	}

	return true;
}


// Private Functions...

//check if quick combat
bool CvUnit::isCombatVisible(const CvUnit* pDefender) const
{
	bool bVisible = false;

	if (!m_pUnitInfo->isQuickCombat())
	{
		if (NULL == pDefender || !pDefender->getUnitInfo().isQuickCombat())
		{
			if (isHuman())
			{
				if (!GET_PLAYER(getOwnerINLINE()).isOption(PLAYEROPTION_QUICK_ATTACK))
				{
					bVisible = true;
				}
			}
			else if (NULL != pDefender && pDefender->isHuman())
			{
				if (!GET_PLAYER(pDefender->getOwnerINLINE()).isOption(PLAYEROPTION_QUICK_DEFENSE))
				{
					bVisible = true;
				}
			}
		}
	}

	return bVisible;
}
/*************************************************************************************************/
/**	Xienwolf Notes							NOTES												**/
/**																								**/
/**Yipee!  I should be able to fix up one of the remaining issues with the Barbarians with this!**/
/*************************************************************************************************/
// used by the executable for the red glow and plot indicators
bool CvUnit::shouldShowEnemyGlow(TeamTypes eForTeam) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		return false;
	}

	if (!canFight())
	{
		return false;
	}

	CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return false;
	}

	TeamTypes ePlotTeam = pPlot->getTeam();
	if (ePlotTeam != eForTeam)
	{
		return false;
	}

	if (!isEnemy(ePlotTeam))
	{
		return false;
	}

	return true;
}

bool CvUnit::shouldShowFoundBorders() const
{
	return isFound();
}


void CvUnit::cheat(bool bCtrl, bool bAlt, bool bShift)
{
	if (gDLL->getChtLvl() > 0)
	{
		if (bCtrl)
		{
			setPromotionReady(true);
		}
	}
}

float CvUnit::getHealthBarModifier() const
{
	return (GC.getDefineFLOAT("HEALTH_BAR_WIDTH") / (GC.getGameINLINE().getBestLandUnitCombat() * 2));
}

void CvUnit::getLayerAnimationPaths(std::vector<AnimationPathTypes>& aAnimationPaths) const
{
	for (int i=0; i < GC.getNumPromotionInfos(); ++i)
	{
		PromotionTypes ePromotion = (PromotionTypes) i;
		if (isHasPromotion(ePromotion))
		{
			AnimationPathTypes eAnimationPath = (AnimationPathTypes) GC.getPromotionInfo(ePromotion).getLayerAnimationPath();
			if(eAnimationPath != ANIMATIONPATH_NONE)
			{
				aAnimationPaths.push_back(eAnimationPath);
			}
		}
	}
}

int CvUnit::getSelectionSoundScript() const
{
	int iScriptId = getArtInfo(0, GET_PLAYER(getOwnerINLINE()).getCurrentEra())->getSelectionSoundScriptId();
	if (iScriptId == -1)
	{
		iScriptId = GC.getCivilizationInfo(getCivilizationType()).getSelectionSoundScriptId();
	}
	return iScriptId;
}
/*************************************************************************************************/
/**	FoodFromAnimals						01/04/08		Written: DomPedroII	Imported: Xienwolf	**/
/**																								**/
/**	Determines available Yields & Commerces from Defeated Units and selects which to receive	**/
/*************************************************************************************************/
void CvUnit::salvage(CvUnit* pDeadUnit)
{
	CvWString szBuffer;
	bool bValid;
	int iI;
	int iCount = 0;
	int iRoll;
	int iYield;
	int iCommerce;
	int iCommerceVariable;
	int iTotalCommerce;
	CvCity* pNearestCity;

	pNearestCity = GC.getMapINLINE().findCity(getX_INLINE(), getY_INLINE(), getOwnerINLINE(), NO_TEAM, true, false);
	if (pNearestCity != NULL)
	{
		for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			if ((pDeadUnit->getYieldForLoss(iI) + GET_PLAYER(getOwnerINLINE()).getBaseYieldFromUnit((YieldTypes)iI) + getYieldFromWin(iI)) != 0)
			{
				iYield = (pDeadUnit->getYieldForLoss(iI) + GET_PLAYER(getOwnerINLINE()).getBaseYieldFromUnit((YieldTypes)iI) + getYieldFromWin(iI));
				iYield *= std::max(0,(GET_PLAYER(getOwnerINLINE()).getYieldFromUnitModifier((YieldTypes)iI) + 100));
				iYield /= 100;

				switch ((YieldTypes)iI)
				{
				case YIELD_FOOD:
					pNearestCity->changeFood(iYield);
					break;

				case YIELD_PRODUCTION:
					pNearestCity->changeProduction(iYield);
					break;
				}
					szBuffer = gDLL->getText("TXT_KEY_MISC_YIELD_FROM_UNIT", getNameKey(), iYield, GC.getYieldInfo((YieldTypes)iI).getChar(), pNearestCity->getNameKey());
					gDLL->getInterfaceIFace()->addMessage(pNearestCity->getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer,  ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_CITY_EDIT")->getPath(), MESSAGE_TYPE_INFO, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pDeadUnit->getX_INLINE(), pDeadUnit->getY_INLINE(), true, true);
			}
		}
	}

	CommerceTypes eCommerce;
	std::vector<TechTypes> aeAvailableTechs;
	std::vector<CommerceTypes> aeValidCommerces;
	TechTypes eTempTech;
	TechTypes eRewardTech;

	for (iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
	{
		int iJ;
		eCommerce = ((CommerceTypes)iI);
		bValid = true;
		if ((pDeadUnit->getCommerceForLoss(iI) + GET_PLAYER(getOwnerINLINE()).getBaseCommerceFromUnit(eCommerce) + getCommerceFromWin(eCommerce)) > 0)
		{
			if (eCommerce == COMMERCE_RESEARCH)
			{
				eTempTech = ((TechTypes)GC.getUnitInfo(pDeadUnit->getUnitType()).getPrereqAndTech());

				if (eTempTech != NO_TECH)
				{
//                    if (GET_PLAYER(getOwnerINLINE()).canResearch(eTempTech, true) && GET_TEAM(GET_PLAYER(pDeadUnit->getOwnerINLINE()).getTeam()).isHasTech(eTempTech))
					if (!GET_TEAM(GET_PLAYER(getOwnerINLINE()).getTeam()).isHasTech(eTempTech))
					{
						if (!GC.getTechInfo(eTempTech).isDisable())
						{
							aeAvailableTechs.push_back(eTempTech);
						}
					}
				}

				for (iJ = 0; iJ < GC.getNUM_UNIT_AND_TECH_PREREQS(); iJ++)
				{
					eTempTech = ((TechTypes)GC.getUnitInfo(pDeadUnit->getUnitType()).getPrereqAndTechs(iJ));
					if (eTempTech != NO_TECH)
					{
//                        if (GET_PLAYER(getOwnerINLINE()).canResearch(eTempTech, true) && GET_TEAM(GET_PLAYER(pDeadUnit->getOwnerINLINE()).getTeam()).isHasTech(eTempTech))
						if (!GET_TEAM(GET_PLAYER(getOwnerINLINE()).getTeam()).isHasTech(eTempTech))
						{
							if (!GC.getTechInfo(eTempTech).isDisable())
							{
								aeAvailableTechs.push_back(eTempTech);
							}
						}
					}
				}

				for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
				{
					if (pDeadUnit->isHasPromotion((PromotionTypes)iJ))
					{
						eTempTech = ((TechTypes)GC.getPromotionInfo((PromotionTypes)iJ).getTechPrereq());
						if (eTempTech != NO_TECH)
						{
							if (!GET_TEAM(GET_PLAYER(getOwnerINLINE()).getTeam()).isHasTech(eTempTech))
							{
								if (!GC.getTechInfo(eTempTech).isDisable())
								{
									aeAvailableTechs.push_back(eTempTech);
								}
							}
						}
					}
				}

				bValid = (aeAvailableTechs.size() > 0);
			}

			if (eCommerce == COMMERCE_ESPIONAGE && pDeadUnit->isBarbarian())
			{
				bValid = false;
			}

			if (bValid)
			{
				aeValidCommerces.push_back(eCommerce);
			}
		}
	}

	if (aeValidCommerces.size() > 0)
	{
		iRoll = (CommerceTypes)GC.getGameINLINE().getSorenRandNum(aeValidCommerces.size(), "Pillage");

		eCommerce = aeValidCommerces[iRoll];

		iCommerce = pDeadUnit->getCommerceForLoss(eCommerce) + GET_PLAYER(getOwnerINLINE()).getBaseCommerceFromUnit(eCommerce) + getCommerceFromWin(eCommerce);

		iCommerce *= std::max(0, (GET_PLAYER(getOwnerINLINE()).getCommerceFromUnitModifier(eCommerce) + 100));
		iCommerce /= 100;

		iCommerceVariable = (GC.getGameINLINE().getSorenRandNum(iCommerce, "Commerce Variable") * GC.getDefineINT("PILLAGE_COMM_VARIABLE_PERCENT"));
		iCommerceVariable /= 100;

		iTotalCommerce = iCommerce + iCommerceVariable;

		if (iTotalCommerce > 0)
		{
			int iRollTech;
			switch(eCommerce)
			{
			case COMMERCE_GOLD:
				GET_PLAYER(getOwnerINLINE()).changeGold(iTotalCommerce);
				szBuffer = gDLL->getText("TXT_KEY_MISC_GOLD_FROM_UNIT", iTotalCommerce, GC.getCommerceInfo(eCommerce).getChar(), GET_PLAYER(pDeadUnit->getVisualOwner()).getCivilizationAdjectiveKey(), pDeadUnit->getNameKey());
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX_INLINE(), getY_INLINE());
//                gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_POSITIVE_TEXT"), getX_INLINE(), getY_INLINE());
				break;
			case COMMERCE_CULTURE:
				if (pNearestCity != NULL)
				{
					pNearestCity->changeCulture(getOwnerINLINE(), iTotalCommerce, true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_CULTURE_FROM_UNIT", iTotalCommerce, GC.getCommerceInfo(eCommerce).getChar(), GET_PLAYER(pDeadUnit->getVisualOwner()).getCivilizationAdjectiveKey(), pDeadUnit->getNameKey(), pNearestCity->getNameKey());
					gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX_INLINE(), getY_INLINE());
				}
				break;
			case COMMERCE_RESEARCH:
				iRollTech = GC.getGameINLINE().getSorenRandNum(aeAvailableTechs.size(), "Choose Tech");
				eRewardTech = aeAvailableTechs[iRollTech];

				if (eRewardTech != NO_TECH)
				{
					if (GET_PLAYER(getOwnerINLINE()).getCurrentResearch() == eRewardTech)
					{
						iTotalCommerce *= GC.getDefineINT("CURRENT_RESEARCH_CONQUEST_TECH_PERCENT");
						iTotalCommerce /= 100;
					}

					GET_TEAM(getTeam()).changeResearchProgress(eRewardTech, iTotalCommerce, getOwnerINLINE());
					szBuffer = gDLL->getText("TXT_KEY_MISC_ACQUIRE_RESEARCH_FROM_UNIT", iTotalCommerce, GC.getCommerceInfo(eCommerce).getChar(), GET_PLAYER(pDeadUnit->getVisualOwner()).getCivilizationAdjectiveKey(), pDeadUnit->getNameKey(), GC.getTechInfo(eRewardTech).getTextKeyWide());
					gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX_INLINE(), getY_INLINE());
				}
				break;
			case COMMERCE_ESPIONAGE:
				if (!pDeadUnit->isBarbarian())
				{
					GET_TEAM(getTeam()).changeEspionagePointsAgainstTeam(GET_PLAYER(pDeadUnit->getOwnerINLINE()).getTeam(), iTotalCommerce);
					szBuffer = gDLL->getText("TXT_KEY_MISC_GATHERED_INTELLIGENCE_FROM_UNIT", iTotalCommerce, GC.getCommerceInfo(eCommerce).getChar(), GET_PLAYER(pDeadUnit->getVisualOwner()).getCivilizationAdjectiveKey(), pDeadUnit->getNameKey(), GET_PLAYER(pDeadUnit->getOwnerINLINE()).getNameKey());
					gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX_INLINE(), getY_INLINE());
				}
				break;
			}
		}
	}
}
/*************************************************************************************************/
/**	FoodFromAnimals							END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	People's Choice							07/23/08								Xienwolf	**/
/**	New Tag Defs	(CityBonuses)			05/15/08											**/
/**							Clears or Applies Modifiers to Cities in Range						**/
/*************************************************************************************************/
void CvUnit::applyCityBonus(CityBonuses cbTemp, CvCity* pCheckCity, int iChange, int iDistance)
{
	if (cbTemp.fDiplo != 0)
	{
		if (!isBarbarian())
		{
			pCheckCity->changeProximityDiplo(getOwner(), iChange * (cbTemp.fDiplo + iDistance*cbTemp.fDecayRate));
		}
		else
		{
			for (int iK = 0; iK < MAX_CIV_PLAYERS; iK++)
			{
				if (GET_PLAYER((PlayerTypes)iK).isAlive() && !((PlayerTypes)iK == pCheckCity->getOwner()))
				{
					pCheckCity->changeProximityDiplo((PlayerTypes)iK, iChange * (cbTemp.fDiplo + iDistance*cbTemp.fDecayRate));
				}
			}
		}
	}
	if (cbTemp.fCulture != 0) pCheckCity->changeProximityCulture(getOwner(), iChange * (cbTemp.fCulture + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fCrime != 0) pCheckCity->changeProximityCrime(iChange * (cbTemp.fCrime + iDistance * cbTemp.fDecayRate));
	if (cbTemp.fDefense != 0) pCheckCity->changeProximityDefense(iChange * (cbTemp.fDefense + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fFood != 0) pCheckCity->changeProximityFood(iChange * (cbTemp.fFood + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fFreeXP != 0) pCheckCity->changeProximityFreeXP(iChange * (cbTemp.fFreeXP + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fGold != 0) pCheckCity->changeProximityGold(iChange * (cbTemp.fGold + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fGPP != 0) pCheckCity->changeProximityGPP(iChange * (cbTemp.fGPP + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fHappy != 0) pCheckCity->changeProximityHappy(iChange * (cbTemp.fHappy + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fHealth != 0) pCheckCity->changeProximityHealth(iChange * (cbTemp.fHealth + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fProduction != 0) pCheckCity->changeProximityProduction(iChange * (cbTemp.fProduction + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fTradeRoutes != 0) pCheckCity->changeProximityTradeRoutes(iChange * (cbTemp.fTradeRoutes + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fRitualAssist != 0) pCheckCity->changeProximityRitualAssist(iChange * (cbTemp.fRitualAssist + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fInfectCulture != 0) pCheckCity->changeProximityInfectCulture(iChange * (cbTemp.fInfectCulture + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fPotency != 0) pCheckCity->changeProximityPotency(iChange * (cbTemp.fPotency + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fShielding != 0) pCheckCity->changeProximityShielding(iChange * (cbTemp.fShielding + iDistance*cbTemp.fDecayRate));
	if (cbTemp.fTrainXPCap != 0) pCheckCity->changeProximityTrainXPCap(iChange * 100 * (cbTemp.fTrainXPCap + iDistance*cbTemp.fDecayRate), m_pUnitInfo->getUnitCombatType());
	if (cbTemp.fTrainXPRate != 0) pCheckCity->changeProximityTrainXPRate(iChange * (cbTemp.fTrainXPRate + iDistance*cbTemp.fDecayRate), m_pUnitInfo->getUnitCombatType());
}
void CvUnit::applyCityBonusEffects(bool bActivate, bool bAlterFullMap)
{
	PROFILE("CvUnit::applyCityBonusEffects");

	int iX, iY, iChange, iDistance, iLoop;
	bool bApplyBonus = false;

	iChange = (bActivate ? 1: -1);

	for (int iI = 0; iI < getNumCityBonuses(); iI++)
	{
		CityBonuses cbTemp = getCityBonus(iI);
		if (cbTemp.bFullMap)
		{
			if (bAlterFullMap)
			{
				for (int iK = 0; iK < MAX_CIV_PLAYERS; iK++)
				{
					if (GET_PLAYER((PlayerTypes)iK).isAlive())
					{
						bApplyBonus = false;
						if ((PlayerTypes)iK == getOwner() && cbTemp.bApplySelf)
						{
							bApplyBonus = true;
						}
						else if  (GET_PLAYER((PlayerTypes)iK).getTeam() == getTeam() && !((PlayerTypes)iK == getOwner()) && cbTemp.bApplyTeam)
						{
							bApplyBonus = true;
						}
						else if (GET_TEAM(GET_PLAYER((PlayerTypes)iK).getTeam()).isAtWar(getTeam()) && cbTemp.bApplyEnemy)
						{
							bApplyBonus = true;
						}
						else if (!(GET_TEAM(GET_PLAYER((PlayerTypes)iK).getTeam()).isAtWar(getTeam())) && !(GET_PLAYER((PlayerTypes)iK).getTeam() == getTeam()) && cbTemp.bApplyRival)
						{
							bApplyBonus = true;
						}
						if (bApplyBonus)
						{
							for (CvCity* pCheckCity = GET_PLAYER((PlayerTypes)iK).firstCity(&iLoop); pCheckCity != NULL; pCheckCity = GET_PLAYER((PlayerTypes)iK).nextCity(&iLoop))
							{
								iDistance = plotDistance(getX(), getY(), pCheckCity->getX(), pCheckCity->getY());
								applyCityBonus(cbTemp, pCheckCity, iChange, iDistance);
							}
						}
					}
				}
			}
		}
		else
		{
			for (int jX = -cbTemp.iBonusRange; jX < cbTemp.iBonusRange+1; jX++)
			{
				iX = jX + getX();
				if (iX >= GC.getMapINLINE().getGridWidthINLINE())
				{
					if (GC.getMapINLINE().isWrapXINLINE())
					{
						iX = iX - GC.getMapINLINE().getGridWidthINLINE();
					}
					else
					{
						iX = GC.getMapINLINE().getGridWidthINLINE();
					}
				}
				else if (iX < 0)
				{
					if (GC.getMapINLINE().isWrapXINLINE())
					{
						iX = GC.getMapINLINE().getGridWidthINLINE() + iX;
					}
					else
					{
						iX = 0;
					}
				}
				for (int jY = -cbTemp.iBonusRange; jY < cbTemp.iBonusRange+1; jY++)
				{
					iY = jY + getY();
					if (iY >= GC.getMapINLINE().getGridHeightINLINE())
					{
						if (GC.getMapINLINE().isWrapYINLINE())
						{
							iY = iY - GC.getMapINLINE().getGridHeightINLINE();
						}
					}
					else if (iY < 0)
					{
						if (GC.getMapINLINE().isWrapYINLINE())
						{
							iY = GC.getMapINLINE().getGridHeightINLINE() + iY;
						}
					}
					CvPlot* pPlot = GC.getMapINLINE().plotINLINE(iX, iY);
					if (pPlot != NULL)
					{
						CvCity* pCheckCity = pPlot->getPlotCity();
						if (pCheckCity != NULL)
						{
							bApplyBonus = false;
							iDistance = plotDistance(getX(), getY(), iX, iY);
							if (pCheckCity->getOwner() == getOwner() && cbTemp.bApplySelf)
							{
								bApplyBonus = true;
							}
							else if  (pCheckCity->getTeam() == getTeam() && !(pCheckCity->getOwner() == getOwner()) && cbTemp.bApplyTeam)
							{
								bApplyBonus = true;
							}
							else if (pPlot->isEnemyCity(*this) && cbTemp.bApplyEnemy)
							{
								bApplyBonus = true;
							}
							else if (!(pPlot->isEnemyCity(*this)) && !(pCheckCity->getTeam() == getTeam()) && cbTemp.bApplyRival)
							{
								bApplyBonus = true;
							}
							if (bApplyBonus)
							{
								applyCityBonus(cbTemp, pCheckCity, iChange, iDistance);
							}
						}
					}
				}
			}
		}
	}
}
/*************************************************************************************************/
/**	People's Choice							END													**/
/*************************************************************************************************/

/************************************************************************************************/
/* Influence Driven War                   06/06/10                                 Valkrionn    */
/*                                                                                              */
/* Original Author Moctezuma              End                                                   */
/************************************************************************************************/
bool CvUnit::canInfluenceWar()
{
	bool bCanInfluence = true;

	if (isNonInfluence())
	{
		bCanInfluence = false;
	}

/*************************************************************************************************/
/**	Tweak							20/10/12								Snarko				**/
/**																								**/
/**			Barbarian having influence on culture slows down the game and screw the AI			**/
/*************************************************************************************************/
	if (isBarbarian())
	{
		bCanInfluence = false;
	}
/*************************************************************************************************/
/**	Tweak								END														**/
/*************************************************************************************************/

	if (getDuration() > 0)
	{
		bCanInfluence = false;
	}
	if (isHiddenNationality())
	{
		bCanInfluence = false;
	}
	if (isAnimal())
	{
		bCanInfluence = false;
	}
	if (isInfluence())
	{
		bCanInfluence = true;
	}

	return bCanInfluence;
}

bool CvUnit::canDeathInfluenceWar()
{
	bool bCanInfluence = true;

	if (isNonInfluence())
	{
		bCanInfluence = false;
	}

/*************************************************************************************************/
/**	Tweak							20/10/12								Snarko				**/
/**																								**/
/**			Barbarian having influence on culture slows down the game and screw the AI			**/
/*************************************************************************************************/
	if (isBarbarian())
	{
		bCanInfluence = false;
	}
/*************************************************************************************************/
/**	Tweak								END														**/
/*************************************************************************************************/

	if (getDuration() > 0)
	{
		bCanInfluence = false;
	}
	if (isHiddenNationality())
	{
		bCanInfluence = false;
	}
	if (isAnimal())
	{
		bCanInfluence = false;
	}
	if (isInfluence())
	{
		bCanInfluence = true;
	}

	return bCanInfluence;
}

float CvUnit::doVictoryInfluence(CvUnit* pLoserUnit, CvUnit* pWinnerUnit, bool bAttacking, bool bWithdrawal)
{
	CvPlot* pWinnerPlot = plot();
	CvPlot* pLoserPlot = pLoserUnit->plot();
	CvPlot* pDefenderPlot = NULL;
	if (!bAttacking)
	{
		pDefenderPlot = pWinnerPlot;
	}
	else
	{
		pDefenderPlot = pLoserPlot;
	}
	int iWinnerCultureBefore = pDefenderPlot->getCulture(getOwnerINLINE()); //used later for influence %

	float fVictoryInfluenceModifier = 1.0f; // Modifier from the Victor, comes from unit and player
	if (GET_PLAYER(pWinnerUnit->getOwner()).getVictoryInfluenceModifier() != 100)
		fVictoryInfluenceModifier += ((((float)GET_PLAYER(pWinnerUnit->getOwner()).getVictoryInfluenceModifier()) / 100.0f) - 1.0f);
	if (pWinnerUnit->getVictoryInfluenceModifier() != 100)
		fVictoryInfluenceModifier += ((((float)pWinnerUnit->getVictoryInfluenceModifier()) / 100.0f) - 1.0f);

	float fDefeatInfluenceModifier = 1.0f; // Modifier from the Loser, comes from unit and player
	if (GET_PLAYER(pLoserUnit->getOwner()).getDefeatInfluenceModifier() != 100)
		fDefeatInfluenceModifier += ((((float)GET_PLAYER(pLoserUnit->getOwner()).getDefeatInfluenceModifier()) / 100.0f) - 1.0f);
	if (pLoserUnit->getDefeatInfluenceModifier() != 100)
		fDefeatInfluenceModifier += ((((float)pLoserUnit->getDefeatInfluenceModifier()) / 100.0f) - 1.0f);

	float fWinnerPlotMultiplier = 1.0f; // by default: same influence in WinnerPlot and LoserPlot
	if (GC.getDefineFLOAT("IDW_WINNER_PLOT_MULTIPLIER"))
		fWinnerPlotMultiplier = GC.getDefineFLOAT("IDW_WINNER_PLOT_MULTIPLIER");

	float fLoserPlotMultiplier = 1.0f; // by default: same influence in WinnerPlot and LoserPlot
	if (GC.getDefineFLOAT("IDW_LOSER_PLOT_MULTIPLIER"))
		fLoserPlotMultiplier = GC.getDefineFLOAT("IDW_LOSER_PLOT_MULTIPLIER");

	float bWithdrawalMultiplier = 0.5f;
	if (bWithdrawal)
	{
		fWinnerPlotMultiplier *= bWithdrawalMultiplier;
		fLoserPlotMultiplier *= bWithdrawalMultiplier;
	}

	if (pLoserPlot->isEnemyCity(*this)) // city combat
	{
		if (pLoserPlot->getNumVisibleEnemyDefenders(this) > 1)
		{
			// if there are still some city defenders ->
			// we use same influence rules as for field combat
			influencePlots(pLoserPlot, pLoserUnit->getOwnerINLINE(), fLoserPlotMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);
			influencePlots(pWinnerPlot, pLoserUnit->getOwnerINLINE(), fWinnerPlotMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);
		}
		else // last defender is dead
		{
			float fNoCityDefenderMultiplier = 2.5; // default: 250%
			if (GC.getDefineFLOAT("IDW_NO_CITY_DEFENDER_MULTIPLIER"))
				fNoCityDefenderMultiplier = GC.getDefineFLOAT("IDW_NO_CITY_DEFENDER_MULTIPLIER");

			// last city defender is dead -> influence is increased
			influencePlots(pLoserPlot, pLoserUnit->getOwnerINLINE(), fLoserPlotMultiplier * fNoCityDefenderMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);
			influencePlots(pWinnerPlot, pLoserUnit->getOwnerINLINE(), fWinnerPlotMultiplier * fNoCityDefenderMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);
		}
	}
	else // field combat
	{
		if (!pLoserUnit->canDefend())
		{
			// no influence from worker capture
			return 0.0f;
		}

		if (pLoserPlot->getImprovementType() != NO_IMPROVEMENT
			&& GC.getImprovementInfo(pLoserPlot->getImprovementType()).isFort())
		{
			// fort captured
			float fFortCaptureMultiplier = 2.0f; // default: 200%
			if (GC.getDefineFLOAT("IDW_FORT_CAPTURE_MULTIPLIER"))
				fFortCaptureMultiplier = GC.getDefineFLOAT("IDW_FORT_CAPTURE_MULTIPLIER");

			// influence is increased
			influencePlots(pLoserPlot, pLoserUnit->getOwnerINLINE(), fLoserPlotMultiplier * fFortCaptureMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);
			influencePlots(pWinnerPlot, pLoserUnit->getOwnerINLINE(), fWinnerPlotMultiplier * fFortCaptureMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);

		}
		else
		{
			influencePlots(pLoserPlot, pLoserUnit->getOwnerINLINE(), fLoserPlotMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);
			influencePlots(pWinnerPlot, pLoserUnit->getOwnerINLINE(), fWinnerPlotMultiplier, fVictoryInfluenceModifier, fDefeatInfluenceModifier);
		}
	}

	// calculate influence % in defended plot (to be displayed in game log)

	int iWinnerCultureAfter = pDefenderPlot->getCulture(getOwnerINLINE());
	int iTotalCulture = pDefenderPlot->countTotalCulture();
	float fInfluenceRatio = 0.0f;
	if (iTotalCulture > 0)
	{
		fInfluenceRatio = ((iWinnerCultureAfter-iWinnerCultureBefore)*100.0f)/iTotalCulture;
	}
	return fInfluenceRatio;
}

void CvUnit::influencePlots(CvPlot* pCentralPlot, PlayerTypes eTargetPlayer, float fLocationMultiplier, float fVictorInfluenceModifier, float fLoserInfluenceModifier)
{
	float fBaseCombatInfluence = 4.0f;
	if (GC.getDefineFLOAT("IDW_BASE_COMBAT_INFLUENCE"))
		fBaseCombatInfluence = GC.getDefineFLOAT("IDW_BASE_COMBAT_INFLUENCE");

	// calculate base multiplier used for all plots
	float fGameSpeedMultiplier = (float) GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getConstructPercent();
	fGameSpeedMultiplier /= 100;
	fGameSpeedMultiplier *= GC.getEraInfo(GC.getGameINLINE().getStartEra()).getConstructPercent();
	fGameSpeedMultiplier /= 100;
	fGameSpeedMultiplier = sqrt(fGameSpeedMultiplier);

	float fExperienceFactor = 0.01f;  // default: each point of experience increases influence by 1%
	if (GC.getDefineFLOAT("IDW_EXPERIENCE_FACTOR"))
		fExperienceFactor = GC.getDefineFLOAT("IDW_EXPERIENCE_FACTOR");
	float fExperienceMultiplier = 1.0f + (getExperience() * 0.005f);

	float fBaseMultiplier = fBaseCombatInfluence * fGameSpeedMultiplier * fLocationMultiplier * fExperienceMultiplier * fVictorInfluenceModifier * fLoserInfluenceModifier;
	if (fBaseMultiplier <= 0.0f)
		return;

	// get influence radius
	int iInfluenceRadius = 2; // default: like 2square city workable radius
	if (GC.getDefineINT("IDW_INFLUENCE_RADIUS"))
		iInfluenceRadius = GC.getDefineINT("IDW_INFLUENCE_RADIUS");
	if (iInfluenceRadius < 0)
		return;

	float fPlotDistanceFactor = 0.2f; // default: influence decreases by 20% with plot distance
	if (GC.getDefineFLOAT("IDW_PLOT_DISTANCE_FACTOR"))
		fPlotDistanceFactor = GC.getDefineFLOAT("IDW_PLOT_DISTANCE_FACTOR");

	for (int iDX = -iInfluenceRadius; iDX <= iInfluenceRadius; iDX++)
	{
		for (int iDY = -iInfluenceRadius; iDY <= iInfluenceRadius; iDY++)
		{
			int iDistance = plotDistance(0, 0, iDX, iDY);

			if (iDistance <= iInfluenceRadius)
			{
				CvPlot* pLoopPlot = plotXY(pCentralPlot->getX_INLINE(), pCentralPlot->getY_INLINE(), iDX, iDY);

				if (pLoopPlot != NULL)
				{
					for (int i=0;i<MAX_CIV_PLAYERS;i++)
					{
						//Check only for Players not in our team
						if(GET_PLAYER((PlayerTypes)i).getTeam()!=getTeam())
						{
							// calculate distance multiplier for current plot
							float fDistanceMultiplier = 0.5f+0.5f*fPlotDistanceFactor-fPlotDistanceFactor*iDistance;
							if (fDistanceMultiplier <= 0.0f)
								continue;
							int iTargetCulture = pLoopPlot->getCulture((PlayerTypes)i);
							if (iTargetCulture <= 0)
								continue;
							if (iTargetCulture>pLoopPlot->getCulture(eTargetPlayer))
								continue;
							int iCultureTransfer = int (fBaseMultiplier * fDistanceMultiplier * sqrt((float) iTargetCulture));
							if (iTargetCulture < iCultureTransfer)
							{
								// cannot transfer more culture than remaining target culure
								iCultureTransfer = iTargetCulture;
							}
							if (iCultureTransfer == 0 && iTargetCulture > 0)
							{
								// always at least 1 point of culture must be transfered
								// othervise we may have the problems with capturing of very low culture cities.
								iCultureTransfer = 1;
							}

							if (iCultureTransfer > 0)
							{
								// target player's culture in plot is lowered
								pLoopPlot->changeCulture((PlayerTypes)i, -iCultureTransfer, false);
								// owners's culture in plot is raised
								pLoopPlot->changeCulture(getOwnerINLINE(), iCultureTransfer, true);
							}
						}
					}
				}
			}
		}
	}
}

float CvUnit::doPillageInfluence()
{
	// only units which can influence war in battle can do so by pillaging
	if (!canInfluenceWar())
	{
		return 0.0f;
	}

	CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		//should not happen
		return 0.0f;
	}

	int iOurCultureBefore = pPlot->getCulture(getOwnerINLINE()); //used later for influence %

	float fPillageInfluenceModifier = 1.0f; // Comes from unit and player
	if (GET_PLAYER(getOwner()).getPillageInfluenceModifier() != 100)
		fPillageInfluenceModifier += ((((float)GET_PLAYER(getOwner()).getPillageInfluenceModifier()) / 100.0f) - 1.0f);
	if (getPillageInfluenceModifier() != 100)
		fPillageInfluenceModifier += ((((float)getPillageInfluenceModifier()) / 100.0f) - 1.0f);

	float fBasePillageInfluence = 2.0f;
	if (GC.getDefineFLOAT("IDW_BASE_PILLAGE_INFLUENCE"))
		fBasePillageInfluence = GC.getDefineFLOAT("IDW_BASE_PILLAGE_INFLUENCE");

	float fGameSpeedMultiplier = (float) GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getConstructPercent();
	fGameSpeedMultiplier /= 100;
	fGameSpeedMultiplier *= GC.getEraInfo(GC.getGameINLINE().getStartEra()).getConstructPercent();
	fGameSpeedMultiplier /= 100;
	fGameSpeedMultiplier = sqrt(fGameSpeedMultiplier);

	PlayerTypes eTargetPlayer = pPlot->getOwner();
	int iTargetCulture = pPlot->getCulture(eTargetPlayer);
	if (iTargetCulture <= 0)
	{
		//should not happen
		return 0.0f;
	}
	int iCultureTransfer = int (fBasePillageInfluence * fGameSpeedMultiplier * fPillageInfluenceModifier * sqrt((float) iTargetCulture));
	if (iTargetCulture < iCultureTransfer)
	{
		// cannot transfer more culture than remaining target culure
		iCultureTransfer = iTargetCulture;
	}

	// target player's culture in plot is lowered
	pPlot->changeCulture(eTargetPlayer, -iCultureTransfer, false);
	// owners's culture in plot is raised
	pPlot->changeCulture(getOwnerINLINE(), iCultureTransfer, true);

	// calculate influence % in pillaged plot (to be displayed in game log)
	int iOurCultureAfter = pPlot->getCulture(getOwnerINLINE());
	float fInfluenceRatio = ((iOurCultureAfter-iOurCultureBefore)*100.0f)/pPlot->countTotalCulture();

//	CvWString szBuffer;
//	szBuffer.Format(L"Factors: %.1f, %.1f, %d, Result: %.3f, ", fGameSpeedMultiplier, fBasePillageInfluence, iTargetCulture, fInfluenceRatio);
//	gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getDefineINT("EVENT_MESSAGE_TIME"), szBuffer, "AS2D_UNIT_BUILD_UNIT", MESSAGE_TYPE_INFO, GC.getUnitInfo(getUnitType()).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_TEXT"), plot()->getX_INLINE(), plot()->getY_INLINE());

	return fInfluenceRatio;
}

/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	AutoCast								24/05/10									Snarko	**/
/**																								**/
/**						Making the human able to set units to autocast spells					**/
/*************************************************************************************************/
void CvUnit::setAutoCast(SpellTypes eSpell, bool bPreTurn)
{
	if (eSpell == NO_SPELL)
	{
		m_eAutoCast = eSpell;
	}
	else
	{
		FAssert(canCast((int)eSpell, true));
		m_eAutoCast = eSpell;
		m_bAutoCastPre = bPreTurn;
	}
}

SpellTypes CvUnit::getAutoCast() const
{
	return m_eAutoCast;
}

bool CvUnit::isAutoCast(bool bPreTurn) const
{
	if (bPreTurn && !m_bAutoCastPre)
	{
		return false;
	}
	else
	{
		return m_eAutoCast != NO_SPELL;
	}
}
/*************************************************************************************************/
/**	Autocast								END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	MISSION_CLAIM_FORT/MISSION_EXPLORE_LAIR	19/06/10									Snarko	**/
/**																								**/
/**						Adding a mission for the claim_fort action...							**/
/**							and one for the explore_lair action									**/
/*************************************************************************************************/
bool CvUnit::canClaimFort(CvPlot* pPlot, bool bTestVisible)
{
	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	// Gold relevant if not barb. Show option even if can't pay gold.
	if (!bTestVisible && !isBarbarian() && GET_PLAYER(getOwnerINLINE()).getGold() < GET_PLAYER(getOwnerINLINE()).getClaimFortCost())
		return false;

	if (NO_IMPROVEMENT == pPlot->getImprovementType() || !GC.getImprovementInfo(pPlot->getImprovementType()).isFort())
		return false;

	if (bTestVisible)
		return true;

	CvUnit* pLoopUnit;
	CLLNode<IDInfo>* pUnitNode;
	pUnitNode = pPlot->headUnitNode();

	while (pUnitNode != NULL)
	{
		pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
		if (pLoopUnit->getUnitClassType() == GC.getDefineINT("FORT_COMMANDER_UNITCLASS"))
			return false;
	}

	if (pPlot->isOwned()
	 && pPlot->getOwner() != getOwnerINLINE()
	 && !GET_TEAM(getTeam()).isAtWar(pPlot->getTeam()))
		return false;

	// Barbs can't claim unowned naval forts.
	else if (isBarbarian() && pPlot->isWater() && !pPlot->isOwned())
		return false;

	// Can't set up commander if adjacent enemy combatants
	if (countUnitsWithinRange(1, true, false, false, true, true) > 0)
		return false;

	return true;
}

bool CvUnit::claimFort(bool bBuilt)
{
	// Relying on fort building rules to avoid e.g. building a fort on a tile that already has one to get 2 commanders/fort
	if (!canClaimFort(plot()) && !bBuilt)
		return false;

	if (!bBuilt && !isBarbarian())
		GET_PLAYER(getOwnerINLINE()).changeGold(-GET_PLAYER(getOwnerINLINE()).getClaimFortCost());

	CvUnit* pUnit;
	int iUnitClass = GC.getDefineINT("FORT_COMMANDER_UNITCLASS");
	UnitTypes eUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iUnitClass)));

	//XXX this really shouldn't be done, fix it in the XML instead. I included it anyway because it was in the spell.
	if (eUnit == NO_UNIT)
		eUnit = (UnitTypes)GC.getUnitClassInfo((UnitClassTypes)iUnitClass).getDefaultUnitIndex();
	pUnit = GET_PLAYER(getOwnerINLINE()).initUnit(eUnit, getX_INLINE(), getY_INLINE(), NO_UNITAI, DIRECTION_SOUTH);
	if (!bBuilt)
		pUnit->finishMoves();

	//if (GC.getCivilizationInfo(getCivilizationType()).getDefaultRace() != NO_PROMOTION)
	//{
	//	if (pUnit->getRace() == NO_PROMOTION)
	//	{
	//		setHasPromotion((PromotionTypes)GC.getCivilizationInfo(getCivilizationType()).getDefaultRace(), true);
	//	}
	//}

	plot()->clearCultureControl(plot()->getOwner(), plot()->getImprovementType(), false);
	plot()->setImprovementOwner(getOwnerINLINE());
	plot()->addCultureControl(getOwnerINLINE(), plot()->getImprovementType(), false);
	// Need a distinct call to update culture; above ones won't update if the improvement doesn't have culture control
	plot()->updateCulture(true, true);

	return true;
}

bool CvUnit::canExploreLair(CvPlot* pPlot, bool bTestVisible)
{
	// Changes may need to be mirrored in CvUnitAI::AI_canExploreLair

	if (pPlot == NULL)
		pPlot = plot();

	if (pPlot->getImprovementType() == NO_IMPROVEMENT
 		|| isBarbarian()
		|| !canFight()
		|| getUnitCombatType() == GC.getInfoTypeForString("UNITCOMBAT_SIEGE")
		|| getSpecialUnitType() == GC.getDefineINT("SPECIALUNIT_SPELL")
		|| getSpecialUnitType() == GC.getDefineINT("SPECIALUNIT_BIRD")
		|| isOnlyDefensive())
		return false;

	if (!GC.getImprovementInfo(pPlot->getImprovementType()).isExplorable()
		|| pPlot->getExploreNextTurn() > GC.getGame().getGameTurn())
		return false;

	if (bTestVisible)
		return true;

	bool bGoodyClass = false;
	for (int i = 0; i < GC.getNumGoodyClassTypes(); i++)
	{
		if (GC.getImprovementInfo(pPlot->getImprovementType()).isGoodyClassType(i))
		{
			bGoodyClass = true;
			break;
		}
	}
	if (!bGoodyClass)
		return false;

	return true;
}

bool CvUnit::exploreLair(CvPlot* pPlot)
{
	if (pPlot == NULL)
		pPlot = plot();

	if (!canExploreLair(pPlot, false))
		return false;

	TraitTriggeredData kData;
	kData.m_iImprovement = pPlot->getImprovementType();
	GET_PLAYER(getOwner()).doTraitTriggers(TRAITHOOK_EXPLORE_LAIR, &kData);

	GoodyTypes eGoody = GET_PLAYER(getOwnerINLINE()).doLair(pPlot, this);

	if (eGoody == NO_GOODY)
		return false;

	finishMoves();
	changeExperience(100);
	if (pPlot->getImprovementType() != NO_IMPROVEMENT && GC.getGameINLINE().getSorenRandNum(100, "Destroy Lair Chance") < GC.getGoodyInfo(eGoody).getDestroyLairChance())
	{
		if ((ImprovementTypes)GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage() != NO_IMPROVEMENT)
		{
			gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(),true,GC.getEVENT_MESSAGE_TIME(),gDLL->getText("TXT_KEY_MESSAGE_LAIR_DESTROYED").GetCString(),"AS2D_POSITIVE_DINK",MESSAGE_TYPE_DISPLAY_ONLY,"Art/Interface/Buttons/Spells/Rob Grave.dds",(ColorTypes)8,pPlot->getX(),pPlot->getY(),true,true);
			pPlot->clearCultureControl(pPlot->getImprovementOwner(), pPlot->getImprovementType(), true);
			plot()->setImprovementOwner(NO_PLAYER);
			pPlot->setImprovementType((ImprovementTypes)GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
		}
		else
		{
			if ((ImprovementTypes)GC.getImprovementInfo(pPlot->getImprovementType()).isUnique())
			{
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_LAIR_DESTROYED").GetCString(), "AS2D_POSITIVE_DINK", MESSAGE_TYPE_DISPLAY_ONLY, "Art/Interface/Buttons/Spells/Rob Grave.dds", (ColorTypes)8, pPlot->getX(), pPlot->getY(), true, true);
				// +-10% on cycle length
				pPlot->setExploreNextTurn(GC.getGame().getGameTurn() + (GC.getImprovementInfo(pPlot->getImprovementType()).getExploreDelay() * 11 / 10 - GC.getGameINLINE().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getExploreDelay() / 5, "randomization to lair cycle length"))
																		* GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getGrowthPercent() / 100);
			}
			else
			{
				gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MESSAGE_LAIR_DESTROYED").GetCString(), "AS2D_POSITIVE_DINK", MESSAGE_TYPE_DISPLAY_ONLY, "Art/Interface/Buttons/Spells/Rob Grave.dds", (ColorTypes)8, pPlot->getX(), pPlot->getY(), true, true);
				pPlot->clearCultureControl(pPlot->getImprovementOwner(), pPlot->getImprovementType(), true);
				plot()->setImprovementOwner(NO_PLAYER);
				pPlot->setImprovementType(NO_IMPROVEMENT);
			}
		}
	}

	return true;
}


/*************************************************************************************************/
/**	Sidar Mist 								25/06/10								Grey Fox	**/
/*************************************************************************************************/
int CvUnit::getPerception() const
{
	return m_iPerception;
}


void CvUnit::changePerception(int iChange)
{
	if (iChange != 0)
	{
		plot()->changeAdjacentSight(getTeam(), visibilityRange(), false, this, true);

		m_iPerception += iChange;
		//	FAssert(getExtraVisibilityRange() >= 0);

		plot()->changeAdjacentSight(getTeam(), visibilityRange(), true, this, true);
	}
	
}
/*************************************************************************************************/
/**	END                                                                   						**/
/*************************************************************************************************/
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                      02/21/10                                jdog5000      */
/*                                                                                              */
/* Lead From Behind                                                                             */
/************************************************************************************************/
// From Lead From Behind by UncutDragon

// Original isBetterDefenderThan call (without the extra parameter) - now just a pass-through
bool CvUnit::isBetterDefenderThan(const CvUnit* pDefender, const CvUnit* pAttacker) const
{
	return isBetterDefenderThan(pDefender, pAttacker, NULL);
}

// Modified version of best defender code (minus the initial boolean tests,
// which we still check in the original method)
bool CvUnit::LFBisBetterDefenderThan(const CvUnit* pDefender, const CvUnit* pAttacker, int* pBestDefenderRank) const
{
	// We adjust ranking based on ratio of our adjusted strength compared to twice that of attacker
	// Effect is if we're over twice as strong as attacker, we increase our ranking
	// (more likely to be picked as defender) - otherwise, we reduce our ranking (less likely)

	// Get our adjusted rankings based on combat odds
	int iOurRanking = LFBgetDefenderRank(pAttacker);
	int iTheirRanking = -1;
	if (pBestDefenderRank)
		iTheirRanking = (*pBestDefenderRank);
	if (iTheirRanking == -1)
		iTheirRanking = pDefender->LFBgetDefenderRank(pAttacker);

	// In case of equal value, fall back on unit cycle order
	if (iOurRanking == iTheirRanking)
	{
		if (isBeforeUnitCycle(this, pDefender))
			iTheirRanking--;
		else
			iTheirRanking++;
	}

	// Retain the basic rank (before value adjustment) for the best defender
	if (pBestDefenderRank)
		if (iOurRanking > iTheirRanking)
			(*pBestDefenderRank) = iOurRanking;

	return (iOurRanking > iTheirRanking);
}

// Get the (adjusted) odds of attacker winning to use in deciding best attacker
int CvUnit::LFBgetAttackerRank(const CvUnit* pDefender, int& iUnadjustedRank) const
{
	if (pDefender)
	{
		int iDefOdds = pDefender->LFBgetDefenderOdds(this);
		iUnadjustedRank = 1000 - iDefOdds;
		// If attacker has a chance to withdraw, factor that in as well
		if (withdrawalProbability() > 0)
			iUnadjustedRank += ((iDefOdds * withdrawalProbability()) / 100);
	} else {
		// No defender ... just use strength, but try to make it a number out of 1000
		iUnadjustedRank = currCombatStr(NULL, NULL) / 5;
	}
	int iRank = LFBgetValueAdjustedOdds(iUnadjustedRank);

	return iRank;
}

// Get the (adjusted) odds of defender winning to use in deciding best defender
int CvUnit::LFBgetDefenderRank(const CvUnit* pAttacker) const
{
	int iRank = LFBgetDefenderOdds(pAttacker);
	// Don't adjust odds for value if attacker is limited in their damage (i.e: no risk of death)
	if ((pAttacker != NULL) && (maxHitPoints() == pAttacker->combatLimit()))
	iRank = LFBgetValueAdjustedOdds(iRank);

	return iRank;
}

// Get the unadjusted odds of defender winning (used for both best defender and best attacker)
int CvUnit::LFBgetDefenderOdds(const CvUnit* pAttacker) const
{
	// Check if we have a valid attacker
	bool bUseAttacker = false;
	int iAttStrength = 0;
	if (pAttacker)
		iAttStrength = pAttacker->currCombatStr(NULL, NULL);
	if (iAttStrength > 0)
		bUseAttacker = true;

	int iDefense = 0;

	if (bUseAttacker && GC.getLFBUseCombatOdds())
	{
		// We start with straight combat odds
		iDefense = LFBgetDefenderCombatOdds(pAttacker);
	} else {
		// Lacking a real opponent (or if combat odds turned off) fall back on just using strength
		iDefense = currCombatStr(plot(), pAttacker);
		if (bUseAttacker)
		{
			// Similiar to the standard method, except I reduced the affect (cut it in half) handle attacker
			// and defender together (instead of applying one on top of the other) and substract the
			// attacker first strikes (instead of adding attacker first strikes when defender is immune)
			int iFirstStrikes = 0;

			if (!pAttacker->immuneToFirstStrikes())
				iFirstStrikes += (firstStrikes() * 2) + chanceFirstStrikes();
			if (!immuneToFirstStrikes())
				iFirstStrikes -= ((pAttacker->firstStrikes() * 2) + pAttacker->chanceFirstStrikes());

			if (iFirstStrikes != 0)
			{
				// With COMBAT_DAMAGE=20, this makes each first strike worth 8% (and each chance worth 4%)
				iDefense *= ((iFirstStrikes * GC.getCOMBAT_DAMAGE() / 5) + 100);
				iDefense /= 100;
			}

			// Make it a number out of 1000, taking attacker into consideration
			iDefense = (iDefense * 1000) / (iDefense + iAttStrength);
		}
	}

	if (hasCargo())
	{
		// This part is taken directly from the standard method
		// Reduces value if a unit is carrying other units
		int iAssetValue = std::max(1, getUnitInfo().getAssetValue());
		int iCargoAssetValue = 0;
		std::vector<CvUnit*> aCargoUnits;
		getCargoUnits(aCargoUnits);
		for (uint i = 0; i < aCargoUnits.size(); ++i)
		{
			iCargoAssetValue += aCargoUnits[i]->getUnitInfo().getAssetValue();
		}
		iDefense = iDefense * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);
	}

	return iDefense;
}

// Take the unadjusted odds and adjust them based on unit value
int CvUnit::LFBgetValueAdjustedOdds(int iOdds) const
{
	// Adjust odds based on value
	int iValue = LFBgetRelativeValueRating();
	long iAdjustment = -250;
	if (GC.getLFBUseSlidingScale())
		iAdjustment = (iOdds - 990);
	// Value Adjustment = (odds-990)*(value*num/denom)^2
	long iValueAdj = (long)(iValue * GC.getLFBAdjustNumerator());
	iValueAdj *= iValueAdj;
	iValueAdj *= iAdjustment;
	iValueAdj /= (long)(GC.getLFBAdjustDenominator() * GC.getLFBAdjustDenominator());
	int iRank = iOdds + iValueAdj + 10000;
	// Note that the +10000 is just to try keeping it > 0 - doesn't really matter, other than that -1
	// would be interpreted later as not computed yet, which would cause us to compute it again each time

	return iRank;
}

// Method to evaluate the value of a unit relative to another
int CvUnit::LFBgetRelativeValueRating() const
{
	int iValueRating = 0;

	// Check if led by a Great General
	if (GC.getLFBBasedOnGeneral() > 0)
		if (NO_UNIT != getLeaderUnitType())
			iValueRating += GC.getLFBBasedOnGeneral();

	// Assign experience value in tiers
	if (GC.getLFBBasedOnExperience() > 0)
	{
		int iTier = 10;
		while (getExperience() >= iTier)
		{
			iValueRating += GC.getLFBBasedOnExperience();
			iTier *= 2;
		}
	}

	// Check if unit is limited in how many can exist
	if (GC.getLFBBasedOnLimited() > 0)
		if (isLimitedUnitClass(getUnitClassType()))
			iValueRating += GC.getLFBBasedOnLimited();

	// Check if unit has ability to heal
	if (GC.getLFBBasedOnHealer() > 0)
		if (getSameTileHeal() > 0)
			iValueRating += GC.getLFBBasedOnHealer();

	return iValueRating;
}

int CvUnit::LFBgetDefenderCombatOdds(const CvUnit* pAttacker) const
{
	int iAttackerStrength;
	int iAttackerFirepower;
	int iDefenderStrength;
	int iDefenderFirepower;
	int iDefenderOdds;
	int iStrengthFactor;
	int iDamageToAttacker;
	int iDamageToDefender;
	int iNeededRoundsAttacker;
	int iNeededRoundsDefender;
	int iAttackerLowFS;
	int iAttackerHighFS;
	int iDefenderLowFS;
	int iDefenderHighFS;
	int iDefenderHitLimit;

	iAttackerStrength = pAttacker->currCombatStr(NULL, NULL);
	iAttackerFirepower = pAttacker->currFirepower(NULL, NULL);

	iDefenderStrength = currCombatStr(plot(), pAttacker);
	iDefenderFirepower = currFirepower(plot(), pAttacker);

	FAssert((iAttackerStrength + iDefenderStrength) > 0);
	FAssert((iAttackerFirepower + iDefenderFirepower) > 0);

	iDefenderOdds = ((GC.getCOMBAT_DIE_SIDES() * iDefenderStrength) / (iAttackerStrength + iDefenderStrength));
	iStrengthFactor = ((iAttackerFirepower + iDefenderFirepower + 1) / 2);

	// calculate damage done in one round
	//////

	iDamageToAttacker = std::max(1,((GC.getCOMBAT_DAMAGE() * (iDefenderFirepower + iStrengthFactor)) / (iAttackerFirepower + iStrengthFactor)));
	iDamageToDefender = std::max(1,((GC.getCOMBAT_DAMAGE() * (iAttackerFirepower + iStrengthFactor)) / (iDefenderFirepower + iStrengthFactor)));

	// calculate needed rounds.
	// Needed rounds = round_up(health/damage)
	//////

	iDefenderHitLimit = maxHitPoints() - pAttacker->combatLimit();

	iNeededRoundsAttacker = (std::max(0, currHitPoints() - iDefenderHitLimit) + iDamageToDefender - 1 ) / iDamageToDefender;
	iNeededRoundsDefender = (pAttacker->currHitPoints() + iDamageToAttacker - 1 ) / iDamageToAttacker;

	// calculate possible first strikes distribution.
	// We can't use the getCombatFirstStrikes() function (only one result,
	// no distribution), so we need to mimic it.
	//////

	iAttackerLowFS = (immuneToFirstStrikes()) ? 0 : pAttacker->firstStrikes();
	iAttackerHighFS = (immuneToFirstStrikes()) ? 0 : (pAttacker->firstStrikes() + pAttacker->chanceFirstStrikes());

	iDefenderLowFS = (pAttacker->immuneToFirstStrikes()) ? 0 : firstStrikes();
	iDefenderHighFS = (pAttacker->immuneToFirstStrikes()) ? 0 : (firstStrikes() + chanceFirstStrikes());

	return LFBgetCombatOdds(iDefenderLowFS, iDefenderHighFS, iAttackerLowFS, iAttackerHighFS, iNeededRoundsDefender, iNeededRoundsAttacker, iDefenderOdds);
}
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/
/*************************************************************************************************/
/**	MISSION_INQUISITION						13/01/12									Snarko	**/
/**																								**/
/**			Adding a mission for inquisition and teaching the AI proper use						**/
/*************************************************************************************************/
bool CvUnit::isInquisition() const
{
	return m_iNumInquisition > 0;
}

void CvUnit::changeInquisition(int iChange)
{
	FAssert(m_iNumInquisition + iChange >= 0);
	m_iNumInquisition += iChange;
}

bool CvUnit::canInquisition(CvPlot* pPlot, bool bTestVisible)
{
	if (!isInquisition())
		return false;

	if (pPlot == NULL)
		pPlot = plot();

	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
		return false;

	if (bTestVisible)
		return true;

	if (pCity->getOwner() != getOwnerINLINE())
	{
		if (GET_PLAYER(getOwnerINLINE()).getStateReligion() == NO_RELIGION)
			return false;
		else if (GET_PLAYER(getOwnerINLINE()).getStateReligion() != GET_PLAYER(pCity->getOwner()).getStateReligion())
			return false;
	}

	bool bFound = false;
	for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		if (pCity->isHasReligion((ReligionTypes)iI) && (ReligionTypes)iI != GET_PLAYER(pCity->getOwner()).getStateReligion())
		{
			bFound = true;
			break;
		}
	}

	return bFound;

}
bool CvUnit::inquisition(CvPlot* pPlot)
{
	if (pPlot == NULL)
		pPlot = plot();

	if (!canInquisition(pPlot, false))
		return false;

	int iRnd = GC.getGameINLINE().getSorenRandNum(4, "Inquisition");
	CvCity* pCity = pPlot->getPlotCity();

	for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		if (pCity->isHasReligion((ReligionTypes)iI))
		{
			if ((GET_PLAYER(getOwnerINLINE()).getStateReligion() != (ReligionTypes)iI) && !pCity->isHolyCity((ReligionTypes)iI))
			{
				pCity->setHasReligion((ReligionTypes)iI, false, true, true);

				for (int iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)
				{
					if (GC.getBuildingInfo((BuildingTypes)iJ).getPrereqReligion() == iI)
						pCity->setNumRealBuilding((BuildingTypes)iJ, 0);
				}
				iRnd += 1;
			}
		}
	}
	if (iRnd >= 1)
		pCity->changeHurryAngerTimer(iRnd);

	finishMoves();

	return true;
}
/*************************************************************************************************/
/**	MISSION_INQUISITION END																		**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	Speedup								12/02/12										Snarko	**/
/**																								**/
/**			Only store the unitclasses we upgrade to, for faster looping						**/
/*************************************************************************************************/
int CvUnit::getUpgradeUnit(UnitClassTypes eUnitClass, UnitTypes eUnit, CvCity* pCity) const
{
	if (GC.getUnitInfo(eUnit).getUpgradeCiv() != NO_CIVILIZATION)
	{
		return GC.getCivilizationInfo((CivilizationTypes)GC.getUnitInfo(eUnit).getUpgradeCiv()).getCivilizationUnits(eUnitClass);
	}
	else
	{
		return (pCity->getCityUnits(eUnitClass));
	}
}
/*************************************************************************************************/
/**	Speedup									END													**/
/*************************************************************************************************/
bool CvUnit::joinPop()
{
	CvCity* pCity;

	if (!canJoinPop(plot()))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changePopulation(1);
	}

	kill(true);

	return true;
}

bool CvUnit::canAddPop()
{
	return	m_pUnitInfo->isJoinPop();
}

bool CvUnit::canAddPopToCity(CvCity* pCity)
{
	return canJoinPop(pCity->plot());
}

bool CvUnit::canJoinPop(CvPlot* pPlot)
{
	CvCity* pCity;


	if (!(m_pUnitInfo->isJoinPop()))
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (!(pCity->canJoinPop()))
	{
		return false;
	}

	if (pCity->getOwner() != getOwner())
	{
		return false;
	}

	if (isDelayedDeath())
	{
		return false;
	}

	//FfH: Added by Kael 08/18/2008
	if (isHasCasted())
	{
		return false;
	}
	//FfH: End Add

	return true;
}

void CvUnit::doCombatCapture(CvUnit* pLoser)
{
	int iUnit = NO_UNIT;
	int iNew = NO_UNIT;
	CvUnit* pUnit;
	bool bConvert = false;
	CvPlot* pLoserPlot = pLoser->plot();
	int pLoserOwner = pLoser->getOwner();
	if (pLoser->getDuration() > 0)
	{
		return;
	}
	//If unit is auto-capturable ( worker), don't handle it here
	if (pLoser->getUnitInfo().getUnitCaptureClassType() != NO_UNITCLASS)
	{
		return;
	}
	//First check UnitCombat Specific content ( Subdue Beasts, Boarding)
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (pLoser->getUnitCombatType()!=NO_UNITCOMBAT && GC.getPromotionInfo((PromotionTypes)iI).getUnitCombatCaptureRatePercent(pLoser->getUnitCombatType()) != 0)
			{
				if (iUnit == NO_UNIT)
				{
					if (GC.getGameINLINE().getSorenRandNum(100, "Capture") <= (GC.getPromotionInfo((PromotionTypes)iI).getUnitCombatCaptureRatePercent(pLoser->getUnitCombatType())))
					{
						iUnit = pLoser->getUnitType();
						bConvert = true;
					}
				}
			}

//			if (GC.getPromotionInfo((PromotionTypes)iI).getCombatCapturePercent() != 0)
//			{
//				if (iUnit == NO_UNIT && pLoser->isAlive())
//				{
//					if (GC.getGameINLINE().getSorenRandNum(100, "Combat Capture") <= GC.getPromotionInfo((PromotionTypes)iI).getCombatCapturePercent())
//					{
//					iUnit = pLoser->getUnitType();
//						bConvert = true;
//					}
//				}
//			}
			
		}
	}
	/*************************************************************************************************/
/**	Slavers									05/19/08								Xienwolf	**/
/**																								**/
/**					Adds Promotion Field to other Chances for Slave Generation					**/
/*************************************************************************************************/

	//Next check general situation
	if (iUnit == NO_UNIT)
	{
		if ((getSlaveGenerationChance() + m_pUnitInfo->getEnslavementChance() + GET_PLAYER(getOwnerINLINE()).getEnslavementChance()) > 0)
		{
			if (!isSuicide())// && pLoser->isAlive() && !pLoser->isAnimal() && pLoser->getUnitCombatType() != GC.getInfoTypeForString("UNITCOMBAT_BEAST"))
			{// allows capture of humanoids if winner is a summon (specters, wraiths... but not fireballs...)
				if (GC.getGameINLINE().getSorenRandNum(100, "Enslavement") <= (getSlaveGenerationChance() + m_pUnitInfo->getEnslavementChance() + GET_PLAYER(getOwnerINLINE()).getEnslavementChance()))
				{
					//Check if there's a specific unit to convert too
					for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						if (isHasPromotion((PromotionTypes)iI))
						{
							if (GC.getPromotionInfo((PromotionTypes)iI).isPrereqAliveCapture() && !pLoser->isAlive())
								return;
							if (pLoser->getUnitCombatType()!=NO_UNITCOMBAT && GC.getPromotionInfo((PromotionTypes)iI).isUnitCombatNonCapture(pLoser->getUnitCombatType()))
								return;
							if (GC.getPromotionInfo((PromotionTypes)iI).getCaptureUnitClass() != NO_UNITCLASS)
							{
								iUnit = GC.getCivilizationInfo(GET_PLAYER(getOwnerINLINE()).getCivilizationType()).getCivilizationUnits((UnitClassTypes)GC.getPromotionInfo((PromotionTypes)iI).getCaptureUnitClass());
								if (iUnit == NO_UNIT)
								{
									iUnit = GC.getUnitClassInfo((UnitClassTypes)GC.getPromotionInfo((PromotionTypes)iI).getCaptureUnitClass()).getDefaultUnitIndex();
								}
							}
						}
					}
					//Else use existing unit
					if (iUnit == NO_UNIT)
					{
						iUnit = pLoser->getUnitType();
						bConvert = true;
					}
				//	iUnit = GC.getCivilizationInfo(GET_PLAYER(getOwnerINLINE()).getCivilizationType()).getCivilizationUnits((UnitClassTypes)GC.getDefineINT("SLAVE_UNITCLASS"));
				}
			}
		}

	}
	/*************************************************************************************************/
	/**	Slavers										END												**/
	/*************************************************************************************************/
	if (iUnit != NO_UNIT)
	{
		if ((!pLoser->isImmuneToCapture() && !isCannotCapture(true) && !pLoser->isImmortal())
			|| GC.getUnitInfo((UnitTypes)pLoser->getUnitType()).getEquipmentPromotion() != NO_PROMOTION)
		{
			pUnit = GET_PLAYER(getOwnerINLINE()).initUnit((UnitTypes)iUnit, plot()->getX_INLINE(), plot()->getY_INLINE());
			if (!plot()->isValidDomainForLocation(*pUnit))
			{
				if (!pLoserPlot->isValidDomainForLocation(*pUnit))
				{
					pUnit->jumpToNearestValidPlot();
				}
				else
				{
					pUnit->setXY(pLoserPlot->getX(), pLoserPlot->getY());
				}
			}
			/*************************************************************************************************/
			/**	Xienwolf Tweak							09/06/08											**/
			/**						Doesn't make much sense for Duration to be passed on					**/
			/**							Display information for Unit Capture/Conversion						**/
			/*************************************************************************************************/
			/**								---- Start Original Code ----									**
						if (getDuration() != 0)
						{
							pUnit->setDuration(getDuration());
						}
			/**								----  End Original Code  ----									**/
			iNew = iUnit;
			/*************************************************************************************************/
			/**	Tweak  									END													**/
			/*************************************************************************************************/
			if (iUnit == GC.getCivilizationInfo(GET_PLAYER(getOwnerINLINE()).getCivilizationType()).getCivilizationUnits((UnitClassTypes)GC.getDefineINT("SLAVE_UNITCLASS")))
			{
				if (pLoser->getRace() != NO_PROMOTION)
				{
					pUnit->setHasPromotion((PromotionTypes)pLoser->getRace(), true);
				}
				else
				{
					for (int i = 0;i < GC.getNumPromotionInfos();i++)
					{
						if (pUnit->isHasPromotion((PromotionTypes)i))
						{
							if (GC.getPromotionInfo((PromotionTypes)i).isRace())
							{
								pUnit->setHasPromotion((PromotionTypes)i, false);
							}
						}
					}
				}
			}
			TraitTriggeredData kTriggerData;

			kTriggerData.m_iUnitClass = getUnitClassType();
			kTriggerData.m_iUnitCombat = getUnitCombatType();
			//	kTriggerData.eLevel = getLevel();
			kTriggerData.m_iRace = (PromotionTypes)getRace();
			kTriggerData.m_iAlignment = GET_PLAYER(getOwner()).getBroadAlignment();
			kTriggerData.m_iEthicalAlignment = GET_PLAYER(getOwner()).getBroadEthicalAlignment();
			kTriggerData.m_iAlignmentStatus = GET_PLAYER(getOwner()).getAlignment();
			kTriggerData.m_iEthicalAlignmentStatus = GET_PLAYER(getOwner()).getEthicalAlignment();

			kTriggerData.m_bWerewolf = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_WEREWOLF"));
			kTriggerData.m_bUndead = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_UNDEAD"));
			kTriggerData.m_bHiddenNationality = isHiddenNationality();
			kTriggerData.m_bHero = isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_HERO"));
			kTriggerData.m_bInBorders = getOwner() == plot()->getOwner();
			kTriggerData.m_bOutsideBorders = getOwner() != plot()->getOwner();


			kTriggerData.m_iKilledUnitClass = pUnit->getUnitClassType();
			kTriggerData.m_iKilledUnitCombat = pUnit->getUnitCombatType();
			kTriggerData.m_iKilledAlignment = GET_PLAYER(getOwner()).getAlignment();;
			kTriggerData.m_iKilledEthicalAlignment = GET_PLAYER(getOwner()).getEthicalAlignment(); ;

			//	kTriggerData.eKilledLevel = pUnit->getLevel();
			kTriggerData.m_iKilledRace = (PromotionTypes)pUnit->getRace();
			kTriggerData.m_bKilledWerewolf = pUnit->isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_WEREWOLF"));
			kTriggerData.m_bKilledUndead = pUnit->isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_UNDEAD"));
			kTriggerData.m_bKilledHero = pUnit->isHasPromotion((PromotionTypes)GC.getInfoTypeForString("PROMOTION_HERO"));
			kTriggerData.m_bKilledHiddenNationality = pUnit->isHiddenNationality();
			kTriggerData.m_bKilledInBorders = pLoserOwner == pLoserPlot->getOwner();
			kTriggerData.m_bKilledOutsideBorders = pLoserOwner != pLoserPlot->getOwner();

			GET_PLAYER(getOwner()).doTraitTriggers(TRAITHOOK_CAPTURE_UNIT, &kTriggerData);

			if (bConvert)
			{
				pLoser->setDamage(75, NO_PLAYER, false);
				pUnit->convert(pLoser);

				for (int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
				{
					CvPromotionInfo& kLoopPromotion = GC.getPromotionInfo((PromotionTypes)iI);
					int iLoop = countHasPromotion((PromotionTypes)iI);
					for (int iK = 0; iK < iLoop; ++iK)
					{
						for (int iJ = 0; iJ < kLoopPromotion.getNumCapturePromotions(); ++iJ)
						{
							if (pUnit->isPromotionValid(kLoopPromotion.getCapturePromotion(iJ)))
							{
								pUnit->setHasPromotion(kLoopPromotion.getCapturePromotion(iJ), true);
							}
						}
					}
				}
			}
		}
	}
	
	/*************************************************************************************************/
	/**	Xienwolf Tweak							09/06/08											**/
	/**																								**/
	/**							Display information for Unit Capture/Conversion						**/
	/*************************************************************************************************/
	if (iNew != NO_UNIT)
	{
		UnitTypes eNewUnit = (UnitTypes)iNew;
		CvWString szBuffer;
		if (eNewUnit == pLoser->getUnitType())
		{
			szBuffer = gDLL->getText("TXT_KEY_UNIT_CAPTURED", GET_PLAYER(pLoser->getVisualOwner()).getCivilizationAdjectiveKey(), pLoser->getNameKey(), GET_PLAYER(pLoser->getOwnerINLINE()).getNameKey());
		}
		else
		{
			szBuffer = gDLL->getText("TXT_KEY_SLAVE_CAPTURED", GC.getUnitInfo(eNewUnit).getTextKeyWide(), GET_PLAYER(pLoser->getVisualOwner()).getCivilizationAdjectiveKey(), pLoser->getNameKey(), GET_PLAYER(pLoser->getOwnerINLINE()).getNameKey());
		}
		gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, m_pUnitInfo->getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_YELLOW"), getX_INLINE(), getY_INLINE());
	}
	/*************************************************************************************************/
	/**	Tweak			  						END													**/
	/*************************************************************************************************/


}

void CvUnit::SelectUnit()
{
	gDLL->getInterfaceIFace()->insertIntoSelectionList(this, true, false);
}

void CvUnit::DeselectUnit()
{
	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->clearSelectionList();
	}
}

bool CvUnit::canSpellTargetPlot(CvPlot* pTarget, int iI)
{
	if (pTarget == NULL)
		return false;

	if (!pTarget->isVisible(getTeam(), false))
		return false;

	int iRange = getSpellTargetRange(iI);//GC.getSpellInfo((SpellTypes)iI).getTargetRange();

	if (plotDistance(plot(), pTarget) > iRange)
		return false;

	if (!plot()->canSeePlot(pTarget, getTeam(), iRange))
		return false;

	return true;
}

bool CvUnit::canSpellTargetSecondaryPlot(CvPlot* pMainTarget, CvPlot* pTarget, int iI)
{
	if (pTarget == NULL)
		return false;

	if (!pTarget->isVisible(getTeam(), false))
	{
		return false;
	}

	int iRange = GC.getSpellInfo((SpellTypes)iI).getRange();

	if (!pMainTarget->canSeePlot(pTarget, getTeam(), iRange))
	{
		return false;
	}

	if (plotDistance(pMainTarget->getX_INLINE(), pMainTarget->getY_INLINE(), pTarget->getX_INLINE(), pTarget->getY_INLINE()) > iRange)
	{
		return false;
	}

	return true;
}

int CvUnit::getMissionSpell() const
{
	return m_iMissionSpell;
}

void CvUnit::setMissionSpell(int newvalue)
{
	m_iMissionSpell = newvalue;
}
//Magic Rework

int CvUnit::getMagicalPower() const
{
	int res = getUnitInfo().getMagicalPower() + getExtraMagicalPower();
//	if (getDominionCapacity() < 0)
//	{
//		res = res + GC.getMAGICAL_POWER_PER_DOMINION() * getDominionCapacity();
//	}
	return res;
}

int CvUnit::getSpellMagicalPower(int spell) const
{
	int res = getMagicalPower();
	for (int i = 0; i < GC.getNumSpellClassInfos(); i++)
	{
		if (GC.getSpellInfo((SpellTypes)spell).isSpellClass(i))
		{
	//		res += getUnitInfo().getSpellClassExtraPower(i);
			res += getExtraSpellClassPower((SpellClassTypes)i);
		}
	}
	return res;
}

//int CvUnit::getDominionCapacity() const
//{
//	return getUnitInfo().getDominionCapacity() + getExtraDominionCapacity();
//}
//
int CvUnit::getExtraMagicalPower() const
{
	return m_iExtraMagicalPower;
}

void CvUnit::changeExtraMagicalPower(int iNewValue)
{
	m_iExtraMagicalPower += iNewValue;
}

void CvUnit::setExtraMagicalPower(int iNewValue)
{
	m_iExtraMagicalPower = iNewValue;
}
//int CvUnit::getExtraDominionCapacity() const
//{
//	return m_iExtraDominionCapacity;
//}
//
//void CvUnit::changeExtraDominionCapacity(int iNewValue)
//{
//	m_iExtraDominionCapacity += iNewValue;
//}
//
//void CvUnit::setExtraDominionCapacity(int iNewValue)
//{
//	m_iExtraDominionCapacity = iNewValue;
//}
//
//int CvUnit::getSpellClassExtraPower(int i) const
//{
//	FAssertMsg(i < GC.getNumSpellClassInfos(), "Index out of bounds");
//	FAssertMsg(i > -1, "Index out of bounds");
//	return m_piSpellClassExtraPower ? m_piSpellClassExtraPower[i] : 0;
//}
//void CvUnit::changeSpellClassExtraPower(int i, int iChange)
//{
//	FAssertMsg(i < GC.getNumSpellClassInfos(), "Index out of bounds");
//	FAssertMsg(i > -1, "Index out of bounds");
//	m_piSpellClassExtraPower[i] += iChange;
//}


int CvUnit::getRealFreeXPRate() const
{
	int res = 0;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			/*************************************************************************************************/
			/**	Xienwolf Tweak							11/21/08											**/
			/**				Prevents exploitation of Puppets with Summoner Trait Feedback					**/
			/**							Ensures that risky spells are always SOME risk						**/
			/**								Prevents pointless AI Control Sessions							**/
			/*************************************************************************************************/
			/**								---- Start Original Code ----									**
						if (GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn() != 0)
						{
							if (getExperience() < GC.getDefineINT("FREE_XP_MAX"))
							{
								changeExperience(GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn(), -1, false, false, false);
							}
						}
						if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply() != NO_PROMOTION)
						{
							if (!isHasPromotion((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply()))
							{
								if (GC.getGameINLINE().getSorenRandNum(100, "Promotion Random Apply") <= 3)
								{
									setHasPromotion(((PromotionTypes)GC.getPromotionInfo((PromotionTypes)iI).getPromotionRandomApply()), true);
								}
							}
						}
						if (GC.getPromotionInfo((PromotionTypes)iI).getBetrayalChance() != 0)
						{
							if (!isImmuneToCapture() && !isBarbarian() && !GC.getGameINLINE().isOption(GAMEOPTION_NO_BARBARIANS))
							{
								if (GC.getGameINLINE().getSorenRandNum(100, "Betrayal Chance") <= GC.getPromotionInfo((PromotionTypes)iI).getBetrayalChance())
								{
									betray(BARBARIAN_PLAYER);
								}
							}
						}
			/**								----  End Original Code  ----									**/
			if (GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn() != 0 && getDuration() == 0)
			{
				if (getExperience() < getFreeXPCap())
				{
					res = res + GC.getPromotionInfo((PromotionTypes)iI).getFreeXPPerTurn() * 100 / GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent();
				}
			}
		}
	}
	return res;

}